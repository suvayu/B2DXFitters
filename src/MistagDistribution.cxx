/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "B2DXFitters/MistagDistribution.h"
#include "RooAbsReal.h"
#include <math.h>
#include "TMath.h"
#include <cstdio>
#include <cassert>
#include <algorithm>

MistagDistribution::MistagDistribution(const char *name, const char *title,
	RooAbsReal& _w, RooAbsReal& _w0, RooAbsReal& _wa,
	RooAbsReal& _f) : RooAbsPdf(name,title),
    w("w","w",this,_w), w0("w0","w0",this,_w0), wa("wa","wa",this,_wa),
    f("f","f",this,_f),
    lastw0(0.), lastwa(0.), lastf(0.), lastwc(0.)
{ }


MistagDistribution::MistagDistribution(const MistagDistribution& other, const char* name) :
    RooAbsPdf(other,name),
    w("w",this,other.w), w0("w0",this,other.w0), wa("wa",this,other.wa),
    f("f",this,other.f),
    lastw0(0.), lastwa(0.), lastf(0.), lastwc(0.)
{ }

MistagDistribution::~MistagDistribution() { }


double MistagDistribution::getWc() const
{
    const double w0 = this->w0;
    const double wa = this->wa;
    const double f = this->f;
    // quickly validate input variables
    if (w0 < 0.0 || w0 > 0.5 || wa <= 0.0 ||
	    wa >= 0.5 || f < 0.0 || f > 1.0)
	return 0.0;
    if (0. != lastwc && lastw0 == w0 && lastwa == wa && lastf == f) {
	return lastwc;
    } else {
	// calculate effective wc
	const double i1 =
	    (36. * f*f + 24. * f + 4.) * wa * wa +
	    ((8. * f + 8.) * w0 - 36. * f*f - 28. * f - 8.) * wa -
	    8. * f * w0*w0 + (4. * f - 4.) * w0 + 9. * f*f + 6. * f + 3.;
	// expression under square root negative, no solution for wc
	if (i1 < 0.0) return 0.;
	const double i2 = (6. * f + 2.) * wa - 2. * w0 - f + 1.;
	const double wc1 = 0.25 * (i2 + sqrt(i1)) / (f + 0.5);
	const double wc2 = 0.25 * (i2 - sqrt(i1)) / (f + 0.5);
	// check for wc solution in allowed range
	const double wc = (0.0 <= wc1 && wc1 <= 0.5) ? wc1 : wc2;
	if (!(0.0 <= wc && wc <= 0.5)) return (lastwc = 0.0);
	lastwc = wc;
	lastw0 = w0;
	lastwa = wa;
	lastf = f;
	return wc;
    }
    return 0.;
}

Double_t MistagDistribution::evaluate() const
{
    const double w = this->w;
    const double w0 = this->w0;
    const double wa = this->wa;
    const double f = this->f;
    // quickly validate input variables
    if (w < 0.0 || w > 0.5 || w0 < 0.0 || w0 > 0.5 || wa <= 0.0 ||
	    wa >= 0.5 || f < 0.0 || f > 1.0)
	return 0.0;
    // we we're below the lower turnon, we're done as well
    if (w < w0) return 0.0;

    const double wc = getWc();
    if (!(0.0 <= wc && wc <= 0.5)) return 0.0;
    // ok, evaluate pdf
    if (w < wc) {
	const double x = (w - w0) / (wc - w0);
	return x * x;
    } else {
	return 1. - (1. - f) * (w - wc) / (0.5 - wc);
    }
    // should never arrive here...
    return 0.0;
}

Int_t MistagDistribution::getAnalyticalIntegral(RooArgSet& integ, RooArgSet& anaIntSet, const char*) const
{
    if (matchArgs(integ, anaIntSet, w)) return 1;
    return 0;
}

Double_t MistagDistribution::analyticalIntegral(Int_t code, const char *rangeName) const
{
    switch(code) {
	default:
	    assert(1 == 0);
	    break;
	case 1:
	    {
		const double w0 = this->w0;
		const double wa = this->wa;
		const double f = this->f;
		// quickly validate input variables
		if (w0 < 0.0 || w0 > 0.5 || wa <= 0.0 ||
			wa >= 0.5 || f < 0.0 || f > 1.0)
		    return 0.0;
		const double wc = getWc();
		if (!(0.0 <= wc && wc <= 0.5)) return 0.0;
		// set up integration ranges
		bool minus = false;
		double wmin = this->w.min(rangeName);
		double wmax = this->w.max(rangeName);
		if (wmax < wmin) {
		    std::swap(wmin, wmax);
		    minus = true;
		}
		// clip integration range
		//
		// from -infinity to w0, pdf is zero
		if (wmin < w0) wmin = w0;
		// from 0.5 to +infinity, pdf is zero
		if (wmax > 0.5) wmax = 0.5;
		// get integration "midpoint" - if wc is in the integration
		// range, wmid is set to wc, otherwise, we set it to the
		// relevant end point of the integration
		const double wmid = std::max(wmin, std::min(wc, wmax));
		double sum = 0.;
		if (wmin >= w0 && wmid > wmin) { 
		    const double tmp = 1. / (wc - w0) / (wc - w0);
		    sum += (wmid - wmin) * w0 * w0 * tmp;
		    sum -= (wmid * wmid - wmin * wmin) * w0 * tmp;
		    sum += (wmid * wmid * wmid - wmin * wmin * wmin) * tmp / 3.;
		}
		if (wmid >= wc && wmax > wmid) {
		    const double tmp = (1. - f) / (0.5 - wc);
		    sum += (wmax - wmid) * (1. + wc * tmp);
		    sum += -0.5 * tmp * (wmax * wmax - wmid * wmid);
		}
		if (minus) return -sum;
		else return sum;
	    }
	    break;
    }
    return 0.;
}
