/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include <cassert>
#include <cmath>

#include "Riostream.h" 

#include "B2DXFitters/CPObservable.h" 
#include "RooAbsReal.h" 

CPObservable::CPObservable(const char *name, const char *title, 
	RooAbsReal& _lambda,
	RooAbsReal& _phi_strong,
	RooAbsReal& _phi_weak,
	CPObservable::which _what) :
    RooAbsReal(name,title), 
    lambda("lambda","lambda",this,_lambda),
    phi_strong("phi_strong","phi_strong",this,_phi_strong),
    phi_weak("phi_weak","phi_weak",this,_phi_weak),
    what(_what)
{ } 

CPObservable::CPObservable(const CPObservable& other, const char* name) :  
    RooAbsReal(other, name), 
    lambda("lambda",this,other.lambda),
    phi_strong("phi_strong",this,other.phi_strong),
    phi_weak("phi_weak",this,other.phi_weak),
    what(other.what)
{ 
} 

CPObservable& CPObservable::operator=(const CPObservable& other)
{
    if (&other == this) return *this;
    RooAbsReal::operator=(other);
    lambda = RooRealProxy("lambda", this, other.lambda);
    phi_strong = RooRealProxy("phi_strong", this, other.phi_strong);
    phi_weak = RooRealProxy("phi_weak", this, other.phi_weak);
    what = other.what;
    return *this;
}

CPObservable::~CPObservable() { }

Double_t CPObservable::evaluate() const 
{
    const double lambda = double(this->lambda);
    const double denom = 1. / (1. + lambda * lambda);
    switch(what) {
	case C:
	    return (1. + lambda) * (1. - lambda) * denom;
	case D:
	    {
		const double phi = double(phi_strong) - double(phi_weak);
		return 2. * lambda * std::cos(phi) * denom;
	    }
	case S:
	    {
		const double phi = double(phi_strong) - double(phi_weak);
		return 2. * lambda * std::sin(phi) * denom;
	    }
	case Dbar:
	    {
		const double phi = double(phi_strong) + double(phi_weak);
		return 2. * lambda * std::cos(phi) * denom;
	    }
	case Sbar:
	    {
		const double phi = double(phi_strong) + double(phi_weak);
		return 2. * lambda * std::sin(phi) * denom;
	    }
	default:
	    break;
    }
    assert(0 == 1);
    return 0.;
} 



