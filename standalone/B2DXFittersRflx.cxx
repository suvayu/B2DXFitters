// Generated at Thu Sep 19 23:38:54 2013. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.7.2"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SSP__='1' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='7' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/usr/share/gccxml-0.9/GCC/4.7" -isystem"/opt/intel/composer_xe_2011_sp1.6.233/mkl/include" -isystem"/opt/intel/composer_xe_2011_sp1.6.233/tbb/include" -isystem"/usr/include/c++/4.7" -isystem"/usr/include/c++/4.7/x86_64-linux-gnu" -isystem"/usr/include/c++/4.7/backward" -isystem"/usr/lib/gcc/x86_64-linux-gnu/4.7/include" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-linux-gnu/4.7/include-fixed" -isystem"/usr/include/x86_64-linux-gnu" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (Debian 4.7.2-5) 4.7.2
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "B2DXFittersDict.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("MassFitUtils") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("PTResModels") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("Bs2Dsh2011TDAnaModels") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("WeightingUtils") );
  ::Reflex::NamespaceBuilder nsb5( Reflex::Literal("GeneralModels") );
  ::Reflex::NamespaceBuilder nsb6( Reflex::Literal("Bs2DshModels") );
  ::Reflex::NamespaceBuilder nsb7( Reflex::Literal("Bd2DhModels") );
  ::Reflex::NamespaceBuilder nsb8( Reflex::Literal("GeneralUtils") );
  ::Reflex::NamespaceBuilder nsb9( Reflex::Literal("SFitUtils") );
  ::Reflex::Type type_141 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_667 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_2823 = ::Reflex::TypeBuilder(Reflex::Literal("TH1"));
  ::Reflex::Type type_2841 = ::Reflex::TypeBuilder(Reflex::Literal("TH2"));
  ::Reflex::Type type_194 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_252 = ::Reflex::TypeBuilder(Reflex::Literal("TH2F"));
  ::Reflex::Type type_265 = ::Reflex::TypeBuilder(Reflex::Literal("TH3F"));
  ::Reflex::Type type_245 = ::Reflex::TypeBuilder(Reflex::Literal("TH1F"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1039 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_196 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_1511 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_102 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_844 = ::Reflex::TypeBuilder(Reflex::Literal("TFile"));
  ::Reflex::Type type_1573 = ::Reflex::TypeBuilder(Reflex::Literal("TCut"));
  ::Reflex::Type type_694 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_2976 = ::Reflex::TypeBuilder(Reflex::Literal("TTree"));
  ::Reflex::Type type_2058 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_286 = ::Reflex::TypeBuilder(Reflex::Literal("Inverse"));
  ::Reflex::Type type_1819 = ::Reflex::TypeBuilder(Reflex::Literal("TGraph"));
  ::Reflex::Type type_1129 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_2929 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_2743 = ::Reflex::TypeBuilder(Reflex::Literal("TString"));
  ::Reflex::Type type_2072 = ::Reflex::TypeBuilder(Reflex::Literal("Dilution"));
  ::Reflex::Type type_1126 = ::Reflex::TypeBuilder(Reflex::Literal("RooArgSet"));
  ::Reflex::Type type_2033 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf"));
  ::Reflex::Type type_1962 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg"));
  ::Reflex::Type type_2579 = ::Reflex::TypeBuilder(Reflex::Literal("TObjArray"));
  ::Reflex::Type type_2017 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_2078 = ::Reflex::TypeBuilder(Reflex::Literal("FitMeTool"));
  ::Reflex::Type type_2007 = ::Reflex::TypeBuilder(Reflex::Literal("RooCmdArg"));
  ::Reflex::Type type_2819 = ::Reflex::TypeBuilder(Reflex::Literal("RooAddPdf"));
  ::Reflex::Type type_781 = ::Reflex::TypeBuilder(Reflex::Literal("RooProdPdf"));
  ::Reflex::Type type_236 = ::Reflex::TypeBuilder(Reflex::Literal("RooHistPdf"));
  ::Reflex::Type type_2525 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal"));
  ::Reflex::Type type_1874 = ::Reflex::TypeBuilder(Reflex::Literal("RooUniform"));
  ::Reflex::Type type_2021 = ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet"));
  ::Reflex::Type type_878 = ::Reflex::TypeBuilder(Reflex::Literal("RooSetProxy"));
  ::Reflex::Type type_1620 = ::Reflex::TypeBuilder(Reflex::Literal("RooArgList"));
  ::Reflex::Type type_1305 = ::Reflex::TypeBuilder(Reflex::Literal("SquaredSum"));
  ::Reflex::Type type_2683 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsFunc"));
  ::Reflex::Type type_1113 = ::Reflex::TypeBuilder(Reflex::Literal("RooRealVar"));
  ::Reflex::Type type_1831 = ::Reflex::TypeBuilder(Reflex::Literal("TaggingCat"));
  ::Reflex::Type type_2494 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData"));
  ::Reflex::Type type_2231 = ::Reflex::TypeBuilder(Reflex::Literal("IfThreeWay"));
  ::Reflex::Type type_2502 = ::Reflex::TypeBuilder(Reflex::Literal("RooCruijff"));
  ::Reflex::Type type_2099 = ::Reflex::TypeBuilder(Reflex::Literal("RooKeysPdf"));
  ::Reflex::Type type_211 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_259 = ::Reflex::TypeBuilder(Reflex::Literal("DecRateCoeff"));
  ::Reflex::Type type_646 = ::Reflex::TypeBuilder(Reflex::Literal("RooListProxy"));
  ::Reflex::Type type_995 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinnedPdf"));
  ::Reflex::Type type_1656 = ::Reflex::TypeBuilder(Reflex::Literal("RooCategory"));
  ::Reflex::Type type_800 = ::Reflex::TypeBuilder(Reflex::Literal("TGraphErrors"));
  ::Reflex::Type type_906 = ::Reflex::TypeBuilder(Reflex::Literal("RooStringVar"));
  ::Reflex::Type type_2134 = ::Reflex::TypeBuilder(Reflex::Literal("RooDataHist"));
  ::Reflex::Type type_1249 = ::Reflex::TypeBuilder(Reflex::Literal("RooRealProxy"));
  ::Reflex::Type type_48 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsCategory"));
  ::Reflex::Type type_266 = ::Reflex::TypeBuilder(Reflex::Literal("IfThreeWayPdf"));
  ::Reflex::Type type_723 = ::Reflex::TypeBuilder(Reflex::Literal("IfThreeWayCat"));
  ::Reflex::Type type_167 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_291 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_2041 = ::Reflex::TypeBuilder(Reflex::Literal("RooFitResult"));
  ::Reflex::Type type_1147 = ::Reflex::TypeBuilder(Reflex::Literal("RooWorkspace"));
  ::Reflex::Type type_2165 = ::Reflex::TypeBuilder(Reflex::Literal("CPObservable"));
  ::Reflex::Type type_2590 = ::Reflex::TypeBuilder(Reflex::Literal("CombBkgPTPdf"));
  ::Reflex::Type type_2744 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinnedFun"));
  ::Reflex::Type type_641 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsBinning"));
  ::Reflex::Type type_532 = ::Reflex::TypeBuilder(Reflex::Literal("TVirtualArray"));
  ::Reflex::Type type_2191 = ::Reflex::TypeBuilder(Reflex::Literal("RooFFTConvPdf"));
  ::Reflex::Type type_2826 = ::Reflex::TypeBuilder(Reflex::Literal("RooNumConvPdf"));
  ::Reflex::Type type_327 = ::Reflex::TypeBuilder(Reflex::Literal("BdPTAcceptance"));
  ::Reflex::Type type_664 = ::Reflex::TypeBuilder(Reflex::Literal("RooEffResModel"));
  ::Reflex::Type type_311 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_1554 = ::Reflex::TypeBuilder(Reflex::Literal("RooFormulaVar"));
  ::Reflex::Type type_1630 = ::Reflex::TypeBuilder(Reflex::Literal("RooEffHistProd"));
  ::Reflex::Type type_795 = ::Reflex::TypeBuilder(Reflex::Literal("RooNormSetCache"));
  ::Reflex::Type type_434 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_485 = ::Reflex::TypeBuilder(Reflex::Literal("IfThreeWayCatPdf"));
  ::Reflex::Type type_515 = ::Reflex::TypeBuilder(Reflex::Literal("NonOscTaggingPdf"));
  ::Reflex::Type type_952 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGenContext"));
  ::Reflex::Type type_145 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_2970 = ::Reflex::TypeBuilder(Reflex::Literal("RooNumIntConfig"));
  ::Reflex::Type type_1880 = ::Reflex::TypeBuilder(Reflex::Literal("RangeAcceptance"));
  ::Reflex::Type type_1173 = ::Reflex::TypeBuilder(Reflex::Literal("RooCategoryProxy"));
  ::Reflex::Type type_1420 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsRealLValue"));
  ::Reflex::Type type_755 = ::Reflex::TypeBuilder(Reflex::Literal("RooConvGenContext"));
  ::Reflex::Type type_2172 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsAnaConvPdf"));
  ::Reflex::Type type_39 = ::Reflex::TypeBuilder(Reflex::Literal("RooResolutionModel"));
  ::Reflex::Type type_670 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsEffResModel"));
  ::Reflex::Type type_2144 = ::Reflex::TypeBuilder(Reflex::Literal("TVectorT<double>"));
  ::Reflex::Type type_2751 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsIntegrator"));
  ::Reflex::Type type_1909 = ::Reflex::TypeBuilder(Reflex::Literal("PowLawAcceptance"));
  ::Reflex::Type type_3102 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_2278 = ::Reflex::TypeBuilder(Reflex::Literal("RooUnblindOffset"));
  ::Reflex::Type type_2212 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<int>"));
  ::Reflex::Type type_12 = ::Reflex::TypeBuilder(Reflex::Literal("TagEfficiencyWeight"));
  ::Reflex::Type type_2995 = ::Reflex::TypeBuilder(Reflex::Literal("std::list<double>"));
  ::Reflex::Type type_855 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineKnot"));
  ::Reflex::Type type_3118 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<bool>"));
  ::Reflex::Type type_1927 = ::Reflex::TypeBuilder(Reflex::Literal("MistagCalibration"));
  ::Reflex::Type type_820 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long long"));
  ::Reflex::Type type_3101 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long>"));
  ::Reflex::Type type_3104 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<char>"));
  ::Reflex::Type type_2117 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineFun"));
  ::Reflex::Type type_2200 = ::Reflex::TypeBuilder(Reflex::Literal("RooComplementCoef"));
  ::Reflex::Type type_2211 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<long>"));
  ::Reflex::Type type_2214 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<char>"));
  ::Reflex::Type type_3366 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,int>"));
  ::Reflex::Type type_2216 = ::Reflex::TypeBuilder(Reflex::Literal("RooObjCacheManager"));
  ::Reflex::Type type_1073 = ::Reflex::TypeBuilder(Reflex::Literal("MistagDistribution"));
  ::Reflex::Type type_3094 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_3103 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<short>"));
  ::Reflex::Type type_2204 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<float>"));
  ::Reflex::Type type_2213 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<short>"));
  ::Reflex::Type type_3225 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_iterator"));
  ::Reflex::Type type_2677 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsCacheElement"));
  ::Reflex::Type type_2203 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<double>"));
  ::Reflex::Type type_324 = ::Reflex::TypeBuilder(Reflex::Literal("RooEffConvGenContext"));
  ::Reflex::Type type_3092 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_1744 = ::Reflex::TypeBuilder(Reflex::Literal("FinalStateChargePdf"));
  ::Reflex::Type type_1948 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<int>"));
  ::Reflex::Type type_3692 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<int>"));
  ::Reflex::Type type_3224 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_reference"));
  ::Reflex::Type type_3114 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TString>"));
  ::Reflex::Type type_3638 = ::Reflex::TypeBuilder(Reflex::Literal("std::complex<double>"));
  ::Reflex::Type type_1947 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<long>"));
  ::Reflex::Type type_1950 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<char>"));
  ::Reflex::Type type_3691 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<long>"));
  ::Reflex::Type type_3694 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char>"));
  ::Reflex::Type type_3729 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<bool>"));
  ::Reflex::Type type_13472 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::TSchemaHelper"));
  ::Reflex::Type type_1940 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<float>"));
  ::Reflex::Type type_1949 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<short>"));
  ::Reflex::Type type_3684 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<float>"));
  ::Reflex::Type type_3693 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<short>"));
  ::Reflex::Type type_1939 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<double>"));
  ::Reflex::Type type_3100 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long long>"));
  ::Reflex::Type type_2210 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<long long>"));
  ::Reflex::Type type_3681 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<double>"));
  ::Reflex::Type type_3353 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<void*,double>"));
  ::Reflex::Type type_5206 = ::Reflex::EnumTypeBuilder(Reflex::Literal("DecRateCoeff::Flags"));
  ::Reflex::Type type_1438 = ::Reflex::TypeBuilder(Reflex::Literal("RooGaussEfficiencyModel"));
  ::Reflex::Type type_3149 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_3730 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TString>"));
  ::Reflex::Type type_3119 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooArgSet*>"));
  ::Reflex::Type type_3122 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooAbsArg*>"));
  ::Reflex::Type type_13039 = ::Reflex::EnumTypeBuilder(Reflex::Literal("RooKeysPdf::Mirror"));
  ::Reflex::Type type_3113 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooAbsReal*>"));
  ::Reflex::Type type_7159 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineKnot::S_jk"));
  ::Reflex::Type type_1679 = ::Reflex::TypeBuilder(Reflex::Literal("TagEfficiencyWeightNoCat"));
  ::Reflex::Type type_13489 = ::Reflex::EnumTypeBuilder(Reflex::Literal("CPObservable::which"));
  ::Reflex::Type type_4022 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_const_iterator"));
  ::Reflex::Type type_3097 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_1946 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<long long>"));
  ::Reflex::Type type_2207 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned int>"));
  ::Reflex::Type type_3690 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<long long>"));
  ::Reflex::Type type_3517 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<double,TString>"));
  ::Reflex::Type type_577 = ::Reflex::TypeBuilder(Reflex::Literal("DTAcceptanceLHCbNote2007041"));
  ::Reflex::Type type_7160 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineKnot::S_edge"));
  ::Reflex::Type type_1672 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGaussModelEfficiency"));
  ::Reflex::Type type_12441 = ::Reflex::EnumTypeBuilder(Reflex::Literal("RooAbsPdf::ExtendMode"));
  ::Reflex::Type type_3096 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3099 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned char>"));
  ::Reflex::Type type_2206 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned long>"));
  ::Reflex::Type type_2209 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned char>"));
  ::Reflex::Type type_13805 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<int>::RWProxy"));
  ::Reflex::Type type_3105 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooFitResult*>"));
  ::Reflex::Type type_3735 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooArgSet*>"));
  ::Reflex::Type type_3754 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooAbsArg*>"));
  ::Reflex::Type type_1382 = ::Reflex::TypeBuilder(Reflex::Literal("RooGenSmearIntegrandBinding"));
  ::Reflex::Type type_3098 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_2208 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned short>"));
  ::Reflex::Type type_13780 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<long>::RWProxy"));
  ::Reflex::Type type_13855 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<char>::RWProxy"));
  ::Reflex::Type type_4328 = ::Reflex::TypeBuilder(Reflex::Literal("RooMsgService::StreamConfig"));
  ::Reflex::Type type_3126 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TVirtualArray*>"));
  ::Reflex::Type type_1943 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned int>"));
  ::Reflex::Type type_13605 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<float>::RWProxy"));
  ::Reflex::Type type_13830 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<short>::RWProxy"));
  ::Reflex::Type type_3687 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned int>"));
  ::Reflex::Type type_3111 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooNormSetCache>"));
  ::Reflex::Type type_1942 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned long>"));
  ::Reflex::Type type_1945 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned char>"));
  ::Reflex::Type type_13580 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<double>::RWProxy"));
  ::Reflex::Type type_3686 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned long>"));
  ::Reflex::Type type_3689 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned char>"));
  ::Reflex::Type type_3695 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooFitResult*>"));
  ::Reflex::Type type_1944 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned short>"));
  ::Reflex::Type type_3688 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned short>"));
  ::Reflex::Type type_3117 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooAbsRealLValue*>"));
  ::Reflex::Type type_3120 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<int> >"));
  ::Reflex::Type type_3780 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TVirtualArray*>"));
  ::Reflex::Type type_3115 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::map<int,int> >"));
  ::Reflex::Type type_3095 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long long>"));
  ::Reflex::Type type_2205 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned long long>"));
  ::Reflex::Type type_3718 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooNormSetCache>"));
  ::Reflex::Type type_3352 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RooArgSet>"));
  ::Reflex::Type type_449 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinned2DBicubicBase<RooAbsPdf>"));
  ::Reflex::Type type_13755 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<long long>::RWProxy"));
  ::Reflex::Type type_3123 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooAbsCacheElement*>"));
  ::Reflex::Type type_3127 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<ROOT::TSchemaHelper>"));
  ::Reflex::Type type_130 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinned1DQuinticBase<RooAbsReal>"));
  ::Reflex::Type type_450 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinned2DBicubicBase<RooAbsReal>"));
  ::Reflex::Type type_3108 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<double> >"));
  ::Reflex::Type type_1576 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinned1DQuinticBase<RooAbsPdf>"));
  ::Reflex::Type type_3110 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<double>*>"));
  ::Reflex::Type type_3116 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const RooAbsBinning*>"));
  ::Reflex::Type type_3727 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooAbsRealLValue*>"));
  ::Reflex::Type type_3736 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<int> >"));
  ::Reflex::Type type_1941 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned long long>"));
  ::Reflex::Type type_3685 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned long long>"));
  ::Reflex::Type type_3731 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::map<int,int> >"));
  ::Reflex::Type type_13680 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned int>::RWProxy"));
  ::Reflex::Type type_3755 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooAbsCacheElement*>"));
  ::Reflex::Type type_3781 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<ROOT::TSchemaHelper>"));
  ::Reflex::Type type_3107 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::map<void*,double> >"));
  ::Reflex::Type type_13655 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned long>::RWProxy"));
  ::Reflex::Type type_13730 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned char>::RWProxy"));
  ::Reflex::Type type_3699 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<double> >"));
  ::Reflex::Type type_3717 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<double>*>"));
  ::Reflex::Type type_3714 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<const RooAbsBinning*>"));
  ::Reflex::Type type_3093 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>"));
  ::Reflex::Type type_1473 = ::Reflex::TypeBuilder(Reflex::Literal("RooGeneralisedSmearingBase<RooAbsPdf>"));
  ::Reflex::Type type_3109 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_13705 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned short>::RWProxy"));
  ::Reflex::Type type_7158 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineKnot::BoundaryConditions"));
  ::Reflex::Type type_1675 = ::Reflex::TypeBuilder(Reflex::Literal("RooGeneralisedSmearingBase<RooAbsReal>"));
  ::Reflex::Type type_3555 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,int>"));
  ::Reflex::Type type_3486 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<DecRateCoeff::CacheElem*,int>"));
  ::Reflex::Type type_3112 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<double,TString> >"));
  ::Reflex::Type type_3697 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::map<void*,double> >"));
  ::Reflex::Type type_3682 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooCubicSplineKnot::S_jk>"));
  ::Reflex::Type type_3124 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooMsgService::StreamConfig>"));
  ::Reflex::Type type_13630 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned long long>::RWProxy"));
  ::Reflex::Type type_3256 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bvector_base<std::allocator<bool> >"));
  ::Reflex::Type type_4001 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Bit_iterator>"));
  ::Reflex::Type type_3723 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<double,TString> >"));
  ::Reflex::Type type_3487 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<NonOscTaggingPdf::CacheElem*,int>"));
  ::Reflex::Type type_3039 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<int,std::allocator<int> >"));
  ::Reflex::Type type_3760 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooMsgService::StreamConfig>"));
  ::Reflex::Type type_3364 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,RooArgSet*>"));
  ::Reflex::Type type_3031 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long,std::allocator<long> >"));
  ::Reflex::Type type_3033 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<char,std::allocator<char> >"));
  ::Reflex::Type type_3488 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,RooAbsData*>"));
  ::Reflex::Type type_3024 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<float,std::allocator<float> >"));
  ::Reflex::Type type_3032 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<short,std::allocator<short> >"));
  ::Reflex::Type type_4000 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Bit_const_iterator>"));
  ::Reflex::Type type_2955 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ostream<char,std::char_traits<char> >"));
  ::Reflex::Type type_11040 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<int> >"));
  ::Reflex::Type type_3041 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<double,std::allocator<double> >"));
  ::Reflex::Type type_11032 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<long> >"));
  ::Reflex::Type type_11034 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<char> >"));
  ::Reflex::Type type_11025 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<float> >"));
  ::Reflex::Type type_11033 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<short> >"));
  ::Reflex::Type type_11042 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<double> >"));
  ::Reflex::Type type_3044 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TString,std::allocator<TString> >"));
  ::Reflex::Type type_11045 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<TString> >"));
  ::Reflex::Type type_3121 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >"));
  ::Reflex::Type type_10884 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<int*,std::vector<int> >"));
  ::Reflex::Type type_11031 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<long long> >"));
  ::Reflex::Type type_3030 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long long,std::allocator<long long> >"));
  ::Reflex::Type type_10868 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<long*,std::vector<long> >"));
  ::Reflex::Type type_10872 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::vector<char> >"));
  ::Reflex::Type type_11047 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooArgSet*> >"));
  ::Reflex::Type type_3753 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,int> >"));
  ::Reflex::Type type_11049 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooAbsArg*> >"));
  ::Reflex::Type type_10854 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<float*,std::vector<float> >"));
  ::Reflex::Type type_11028 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned int> >"));
  ::Reflex::Type type_10870 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<short*,std::vector<short> >"));
  ::Reflex::Type type_3046 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> >"));
  ::Reflex::Type type_3048 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> >"));
  ::Reflex::Type type_3360 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<int,RooArgSet> >"));
  ::Reflex::Type type_11027 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned long> >"));
  ::Reflex::Type type_11030 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned char> >"));
  ::Reflex::Type type_11035 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooFitResult*> >"));
  ::Reflex::Type type_10888 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<double*,std::vector<double> >"));
  ::Reflex::Type type_11029 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned short> >"));
  ::Reflex::Type type_10885 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const int*,std::vector<int> >"));
  ::Reflex::Type type_3489 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_11054 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<TVirtualArray*> >"));
  ::Reflex::Type type_3358 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<int,RooAbsReal*> >"));
  ::Reflex::Type type_11051 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooNormSetCache> >"));
  ::Reflex::Type type_3027 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >"));
  ::Reflex::Type type_10869 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const long*,std::vector<long> >"));
  ::Reflex::Type type_10873 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::vector<char> >"));
  ::Reflex::Type type_10894 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >"));
  ::Reflex::Type type_11044 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooAbsRealLValue*> >"));
  ::Reflex::Type type_11048 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::vector<int> > >"));
  ::Reflex::Type type_10855 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const float*,std::vector<float> >"));
  ::Reflex::Type type_11026 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned long long> >"));
  ::Reflex::Type type_3026 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long,std::allocator<unsigned long> >"));
  ::Reflex::Type type_3029 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned char,std::allocator<unsigned char> >"));
  ::Reflex::Type type_10871 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const short*,std::vector<short> >"));
  ::Reflex::Type type_3034 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> >"));
  ::Reflex::Type type_11046 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::map<int,int> > >"));
  ::Reflex::Type type_11050 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooAbsCacheElement*> >"));
  ::Reflex::Type type_11055 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<ROOT::TSchemaHelper> >"));
  ::Reflex::Type type_10889 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const double*,std::vector<double> >"));
  ::Reflex::Type type_3028 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned short,std::allocator<unsigned short> >"));
  ::Reflex::Type type_10866 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >"));
  ::Reflex::Type type_11038 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::vector<double> > >"));
  ::Reflex::Type type_11039 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::vector<double>*> >"));
  ::Reflex::Type type_11043 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<const RooAbsBinning*> >"));
  ::Reflex::Type type_3053 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> >"));
  ::Reflex::Type type_3354 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> >"));
  ::Reflex::Type type_3050 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> >"));
  ::Reflex::Type type_10895 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const TString*,std::vector<TString> >"));
  ::Reflex::Type type_10898 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >"));
  ::Reflex::Type type_10902 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >"));
  ::Reflex::Type type_11037 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::map<void*,double> > >"));
  ::Reflex::Type type_11024 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooCubicSplineKnot::S_jk> >"));
  ::Reflex::Type type_3047 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > >"));
  ::Reflex::Type type_10860 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_10867 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> >"));
  ::Reflex::Type type_11041 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<double,TString> > >"));
  ::Reflex::Type type_3043 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> >"));
  ::Reflex::Type type_3045 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > >"));
  ::Reflex::Type type_11052 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooMsgService::StreamConfig> >"));
  ::Reflex::Type type_3025 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long long,std::allocator<unsigned long long> >"));
  ::Reflex::Type type_10858 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >"));
  ::Reflex::Type type_10864 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >"));
  ::Reflex::Type type_10874 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >"));
  ::Reflex::Type type_3106 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_10899 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooArgSet* const*,std::vector<RooArgSet*> >"));
  ::Reflex::Type type_10903 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsArg* const*,std::vector<RooAbsArg*> >"));
  ::Reflex::Type type_10862 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >"));
  ::Reflex::Type type_3049 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> >"));
  ::Reflex::Type type_10912 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >"));
  ::Reflex::Type type_3054 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> >"));
  ::Reflex::Type type_3945 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<int*,std::vector<int> > >"));
  ::Reflex::Type type_3696 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_3037 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > >"));
  ::Reflex::Type type_3356 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> >"));
  ::Reflex::Type type_10861 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_3038 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> >"));
  ::Reflex::Type type_10906 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >"));
  ::Reflex::Type type_3042 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> >"));
  ::Reflex::Type type_3917 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<long*,std::vector<long> > >"));
  ::Reflex::Type type_3921 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::vector<char> > >"));
  ::Reflex::Type type_10859 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >"));
  ::Reflex::Type type_10865 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> >"));
  ::Reflex::Type type_10875 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooFitResult* const*,std::vector<RooFitResult*> >"));
  ::Reflex::Type type_3903 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<float*,std::vector<float> > >"));
  ::Reflex::Type type_3919 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<short*,std::vector<short> > >"));
  ::Reflex::Type type_10900 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >"));
  ::Reflex::Type type_10863 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >"));
  ::Reflex::Type type_10892 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >"));
  ::Reflex::Type type_10913 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TVirtualArray* const*,std::vector<TVirtualArray*> >"));
  ::Reflex::Type type_3951 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<double*,std::vector<double> > >"));
  ::Reflex::Type type_3944 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const int*,std::vector<int> > >"));
  ::Reflex::Type type_3036 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > >"));
  ::Reflex::Type type_10896 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >"));
  ::Reflex::Type type_10856 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >"));
  ::Reflex::Type type_10907 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooNormSetCache*,std::vector<RooNormSetCache> >"));
  ::Reflex::Type type_3916 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const long*,std::vector<long> > >"));
  ::Reflex::Type type_3920 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::vector<char> > >"));
  ::Reflex::Type type_3961 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,std::vector<TString> > >"));
  ::Reflex::Type type_11053 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_3023 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> >"));
  ::Reflex::Type type_10904 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >"));
  ::Reflex::Type type_10914 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >"));
  ::Reflex::Type type_3902 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const float*,std::vector<float> > >"));
  ::Reflex::Type type_3918 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const short*,std::vector<short> > >"));
  ::Reflex::Type type_10880 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >"));
  ::Reflex::Type type_10901 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >"));
  ::Reflex::Type type_10882 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >"));
  ::Reflex::Type type_10890 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >"));
  ::Reflex::Type type_10893 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsRealLValue* const*,std::vector<RooAbsRealLValue*> >"));
  ::Reflex::Type type_3950 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const double*,std::vector<double> > >"));
  ::Reflex::Type type_3915 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<long long*,std::vector<long long> > >"));
  ::Reflex::Type type_3040 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > >"));
  ::Reflex::Type type_10897 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::map<int,int>*,std::vector<std::map<int,int> > >"));
  ::Reflex::Type type_10857 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> >"));
  ::Reflex::Type type_3960 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const TString*,std::vector<TString> > >"));
  ::Reflex::Type type_3965 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> > >"));
  ::Reflex::Type type_3983 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> > >"));
  ::Reflex::Type type_10905 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsCacheElement* const*,std::vector<RooAbsCacheElement*> >"));
  ::Reflex::Type type_3051 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> >"));
  ::Reflex::Type type_10915 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >"));
  ::Reflex::Type type_10878 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >"));
  ::Reflex::Type type_10881 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > >"));
  ::Reflex::Type type_10883 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<double>* const*,std::vector<std::vector<double>*> >"));
  ::Reflex::Type type_10891 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooAbsBinning* const*,std::vector<const RooAbsBinning*> >"));
  ::Reflex::Type type_3909 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_3914 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> > >"));
  ::Reflex::Type type_10852 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >"));
  ::Reflex::Type type_3907 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> > >"));
  ::Reflex::Type type_3913 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> > >"));
  ::Reflex::Type type_3923 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> > >"));
  ::Reflex::Type type_3964 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooArgSet* const*,std::vector<RooArgSet*> > >"));
  ::Reflex::Type type_3982 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsArg* const*,std::vector<RooAbsArg*> > >"));
  ::Reflex::Type type_3911 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> > >"));
  ::Reflex::Type type_10879 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::map<void*,double>*,std::vector<std::map<void*,double> > >"));
  ::Reflex::Type type_10886 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >"));
  ::Reflex::Type type_4013 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> > >"));
  ::Reflex::Type type_3908 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_3987 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> > >"));
  ::Reflex::Type type_10853 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >"));
  ::Reflex::Type type_10908 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >"));
  ::Reflex::Type type_3906 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> > >"));
  ::Reflex::Type type_3912 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> > >"));
  ::Reflex::Type type_3922 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooFitResult* const*,std::vector<RooFitResult*> > >"));
  ::Reflex::Type type_3967 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_3910 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> > >"));
  ::Reflex::Type type_10887 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<double,TString>*,std::vector<std::pair<double,TString> > >"));
  ::Reflex::Type type_3957 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> > >"));
  ::Reflex::Type type_4012 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TVirtualArray* const*,std::vector<TVirtualArray*> > >"));
  ::Reflex::Type type_11036 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_3963 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > > >"));
  ::Reflex::Type type_3905 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> > >"));
  ::Reflex::Type type_3986 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooNormSetCache*,std::vector<RooNormSetCache> > >"));
  ::Reflex::Type type_10909 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >"));
  ::Reflex::Type type_3985 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> > >"));
  ::Reflex::Type type_4015 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> > >"));
  ::Reflex::Type type_3929 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > > >"));
  ::Reflex::Type type_3966 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_3943 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> > >"));
  ::Reflex::Type type_3955 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> > >"));
  ::Reflex::Type type_3956 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsRealLValue* const*,std::vector<RooAbsRealLValue*> > >"));
  ::Reflex::Type type_3962 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::map<int,int>*,std::vector<std::map<int,int> > > >"));
  ::Reflex::Type type_3904 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> > >"));
  ::Reflex::Type type_3052 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_3984 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsCacheElement* const*,std::vector<RooAbsCacheElement*> > >"));
  ::Reflex::Type type_4014 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> > >"));
  ::Reflex::Type type_3927 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > > >"));
  ::Reflex::Type type_3928 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > > >"));
  ::Reflex::Type type_3942 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<double>* const*,std::vector<std::vector<double>*> > >"));
  ::Reflex::Type type_3954 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooAbsBinning* const*,std::vector<const RooAbsBinning*> > >"));
  ::Reflex::Type type_3901 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> > >"));
  ::Reflex::Type type_3926 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::map<void*,double>*,std::vector<std::map<void*,double> > > >"));
  ::Reflex::Type type_3949 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > > >"));
  ::Reflex::Type type_3900 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> > >"));
  ::Reflex::Type type_10910 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_3993 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> > >"));
  ::Reflex::Type type_3948 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<double,TString>*,std::vector<std::pair<double,TString> > > >"));
  ::Reflex::Type type_10911 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_3992 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> > >"));
  ::Reflex::Type type_4005 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > > >"));
  ::Reflex::Type type_4004 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > > >"));
  ::Reflex::Type type_3035 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_10876 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_10877 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_3925 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_3924 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_27790 = ::Reflex::ReferenceBuilder(type_12);
  ::Reflex::Type type_12c = ::Reflex::ConstBuilder(type_12);
  ::Reflex::Type type_27791 = ::Reflex::ReferenceBuilder(type_12c);
  ::Reflex::Type type_1039c = ::Reflex::ConstBuilder(type_1039);
  ::Reflex::Type type_4138 = ::Reflex::PointerBuilder(type_1039c);
  ::Reflex::Type type_27792 = ::Reflex::ReferenceBuilder(type_48);
  ::Reflex::Type type_27793 = ::Reflex::ReferenceBuilder(type_2525);
  ::Reflex::Type type_25556 = ::Reflex::PointerBuilder(type_1129);
  ::Reflex::Type type_8028 = ::Reflex::PointerBuilder(type_2058);
  ::Reflex::Type type_2654 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_196);
  ::Reflex::Type type_27794 = ::Reflex::ReferenceBuilder(type_434);
  ::Reflex::Type type_6055 = ::Reflex::ReferenceBuilder(type_2929);
  ::Reflex::Type type_2823c = ::Reflex::ConstBuilder(type_2823);
  ::Reflex::Type type_27878 = ::Reflex::ReferenceBuilder(type_2823c);
  ::Reflex::Type type_130c = ::Reflex::ConstBuilder(type_130);
  ::Reflex::Type type_27879 = ::Reflex::ReferenceBuilder(type_130c);
  ::Reflex::Type type_27880 = ::Reflex::ReferenceBuilder(type_130);
  ::Reflex::Type type_27881 = ::Reflex::PointerBuilder(type_130);
  ::Reflex::Type type_2317 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Double_t"), type_694);
  ::Reflex::Type type_1309 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_141);
  ::Reflex::Type type_27811 = ::Reflex::ReferenceBuilder(type_1126);
  ::Reflex::Type type_668 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_667);
  ::Reflex::Type type_1126c = ::Reflex::ConstBuilder(type_1126);
  ::Reflex::Type type_27806 = ::Reflex::ReferenceBuilder(type_1126c);
  ::Reflex::Type type_27882 = ::Reflex::PointerBuilder(type_2995);
  ::Reflex::Type type_27883 = ::Reflex::ReferenceBuilder(type_1420);
  ::Reflex::Type type_27808 = ::Reflex::PointerBuilder(type_1126c);
  ::Reflex::Type type_2834 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("UInt_t"), type_211);
  ::Reflex::Type type_27993 = ::Reflex::ReferenceBuilder(type_259);
  ::Reflex::Type type_259c = ::Reflex::ConstBuilder(type_259);
  ::Reflex::Type type_27994 = ::Reflex::ReferenceBuilder(type_259c);
  ::Reflex::Type type_27995 = ::Reflex::ReferenceBuilder(type_2033);
  ::Reflex::Type type_1962c = ::Reflex::ConstBuilder(type_1962);
  ::Reflex::Type type_9895 = ::Reflex::ReferenceBuilder(type_1962c);
  ::Reflex::Type type_28000 = ::Reflex::ReferenceBuilder(type_266);
  ::Reflex::Type type_266c = ::Reflex::ConstBuilder(type_266);
  ::Reflex::Type type_28001 = ::Reflex::ReferenceBuilder(type_266c);
  ::Reflex::Type type_28005 = ::Reflex::ReferenceBuilder(type_286);
  ::Reflex::Type type_286c = ::Reflex::ConstBuilder(type_286);
  ::Reflex::Type type_28006 = ::Reflex::ReferenceBuilder(type_286c);
  ::Reflex::Type type_28020 = ::Reflex::ReferenceBuilder(type_324);
  ::Reflex::Type type_324c = ::Reflex::ConstBuilder(type_324);
  ::Reflex::Type type_28021 = ::Reflex::ReferenceBuilder(type_324c);
  ::Reflex::Type type_2191c = ::Reflex::ConstBuilder(type_2191);
  ::Reflex::Type type_28022 = ::Reflex::ReferenceBuilder(type_2191c);
  ::Reflex::Type type_2021c = ::Reflex::ConstBuilder(type_2021);
  ::Reflex::Type type_27807 = ::Reflex::PointerBuilder(type_2021c);
  ::Reflex::Type type_2826c = ::Reflex::ConstBuilder(type_2826);
  ::Reflex::Type type_28023 = ::Reflex::ReferenceBuilder(type_2826c);
  ::Reflex::Type type_2172c = ::Reflex::ConstBuilder(type_2172);
  ::Reflex::Type type_27805 = ::Reflex::ReferenceBuilder(type_2172c);
  ::Reflex::Type type_28025 = ::Reflex::ReferenceBuilder(type_327);
  ::Reflex::Type type_327c = ::Reflex::ConstBuilder(type_327);
  ::Reflex::Type type_28026 = ::Reflex::ReferenceBuilder(type_327c);
  ::Reflex::Type type_2841c = ::Reflex::ConstBuilder(type_2841);
  ::Reflex::Type type_28081 = ::Reflex::ReferenceBuilder(type_2841c);
  ::Reflex::Type type_449c = ::Reflex::ConstBuilder(type_449);
  ::Reflex::Type type_28082 = ::Reflex::ReferenceBuilder(type_449c);
  ::Reflex::Type type_28083 = ::Reflex::ReferenceBuilder(type_449);
  ::Reflex::Type type_28084 = ::Reflex::PointerBuilder(type_449);
  ::Reflex::Type type_450c = ::Reflex::ConstBuilder(type_450);
  ::Reflex::Type type_28090 = ::Reflex::ReferenceBuilder(type_450c);
  ::Reflex::Type type_28091 = ::Reflex::ReferenceBuilder(type_450);
  ::Reflex::Type type_28092 = ::Reflex::PointerBuilder(type_450);
  ::Reflex::Type type_28105 = ::Reflex::ReferenceBuilder(type_485);
  ::Reflex::Type type_485c = ::Reflex::ConstBuilder(type_485);
  ::Reflex::Type type_28106 = ::Reflex::ReferenceBuilder(type_485c);
  ::Reflex::Type type_28133 = ::Reflex::ReferenceBuilder(type_515);
  ::Reflex::Type type_515c = ::Reflex::ConstBuilder(type_515);
  ::Reflex::Type type_28134 = ::Reflex::ReferenceBuilder(type_515c);
  ::Reflex::Type type_28143 = ::Reflex::ReferenceBuilder(type_577);
  ::Reflex::Type type_577c = ::Reflex::ConstBuilder(type_577);
  ::Reflex::Type type_28144 = ::Reflex::ReferenceBuilder(type_577c);
  ::Reflex::Type type_28194 = ::Reflex::ReferenceBuilder(type_664);
  ::Reflex::Type type_664c = ::Reflex::ConstBuilder(type_664);
  ::Reflex::Type type_28195 = ::Reflex::ReferenceBuilder(type_664c);
  ::Reflex::Type type_27801 = ::Reflex::ReferenceBuilder(type_39);
  ::Reflex::Type type_28196 = ::Reflex::PointerBuilder(type_664);
  ::Reflex::Type type_27804 = ::Reflex::PointerBuilder(type_952);
  ::Reflex::Type type_28158 = ::Reflex::PointerBuilder(type_2525);
  ::Reflex::Type type_2835 = ::Reflex::PointerBuilder(type_1126);
  ::Reflex::Type type_28198 = ::Reflex::ReferenceBuilder(type_670);
  ::Reflex::Type type_670c = ::Reflex::ConstBuilder(type_670);
  ::Reflex::Type type_28199 = ::Reflex::ReferenceBuilder(type_670c);
  ::Reflex::Type type_2525c = ::Reflex::ConstBuilder(type_2525);
  ::Reflex::Type type_28024 = ::Reflex::PointerBuilder(type_2525c);
  ::Reflex::Type type_28211 = ::Reflex::ReferenceBuilder(type_723);
  ::Reflex::Type type_723c = ::Reflex::ConstBuilder(type_723);
  ::Reflex::Type type_28212 = ::Reflex::ReferenceBuilder(type_723c);
  ::Reflex::Type type_28359 = ::Reflex::ReferenceBuilder(type_855);
  ::Reflex::Type type_855c = ::Reflex::ConstBuilder(type_855);
  ::Reflex::Type type_28360 = ::Reflex::ReferenceBuilder(type_855c);
  ::Reflex::Type type_694c = ::Reflex::ConstBuilder(type_694);
  ::Reflex::Type type_17964 = ::Reflex::PointerBuilder(type_694c);
  ::Reflex::Type type_3092c = ::Reflex::ConstBuilder(type_3092);
  ::Reflex::Type type_19008 = ::Reflex::ReferenceBuilder(type_3092c);
  ::Reflex::Type type_1620c = ::Reflex::ConstBuilder(type_1620);
  ::Reflex::Type type_27954 = ::Reflex::ReferenceBuilder(type_1620c);
  ::Reflex::Type type_19006 = ::Reflex::ReferenceBuilder(type_3092);
  ::Reflex::Type type_28266 = ::Reflex::PointerBuilder(type_2823c);
  ::Reflex::Type type_2145 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TVectorD"), type_2144);
  ::Reflex::Type type_28361 = ::Reflex::ReferenceBuilder(type_2145);
  ::Reflex::Type type_146 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_145);
  ::Reflex::Type type_28362 = ::Reflex::ReferenceBuilder(type_146);
  ::Reflex::Type type_28425 = ::Reflex::ReferenceBuilder(type_995);
  ::Reflex::Type type_995c = ::Reflex::ConstBuilder(type_995);
  ::Reflex::Type type_28426 = ::Reflex::ReferenceBuilder(type_995c);
  ::Reflex::Type type_2579c = ::Reflex::ConstBuilder(type_2579);
  ::Reflex::Type type_28427 = ::Reflex::ReferenceBuilder(type_2579c);
  ::Reflex::Type type_6064 = ::Reflex::ReferenceBuilder(type_1962);
  ::Reflex::Type type_2013 = ::Reflex::PointerBuilder(type_1620);
  ::Reflex::Type type_28442 = ::Reflex::ReferenceBuilder(type_1073);
  ::Reflex::Type type_1073c = ::Reflex::ConstBuilder(type_1073);
  ::Reflex::Type type_28443 = ::Reflex::ReferenceBuilder(type_1073c);
  ::Reflex::Type type_28562 = ::Reflex::ReferenceBuilder(type_1305);
  ::Reflex::Type type_1305c = ::Reflex::ConstBuilder(type_1305);
  ::Reflex::Type type_28563 = ::Reflex::ReferenceBuilder(type_1305c);
  ::Reflex::Type type_19447 = ::Reflex::PointerBuilder(type_1420);
  ::Reflex::Type type_28612 = ::Reflex::ReferenceBuilder(type_1382);
  ::Reflex::Type type_1382c = ::Reflex::ConstBuilder(type_1382);
  ::Reflex::Type type_28613 = ::Reflex::ReferenceBuilder(type_1382c);
  ::Reflex::Type type_27884 = ::Reflex::ReferenceBuilder(type_2525c);
  ::Reflex::Type type_2317c = ::Reflex::ConstBuilder(type_2317);
  ::Reflex::Type type_27858 = ::Reflex::PointerBuilder(type_2317c);
  ::Reflex::Type type_28647 = ::Reflex::ReferenceBuilder(type_1438);
  ::Reflex::Type type_1438c = ::Reflex::ConstBuilder(type_1438);
  ::Reflex::Type type_28648 = ::Reflex::ReferenceBuilder(type_1438c);
  ::Reflex::Type type_27803 = ::Reflex::ReferenceBuilder(type_1113);
  ::Reflex::Type type_28649 = ::Reflex::ReferenceBuilder(type_1672);
  ::Reflex::Type type_28656 = ::Reflex::PointerBuilder(type_2751);
  ::Reflex::Type type_28657 = ::Reflex::PointerBuilder(type_1382);
  ::Reflex::Type type_2786 = ::Reflex::PointerBuilder(type_1039);
  ::Reflex::Type type_22942 = ::Reflex::PointerBuilder(type_1113);
  ::Reflex::Type type_1473c = ::Reflex::ConstBuilder(type_1473);
  ::Reflex::Type type_28658 = ::Reflex::ReferenceBuilder(type_1473c);
  ::Reflex::Type type_28659 = ::Reflex::ReferenceBuilder(type_1473);
  ::Reflex::Type type_28660 = ::Reflex::ReferenceBuilder(type_2970);
  ::Reflex::Type type_2970c = ::Reflex::ConstBuilder(type_2970);
  ::Reflex::Type type_28661 = ::Reflex::ReferenceBuilder(type_2970c);
  ::Reflex::Type type_1576c = ::Reflex::ConstBuilder(type_1576);
  ::Reflex::Type type_28691 = ::Reflex::ReferenceBuilder(type_1576c);
  ::Reflex::Type type_28692 = ::Reflex::ReferenceBuilder(type_1576);
  ::Reflex::Type type_28693 = ::Reflex::PointerBuilder(type_1576);
  ::Reflex::Type type_28728 = ::Reflex::ReferenceBuilder(type_1630);
  ::Reflex::Type type_1630c = ::Reflex::ConstBuilder(type_1630);
  ::Reflex::Type type_28729 = ::Reflex::ReferenceBuilder(type_1630c);
  ::Reflex::Type type_28050 = ::Reflex::PointerBuilder(type_2033);
  ::Reflex::Type type_1672c = ::Reflex::ConstBuilder(type_1672);
  ::Reflex::Type type_28741 = ::Reflex::ReferenceBuilder(type_1672c);
  ::Reflex::Type type_3638c = ::Reflex::ConstBuilder(type_3638);
  ::Reflex::Type type_22832 = ::Reflex::ReferenceBuilder(type_3638c);
  ::Reflex::Type type_1675c = ::Reflex::ConstBuilder(type_1675);
  ::Reflex::Type type_28742 = ::Reflex::ReferenceBuilder(type_1675c);
  ::Reflex::Type type_28743 = ::Reflex::ReferenceBuilder(type_1675);
  ::Reflex::Type type_28744 = ::Reflex::ReferenceBuilder(type_1679);
  ::Reflex::Type type_1679c = ::Reflex::ConstBuilder(type_1679);
  ::Reflex::Type type_28745 = ::Reflex::ReferenceBuilder(type_1679c);
  ::Reflex::Type type_31095 = ::Reflex::ReferenceBuilder(type_1744);
  ::Reflex::Type type_1744c = ::Reflex::ConstBuilder(type_1744);
  ::Reflex::Type type_31096 = ::Reflex::ReferenceBuilder(type_1744c);
  ::Reflex::Type type_31129 = ::Reflex::ReferenceBuilder(type_1831);
  ::Reflex::Type type_1831c = ::Reflex::ConstBuilder(type_1831);
  ::Reflex::Type type_31130 = ::Reflex::ReferenceBuilder(type_1831c);
  ::Reflex::Type type_28642 = ::Reflex::ReferenceBuilder(type_1620);
  ::Reflex::Type type_31137 = ::Reflex::ReferenceBuilder(type_1880);
  ::Reflex::Type type_1880c = ::Reflex::ConstBuilder(type_1880);
  ::Reflex::Type type_31138 = ::Reflex::ReferenceBuilder(type_1880c);
  ::Reflex::Type type_1909c = ::Reflex::ConstBuilder(type_1909);
  ::Reflex::Type type_31143 = ::Reflex::ReferenceBuilder(type_1909c);
  ::Reflex::Type type_31144 = ::Reflex::ReferenceBuilder(type_1909);
  ::Reflex::Type type_31145 = ::Reflex::ReferenceBuilder(type_1927);
  ::Reflex::Type type_1927c = ::Reflex::ConstBuilder(type_1927);
  ::Reflex::Type type_31146 = ::Reflex::ReferenceBuilder(type_1927c);
  ::Reflex::Type type_31149 = ::Reflex::ReferenceBuilder(type_1939);
  ::Reflex::Type type_1939c = ::Reflex::ConstBuilder(type_1939);
  ::Reflex::Type type_31150 = ::Reflex::ReferenceBuilder(type_1939c);
  ::Reflex::Type type_31151 = ::Reflex::PointerBuilder(type_1939);
  ::Reflex::Type type_17968 = ::Reflex::ReferenceBuilder(type_694c);
  ::Reflex::Type type_17966 = ::Reflex::ReferenceBuilder(type_694);
  ::Reflex::Type type_31152 = ::Reflex::ReferenceBuilder(type_1940);
  ::Reflex::Type type_1940c = ::Reflex::ConstBuilder(type_1940);
  ::Reflex::Type type_31153 = ::Reflex::ReferenceBuilder(type_1940c);
  ::Reflex::Type type_31154 = ::Reflex::PointerBuilder(type_1940);
  ::Reflex::Type type_102c = ::Reflex::ConstBuilder(type_102);
  ::Reflex::Type type_18098 = ::Reflex::ReferenceBuilder(type_102c);
  ::Reflex::Type type_18096 = ::Reflex::ReferenceBuilder(type_102);
  ::Reflex::Type type_31155 = ::Reflex::ReferenceBuilder(type_1941);
  ::Reflex::Type type_1941c = ::Reflex::ConstBuilder(type_1941);
  ::Reflex::Type type_31156 = ::Reflex::ReferenceBuilder(type_1941c);
  ::Reflex::Type type_31157 = ::Reflex::PointerBuilder(type_1941);
  ::Reflex::Type type_820c = ::Reflex::ConstBuilder(type_820);
  ::Reflex::Type type_18163 = ::Reflex::ReferenceBuilder(type_820c);
  ::Reflex::Type type_18161 = ::Reflex::ReferenceBuilder(type_820);
  ::Reflex::Type type_31158 = ::Reflex::ReferenceBuilder(type_1942);
  ::Reflex::Type type_1942c = ::Reflex::ConstBuilder(type_1942);
  ::Reflex::Type type_31159 = ::Reflex::ReferenceBuilder(type_1942c);
  ::Reflex::Type type_31160 = ::Reflex::PointerBuilder(type_1942);
  ::Reflex::Type type_167c = ::Reflex::ConstBuilder(type_167);
  ::Reflex::Type type_18228 = ::Reflex::ReferenceBuilder(type_167c);
  ::Reflex::Type type_18226 = ::Reflex::ReferenceBuilder(type_167);
  ::Reflex::Type type_31161 = ::Reflex::ReferenceBuilder(type_1943);
  ::Reflex::Type type_1943c = ::Reflex::ConstBuilder(type_1943);
  ::Reflex::Type type_31162 = ::Reflex::ReferenceBuilder(type_1943c);
  ::Reflex::Type type_31163 = ::Reflex::PointerBuilder(type_1943);
  ::Reflex::Type type_211c = ::Reflex::ConstBuilder(type_211);
  ::Reflex::Type type_18293 = ::Reflex::ReferenceBuilder(type_211c);
  ::Reflex::Type type_18291 = ::Reflex::ReferenceBuilder(type_211);
  ::Reflex::Type type_31164 = ::Reflex::ReferenceBuilder(type_1944);
  ::Reflex::Type type_1944c = ::Reflex::ConstBuilder(type_1944);
  ::Reflex::Type type_31165 = ::Reflex::ReferenceBuilder(type_1944c);
  ::Reflex::Type type_31166 = ::Reflex::PointerBuilder(type_1944);
  ::Reflex::Type type_311c = ::Reflex::ConstBuilder(type_311);
  ::Reflex::Type type_18358 = ::Reflex::ReferenceBuilder(type_311c);
  ::Reflex::Type type_18356 = ::Reflex::ReferenceBuilder(type_311);
  ::Reflex::Type type_31167 = ::Reflex::ReferenceBuilder(type_1945);
  ::Reflex::Type type_1945c = ::Reflex::ConstBuilder(type_1945);
  ::Reflex::Type type_31168 = ::Reflex::ReferenceBuilder(type_1945c);
  ::Reflex::Type type_31169 = ::Reflex::PointerBuilder(type_1945);
  ::Reflex::Type type_291c = ::Reflex::ConstBuilder(type_291);
  ::Reflex::Type type_18423 = ::Reflex::ReferenceBuilder(type_291c);
  ::Reflex::Type type_18421 = ::Reflex::ReferenceBuilder(type_291);
  ::Reflex::Type type_31170 = ::Reflex::ReferenceBuilder(type_1946);
  ::Reflex::Type type_1946c = ::Reflex::ConstBuilder(type_1946);
  ::Reflex::Type type_31171 = ::Reflex::ReferenceBuilder(type_1946c);
  ::Reflex::Type type_31172 = ::Reflex::PointerBuilder(type_1946);
  ::Reflex::Type type_2017c = ::Reflex::ConstBuilder(type_2017);
  ::Reflex::Type type_18488 = ::Reflex::ReferenceBuilder(type_2017c);
  ::Reflex::Type type_18486 = ::Reflex::ReferenceBuilder(type_2017);
  ::Reflex::Type type_31173 = ::Reflex::ReferenceBuilder(type_1947);
  ::Reflex::Type type_1947c = ::Reflex::ConstBuilder(type_1947);
  ::Reflex::Type type_31174 = ::Reflex::ReferenceBuilder(type_1947c);
  ::Reflex::Type type_31175 = ::Reflex::PointerBuilder(type_1947);
  ::Reflex::Type type_194c = ::Reflex::ConstBuilder(type_194);
  ::Reflex::Type type_18553 = ::Reflex::ReferenceBuilder(type_194c);
  ::Reflex::Type type_18551 = ::Reflex::ReferenceBuilder(type_194);
  ::Reflex::Type type_31176 = ::Reflex::ReferenceBuilder(type_1948);
  ::Reflex::Type type_1948c = ::Reflex::ConstBuilder(type_1948);
  ::Reflex::Type type_31177 = ::Reflex::ReferenceBuilder(type_1948c);
  ::Reflex::Type type_31178 = ::Reflex::PointerBuilder(type_1948);
  ::Reflex::Type type_141c = ::Reflex::ConstBuilder(type_141);
  ::Reflex::Type type_18618 = ::Reflex::ReferenceBuilder(type_141c);
  ::Reflex::Type type_18616 = ::Reflex::ReferenceBuilder(type_141);
  ::Reflex::Type type_31179 = ::Reflex::ReferenceBuilder(type_1949);
  ::Reflex::Type type_1949c = ::Reflex::ConstBuilder(type_1949);
  ::Reflex::Type type_31180 = ::Reflex::ReferenceBuilder(type_1949c);
  ::Reflex::Type type_31181 = ::Reflex::PointerBuilder(type_1949);
  ::Reflex::Type type_196c = ::Reflex::ConstBuilder(type_196);
  ::Reflex::Type type_18683 = ::Reflex::ReferenceBuilder(type_196c);
  ::Reflex::Type type_18681 = ::Reflex::ReferenceBuilder(type_196);
  ::Reflex::Type type_31182 = ::Reflex::ReferenceBuilder(type_1950);
  ::Reflex::Type type_1950c = ::Reflex::ConstBuilder(type_1950);
  ::Reflex::Type type_31183 = ::Reflex::ReferenceBuilder(type_1950c);
  ::Reflex::Type type_31184 = ::Reflex::PointerBuilder(type_1950);
  ::Reflex::Type type_18747 = ::Reflex::ReferenceBuilder(type_1039c);
  ::Reflex::Type type_18745 = ::Reflex::ReferenceBuilder(type_1039);
  ::Reflex::Type type_31285 = ::Reflex::ReferenceBuilder(type_2072);
  ::Reflex::Type type_2072c = ::Reflex::ConstBuilder(type_2072);
  ::Reflex::Type type_31286 = ::Reflex::ReferenceBuilder(type_2072c);
  ::Reflex::Type type_22409 = ::Reflex::PointerBuilder(type_2494);
  ::Reflex::Type type_18802 = ::Reflex::PointerBuilder(type_2041);
  ::Reflex::Type type_28320 = ::Reflex::PointerBuilder(type_844);
  ::Reflex::Type type_27832 = ::Reflex::PointerBuilder(type_1147);
  ::Reflex::Type type_31287 = ::Reflex::ReferenceBuilder(type_2078);
  ::Reflex::Type type_2078c = ::Reflex::ConstBuilder(type_2078);
  ::Reflex::Type type_31288 = ::Reflex::ReferenceBuilder(type_2078c);
  ::Reflex::Type type_2007c = ::Reflex::ConstBuilder(type_2007);
  ::Reflex::Type type_27854 = ::Reflex::ReferenceBuilder(type_2007c);
  ::Reflex::Type type_31289 = ::Reflex::PointerBuilder(type_2278);
  ::Reflex::Type type_28738 = ::Reflex::ReferenceBuilder(type_1656);
  ::Reflex::Type type_3159 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_3149);
  ::Reflex::Type type_3159c = ::Reflex::ConstBuilder(type_3159);
  ::Reflex::Type type_28052 = ::Reflex::PointerBuilder(type_2021);
  ::Reflex::Type type_6066 = ::Reflex::ReferenceBuilder(type_2743);
  ::Reflex::Type type_31300 = ::Reflex::ReferenceBuilder(type_2117);
  ::Reflex::Type type_2117c = ::Reflex::ConstBuilder(type_2117);
  ::Reflex::Type type_31301 = ::Reflex::ReferenceBuilder(type_2117c);
  ::Reflex::Type type_1819c = ::Reflex::ConstBuilder(type_1819);
  ::Reflex::Type type_31123 = ::Reflex::PointerBuilder(type_1819c);
  ::Reflex::Type type_800c = ::Reflex::ConstBuilder(type_800);
  ::Reflex::Type type_31302 = ::Reflex::PointerBuilder(type_800c);
  ::Reflex::Type type_2165c = ::Reflex::ConstBuilder(type_2165);
  ::Reflex::Type type_31429 = ::Reflex::ReferenceBuilder(type_2165c);
  ::Reflex::Type type_31430 = ::Reflex::ReferenceBuilder(type_2165);
  ::Reflex::Type type_31432 = ::Reflex::ReferenceBuilder(type_2200);
  ::Reflex::Type type_2200c = ::Reflex::ConstBuilder(type_2200);
  ::Reflex::Type type_31433 = ::Reflex::ReferenceBuilder(type_2200c);
  ::Reflex::Type type_2956 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ostream"), type_2955);
  ::Reflex::Type type_9893 = ::Reflex::ReferenceBuilder(type_2956);
  ::Reflex::Type type_2203c = ::Reflex::ConstBuilder(type_2203);
  ::Reflex::Type type_31466 = ::Reflex::ReferenceBuilder(type_2203c);
  ::Reflex::Type type_31467 = ::Reflex::PointerBuilder(type_2203);
  ::Reflex::Type type_31468 = ::Reflex::ReferenceBuilder(type_2203);
  ::Reflex::Type type_13580c = ::Reflex::ConstBuilder(type_13580);
  ::Reflex::Type type_2204c = ::Reflex::ConstBuilder(type_2204);
  ::Reflex::Type type_31502 = ::Reflex::ReferenceBuilder(type_2204c);
  ::Reflex::Type type_31503 = ::Reflex::PointerBuilder(type_2204);
  ::Reflex::Type type_31504 = ::Reflex::ReferenceBuilder(type_2204);
  ::Reflex::Type type_13605c = ::Reflex::ConstBuilder(type_13605);
  ::Reflex::Type type_2205c = ::Reflex::ConstBuilder(type_2205);
  ::Reflex::Type type_31538 = ::Reflex::ReferenceBuilder(type_2205c);
  ::Reflex::Type type_31539 = ::Reflex::PointerBuilder(type_2205);
  ::Reflex::Type type_31540 = ::Reflex::ReferenceBuilder(type_2205);
  ::Reflex::Type type_13630c = ::Reflex::ConstBuilder(type_13630);
  ::Reflex::Type type_2206c = ::Reflex::ConstBuilder(type_2206);
  ::Reflex::Type type_31574 = ::Reflex::ReferenceBuilder(type_2206c);
  ::Reflex::Type type_31575 = ::Reflex::PointerBuilder(type_2206);
  ::Reflex::Type type_31576 = ::Reflex::ReferenceBuilder(type_2206);
  ::Reflex::Type type_13655c = ::Reflex::ConstBuilder(type_13655);
  ::Reflex::Type type_2207c = ::Reflex::ConstBuilder(type_2207);
  ::Reflex::Type type_31610 = ::Reflex::ReferenceBuilder(type_2207c);
  ::Reflex::Type type_31611 = ::Reflex::PointerBuilder(type_2207);
  ::Reflex::Type type_31612 = ::Reflex::ReferenceBuilder(type_2207);
  ::Reflex::Type type_13680c = ::Reflex::ConstBuilder(type_13680);
  ::Reflex::Type type_2208c = ::Reflex::ConstBuilder(type_2208);
  ::Reflex::Type type_31646 = ::Reflex::ReferenceBuilder(type_2208c);
  ::Reflex::Type type_31647 = ::Reflex::PointerBuilder(type_2208);
  ::Reflex::Type type_31648 = ::Reflex::ReferenceBuilder(type_2208);
  ::Reflex::Type type_13705c = ::Reflex::ConstBuilder(type_13705);
  ::Reflex::Type type_2209c = ::Reflex::ConstBuilder(type_2209);
  ::Reflex::Type type_31682 = ::Reflex::ReferenceBuilder(type_2209c);
  ::Reflex::Type type_31683 = ::Reflex::PointerBuilder(type_2209);
  ::Reflex::Type type_31684 = ::Reflex::ReferenceBuilder(type_2209);
  ::Reflex::Type type_13730c = ::Reflex::ConstBuilder(type_13730);
  ::Reflex::Type type_2210c = ::Reflex::ConstBuilder(type_2210);
  ::Reflex::Type type_31718 = ::Reflex::ReferenceBuilder(type_2210c);
  ::Reflex::Type type_31719 = ::Reflex::PointerBuilder(type_2210);
  ::Reflex::Type type_31720 = ::Reflex::ReferenceBuilder(type_2210);
  ::Reflex::Type type_13755c = ::Reflex::ConstBuilder(type_13755);
  ::Reflex::Type type_2211c = ::Reflex::ConstBuilder(type_2211);
  ::Reflex::Type type_31754 = ::Reflex::ReferenceBuilder(type_2211c);
  ::Reflex::Type type_31755 = ::Reflex::PointerBuilder(type_2211);
  ::Reflex::Type type_31756 = ::Reflex::ReferenceBuilder(type_2211);
  ::Reflex::Type type_13780c = ::Reflex::ConstBuilder(type_13780);
  ::Reflex::Type type_2212c = ::Reflex::ConstBuilder(type_2212);
  ::Reflex::Type type_31790 = ::Reflex::ReferenceBuilder(type_2212c);
  ::Reflex::Type type_31791 = ::Reflex::PointerBuilder(type_2212);
  ::Reflex::Type type_31792 = ::Reflex::ReferenceBuilder(type_2212);
  ::Reflex::Type type_13805c = ::Reflex::ConstBuilder(type_13805);
  ::Reflex::Type type_2213c = ::Reflex::ConstBuilder(type_2213);
  ::Reflex::Type type_31826 = ::Reflex::ReferenceBuilder(type_2213c);
  ::Reflex::Type type_31827 = ::Reflex::PointerBuilder(type_2213);
  ::Reflex::Type type_31828 = ::Reflex::ReferenceBuilder(type_2213);
  ::Reflex::Type type_13830c = ::Reflex::ConstBuilder(type_13830);
  ::Reflex::Type type_2214c = ::Reflex::ConstBuilder(type_2214);
  ::Reflex::Type type_31862 = ::Reflex::ReferenceBuilder(type_2214c);
  ::Reflex::Type type_31863 = ::Reflex::PointerBuilder(type_2214);
  ::Reflex::Type type_31864 = ::Reflex::ReferenceBuilder(type_2214);
  ::Reflex::Type type_13855c = ::Reflex::ConstBuilder(type_13855);
  ::Reflex::Type type_31869 = ::Reflex::ReferenceBuilder(type_2231);
  ::Reflex::Type type_2231c = ::Reflex::ConstBuilder(type_2231);
  ::Reflex::Type type_31870 = ::Reflex::ReferenceBuilder(type_2231c);
  ::Reflex::Type type_31921 = ::Reflex::ReferenceBuilder(type_2502);
  ::Reflex::Type type_2502c = ::Reflex::ConstBuilder(type_2502);
  ::Reflex::Type type_31922 = ::Reflex::ReferenceBuilder(type_2502c);
  ::Reflex::Type type_31986 = ::Reflex::ReferenceBuilder(type_2590);
  ::Reflex::Type type_2590c = ::Reflex::ConstBuilder(type_2590);
  ::Reflex::Type type_31987 = ::Reflex::ReferenceBuilder(type_2590c);
  ::Reflex::Type type_32060 = ::Reflex::ReferenceBuilder(type_2744);
  ::Reflex::Type type_2744c = ::Reflex::ConstBuilder(type_2744);
  ::Reflex::Type type_32061 = ::Reflex::ReferenceBuilder(type_2744c);
  ::Reflex::Type type_32062 = ::Reflex::PointerBuilder(type_2744);
  ::Reflex::Type type_6346 = ::Reflex::PointerBuilder(type_694);
  ::Reflex::Type type_3405 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_167);
  ::Reflex::Type type_3258 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_194);
  ::Reflex::Type type_3681c = ::Reflex::ConstBuilder(type_3681);
  ::Reflex::Type type_32471 = ::Reflex::ReferenceBuilder(type_3681c);
  ::Reflex::Type type_18031 = ::Reflex::ReferenceBuilder(type_7159);
  ::Reflex::Type type_7159c = ::Reflex::ConstBuilder(type_7159);
  ::Reflex::Type type_18033 = ::Reflex::ReferenceBuilder(type_7159c);
  ::Reflex::Type type_17327 = ::Reflex::PointerBuilder(type_7159);
  ::Reflex::Type type_18029 = ::Reflex::PointerBuilder(type_7159c);
  ::Reflex::Type type_3682c = ::Reflex::ConstBuilder(type_3682);
  ::Reflex::Type type_32237 = ::Reflex::ReferenceBuilder(type_3682c);
  ::Reflex::Type type_3093c = ::Reflex::ConstBuilder(type_3093);
  ::Reflex::Type type_32656 = ::Reflex::ReferenceBuilder(type_3093c);
  ::Reflex::Type type_32657 = ::Reflex::ReferenceBuilder(type_3093);
  ::Reflex::Type type_6054 = ::Reflex::PointerBuilder(type_102);
  ::Reflex::Type type_18094 = ::Reflex::PointerBuilder(type_102c);
  ::Reflex::Type type_3684c = ::Reflex::ConstBuilder(type_3684);
  ::Reflex::Type type_32250 = ::Reflex::ReferenceBuilder(type_3684c);
  ::Reflex::Type type_3094c = ::Reflex::ConstBuilder(type_3094);
  ::Reflex::Type type_32659 = ::Reflex::ReferenceBuilder(type_3094c);
  ::Reflex::Type type_32660 = ::Reflex::ReferenceBuilder(type_3094);
  ::Reflex::Type type_17364 = ::Reflex::PointerBuilder(type_820);
  ::Reflex::Type type_18159 = ::Reflex::PointerBuilder(type_820c);
  ::Reflex::Type type_3685c = ::Reflex::ConstBuilder(type_3685);
  ::Reflex::Type type_32263 = ::Reflex::ReferenceBuilder(type_3685c);
  ::Reflex::Type type_3095c = ::Reflex::ConstBuilder(type_3095);
  ::Reflex::Type type_32662 = ::Reflex::ReferenceBuilder(type_3095c);
  ::Reflex::Type type_32663 = ::Reflex::ReferenceBuilder(type_3095);
  ::Reflex::Type type_17383 = ::Reflex::PointerBuilder(type_167);
  ::Reflex::Type type_18224 = ::Reflex::PointerBuilder(type_167c);
  ::Reflex::Type type_3686c = ::Reflex::ConstBuilder(type_3686);
  ::Reflex::Type type_32276 = ::Reflex::ReferenceBuilder(type_3686c);
  ::Reflex::Type type_3096c = ::Reflex::ConstBuilder(type_3096);
  ::Reflex::Type type_32665 = ::Reflex::ReferenceBuilder(type_3096c);
  ::Reflex::Type type_32666 = ::Reflex::ReferenceBuilder(type_3096);
  ::Reflex::Type type_13938 = ::Reflex::PointerBuilder(type_211);
  ::Reflex::Type type_18289 = ::Reflex::PointerBuilder(type_211c);
  ::Reflex::Type type_3687c = ::Reflex::ConstBuilder(type_3687);
  ::Reflex::Type type_32289 = ::Reflex::ReferenceBuilder(type_3687c);
  ::Reflex::Type type_3097c = ::Reflex::ConstBuilder(type_3097);
  ::Reflex::Type type_32668 = ::Reflex::ReferenceBuilder(type_3097c);
  ::Reflex::Type type_32669 = ::Reflex::ReferenceBuilder(type_3097);
  ::Reflex::Type type_4409 = ::Reflex::PointerBuilder(type_311);
  ::Reflex::Type type_18354 = ::Reflex::PointerBuilder(type_311c);
  ::Reflex::Type type_3688c = ::Reflex::ConstBuilder(type_3688);
  ::Reflex::Type type_32302 = ::Reflex::ReferenceBuilder(type_3688c);
  ::Reflex::Type type_3098c = ::Reflex::ConstBuilder(type_3098);
  ::Reflex::Type type_32671 = ::Reflex::ReferenceBuilder(type_3098c);
  ::Reflex::Type type_32672 = ::Reflex::ReferenceBuilder(type_3098);
  ::Reflex::Type type_17438 = ::Reflex::PointerBuilder(type_291);
  ::Reflex::Type type_18419 = ::Reflex::PointerBuilder(type_291c);
  ::Reflex::Type type_3689c = ::Reflex::ConstBuilder(type_3689);
  ::Reflex::Type type_32315 = ::Reflex::ReferenceBuilder(type_3689c);
  ::Reflex::Type type_3099c = ::Reflex::ConstBuilder(type_3099);
  ::Reflex::Type type_32674 = ::Reflex::ReferenceBuilder(type_3099c);
  ::Reflex::Type type_32675 = ::Reflex::ReferenceBuilder(type_3099);
  ::Reflex::Type type_17457 = ::Reflex::PointerBuilder(type_2017);
  ::Reflex::Type type_18484 = ::Reflex::PointerBuilder(type_2017c);
  ::Reflex::Type type_3690c = ::Reflex::ConstBuilder(type_3690);
  ::Reflex::Type type_32328 = ::Reflex::ReferenceBuilder(type_3690c);
  ::Reflex::Type type_3100c = ::Reflex::ConstBuilder(type_3100);
  ::Reflex::Type type_32677 = ::Reflex::ReferenceBuilder(type_3100c);
  ::Reflex::Type type_32678 = ::Reflex::ReferenceBuilder(type_3100);
  ::Reflex::Type type_9464 = ::Reflex::PointerBuilder(type_194);
  ::Reflex::Type type_18549 = ::Reflex::PointerBuilder(type_194c);
  ::Reflex::Type type_3691c = ::Reflex::ConstBuilder(type_3691);
  ::Reflex::Type type_32341 = ::Reflex::ReferenceBuilder(type_3691c);
  ::Reflex::Type type_3101c = ::Reflex::ConstBuilder(type_3101);
  ::Reflex::Type type_32679 = ::Reflex::ReferenceBuilder(type_3101c);
  ::Reflex::Type type_32680 = ::Reflex::ReferenceBuilder(type_3101);
  ::Reflex::Type type_4140 = ::Reflex::PointerBuilder(type_141);
  ::Reflex::Type type_18614 = ::Reflex::PointerBuilder(type_141c);
  ::Reflex::Type type_3692c = ::Reflex::ConstBuilder(type_3692);
  ::Reflex::Type type_32445 = ::Reflex::ReferenceBuilder(type_3692c);
  ::Reflex::Type type_3102c = ::Reflex::ConstBuilder(type_3102);
  ::Reflex::Type type_19651 = ::Reflex::ReferenceBuilder(type_3102c);
  ::Reflex::Type type_19649 = ::Reflex::ReferenceBuilder(type_3102);
  ::Reflex::Type type_17494 = ::Reflex::PointerBuilder(type_196);
  ::Reflex::Type type_18679 = ::Reflex::PointerBuilder(type_196c);
  ::Reflex::Type type_3693c = ::Reflex::ConstBuilder(type_3693);
  ::Reflex::Type type_32354 = ::Reflex::ReferenceBuilder(type_3693c);
  ::Reflex::Type type_3103c = ::Reflex::ConstBuilder(type_3103);
  ::Reflex::Type type_32682 = ::Reflex::ReferenceBuilder(type_3103c);
  ::Reflex::Type type_32683 = ::Reflex::ReferenceBuilder(type_3103);
  ::Reflex::Type type_3694c = ::Reflex::ConstBuilder(type_3694);
  ::Reflex::Type type_32367 = ::Reflex::ReferenceBuilder(type_3694c);
  ::Reflex::Type type_3104c = ::Reflex::ConstBuilder(type_3104);
  ::Reflex::Type type_32684 = ::Reflex::ReferenceBuilder(type_3104c);
  ::Reflex::Type type_32685 = ::Reflex::ReferenceBuilder(type_3104);
  ::Reflex::Type type_17531 = ::Reflex::PointerBuilder(type_18802);
  ::Reflex::Type type_18802c = ::Reflex::ConstBuilder(type_18802);
  ::Reflex::Type type_18809 = ::Reflex::PointerBuilder(type_18802c);
  ::Reflex::Type type_18811 = ::Reflex::ReferenceBuilder(type_18802);
  ::Reflex::Type type_18813 = ::Reflex::ReferenceBuilder(type_18802c);
  ::Reflex::Type type_3695c = ::Reflex::ConstBuilder(type_3695);
  ::Reflex::Type type_32380 = ::Reflex::ReferenceBuilder(type_3695c);
  ::Reflex::Type type_3105c = ::Reflex::ConstBuilder(type_3105);
  ::Reflex::Type type_32687 = ::Reflex::ReferenceBuilder(type_3105c);
  ::Reflex::Type type_32688 = ::Reflex::ReferenceBuilder(type_3105);
  ::Reflex::Type type_17550 = ::Reflex::PointerBuilder(type_3489);
  ::Reflex::Type type_3489c = ::Reflex::ConstBuilder(type_3489);
  ::Reflex::Type type_18874 = ::Reflex::PointerBuilder(type_3489c);
  ::Reflex::Type type_18876 = ::Reflex::ReferenceBuilder(type_3489);
  ::Reflex::Type type_18878 = ::Reflex::ReferenceBuilder(type_3489c);
  ::Reflex::Type type_3696c = ::Reflex::ConstBuilder(type_3696);
  ::Reflex::Type type_32393 = ::Reflex::ReferenceBuilder(type_3696c);
  ::Reflex::Type type_3106c = ::Reflex::ConstBuilder(type_3106);
  ::Reflex::Type type_32690 = ::Reflex::ReferenceBuilder(type_3106c);
  ::Reflex::Type type_32691 = ::Reflex::ReferenceBuilder(type_3106);
  ::Reflex::Type type_17569 = ::Reflex::PointerBuilder(type_3353);
  ::Reflex::Type type_3353c = ::Reflex::ConstBuilder(type_3353);
  ::Reflex::Type type_18939 = ::Reflex::PointerBuilder(type_3353c);
  ::Reflex::Type type_18941 = ::Reflex::ReferenceBuilder(type_3353);
  ::Reflex::Type type_18943 = ::Reflex::ReferenceBuilder(type_3353c);
  ::Reflex::Type type_3697c = ::Reflex::ConstBuilder(type_3697);
  ::Reflex::Type type_32406 = ::Reflex::ReferenceBuilder(type_3697c);
  ::Reflex::Type type_3107c = ::Reflex::ConstBuilder(type_3107);
  ::Reflex::Type type_32693 = ::Reflex::ReferenceBuilder(type_3107c);
  ::Reflex::Type type_32694 = ::Reflex::ReferenceBuilder(type_3107);
  ::Reflex::Type type_17588 = ::Reflex::PointerBuilder(type_3092);
  ::Reflex::Type type_19004 = ::Reflex::PointerBuilder(type_3092c);
  ::Reflex::Type type_3699c = ::Reflex::ConstBuilder(type_3699);
  ::Reflex::Type type_32419 = ::Reflex::ReferenceBuilder(type_3699c);
  ::Reflex::Type type_3108c = ::Reflex::ConstBuilder(type_3108);
  ::Reflex::Type type_32696 = ::Reflex::ReferenceBuilder(type_3108c);
  ::Reflex::Type type_32697 = ::Reflex::ReferenceBuilder(type_3108);
  ::Reflex::Type type_17607 = ::Reflex::PointerBuilder(type_17588);
  ::Reflex::Type type_17588c = ::Reflex::ConstBuilder(type_17588);
  ::Reflex::Type type_19069 = ::Reflex::PointerBuilder(type_17588c);
  ::Reflex::Type type_19071 = ::Reflex::ReferenceBuilder(type_17588);
  ::Reflex::Type type_19073 = ::Reflex::ReferenceBuilder(type_17588c);
  ::Reflex::Type type_3717c = ::Reflex::ConstBuilder(type_3717);
  ::Reflex::Type type_32432 = ::Reflex::ReferenceBuilder(type_3717c);
  ::Reflex::Type type_3110c = ::Reflex::ConstBuilder(type_3110);
  ::Reflex::Type type_32699 = ::Reflex::ReferenceBuilder(type_3110c);
  ::Reflex::Type type_32700 = ::Reflex::ReferenceBuilder(type_3110);
  ::Reflex::Type type_17832 = ::Reflex::PointerBuilder(type_795);
  ::Reflex::Type type_795c = ::Reflex::ConstBuilder(type_795);
  ::Reflex::Type type_19134 = ::Reflex::PointerBuilder(type_795c);
  ::Reflex::Type type_19136 = ::Reflex::ReferenceBuilder(type_795);
  ::Reflex::Type type_19138 = ::Reflex::ReferenceBuilder(type_795c);
  ::Reflex::Type type_3718c = ::Reflex::ConstBuilder(type_3718);
  ::Reflex::Type type_32587 = ::Reflex::ReferenceBuilder(type_3718c);
  ::Reflex::Type type_3111c = ::Reflex::ConstBuilder(type_3111);
  ::Reflex::Type type_32702 = ::Reflex::ReferenceBuilder(type_3111c);
  ::Reflex::Type type_32703 = ::Reflex::ReferenceBuilder(type_3111);
  ::Reflex::Type type_17644 = ::Reflex::PointerBuilder(type_3517);
  ::Reflex::Type type_3517c = ::Reflex::ConstBuilder(type_3517);
  ::Reflex::Type type_19199 = ::Reflex::PointerBuilder(type_3517c);
  ::Reflex::Type type_19201 = ::Reflex::ReferenceBuilder(type_3517);
  ::Reflex::Type type_19203 = ::Reflex::ReferenceBuilder(type_3517c);
  ::Reflex::Type type_3723c = ::Reflex::ConstBuilder(type_3723);
  ::Reflex::Type type_32458 = ::Reflex::ReferenceBuilder(type_3723c);
  ::Reflex::Type type_3112c = ::Reflex::ConstBuilder(type_3112);
  ::Reflex::Type type_32705 = ::Reflex::ReferenceBuilder(type_3112c);
  ::Reflex::Type type_32706 = ::Reflex::ReferenceBuilder(type_3112);
  ::Reflex::Type type_17718 = ::Reflex::PointerBuilder(type_2743);
  ::Reflex::Type type_2743c = ::Reflex::ConstBuilder(type_2743);
  ::Reflex::Type type_9755 = ::Reflex::PointerBuilder(type_2743c);
  ::Reflex::Type type_5554 = ::Reflex::ReferenceBuilder(type_2743c);
  ::Reflex::Type type_3730c = ::Reflex::ConstBuilder(type_3730);
  ::Reflex::Type type_32509 = ::Reflex::ReferenceBuilder(type_3730c);
  ::Reflex::Type type_3114c = ::Reflex::ConstBuilder(type_3114);
  ::Reflex::Type type_32707 = ::Reflex::ReferenceBuilder(type_3114c);
  ::Reflex::Type type_32708 = ::Reflex::ReferenceBuilder(type_3114);
  ::Reflex::Type type_17737 = ::Reflex::PointerBuilder(type_3366);
  ::Reflex::Type type_3366c = ::Reflex::ConstBuilder(type_3366);
  ::Reflex::Type type_19326 = ::Reflex::PointerBuilder(type_3366c);
  ::Reflex::Type type_19328 = ::Reflex::ReferenceBuilder(type_3366);
  ::Reflex::Type type_19330 = ::Reflex::ReferenceBuilder(type_3366c);
  ::Reflex::Type type_3731c = ::Reflex::ConstBuilder(type_3731);
  ::Reflex::Type type_32522 = ::Reflex::ReferenceBuilder(type_3731c);
  ::Reflex::Type type_3115c = ::Reflex::ConstBuilder(type_3115);
  ::Reflex::Type type_32710 = ::Reflex::ReferenceBuilder(type_3115c);
  ::Reflex::Type type_32711 = ::Reflex::ReferenceBuilder(type_3115);
  ::Reflex::Type type_641c = ::Reflex::ConstBuilder(type_641);
  ::Reflex::Type type_16939 = ::Reflex::PointerBuilder(type_641c);
  ::Reflex::Type type_16945 = ::Reflex::PointerBuilder(type_16939);
  ::Reflex::Type type_16939c = ::Reflex::ConstBuilder(type_16939);
  ::Reflex::Type type_16947 = ::Reflex::PointerBuilder(type_16939c);
  ::Reflex::Type type_16949 = ::Reflex::ReferenceBuilder(type_16939);
  ::Reflex::Type type_16951 = ::Reflex::ReferenceBuilder(type_16939c);
  ::Reflex::Type type_3714c = ::Reflex::ConstBuilder(type_3714);
  ::Reflex::Type type_32195 = ::Reflex::ReferenceBuilder(type_3714c);
  ::Reflex::Type type_3116c = ::Reflex::ConstBuilder(type_3116);
  ::Reflex::Type type_32712 = ::Reflex::ReferenceBuilder(type_3116c);
  ::Reflex::Type type_32713 = ::Reflex::ReferenceBuilder(type_3116);
  ::Reflex::Type type_17699 = ::Reflex::PointerBuilder(type_19447);
  ::Reflex::Type type_19447c = ::Reflex::ConstBuilder(type_19447);
  ::Reflex::Type type_19454 = ::Reflex::PointerBuilder(type_19447c);
  ::Reflex::Type type_19456 = ::Reflex::ReferenceBuilder(type_19447);
  ::Reflex::Type type_19458 = ::Reflex::ReferenceBuilder(type_19447c);
  ::Reflex::Type type_3727c = ::Reflex::ConstBuilder(type_3727);
  ::Reflex::Type type_32496 = ::Reflex::ReferenceBuilder(type_3727c);
  ::Reflex::Type type_3117c = ::Reflex::ConstBuilder(type_3117);
  ::Reflex::Type type_32715 = ::Reflex::ReferenceBuilder(type_3117c);
  ::Reflex::Type type_32716 = ::Reflex::ReferenceBuilder(type_3117);
  ::Reflex::Type type_17951 = ::Reflex::PointerBuilder(type_3224);
  ::Reflex::Type type_667c = ::Reflex::ConstBuilder(type_667);
  ::Reflex::Type type_17941 = ::Reflex::PointerBuilder(type_667c);
  ::Reflex::Type type_3729c = ::Reflex::ConstBuilder(type_3729);
  ::Reflex::Type type_32717 = ::Reflex::ReferenceBuilder(type_3729c);
  ::Reflex::Type type_26071 = ::Reflex::ReferenceBuilder(type_667c);
  ::Reflex::Type type_3118c = ::Reflex::ConstBuilder(type_3118);
  ::Reflex::Type type_32718 = ::Reflex::ReferenceBuilder(type_3118c);
  ::Reflex::Type type_32719 = ::Reflex::ReferenceBuilder(type_3118);
  ::Reflex::Type type_17756 = ::Reflex::PointerBuilder(type_2835);
  ::Reflex::Type type_2835c = ::Reflex::ConstBuilder(type_2835);
  ::Reflex::Type type_19582 = ::Reflex::PointerBuilder(type_2835c);
  ::Reflex::Type type_19584 = ::Reflex::ReferenceBuilder(type_2835);
  ::Reflex::Type type_19586 = ::Reflex::ReferenceBuilder(type_2835c);
  ::Reflex::Type type_3735c = ::Reflex::ConstBuilder(type_3735);
  ::Reflex::Type type_32535 = ::Reflex::ReferenceBuilder(type_3735c);
  ::Reflex::Type type_3119c = ::Reflex::ConstBuilder(type_3119);
  ::Reflex::Type type_32721 = ::Reflex::ReferenceBuilder(type_3119c);
  ::Reflex::Type type_32722 = ::Reflex::ReferenceBuilder(type_3119);
  ::Reflex::Type type_17775 = ::Reflex::PointerBuilder(type_3102);
  ::Reflex::Type type_19647 = ::Reflex::PointerBuilder(type_3102c);
  ::Reflex::Type type_3736c = ::Reflex::ConstBuilder(type_3736);
  ::Reflex::Type type_32548 = ::Reflex::ReferenceBuilder(type_3736c);
  ::Reflex::Type type_3120c = ::Reflex::ConstBuilder(type_3120);
  ::Reflex::Type type_32724 = ::Reflex::ReferenceBuilder(type_3120c);
  ::Reflex::Type type_32725 = ::Reflex::ReferenceBuilder(type_3120);
  ::Reflex::Type type_17870 = ::Reflex::PointerBuilder(type_3555);
  ::Reflex::Type type_3555c = ::Reflex::ConstBuilder(type_3555);
  ::Reflex::Type type_19712 = ::Reflex::PointerBuilder(type_3555c);
  ::Reflex::Type type_19714 = ::Reflex::ReferenceBuilder(type_3555);
  ::Reflex::Type type_19716 = ::Reflex::ReferenceBuilder(type_3555c);
  ::Reflex::Type type_3753c = ::Reflex::ConstBuilder(type_3753);
  ::Reflex::Type type_32613 = ::Reflex::ReferenceBuilder(type_3753c);
  ::Reflex::Type type_3121c = ::Reflex::ConstBuilder(type_3121);
  ::Reflex::Type type_32727 = ::Reflex::ReferenceBuilder(type_3121c);
  ::Reflex::Type type_31252 = ::Reflex::ReferenceBuilder(type_3121);
  ::Reflex::Type type_19771 = ::Reflex::PointerBuilder(type_1962);
  ::Reflex::Type type_17794 = ::Reflex::PointerBuilder(type_19771);
  ::Reflex::Type type_19771c = ::Reflex::ConstBuilder(type_19771);
  ::Reflex::Type type_19778 = ::Reflex::PointerBuilder(type_19771c);
  ::Reflex::Type type_19780 = ::Reflex::ReferenceBuilder(type_19771);
  ::Reflex::Type type_19782 = ::Reflex::ReferenceBuilder(type_19771c);
  ::Reflex::Type type_3754c = ::Reflex::ConstBuilder(type_3754);
  ::Reflex::Type type_32561 = ::Reflex::ReferenceBuilder(type_3754c);
  ::Reflex::Type type_3122c = ::Reflex::ConstBuilder(type_3122);
  ::Reflex::Type type_32729 = ::Reflex::ReferenceBuilder(type_3122c);
  ::Reflex::Type type_32730 = ::Reflex::ReferenceBuilder(type_3122);
  ::Reflex::Type type_19837 = ::Reflex::PointerBuilder(type_2677);
  ::Reflex::Type type_17813 = ::Reflex::PointerBuilder(type_19837);
  ::Reflex::Type type_19837c = ::Reflex::ConstBuilder(type_19837);
  ::Reflex::Type type_19844 = ::Reflex::PointerBuilder(type_19837c);
  ::Reflex::Type type_19846 = ::Reflex::ReferenceBuilder(type_19837);
  ::Reflex::Type type_19848 = ::Reflex::ReferenceBuilder(type_19837c);
  ::Reflex::Type type_3755c = ::Reflex::ConstBuilder(type_3755);
  ::Reflex::Type type_32574 = ::Reflex::ReferenceBuilder(type_3755c);
  ::Reflex::Type type_3123c = ::Reflex::ConstBuilder(type_3123);
  ::Reflex::Type type_32732 = ::Reflex::ReferenceBuilder(type_3123c);
  ::Reflex::Type type_32733 = ::Reflex::ReferenceBuilder(type_3123);
  ::Reflex::Type type_17851 = ::Reflex::PointerBuilder(type_4328);
  ::Reflex::Type type_4328c = ::Reflex::ConstBuilder(type_4328);
  ::Reflex::Type type_19909 = ::Reflex::PointerBuilder(type_4328c);
  ::Reflex::Type type_19911 = ::Reflex::ReferenceBuilder(type_4328);
  ::Reflex::Type type_19913 = ::Reflex::ReferenceBuilder(type_4328c);
  ::Reflex::Type type_3760c = ::Reflex::ConstBuilder(type_3760);
  ::Reflex::Type type_32600 = ::Reflex::ReferenceBuilder(type_3760c);
  ::Reflex::Type type_3124c = ::Reflex::ConstBuilder(type_3124);
  ::Reflex::Type type_20756 = ::Reflex::ReferenceBuilder(type_3124c);
  ::Reflex::Type type_20754 = ::Reflex::ReferenceBuilder(type_3124);
  ::Reflex::Type type_19968 = ::Reflex::PointerBuilder(type_532);
  ::Reflex::Type type_17889 = ::Reflex::PointerBuilder(type_19968);
  ::Reflex::Type type_19968c = ::Reflex::ConstBuilder(type_19968);
  ::Reflex::Type type_19975 = ::Reflex::PointerBuilder(type_19968c);
  ::Reflex::Type type_19977 = ::Reflex::ReferenceBuilder(type_19968);
  ::Reflex::Type type_19979 = ::Reflex::ReferenceBuilder(type_19968c);
  ::Reflex::Type type_3780c = ::Reflex::ConstBuilder(type_3780);
  ::Reflex::Type type_32626 = ::Reflex::ReferenceBuilder(type_3780c);
  ::Reflex::Type type_3126c = ::Reflex::ConstBuilder(type_3126);
  ::Reflex::Type type_32736 = ::Reflex::ReferenceBuilder(type_3126c);
  ::Reflex::Type type_32737 = ::Reflex::ReferenceBuilder(type_3126);
  ::Reflex::Type type_17908 = ::Reflex::PointerBuilder(type_13472);
  ::Reflex::Type type_13472c = ::Reflex::ConstBuilder(type_13472);
  ::Reflex::Type type_20040 = ::Reflex::PointerBuilder(type_13472c);
  ::Reflex::Type type_20042 = ::Reflex::ReferenceBuilder(type_13472);
  ::Reflex::Type type_20044 = ::Reflex::ReferenceBuilder(type_13472c);
  ::Reflex::Type type_3781c = ::Reflex::ConstBuilder(type_3781);
  ::Reflex::Type type_32639 = ::Reflex::ReferenceBuilder(type_3781c);
  ::Reflex::Type type_3127c = ::Reflex::ConstBuilder(type_3127);
  ::Reflex::Type type_32739 = ::Reflex::ReferenceBuilder(type_3127c);
  ::Reflex::Type type_32740 = ::Reflex::ReferenceBuilder(type_3127);
  ::Reflex::Type type_33171 = ::Reflex::ReferenceBuilder(type_3488);
  ::Reflex::Type type_3488c = ::Reflex::ConstBuilder(type_3488);
  ::Reflex::Type type_33172 = ::Reflex::ReferenceBuilder(type_3488c);
  ::Reflex::Type type_3149c = ::Reflex::ConstBuilder(type_3149);
  ::Reflex::Type type_17092 = ::Reflex::ReferenceBuilder(type_3149c);
  ::Reflex::Type type_22409c = ::Reflex::ConstBuilder(type_22409);
  ::Reflex::Type type_33109 = ::Reflex::ReferenceBuilder(type_22409c);
  ::Reflex::Type type_33860 = ::Reflex::ArrayBuilder(type_667, 2);
  ::Reflex::Type type_33775 = ::Reflex::ArrayBuilder(type_694, 2);
  ::Reflex::Type type_33861 = ::Reflex::ReferenceBuilder(type_7158);
  ::Reflex::Type type_7158c = ::Reflex::ConstBuilder(type_7158);
  ::Reflex::Type type_33862 = ::Reflex::ReferenceBuilder(type_7158c);
  ::Reflex::Type type_33863 = ::Reflex::ReferenceBuilder(type_7160);
  ::Reflex::Type type_7160c = ::Reflex::ConstBuilder(type_7160);
  ::Reflex::Type type_33864 = ::Reflex::ReferenceBuilder(type_7160c);
  ::Reflex::Type type_28007 = ::Reflex::ReferenceBuilder(type_844);
  ::Reflex::Type type_27809 = ::Reflex::PointerBuilder(type_39);
  ::Reflex::Type type_28430 = ::Reflex::PointerBuilder(type_2819);
  ::Reflex::Type type_28431 = ::Reflex::PointerBuilder(type_781);
  ::Reflex::Type type_28255 = ::Reflex::ReferenceBuilder(type_1554);
  ::Reflex::Type type_28432 = ::Reflex::PointerBuilder(type_2099);
  ::Reflex::Type type_28433 = ::Reflex::PointerBuilder(type_236);
  ::Reflex::Type type_28610 = ::Reflex::PointerBuilder(type_252);
  ::Reflex::Type type_28611 = ::Reflex::PointerBuilder(type_265);
  ::Reflex::Type type_28682 = ::Reflex::ReferenceBuilder(type_2021);
  ::Reflex::Type type_28388 = ::Reflex::ReferenceBuilder(type_906);
  ::Reflex::Type type_28641 = ::Reflex::PointerBuilder(type_245);
  ::Reflex::Type type_31923 = ::Reflex::ReferenceBuilder(type_3109);
  ::Reflex::Type type_27950 = ::Reflex::PointerBuilder(type_2134);
  ::Reflex::Type type_8027 = ::Reflex::PointerBuilder(type_2976);
  ::Reflex::Type type_28058 = ::Reflex::PointerBuilder(type_1656);
  ::Reflex::Type type_31924 = ::Reflex::ReferenceBuilder(type_3159);
  ::Reflex::Type type_28685 = ::Reflex::ReferenceBuilder(type_1573);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TagEfficiencyWeight
#undef __TagEfficiencyWeight
#endif
class __TagEfficiencyWeight : public ::RooAbsReal {
  public:
  __TagEfficiencyWeight();
  virtual ~__TagEfficiencyWeight() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooCategoryProxy tag;
  ::RooRealProxy eff;
};
#ifdef __RooBinned1DQuinticBase_RooAbsReal_
#undef __RooBinned1DQuinticBase_RooAbsReal_
#endif
class __RooBinned1DQuinticBase_RooAbsReal_ : public ::RooAbsReal {
  public:
  __RooBinned1DQuinticBase_RooAbsReal_();
  virtual ~__RooBinned1DQuinticBase_RooAbsReal_() throw();
#ifdef __RooBinned1DQuinticBase_RooAbsReal_____148
#undef __RooBinned1DQuinticBase_RooAbsReal_____148
#endif
  enum __RooBinned1DQuinticBase_RooAbsReal_____148 {};
#ifdef __RooBinned1DQuinticBase_RooAbsReal___BinSizeException
#undef __RooBinned1DQuinticBase_RooAbsReal___BinSizeException
#endif
  class __RooBinned1DQuinticBase_RooAbsReal___BinSizeException :   public ::std::exception   {
    public:
    __RooBinned1DQuinticBase_RooAbsReal___BinSizeException();
    virtual ~__RooBinned1DQuinticBase_RooAbsReal___BinSizeException() throw();
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Bool_t isBinnedDistribution(RooArgSet const&) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::std::list<double>* binBoundaries(RooAbsRealLValue&, double, double) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooBinned1DQuinticBase<RooAbsReal>* clone(char const*) const throw();
  virtual ::std::list<double>* plotSamplingHint(RooAbsRealLValue&, double, double) const throw();
  ::RooRealProxy x;
  int nBinsX;
  double binSizeX;
  double xmin;
  double xmax;
  bool isIntegral;
  ::SharedArray<double> coeffs;
};
#ifdef __DecRateCoeff
#undef __DecRateCoeff
#endif
class __DecRateCoeff : public ::RooAbsReal {
  public:
  __DecRateCoeff();
  virtual ~__DecRateCoeff() throw();
#ifdef __DecRateCoeff__CacheElem
#undef __DecRateCoeff__CacheElem
#endif
  class __DecRateCoeff__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __DecRateCoeff__CacheElem();
    virtual ~__DecRateCoeff__CacheElem() throw();
#ifdef __DecRateCoeff__CacheElem__Flags
#undef __DecRateCoeff__CacheElem__Flags
#endif
    enum __DecRateCoeff__CacheElem__Flags {};
    void* m_etaintpdftagged;
    void* m_etaintprodpdfmistagtaggedplus;
    void* m_etaintprodpdfmistagtaggedminus;
    void* m_etaintpdfuntagged;
    ::RooArgSet m_nset;
    void* m_rangeName;
    int& m_parent;
    ::std::string m_workRangeName[2];
    ::std::pair<RooRealVar*,RooRealVar*> m_workRange[2];
    ::std::vector<double> m_etabins;
    double m_prodcachedval[2];
    __DecRateCoeff__CacheElem__Flags m_flags;
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegralWN(int, RooArgSet const*, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::Double_t getValV(RooArgSet const*) const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual ::Int_t getAnalyticalIntegralWN(RooArgSet&, RooArgSet&, RooArgSet const*, char const*) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooCategoryProxy m_qf;
  ::RooCategoryProxy m_qt;
  ::RooRealProxy m_Cf;
  ::RooRealProxy m_Cfbar;
  ::RooRealProxy m_etaobs;
  ::RooRealProxy m_etapdf;
  ::RooUniform m_etapdfutinstance;
  ::RooRealProxy m_etapdfut;
  ::RooRealProxy m_tageff;
  ::RooRealProxy m_eta;
  ::RooRealProxy m_etabar;
  ::RooRealProxy m_aprod;
  ::RooRealProxy m_adet;
  ::RooRealProxy m_atageff;
  ::RooObjCacheManager m_cacheMgr;
  ::std::map<unsigned int,RooArgSet> m_nsets;
  void* m_nset;
  ::UInt_t m_nsethash;
  ::DecRateCoeff::Flags m_flags;
};
#ifdef __IfThreeWayPdf
#undef __IfThreeWayPdf
#endif
class __IfThreeWayPdf : public ::RooAbsPdf {
  public:
  __IfThreeWayPdf();
  virtual ~__IfThreeWayPdf() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy cond;
  ::RooRealProxy pos;
  ::RooRealProxy zero;
  ::RooRealProxy neg;
};
#ifdef __Inverse
#undef __Inverse
#endif
class __Inverse : public ::RooAbsReal {
  public:
  __Inverse();
  virtual ~__Inverse() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy val;
};
#ifdef __RooEffConvGenContext
#undef __RooEffConvGenContext
#endif
class __RooEffConvGenContext : public ::RooConvGenContext {
  public:
  __RooEffConvGenContext();
  virtual ~__RooEffConvGenContext() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual void generateEvent(RooArgSet&, int) throw();
  virtual ::TClass* IsA() const throw();
  virtual void attach(RooArgSet const&) throw();
  virtual void Streamer(TBuffer&) throw();
  double _maxEff;
};
#ifdef __BdPTAcceptance
#undef __BdPTAcceptance
#endif
class __BdPTAcceptance : public ::RooAbsReal {
  public:
  __BdPTAcceptance();
  virtual ~__BdPTAcceptance() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy t;
  ::RooRealProxy beta;
  ::RooRealProxy slope;
  ::RooRealProxy offset;
};
#ifdef __RooBinned2DBicubicBase_RooAbsPdf_
#undef __RooBinned2DBicubicBase_RooAbsPdf_
#endif
class __RooBinned2DBicubicBase_RooAbsPdf_ : public ::RooAbsPdf {
  public:
  __RooBinned2DBicubicBase_RooAbsPdf_();
  virtual ~__RooBinned2DBicubicBase_RooAbsPdf_() throw();
#ifdef __RooBinned2DBicubicBase_RooAbsPdf_____147
#undef __RooBinned2DBicubicBase_RooAbsPdf_____147
#endif
  enum __RooBinned2DBicubicBase_RooAbsPdf_____147 {};
#ifdef __RooBinned2DBicubicBase_RooAbsPdf___BinSizeException
#undef __RooBinned2DBicubicBase_RooAbsPdf___BinSizeException
#endif
  class __RooBinned2DBicubicBase_RooAbsPdf___BinSizeException :   public ::std::exception   {
    public:
    __RooBinned2DBicubicBase_RooAbsPdf___BinSizeException();
    virtual ~__RooBinned2DBicubicBase_RooAbsPdf___BinSizeException() throw();
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooBinned2DBicubicBase<RooAbsPdf>* clone(char const*) const throw();
  ::RooRealProxy x;
  ::RooRealProxy y;
  int nBinsX;
  int nBinsY;
  double binSizeX;
  double binSizeY;
  double xmin;
  double xmax;
  double ymin;
  double ymax;
  ::SharedArray<double> coeffs;
};
#ifdef __RooBinned2DBicubicBase_RooAbsReal_
#undef __RooBinned2DBicubicBase_RooAbsReal_
#endif
class __RooBinned2DBicubicBase_RooAbsReal_ : public ::RooAbsReal {
  public:
  __RooBinned2DBicubicBase_RooAbsReal_();
  virtual ~__RooBinned2DBicubicBase_RooAbsReal_() throw();
#ifdef __RooBinned2DBicubicBase_RooAbsReal_____147
#undef __RooBinned2DBicubicBase_RooAbsReal_____147
#endif
  enum __RooBinned2DBicubicBase_RooAbsReal_____147 {};
#ifdef __RooBinned2DBicubicBase_RooAbsReal___BinSizeException
#undef __RooBinned2DBicubicBase_RooAbsReal___BinSizeException
#endif
  class __RooBinned2DBicubicBase_RooAbsReal___BinSizeException :   public ::std::exception   {
    public:
    __RooBinned2DBicubicBase_RooAbsReal___BinSizeException();
    virtual ~__RooBinned2DBicubicBase_RooAbsReal___BinSizeException() throw();
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooBinned2DBicubicBase<RooAbsReal>* clone(char const*) const throw();
  ::RooRealProxy x;
  ::RooRealProxy y;
  int nBinsX;
  int nBinsY;
  double binSizeX;
  double binSizeY;
  double xmin;
  double xmax;
  double ymin;
  double ymax;
  ::SharedArray<double> coeffs;
};
#ifdef __IfThreeWayCatPdf
#undef __IfThreeWayCatPdf
#endif
class __IfThreeWayCatPdf : public ::RooAbsPdf {
  public:
  __IfThreeWayCatPdf();
  virtual ~__IfThreeWayCatPdf() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooCategoryProxy cond;
  ::RooRealProxy pos;
  ::RooRealProxy zero;
  ::RooRealProxy neg;
};
#ifdef __NonOscTaggingPdf
#undef __NonOscTaggingPdf
#endif
class __NonOscTaggingPdf : public ::RooAbsPdf {
  public:
  __NonOscTaggingPdf();
  virtual ~__NonOscTaggingPdf() throw();
#ifdef __NonOscTaggingPdf__CacheElem
#undef __NonOscTaggingPdf__CacheElem
#endif
  class __NonOscTaggingPdf__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __NonOscTaggingPdf__CacheElem();
    virtual ~__NonOscTaggingPdf__CacheElem() throw();
#ifdef __NonOscTaggingPdf__CacheElem__Flags
#undef __NonOscTaggingPdf__CacheElem__Flags
#endif
    enum __NonOscTaggingPdf__CacheElem__Flags {};
    int& m_parent;
    void* m_etapdfint;
    void* m_etapdfintut;
    ::RooArgSet m_nset;
    void* m_rangeName;
    __NonOscTaggingPdf__CacheElem__Flags m_flags;
  };
  virtual ::Bool_t selfNormalized() const throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegralWN(int, RooArgSet const*, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual ::Int_t getAnalyticalIntegralWN(RooArgSet&, RooArgSet&, RooArgSet const*, char const*) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooCategoryProxy m_qf;
  ::RooCategoryProxy m_qt;
  ::RooRealProxy m_etaobs;
  ::RooRealProxy m_etapdf;
  ::RooUniform m_etapdfutinstance;
  ::RooRealProxy m_etapdfut;
  ::RooRealProxy m_epsilon;
  ::RooRealProxy m_adet;
  ::RooRealProxy m_atageff_f;
  ::RooRealProxy m_atageff_t;
  ::RooObjCacheManager m_cacheMgr;
};
#ifdef __DTAcceptanceLHCbNote2007041
#undef __DTAcceptanceLHCbNote2007041
#endif
class __DTAcceptanceLHCbNote2007041 : public ::RooAbsReal {
  public:
  __DTAcceptanceLHCbNote2007041();
  virtual ~__DTAcceptanceLHCbNote2007041() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy t;
  ::RooRealProxy s_low;
  ::RooRealProxy s_high;
  ::RooRealProxy n;
  ::RooRealProxy limit;
};
#ifdef __RooEffResModel
#undef __RooEffResModel
#endif
class __RooEffResModel : public ::RooResolutionModel, public ::RooAbsEffResModel {
  public:
  __RooEffResModel();
  virtual ~__RooEffResModel() throw();
#ifdef __RooEffResModel__CacheElem
#undef __RooEffResModel__CacheElem
#endif
  class __RooEffResModel__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __RooEffResModel__CacheElem();
    virtual ~__RooEffResModel__CacheElem() throw();
    ::std::vector<double> _bounds;
    void* _x;
    void* _eff;
    void* _xmin;
    void* _xmax;
    void* _int;
    ::Double_t _val;
  };
  virtual ::Int_t getGenerator(RooArgSet const&, RooArgSet&, bool) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::RooArgSet* observables() const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::std::vector<RooAbsReal*> efficiencies() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::RooAbsReal* efficiency() const throw();
  virtual ::RooResolutionModel& model() const throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual void initGenerator(int) throw();
  virtual ::Int_t basisCode(char const*) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooEffResModel* clone(char const*) const throw();
  virtual void generateEvent(int) throw();
  virtual ::RooAbsGenContext* modelGenContext(RooAbsAnaConvPdf const&, RooArgSet const&, RooDataSet const*, RooArgSet const*, bool) const throw();
  virtual ::RooEffResModel* convolution(RooFormulaVar*, RooAbsArg*) const throw();
  ::RooSetProxy _observables;
  ::RooRealProxy _model;
  ::RooRealProxy _eff;
  ::RooObjCacheManager _cacheMgr;
};
#ifdef __RooAbsEffResModel
#undef __RooAbsEffResModel
#endif
class __RooAbsEffResModel {
  public:
  __RooAbsEffResModel();
  virtual ~__RooAbsEffResModel() throw();
};
#ifdef __IfThreeWayCat
#undef __IfThreeWayCat
#endif
class __IfThreeWayCat : public ::RooAbsReal {
  public:
  __IfThreeWayCat();
  virtual ~__IfThreeWayCat() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooCategoryProxy cond;
  ::RooRealProxy pos;
  ::RooRealProxy zero;
  ::RooRealProxy neg;
};
#ifdef __RooCubicSplineKnot
#undef __RooCubicSplineKnot
#endif
class __RooCubicSplineKnot {
  public:
  __RooCubicSplineKnot();
  virtual ~__RooCubicSplineKnot() throw();
  ::std::vector<double> _u;
  ::std::vector<double> _PQRS;
  ::std::vector<double> _IABCD;
  ::std::vector<RooCubicSplineKnot::S_jk> _S_jk;
};
#ifdef __RooBinnedPdf
#undef __RooBinnedPdf
#endif
class __RooBinnedPdf : public ::RooAbsPdf {
  public:
  __RooBinnedPdf();
  virtual ~__RooBinnedPdf() throw();
#ifdef __RooBinnedPdf__CacheElem
#undef __RooBinnedPdf__CacheElem
#endif
  class __RooBinnedPdf__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __RooBinnedPdf__CacheElem();
    virtual ~__RooBinnedPdf__CacheElem() throw();
    int& _parent;
    void* _function;
    ::std::vector<RooAbsRealLValue*> _baseVarsList;
    ::std::vector<const RooAbsBinning*> _binningList;
    ::std::map<RooAbsRealLValue*,RooAbsRealLValue*> _baseVarsMapping;
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::std::list<double>* binBoundaries(RooAbsRealLValue&, double, double) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::Double_t getValV(RooArgSet const*) const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t maxVal(int) const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::std::list<double>* plotSamplingHint(RooAbsRealLValue&, double, double) const throw();
  ::RooListProxy _baseCatsList;
  ::RooListProxy _baseVarsList;
  ::TObjArray _coefLists;
  ::RooRealProxy _function;
  ::std::vector<std::map<int,int> > _indexPositions;
  ::std::vector<TString> _binningNames;
  ::std::vector<bool> _calcCoefZeros;
  ::Int_t _numCats;
  ::Bool_t _continuousBase;
  ::Bool_t _forceUnitIntegral;
  ::Bool_t _binIntegralCoefs;
  ::Bool_t _ignoreFirstBin;
  ::RooObjCacheManager m_cacheMgr;
  void* m_nset;
  ::UInt_t m_nsethash;
  ::std::map<unsigned int,RooArgSet> m_nsets;
};
#ifdef __MistagDistribution
#undef __MistagDistribution
#endif
class __MistagDistribution : public ::RooAbsPdf {
  public:
  __MistagDistribution();
  virtual ~__MistagDistribution() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy w;
  ::RooRealProxy w0;
  ::RooRealProxy wa;
  ::RooRealProxy f;
  double lastw0;
  double lastwa;
  double lastf;
  double lastwc;
};
#ifdef __SquaredSum
#undef __SquaredSum
#endif
class __SquaredSum : public ::RooAbsReal {
  public:
  __SquaredSum();
  virtual ~__SquaredSum() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy C;
  ::RooRealProxy D;
  ::RooRealProxy S;
};
#ifdef __RooGenSmearIntegrandBinding
#undef __RooGenSmearIntegrandBinding
#endif
class __RooGenSmearIntegrandBinding : public ::RooAbsFunc {
  public:
  __RooGenSmearIntegrandBinding();
  virtual ~__RooGenSmearIntegrandBinding() throw();
  void* _func;
  void* _model;
  void* _var;
  void* _nset;
  ::Bool_t _xvecValid;
  ::Bool_t _clipInvalid;
};
#ifdef __RooGaussEfficiencyModel
#undef __RooGaussEfficiencyModel
#endif
class __RooGaussEfficiencyModel : public ::RooResolutionModel, public ::RooAbsEffResModel {
  public:
  __RooGaussEfficiencyModel();
  virtual ~__RooGaussEfficiencyModel() throw();
  virtual ::Int_t getGenerator(RooArgSet const&, RooArgSet&, bool) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::RooArgSet* observables() const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual const ::RooAbsReal* efficiency() const throw();
  virtual ::Int_t basisCode(char const*) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual void generateEvent(int) throw();
  virtual ::Bool_t isDirectGenSafe(RooAbsArg const&) const throw();
  virtual ::RooAbsGenContext* modelGenContext(RooAbsAnaConvPdf const&, RooArgSet const&, RooDataSet const*, RooArgSet const*, bool) const throw();
  ::Bool_t _flatSFInt;
  ::RooRealProxy eff;
  ::RooRealProxy mean;
  ::RooRealProxy sigma;
  ::RooRealProxy msf;
  ::RooRealProxy ssf;
};
#ifdef __RooGeneralisedSmearingBase_RooAbsPdf_
#undef __RooGeneralisedSmearingBase_RooAbsPdf_
#endif
class __RooGeneralisedSmearingBase_RooAbsPdf_ : public ::RooAbsPdf {
  public:
  __RooGeneralisedSmearingBase_RooAbsPdf_();
  virtual ~__RooGeneralisedSmearingBase_RooAbsPdf_() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t getMax(int) const throw();
  virtual void printCompactTreeHook(std::ostream&, char const*) throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::Bool_t redirectServersHook(RooAbsCollection const&, bool, bool, bool) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::Bool_t _init;
  ::RooNumIntConfig _convIntConfig;
  void* _integrator;
  void* _integrand;
  ::RooRealProxy _origVar;
  ::RooRealProxy _origPdf;
  ::RooRealProxy _origModel;
  void* _cloneVar;
  void* _clonePdf;
  void* _cloneModel;
  ::std::map<std::basic_string<char>,std::map<int,RooArgSet> > _integvarset;
  ::std::map<std::basic_string<char>,std::map<int,RooAbsReal*> > _integralset;
  ::std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> > _integrandset;
  ::std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> > _integratorset;
  void* _binning;
  ::RooRealProxy _binnedvar;
  void* _binnedvarClone;
  ::RooArgSet _binnedcats;
  ::std::vector<std::vector<double> > _binnedcache;
  ::std::vector<std::map<void*,double> > _binnedcacheLastVal;
  bool _preferBinnedIntegrals;
  ::Bool_t _useWindow;
  ::Double_t _windowScale;
  ::RooListProxy _windowParam;
};
#ifdef __RooBinned1DQuinticBase_RooAbsPdf_
#undef __RooBinned1DQuinticBase_RooAbsPdf_
#endif
class __RooBinned1DQuinticBase_RooAbsPdf_ : public ::RooAbsPdf {
  public:
  __RooBinned1DQuinticBase_RooAbsPdf_();
  virtual ~__RooBinned1DQuinticBase_RooAbsPdf_() throw();
#ifdef __RooBinned1DQuinticBase_RooAbsPdf_____148
#undef __RooBinned1DQuinticBase_RooAbsPdf_____148
#endif
  enum __RooBinned1DQuinticBase_RooAbsPdf_____148 {};
#ifdef __RooBinned1DQuinticBase_RooAbsPdf___BinSizeException
#undef __RooBinned1DQuinticBase_RooAbsPdf___BinSizeException
#endif
  class __RooBinned1DQuinticBase_RooAbsPdf___BinSizeException :   public ::std::exception   {
    public:
    __RooBinned1DQuinticBase_RooAbsPdf___BinSizeException();
    virtual ~__RooBinned1DQuinticBase_RooAbsPdf___BinSizeException() throw();
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Bool_t isBinnedDistribution(RooArgSet const&) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::std::list<double>* binBoundaries(RooAbsRealLValue&, double, double) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooBinned1DQuinticBase<RooAbsPdf>* clone(char const*) const throw();
  virtual ::std::list<double>* plotSamplingHint(RooAbsRealLValue&, double, double) const throw();
  ::RooRealProxy x;
  int nBinsX;
  double binSizeX;
  double xmin;
  double xmax;
  bool isIntegral;
  ::SharedArray<double> coeffs;
};
#ifdef __RooEffHistProd
#undef __RooEffHistProd
#endif
class __RooEffHistProd : public ::RooAbsPdf {
  public:
  __RooEffHistProd();
  virtual ~__RooEffHistProd() throw();
#ifdef __RooEffHistProd__CacheElem
#undef __RooEffHistProd__CacheElem
#endif
  class __RooEffHistProd__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __RooEffHistProd__CacheElem();
    virtual ~__RooEffHistProd__CacheElem() throw();
    ::RooArgSet _intObs;
    void* _clone;
    void* _I;
    bool _trivial;
  };
  virtual ::Int_t getGenerator(RooArgSet const&, RooArgSet&, bool) const throw();
  virtual ::RooAbsGenContext* genContext(RooArgSet const&, RooDataSet const*, RooArgSet const*, bool) const throw();
  virtual ::Double_t expectedEvents(RooArgSet const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::RooAbsPdf::ExtendMode extendMode() const throw();
  virtual ::Double_t getValV(RooArgSet const*) const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual void initGenerator(int) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual void generateEvent(int) throw();
  virtual void selectNormalization(RooArgSet const*, bool) throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  ::std::vector<double> _binboundaries;
  ::RooRealProxy _pdf;
  ::RooRealProxy _eff;
  ::RooSetProxy _observables;
  ::RooArgSet _pdfGenVars;
  ::Int_t _pdfGenCode;
  ::Double_t _maxEff;
  ::std::vector<std::pair<double,TString> > _levels;
  ::std::map<std::basic_string<char>,RooArgSet*> _pdfObs;
  void* _pdfNormSet;
  void* _fixedNormSet;
  ::RooObjCacheManager _cacheMgr;
};
#ifdef __RooAbsGaussModelEfficiency
#undef __RooAbsGaussModelEfficiency
#endif
class __RooAbsGaussModelEfficiency : public ::RooAbsReal {
  public:
  __RooAbsGaussModelEfficiency();
  virtual ~__RooAbsGaussModelEfficiency() throw();
  virtual ::std::complex<double> productAnalyticalIntegral(double, double, double, double, std::complex<double> const&) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __RooGeneralisedSmearingBase_RooAbsReal_
#undef __RooGeneralisedSmearingBase_RooAbsReal_
#endif
class __RooGeneralisedSmearingBase_RooAbsReal_ : public ::RooAbsReal {
  public:
  __RooGeneralisedSmearingBase_RooAbsReal_();
  virtual ~__RooGeneralisedSmearingBase_RooAbsReal_() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t getMax(int) const throw();
  virtual void printCompactTreeHook(std::ostream&, char const*) throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::Bool_t redirectServersHook(RooAbsCollection const&, bool, bool, bool) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::Bool_t _init;
  ::RooNumIntConfig _convIntConfig;
  void* _integrator;
  void* _integrand;
  ::RooRealProxy _origVar;
  ::RooRealProxy _origPdf;
  ::RooRealProxy _origModel;
  void* _cloneVar;
  void* _clonePdf;
  void* _cloneModel;
  ::std::map<std::basic_string<char>,std::map<int,RooArgSet> > _integvarset;
  ::std::map<std::basic_string<char>,std::map<int,RooAbsReal*> > _integralset;
  ::std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> > _integrandset;
  ::std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> > _integratorset;
  void* _binning;
  ::RooRealProxy _binnedvar;
  void* _binnedvarClone;
  ::RooArgSet _binnedcats;
  ::std::vector<std::vector<double> > _binnedcache;
  ::std::vector<std::map<void*,double> > _binnedcacheLastVal;
  bool _preferBinnedIntegrals;
  ::Bool_t _useWindow;
  ::Double_t _windowScale;
  ::RooListProxy _windowParam;
};
#ifdef __TagEfficiencyWeightNoCat
#undef __TagEfficiencyWeightNoCat
#endif
class __TagEfficiencyWeightNoCat : public ::RooAbsReal {
  public:
  __TagEfficiencyWeightNoCat();
  virtual ~__TagEfficiencyWeightNoCat() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy tag;
  ::RooRealProxy eff;
};
#ifdef __FinalStateChargePdf
#undef __FinalStateChargePdf
#endif
class __FinalStateChargePdf : public ::RooAbsPdf {
  public:
  __FinalStateChargePdf();
  virtual ~__FinalStateChargePdf() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooCategoryProxy m_qf;
  ::RooRealProxy m_asymm;
};
#ifdef __TaggingCat
#undef __TaggingCat
#endif
class __TaggingCat : public ::RooAbsReal {
  public:
  __TaggingCat();
  virtual ~__TaggingCat() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooCategoryProxy qt;
  ::RooCategoryProxy cat;
  ::RooListProxy catlist;
};
#ifdef __RangeAcceptance
#undef __RangeAcceptance
#endif
class __RangeAcceptance : public ::RooAbsReal {
  public:
  __RangeAcceptance();
  virtual ~__RangeAcceptance() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy x;
  double xmin;
  double xmax;
};
#ifdef __PowLawAcceptance
#undef __PowLawAcceptance
#endif
class __PowLawAcceptance : public ::RooAbsReal {
  public:
  __PowLawAcceptance();
  virtual ~__PowLawAcceptance() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy _turnon;
  ::RooRealProxy _time;
  ::RooRealProxy _offset;
  ::RooRealProxy _exponent;
  ::RooRealProxy _beta;
  ::RooRealProxy _correction;
};
#ifdef __MistagCalibration
#undef __MistagCalibration
#endif
class __MistagCalibration : public ::RooAbsReal {
  public:
  __MistagCalibration();
  virtual ~__MistagCalibration() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy m_eta;
  ::RooListProxy m_calibcoeffs;
  ::RooRealProxy m_etaavg;
};
#ifdef __SharedArrayImp_double_
#undef __SharedArrayImp_double_
#endif
class __SharedArrayImp_double_ : public ::TObject {
  public:
  __SharedArrayImp_double_();
  virtual ~__SharedArrayImp_double_() throw();
  unsigned int refcount;
  ::std::vector<double> arr;
};
#ifdef __SharedArrayImp_float_
#undef __SharedArrayImp_float_
#endif
class __SharedArrayImp_float_ : public ::TObject {
  public:
  __SharedArrayImp_float_();
  virtual ~__SharedArrayImp_float_() throw();
  unsigned int refcount;
  ::std::vector<float> arr;
};
#ifdef __SharedArrayImp_unsignedslongslong_
#undef __SharedArrayImp_unsignedslongslong_
#endif
class __SharedArrayImp_unsignedslongslong_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedslongslong_();
  virtual ~__SharedArrayImp_unsignedslongslong_() throw();
  unsigned int refcount;
  ::std::vector<unsigned long long> arr;
};
#ifdef __SharedArrayImp_unsignedslong_
#undef __SharedArrayImp_unsignedslong_
#endif
class __SharedArrayImp_unsignedslong_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedslong_();
  virtual ~__SharedArrayImp_unsignedslong_() throw();
  unsigned int refcount;
  ::std::vector<unsigned long> arr;
};
#ifdef __SharedArrayImp_unsignedsint_
#undef __SharedArrayImp_unsignedsint_
#endif
class __SharedArrayImp_unsignedsint_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedsint_();
  virtual ~__SharedArrayImp_unsignedsint_() throw();
  unsigned int refcount;
  ::std::vector<unsigned int> arr;
};
#ifdef __SharedArrayImp_unsignedsshort_
#undef __SharedArrayImp_unsignedsshort_
#endif
class __SharedArrayImp_unsignedsshort_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedsshort_();
  virtual ~__SharedArrayImp_unsignedsshort_() throw();
  unsigned int refcount;
  ::std::vector<unsigned short> arr;
};
#ifdef __SharedArrayImp_unsignedschar_
#undef __SharedArrayImp_unsignedschar_
#endif
class __SharedArrayImp_unsignedschar_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedschar_();
  virtual ~__SharedArrayImp_unsignedschar_() throw();
  unsigned int refcount;
  ::std::vector<unsigned char> arr;
};
#ifdef __SharedArrayImp_longslong_
#undef __SharedArrayImp_longslong_
#endif
class __SharedArrayImp_longslong_ : public ::TObject {
  public:
  __SharedArrayImp_longslong_();
  virtual ~__SharedArrayImp_longslong_() throw();
  unsigned int refcount;
  ::std::vector<long long> arr;
};
#ifdef __SharedArrayImp_long_
#undef __SharedArrayImp_long_
#endif
class __SharedArrayImp_long_ : public ::TObject {
  public:
  __SharedArrayImp_long_();
  virtual ~__SharedArrayImp_long_() throw();
  unsigned int refcount;
  ::std::vector<long> arr;
};
#ifdef __SharedArrayImp_int_
#undef __SharedArrayImp_int_
#endif
class __SharedArrayImp_int_ : public ::TObject {
  public:
  __SharedArrayImp_int_();
  virtual ~__SharedArrayImp_int_() throw();
  unsigned int refcount;
  ::std::vector<int> arr;
};
#ifdef __SharedArrayImp_short_
#undef __SharedArrayImp_short_
#endif
class __SharedArrayImp_short_ : public ::TObject {
  public:
  __SharedArrayImp_short_();
  virtual ~__SharedArrayImp_short_() throw();
  unsigned int refcount;
  ::std::vector<short> arr;
};
#ifdef __SharedArrayImp_char_
#undef __SharedArrayImp_char_
#endif
class __SharedArrayImp_char_ : public ::TObject {
  public:
  __SharedArrayImp_char_();
  virtual ~__SharedArrayImp_char_() throw();
  unsigned int refcount;
  ::std::vector<char> arr;
};
#ifdef __Dilution
#undef __Dilution
#endif
class __Dilution : public ::RooAbsReal {
  public:
  __Dilution();
  virtual ~__Dilution() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy omega;
};
#ifdef __FitMeTool
#undef __FitMeTool
#endif
class __FitMeTool {
  public:
  __FitMeTool();
  virtual ~__FitMeTool() throw();
  void* m_observables;
  void* m_conditionalObservables;
  void* m_externalConstraints;
  bool m_config_debug;
  int m_config_toyNumber;
  int m_config_seed;
  bool m_config_seedSet;
  bool m_config_saveFitResult2File;
  void* m_modelPDF;
  void* m_data;
  void* m_fitResult;
  void* m_outputFile;
  void* m_workSpace;
};
#ifdef __RooCubicSplineFun
#undef __RooCubicSplineFun
#endif
class __RooCubicSplineFun : public ::RooAbsGaussModelEfficiency {
  public:
  __RooCubicSplineFun();
  virtual ~__RooCubicSplineFun() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::std::complex<double> productAnalyticalIntegral(double, double, double, double, std::complex<double> const&) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t maxVal(int) const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy _x;
  ::RooListProxy _coefList;
  ::RooCubicSplineKnot _aux;
};
#ifdef __CPObservable
#undef __CPObservable
#endif
class __CPObservable : public ::RooAbsReal {
  public:
  __CPObservable();
  virtual ~__CPObservable() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy lambda;
  ::RooRealProxy phi_strong;
  ::RooRealProxy phi_weak;
  int what;
};
#ifdef __RooComplementCoef
#undef __RooComplementCoef
#endif
class __RooComplementCoef : public ::RooAbsReal {
  public:
  __RooComplementCoef();
  virtual ~__RooComplementCoef() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual void printArgs(std::ostream&) const throw();
  ::RooListProxy _coefs;
};
#ifdef __SharedArray_double_
#undef __SharedArray_double_
#endif
class __SharedArray_double_ : public ::TObject {
  public:
  __SharedArray_double_();
  virtual ~__SharedArray_double_() throw();
  void* pimpl;
};
#ifdef __SharedArray_float_
#undef __SharedArray_float_
#endif
class __SharedArray_float_ : public ::TObject {
  public:
  __SharedArray_float_();
  virtual ~__SharedArray_float_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedslongslong_
#undef __SharedArray_unsignedslongslong_
#endif
class __SharedArray_unsignedslongslong_ : public ::TObject {
  public:
  __SharedArray_unsignedslongslong_();
  virtual ~__SharedArray_unsignedslongslong_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedslong_
#undef __SharedArray_unsignedslong_
#endif
class __SharedArray_unsignedslong_ : public ::TObject {
  public:
  __SharedArray_unsignedslong_();
  virtual ~__SharedArray_unsignedslong_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedsint_
#undef __SharedArray_unsignedsint_
#endif
class __SharedArray_unsignedsint_ : public ::TObject {
  public:
  __SharedArray_unsignedsint_();
  virtual ~__SharedArray_unsignedsint_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedsshort_
#undef __SharedArray_unsignedsshort_
#endif
class __SharedArray_unsignedsshort_ : public ::TObject {
  public:
  __SharedArray_unsignedsshort_();
  virtual ~__SharedArray_unsignedsshort_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedschar_
#undef __SharedArray_unsignedschar_
#endif
class __SharedArray_unsignedschar_ : public ::TObject {
  public:
  __SharedArray_unsignedschar_();
  virtual ~__SharedArray_unsignedschar_() throw();
  void* pimpl;
};
#ifdef __SharedArray_longslong_
#undef __SharedArray_longslong_
#endif
class __SharedArray_longslong_ : public ::TObject {
  public:
  __SharedArray_longslong_();
  virtual ~__SharedArray_longslong_() throw();
  void* pimpl;
};
#ifdef __SharedArray_long_
#undef __SharedArray_long_
#endif
class __SharedArray_long_ : public ::TObject {
  public:
  __SharedArray_long_();
  virtual ~__SharedArray_long_() throw();
  void* pimpl;
};
#ifdef __SharedArray_int_
#undef __SharedArray_int_
#endif
class __SharedArray_int_ : public ::TObject {
  public:
  __SharedArray_int_();
  virtual ~__SharedArray_int_() throw();
  void* pimpl;
};
#ifdef __SharedArray_short_
#undef __SharedArray_short_
#endif
class __SharedArray_short_ : public ::TObject {
  public:
  __SharedArray_short_();
  virtual ~__SharedArray_short_() throw();
  void* pimpl;
};
#ifdef __SharedArray_char_
#undef __SharedArray_char_
#endif
class __SharedArray_char_ : public ::TObject {
  public:
  __SharedArray_char_();
  virtual ~__SharedArray_char_() throw();
  void* pimpl;
};
#ifdef __IfThreeWay
#undef __IfThreeWay
#endif
class __IfThreeWay : public ::RooAbsReal {
  public:
  __IfThreeWay();
  virtual ~__IfThreeWay() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy cond;
  ::RooRealProxy pos;
  ::RooRealProxy zero;
  ::RooRealProxy neg;
};
#ifdef __RooCruijff
#undef __RooCruijff
#endif
class __RooCruijff : public ::RooAbsPdf {
  public:
  __RooCruijff();
  virtual ~__RooCruijff() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy x;
  ::RooRealProxy m0;
  ::RooRealProxy sigmaL;
  ::RooRealProxy sigmaR;
  ::RooRealProxy alphaL;
  ::RooRealProxy alphaR;
};
#ifdef __CombBkgPTPdf
#undef __CombBkgPTPdf
#endif
class __CombBkgPTPdf : public ::RooAbsPdf {
  public:
  __CombBkgPTPdf();
  virtual ~__CombBkgPTPdf() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy t;
  ::RooRealProxy a;
  ::RooRealProxy f;
  ::RooRealProxy alpha;
  ::RooRealProxy beta;
};
#ifdef __RooBinnedFun
#undef __RooBinnedFun
#endif
class __RooBinnedFun : public ::RooAbsGaussModelEfficiency {
  public:
  __RooBinnedFun();
  virtual ~__RooBinnedFun() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::std::complex<double> productAnalyticalIntegral(double, double, double, double, std::complex<double> const&) const throw();
  virtual ::std::list<double>* binBoundaries(RooAbsRealLValue&, double, double) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t maxVal(int) const throw();
  virtual ::RooBinnedFun* clone(char const*) const throw();
  ::RooRealProxy _x;
  ::RooListProxy _coefList;
  ::std::vector<double> _u;
};
#ifdef __std__vector_double_
#undef __std__vector_double_
#endif
class __std__vector_double_ : protected ::std::_Vector_base<double,std::allocator<double> > {
  public:
  __std__vector_double_();
};
#ifdef __RooCubicSplineKnot__S_jk
#undef __RooCubicSplineKnot__S_jk
#endif
class __RooCubicSplineKnot__S_jk {
  public:
  __RooCubicSplineKnot__S_jk();
  double t;
  double d;
  double s;
  double o;
};
#ifdef __std__vector_RooCubicSplineKnot__S_jk_
#undef __std__vector_RooCubicSplineKnot__S_jk_
#endif
class __std__vector_RooCubicSplineKnot__S_jk_ : protected ::std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > {
  public:
  __std__vector_RooCubicSplineKnot__S_jk_();
};
#ifdef __std__vector_float_
#undef __std__vector_float_
#endif
class __std__vector_float_ : protected ::std::_Vector_base<float,std::allocator<float> > {
  public:
  __std__vector_float_();
};
#ifdef __std__vector_unsignedslongslong_
#undef __std__vector_unsignedslongslong_
#endif
class __std__vector_unsignedslongslong_ : protected ::std::_Vector_base<unsigned long long,std::allocator<unsigned long long> > {
  public:
  __std__vector_unsignedslongslong_();
};
#ifdef __std__vector_unsignedslong_
#undef __std__vector_unsignedslong_
#endif
class __std__vector_unsignedslong_ : protected ::std::_Vector_base<unsigned long,std::allocator<unsigned long> > {
  public:
  __std__vector_unsignedslong_();
};
#ifdef __std__vector_unsignedsint_
#undef __std__vector_unsignedsint_
#endif
class __std__vector_unsignedsint_ : protected ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > {
  public:
  __std__vector_unsignedsint_();
};
#ifdef __std__vector_unsignedsshort_
#undef __std__vector_unsignedsshort_
#endif
class __std__vector_unsignedsshort_ : protected ::std::_Vector_base<unsigned short,std::allocator<unsigned short> > {
  public:
  __std__vector_unsignedsshort_();
};
#ifdef __std__vector_unsignedschar_
#undef __std__vector_unsignedschar_
#endif
class __std__vector_unsignedschar_ : protected ::std::_Vector_base<unsigned char,std::allocator<unsigned char> > {
  public:
  __std__vector_unsignedschar_();
};
#ifdef __std__vector_longslong_
#undef __std__vector_longslong_
#endif
class __std__vector_longslong_ : protected ::std::_Vector_base<long long,std::allocator<long long> > {
  public:
  __std__vector_longslong_();
};
#ifdef __std__vector_long_
#undef __std__vector_long_
#endif
class __std__vector_long_ : protected ::std::_Vector_base<long,std::allocator<long> > {
  public:
  __std__vector_long_();
};
#ifdef __std__vector_int_
#undef __std__vector_int_
#endif
class __std__vector_int_ : protected ::std::_Vector_base<int,std::allocator<int> > {
  public:
  __std__vector_int_();
};
#ifdef __std__vector_short_
#undef __std__vector_short_
#endif
class __std__vector_short_ : protected ::std::_Vector_base<short,std::allocator<short> > {
  public:
  __std__vector_short_();
};
#ifdef __std__vector_char_
#undef __std__vector_char_
#endif
class __std__vector_char_ : protected ::std::_Vector_base<char,std::allocator<char> > {
  public:
  __std__vector_char_();
};
#ifdef __std__vector_RooFitResultp_
#undef __std__vector_RooFitResultp_
#endif
class __std__vector_RooFitResultp_ : protected ::std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> > {
  public:
  __std__vector_RooFitResultp_();
};
#ifdef __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_
#undef __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_
#endif
class __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > > {
  public:
  __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_();
};
#ifdef __std__vector_std__map_voidp_double_s_
#undef __std__vector_std__map_voidp_double_s_
#endif
class __std__vector_std__map_voidp_double_s_ : protected ::std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > > {
  public:
  __std__vector_std__map_voidp_double_s_();
};
#ifdef __std__vector_std__vector_double_s_
#undef __std__vector_std__vector_double_s_
#endif
class __std__vector_std__vector_double_s_ : protected ::std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > > {
  public:
  __std__vector_std__vector_double_s_();
};
#ifdef __std__vector_std__vector_double_p_
#undef __std__vector_std__vector_double_p_
#endif
class __std__vector_std__vector_double_p_ : protected ::std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> > {
  public:
  __std__vector_std__vector_double_p_();
};
#ifdef __std__vector_RooNormSetCache_
#undef __std__vector_RooNormSetCache_
#endif
class __std__vector_RooNormSetCache_ : protected ::std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> > {
  public:
  __std__vector_RooNormSetCache_();
};
#ifdef __std__vector_std__pair_double_TString_s_
#undef __std__vector_std__pair_double_TString_s_
#endif
class __std__vector_std__pair_double_TString_s_ : protected ::std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > > {
  public:
  __std__vector_std__pair_double_TString_s_();
};
#ifdef __std__vector_TString_
#undef __std__vector_TString_
#endif
class __std__vector_TString_ : protected ::std::_Vector_base<TString,std::allocator<TString> > {
  public:
  __std__vector_TString_();
};
#ifdef __std__vector_std__map_int_int_s_
#undef __std__vector_std__map_int_int_s_
#endif
class __std__vector_std__map_int_int_s_ : protected ::std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > > {
  public:
  __std__vector_std__map_int_int_s_();
};
#ifdef __std__vector_constsRooAbsBinningp_
#undef __std__vector_constsRooAbsBinningp_
#endif
class __std__vector_constsRooAbsBinningp_ : protected ::std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > {
  public:
  __std__vector_constsRooAbsBinningp_();
};
#ifdef __std__vector_RooAbsRealLValuep_
#undef __std__vector_RooAbsRealLValuep_
#endif
class __std__vector_RooAbsRealLValuep_ : protected ::std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > {
  public:
  __std__vector_RooAbsRealLValuep_();
};
#ifdef __std__vector_bool_
#undef __std__vector_bool_
#endif
class __std__vector_bool_ : protected ::std::_Bvector_base<std::allocator<bool> > {
  public:
  __std__vector_bool_();
};
#ifdef __std__vector_RooArgSetp_
#undef __std__vector_RooArgSetp_
#endif
class __std__vector_RooArgSetp_ : protected ::std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> > {
  public:
  __std__vector_RooArgSetp_();
};
#ifdef __std__vector_std__vector_int_s_
#undef __std__vector_std__vector_int_s_
#endif
class __std__vector_std__vector_int_s_ : protected ::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > {
  public:
  __std__vector_std__vector_int_s_();
};
#ifdef __std__vector_std__pair_std__basic_string_char__int_s_
#undef __std__vector_std__pair_std__basic_string_char__int_s_
#endif
class __std__vector_std__pair_std__basic_string_char__int_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > > {
  public:
  __std__vector_std__pair_std__basic_string_char__int_s_();
};
#ifdef __std__vector_RooAbsArgp_
#undef __std__vector_RooAbsArgp_
#endif
class __std__vector_RooAbsArgp_ : protected ::std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> > {
  public:
  __std__vector_RooAbsArgp_();
};
#ifdef __std__vector_RooAbsCacheElementp_
#undef __std__vector_RooAbsCacheElementp_
#endif
class __std__vector_RooAbsCacheElementp_ : protected ::std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > {
  public:
  __std__vector_RooAbsCacheElementp_();
};
#ifdef __std__vector_RooMsgService__StreamConfig_
#undef __std__vector_RooMsgService__StreamConfig_
#endif
class __std__vector_RooMsgService__StreamConfig_ : protected ::std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > {
  public:
  __std__vector_RooMsgService__StreamConfig_();
};
#ifdef __std__vector_TVirtualArrayp_
#undef __std__vector_TVirtualArrayp_
#endif
class __std__vector_TVirtualArrayp_ : protected ::std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> > {
  public:
  __std__vector_TVirtualArrayp_();
};
#ifdef __std__vector_ROOT__TSchemaHelper_
#undef __std__vector_ROOT__TSchemaHelper_
#endif
class __std__vector_ROOT__TSchemaHelper_ : protected ::std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > {
  public:
  __std__vector_ROOT__TSchemaHelper_();
};
#ifdef __std__pair_std__basic_string_char__RooAbsDatap_
#undef __std__pair_std__basic_string_char__RooAbsDatap_
#endif
struct __std__pair_std__basic_string_char__RooAbsDatap_ {
  public:
  __std__pair_std__basic_string_char__RooAbsDatap_();
  ::std::basic_string<char> first;
  void* second;
};
#ifdef __RooCubicSplineKnot__BoundaryConditions
#undef __RooCubicSplineKnot__BoundaryConditions
#endif
class __RooCubicSplineKnot__BoundaryConditions {
  public:
  __RooCubicSplineKnot__BoundaryConditions();
  bool secondDerivative[2];
  double value[2];
};
#ifdef __RooCubicSplineKnot__S_edge
#undef __RooCubicSplineKnot__S_edge
#endif
class __RooCubicSplineKnot__S_edge {
  public:
  __RooCubicSplineKnot__S_edge();
  double alpha;
  double beta;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
TClass* ::TagEfficiencyWeight::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("TagEfficiencyWeight");
   return fgIsA;
}
const char * ::TagEfficiencyWeight::Class_Name() {return "TagEfficiencyWeight";}
void ::TagEfficiencyWeight::Dictionary() {}
const char *::TagEfficiencyWeight::ImplFileName() {return "";}
int ::TagEfficiencyWeight::ImplFileLine() {return 1;}
void ::TagEfficiencyWeight::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TagEfficiencyWeight::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "tag", &tag);
   R__insp.InspectMember(tag, "tag.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "eff", &eff);
   R__insp.InspectMember(eff, "eff.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::TagEfficiencyWeight::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TagEfficiencyWeight::Class(),this);
   } else {
      b.WriteClassBuffer(::TagEfficiencyWeight::Class(),this);
   }
}
TClass* ::TagEfficiencyWeight::fgIsA = 0;

template<> TClass* RooBinned1DQuinticBase<RooAbsReal>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinned1DQuinticBase<RooAbsReal>");
   return fgIsA;
}
template<> const char * RooBinned1DQuinticBase<RooAbsReal>::Class_Name() {return "RooBinned1DQuinticBase<RooAbsReal>";}
template<> void RooBinned1DQuinticBase<RooAbsReal>::Dictionary() {}
template<> const char *RooBinned1DQuinticBase<RooAbsReal>::ImplFileName() {return "";}
template<> int RooBinned1DQuinticBase<RooAbsReal>::ImplFileLine() {return 1;}
template<> void RooBinned1DQuinticBase<RooAbsReal>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinned1DQuinticBase<RooAbsReal>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsX", &nBinsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeX", &binSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "isIntegral", &isIntegral);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "coeffs", &coeffs);
   R__insp.InspectMember(coeffs, "coeffs.");
   RooAbsReal::ShowMembers(R__insp);
}
template<> void RooBinned1DQuinticBase<RooAbsReal>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinned1DQuinticBase<RooAbsReal>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinned1DQuinticBase<RooAbsReal>::Class(),this);
   }
}
template<> TClass* RooBinned1DQuinticBase<RooAbsReal>::fgIsA = 0;

TClass* ::DecRateCoeff::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("DecRateCoeff");
   return fgIsA;
}
const char * ::DecRateCoeff::Class_Name() {return "DecRateCoeff";}
void ::DecRateCoeff::Dictionary() {}
const char *::DecRateCoeff::ImplFileName() {return "";}
int ::DecRateCoeff::ImplFileLine() {return 1;}
void ::DecRateCoeff::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::DecRateCoeff::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qf", &m_qf);
   R__insp.InspectMember(m_qf, "m_qf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qt", &m_qt);
   R__insp.InspectMember(m_qt, "m_qt.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Cf", &m_Cf);
   R__insp.InspectMember(m_Cf, "m_Cf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Cfbar", &m_Cfbar);
   R__insp.InspectMember(m_Cfbar, "m_Cfbar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etaobs", &m_etaobs);
   R__insp.InspectMember(m_etaobs, "m_etaobs.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdf", &m_etapdf);
   R__insp.InspectMember(m_etapdf, "m_etapdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdfutinstance", &m_etapdfutinstance);
   R__insp.InspectMember(m_etapdfutinstance, "m_etapdfutinstance.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdfut", &m_etapdfut);
   R__insp.InspectMember(m_etapdfut, "m_etapdfut.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_tageff", &m_tageff);
   R__insp.InspectMember(m_tageff, "m_tageff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_eta", &m_eta);
   R__insp.InspectMember(m_eta, "m_eta.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etabar", &m_etabar);
   R__insp.InspectMember(m_etabar, "m_etabar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_aprod", &m_aprod);
   R__insp.InspectMember(m_aprod, "m_aprod.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_adet", &m_adet);
   R__insp.InspectMember(m_adet, "m_adet.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_atageff", &m_atageff);
   R__insp.InspectMember(m_atageff, "m_atageff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_cacheMgr", &m_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&m_cacheMgr, "m_cacheMgr.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nsets", &m_nsets);
   R__insp.InspectMember("std::map<unsigned int,RooArgSet>", (void*)&m_nsets, "m_nsets.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_nset", &m_nset);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nsethash", &m_nsethash);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_flags", &m_flags);
   RooAbsReal::ShowMembers(R__insp);
}
void ::DecRateCoeff::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::DecRateCoeff::Class(),this);
   } else {
      b.WriteClassBuffer(::DecRateCoeff::Class(),this);
   }
}
TClass* ::DecRateCoeff::fgIsA = 0;

TClass* ::IfThreeWayPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("IfThreeWayPdf");
   return fgIsA;
}
const char * ::IfThreeWayPdf::Class_Name() {return "IfThreeWayPdf";}
void ::IfThreeWayPdf::Dictionary() {}
const char *::IfThreeWayPdf::ImplFileName() {return "";}
int ::IfThreeWayPdf::ImplFileLine() {return 1;}
void ::IfThreeWayPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::IfThreeWayPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cond", &cond);
   R__insp.InspectMember(cond, "cond.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "pos", &pos);
   R__insp.InspectMember(pos, "pos.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "zero", &zero);
   R__insp.InspectMember(zero, "zero.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "neg", &neg);
   R__insp.InspectMember(neg, "neg.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::IfThreeWayPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::IfThreeWayPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::IfThreeWayPdf::Class(),this);
   }
}
TClass* ::IfThreeWayPdf::fgIsA = 0;

TClass* ::Inverse::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("Inverse");
   return fgIsA;
}
const char * ::Inverse::Class_Name() {return "Inverse";}
void ::Inverse::Dictionary() {}
const char *::Inverse::ImplFileName() {return "";}
int ::Inverse::ImplFileLine() {return 1;}
void ::Inverse::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::Inverse::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "val", &val);
   R__insp.InspectMember(val, "val.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::Inverse::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::Inverse::Class(),this);
   } else {
      b.WriteClassBuffer(::Inverse::Class(),this);
   }
}
TClass* ::Inverse::fgIsA = 0;

TClass* ::RooEffConvGenContext::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooEffConvGenContext");
   return fgIsA;
}
const char * ::RooEffConvGenContext::Class_Name() {return "RooEffConvGenContext";}
void ::RooEffConvGenContext::Dictionary() {}
const char *::RooEffConvGenContext::ImplFileName() {return "";}
int ::RooEffConvGenContext::ImplFileLine() {return 1;}
void ::RooEffConvGenContext::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooEffConvGenContext::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_maxEff", &_maxEff);
   RooConvGenContext::ShowMembers(R__insp);
}
void ::RooEffConvGenContext::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooEffConvGenContext::Class(),this);
   } else {
      b.WriteClassBuffer(::RooEffConvGenContext::Class(),this);
   }
}
TClass* ::RooEffConvGenContext::fgIsA = 0;

TClass* ::BdPTAcceptance::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("BdPTAcceptance");
   return fgIsA;
}
const char * ::BdPTAcceptance::Class_Name() {return "BdPTAcceptance";}
void ::BdPTAcceptance::Dictionary() {}
const char *::BdPTAcceptance::ImplFileName() {return "";}
int ::BdPTAcceptance::ImplFileLine() {return 1;}
void ::BdPTAcceptance::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::BdPTAcceptance::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "t", &t);
   R__insp.InspectMember(t, "t.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "beta", &beta);
   R__insp.InspectMember(beta, "beta.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "slope", &slope);
   R__insp.InspectMember(slope, "slope.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "offset", &offset);
   R__insp.InspectMember(offset, "offset.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::BdPTAcceptance::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::BdPTAcceptance::Class(),this);
   } else {
      b.WriteClassBuffer(::BdPTAcceptance::Class(),this);
   }
}
TClass* ::BdPTAcceptance::fgIsA = 0;

template<> TClass* RooBinned2DBicubicBase<RooAbsPdf>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinned2DBicubicBase<RooAbsPdf>");
   return fgIsA;
}
template<> const char * RooBinned2DBicubicBase<RooAbsPdf>::Class_Name() {return "RooBinned2DBicubicBase<RooAbsPdf>";}
template<> void RooBinned2DBicubicBase<RooAbsPdf>::Dictionary() {}
template<> const char *RooBinned2DBicubicBase<RooAbsPdf>::ImplFileName() {return "";}
template<> int RooBinned2DBicubicBase<RooAbsPdf>::ImplFileLine() {return 1;}
template<> void RooBinned2DBicubicBase<RooAbsPdf>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinned2DBicubicBase<RooAbsPdf>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "y", &y);
   R__insp.InspectMember(y, "y.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsX", &nBinsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsY", &nBinsY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeX", &binSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeY", &binSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ymin", &ymin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ymax", &ymax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "coeffs", &coeffs);
   R__insp.InspectMember(coeffs, "coeffs.");
   RooAbsPdf::ShowMembers(R__insp);
}
template<> void RooBinned2DBicubicBase<RooAbsPdf>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinned2DBicubicBase<RooAbsPdf>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinned2DBicubicBase<RooAbsPdf>::Class(),this);
   }
}
template<> TClass* RooBinned2DBicubicBase<RooAbsPdf>::fgIsA = 0;

template<> TClass* RooBinned2DBicubicBase<RooAbsReal>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinned2DBicubicBase<RooAbsReal>");
   return fgIsA;
}
template<> const char * RooBinned2DBicubicBase<RooAbsReal>::Class_Name() {return "RooBinned2DBicubicBase<RooAbsReal>";}
template<> void RooBinned2DBicubicBase<RooAbsReal>::Dictionary() {}
template<> const char *RooBinned2DBicubicBase<RooAbsReal>::ImplFileName() {return "";}
template<> int RooBinned2DBicubicBase<RooAbsReal>::ImplFileLine() {return 1;}
template<> void RooBinned2DBicubicBase<RooAbsReal>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinned2DBicubicBase<RooAbsReal>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "y", &y);
   R__insp.InspectMember(y, "y.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsX", &nBinsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsY", &nBinsY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeX", &binSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeY", &binSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ymin", &ymin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ymax", &ymax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "coeffs", &coeffs);
   R__insp.InspectMember(coeffs, "coeffs.");
   RooAbsReal::ShowMembers(R__insp);
}
template<> void RooBinned2DBicubicBase<RooAbsReal>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinned2DBicubicBase<RooAbsReal>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinned2DBicubicBase<RooAbsReal>::Class(),this);
   }
}
template<> TClass* RooBinned2DBicubicBase<RooAbsReal>::fgIsA = 0;

TClass* ::IfThreeWayCatPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("IfThreeWayCatPdf");
   return fgIsA;
}
const char * ::IfThreeWayCatPdf::Class_Name() {return "IfThreeWayCatPdf";}
void ::IfThreeWayCatPdf::Dictionary() {}
const char *::IfThreeWayCatPdf::ImplFileName() {return "";}
int ::IfThreeWayCatPdf::ImplFileLine() {return 1;}
void ::IfThreeWayCatPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::IfThreeWayCatPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cond", &cond);
   R__insp.InspectMember(cond, "cond.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "pos", &pos);
   R__insp.InspectMember(pos, "pos.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "zero", &zero);
   R__insp.InspectMember(zero, "zero.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "neg", &neg);
   R__insp.InspectMember(neg, "neg.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::IfThreeWayCatPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::IfThreeWayCatPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::IfThreeWayCatPdf::Class(),this);
   }
}
TClass* ::IfThreeWayCatPdf::fgIsA = 0;

TClass* ::NonOscTaggingPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("NonOscTaggingPdf");
   return fgIsA;
}
const char * ::NonOscTaggingPdf::Class_Name() {return "NonOscTaggingPdf";}
void ::NonOscTaggingPdf::Dictionary() {}
const char *::NonOscTaggingPdf::ImplFileName() {return "";}
int ::NonOscTaggingPdf::ImplFileLine() {return 1;}
void ::NonOscTaggingPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::NonOscTaggingPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qf", &m_qf);
   R__insp.InspectMember(m_qf, "m_qf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qt", &m_qt);
   R__insp.InspectMember(m_qt, "m_qt.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etaobs", &m_etaobs);
   R__insp.InspectMember(m_etaobs, "m_etaobs.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdf", &m_etapdf);
   R__insp.InspectMember(m_etapdf, "m_etapdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdfutinstance", &m_etapdfutinstance);
   R__insp.InspectMember(m_etapdfutinstance, "m_etapdfutinstance.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdfut", &m_etapdfut);
   R__insp.InspectMember(m_etapdfut, "m_etapdfut.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_epsilon", &m_epsilon);
   R__insp.InspectMember(m_epsilon, "m_epsilon.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_adet", &m_adet);
   R__insp.InspectMember(m_adet, "m_adet.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_atageff_f", &m_atageff_f);
   R__insp.InspectMember(m_atageff_f, "m_atageff_f.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_atageff_t", &m_atageff_t);
   R__insp.InspectMember(m_atageff_t, "m_atageff_t.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_cacheMgr", &m_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&m_cacheMgr, "m_cacheMgr.", false);
   RooAbsPdf::ShowMembers(R__insp);
}
void ::NonOscTaggingPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::NonOscTaggingPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::NonOscTaggingPdf::Class(),this);
   }
}
TClass* ::NonOscTaggingPdf::fgIsA = 0;

TClass* ::DTAcceptanceLHCbNote2007041::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("DTAcceptanceLHCbNote2007041");
   return fgIsA;
}
const char * ::DTAcceptanceLHCbNote2007041::Class_Name() {return "DTAcceptanceLHCbNote2007041";}
void ::DTAcceptanceLHCbNote2007041::Dictionary() {}
const char *::DTAcceptanceLHCbNote2007041::ImplFileName() {return "";}
int ::DTAcceptanceLHCbNote2007041::ImplFileLine() {return 1;}
void ::DTAcceptanceLHCbNote2007041::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::DTAcceptanceLHCbNote2007041::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "t", &t);
   R__insp.InspectMember(t, "t.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "s_low", &s_low);
   R__insp.InspectMember(s_low, "s_low.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "s_high", &s_high);
   R__insp.InspectMember(s_high, "s_high.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "n", &n);
   R__insp.InspectMember(n, "n.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "limit", &limit);
   R__insp.InspectMember(limit, "limit.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::DTAcceptanceLHCbNote2007041::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::DTAcceptanceLHCbNote2007041::Class(),this);
   } else {
      b.WriteClassBuffer(::DTAcceptanceLHCbNote2007041::Class(),this);
   }
}
TClass* ::DTAcceptanceLHCbNote2007041::fgIsA = 0;

TClass* ::RooEffResModel::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooEffResModel");
   return fgIsA;
}
const char * ::RooEffResModel::Class_Name() {return "RooEffResModel";}
void ::RooEffResModel::Dictionary() {}
const char *::RooEffResModel::ImplFileName() {return "";}
int ::RooEffResModel::ImplFileLine() {return 1;}
void ::RooEffResModel::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooEffResModel::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_observables", &_observables);
   R__insp.InspectMember(_observables, "_observables.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_model", &_model);
   R__insp.InspectMember(_model, "_model.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_eff", &_eff);
   R__insp.InspectMember(_eff, "_eff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_cacheMgr", &_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&_cacheMgr, "_cacheMgr.", false);
   RooResolutionModel::ShowMembers(R__insp);
   R__insp.GenericShowMembers("RooAbsEffResModel", ( ::RooAbsEffResModel *)(this), false);
}
void ::RooEffResModel::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooEffResModel::Class(),this);
   } else {
      b.WriteClassBuffer(::RooEffResModel::Class(),this);
   }
}
TClass* ::RooEffResModel::fgIsA = 0;

TClass* ::IfThreeWayCat::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("IfThreeWayCat");
   return fgIsA;
}
const char * ::IfThreeWayCat::Class_Name() {return "IfThreeWayCat";}
void ::IfThreeWayCat::Dictionary() {}
const char *::IfThreeWayCat::ImplFileName() {return "";}
int ::IfThreeWayCat::ImplFileLine() {return 1;}
void ::IfThreeWayCat::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::IfThreeWayCat::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cond", &cond);
   R__insp.InspectMember(cond, "cond.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "pos", &pos);
   R__insp.InspectMember(pos, "pos.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "zero", &zero);
   R__insp.InspectMember(zero, "zero.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "neg", &neg);
   R__insp.InspectMember(neg, "neg.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::IfThreeWayCat::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::IfThreeWayCat::Class(),this);
   } else {
      b.WriteClassBuffer(::IfThreeWayCat::Class(),this);
   }
}
TClass* ::IfThreeWayCat::fgIsA = 0;

TClass* ::RooCubicSplineKnot::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooCubicSplineKnot");
   return fgIsA;
}
const char * ::RooCubicSplineKnot::Class_Name() {return "RooCubicSplineKnot";}
void ::RooCubicSplineKnot::Dictionary() {}
const char *::RooCubicSplineKnot::ImplFileName() {return "";}
int ::RooCubicSplineKnot::ImplFileLine() {return 1;}
void ::RooCubicSplineKnot::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooCubicSplineKnot::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_u", &_u);
   R__insp.InspectMember("std::vector<double>", (void*)&_u, "_u.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_PQRS", &_PQRS);
   R__insp.InspectMember("std::vector<double>", (void*)&_PQRS, "_PQRS.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_IABCD", &_IABCD);
   R__insp.InspectMember("std::vector<double>", (void*)&_IABCD, "_IABCD.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_S_jk", &_S_jk);
   R__insp.InspectMember("std::vector<RooCubicSplineKnot::S_jk>", (void*)&_S_jk, "_S_jk.", false);
}
void ::RooCubicSplineKnot::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooCubicSplineKnot::Class(),this);
   } else {
      b.WriteClassBuffer(::RooCubicSplineKnot::Class(),this);
   }
}
TClass* ::RooCubicSplineKnot::fgIsA = 0;

TClass* ::RooBinnedPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinnedPdf");
   return fgIsA;
}
const char * ::RooBinnedPdf::Class_Name() {return "RooBinnedPdf";}
void ::RooBinnedPdf::Dictionary() {}
const char *::RooBinnedPdf::ImplFileName() {return "";}
int ::RooBinnedPdf::ImplFileLine() {return 1;}
void ::RooBinnedPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinnedPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_baseCatsList", &_baseCatsList);
   R__insp.InspectMember(_baseCatsList, "_baseCatsList.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_baseVarsList", &_baseVarsList);
   R__insp.InspectMember(_baseVarsList, "_baseVarsList.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_coefLists", &_coefLists);
   R__insp.InspectMember(_coefLists, "_coefLists.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_function", &_function);
   R__insp.InspectMember(_function, "_function.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_indexPositions", &_indexPositions);
   R__insp.InspectMember("std::vector<std::map<int,int> >", (void*)&_indexPositions, "_indexPositions.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binningNames", &_binningNames);
   R__insp.InspectMember("std::vector<TString>", (void*)&_binningNames, "_binningNames.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_calcCoefZeros", &_calcCoefZeros);
   R__insp.InspectMember("std::vector<bool>", (void*)&_calcCoefZeros, "_calcCoefZeros.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_numCats", &_numCats);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_continuousBase", &_continuousBase);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_forceUnitIntegral", &_forceUnitIntegral);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binIntegralCoefs", &_binIntegralCoefs);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_ignoreFirstBin", &_ignoreFirstBin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_cacheMgr", &m_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&m_cacheMgr, "m_cacheMgr.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_nset", &m_nset);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nsethash", &m_nsethash);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nsets", &m_nsets);
   R__insp.InspectMember("std::map<unsigned int,RooArgSet>", (void*)&m_nsets, "m_nsets.", false);
   RooAbsPdf::ShowMembers(R__insp);
}
void ::RooBinnedPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinnedPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinnedPdf::Class(),this);
   }
}
TClass* ::RooBinnedPdf::fgIsA = 0;

TClass* ::MistagDistribution::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("MistagDistribution");
   return fgIsA;
}
const char * ::MistagDistribution::Class_Name() {return "MistagDistribution";}
void ::MistagDistribution::Dictionary() {}
const char *::MistagDistribution::ImplFileName() {return "";}
int ::MistagDistribution::ImplFileLine() {return 1;}
void ::MistagDistribution::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::MistagDistribution::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "w", &w);
   R__insp.InspectMember(w, "w.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "w0", &w0);
   R__insp.InspectMember(w0, "w0.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "wa", &wa);
   R__insp.InspectMember(wa, "wa.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "f", &f);
   R__insp.InspectMember(f, "f.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lastw0", &lastw0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lastwa", &lastwa);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lastf", &lastf);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lastwc", &lastwc);
   RooAbsPdf::ShowMembers(R__insp);
}
void ::MistagDistribution::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::MistagDistribution::Class(),this);
   } else {
      b.WriteClassBuffer(::MistagDistribution::Class(),this);
   }
}
TClass* ::MistagDistribution::fgIsA = 0;

TClass* ::SquaredSum::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SquaredSum");
   return fgIsA;
}
const char * ::SquaredSum::Class_Name() {return "SquaredSum";}
void ::SquaredSum::Dictionary() {}
const char *::SquaredSum::ImplFileName() {return "";}
int ::SquaredSum::ImplFileLine() {return 1;}
void ::SquaredSum::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SquaredSum::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "C", &C);
   R__insp.InspectMember(C, "C.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "D", &D);
   R__insp.InspectMember(D, "D.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "S", &S);
   R__insp.InspectMember(S, "S.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::SquaredSum::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SquaredSum::Class(),this);
   } else {
      b.WriteClassBuffer(::SquaredSum::Class(),this);
   }
}
TClass* ::SquaredSum::fgIsA = 0;

TClass* ::RooGenSmearIntegrandBinding::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooGenSmearIntegrandBinding");
   return fgIsA;
}
const char * ::RooGenSmearIntegrandBinding::Class_Name() {return "RooGenSmearIntegrandBinding";}
void ::RooGenSmearIntegrandBinding::Dictionary() {}
const char *::RooGenSmearIntegrandBinding::ImplFileName() {return "";}
int ::RooGenSmearIntegrandBinding::ImplFileLine() {return 1;}
void ::RooGenSmearIntegrandBinding::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooGenSmearIntegrandBinding::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_func", &_func);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_model", &_model);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_var", &_var);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_nset", &_nset);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_xvecValid", &_xvecValid);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_clipInvalid", &_clipInvalid);
   RooAbsFunc::ShowMembers(R__insp);
}
void ::RooGenSmearIntegrandBinding::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooGenSmearIntegrandBinding::Class(),this);
   } else {
      b.WriteClassBuffer(::RooGenSmearIntegrandBinding::Class(),this);
   }
}
TClass* ::RooGenSmearIntegrandBinding::fgIsA = 0;

TClass* ::RooGaussEfficiencyModel::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooGaussEfficiencyModel");
   return fgIsA;
}
const char * ::RooGaussEfficiencyModel::Class_Name() {return "RooGaussEfficiencyModel";}
void ::RooGaussEfficiencyModel::Dictionary() {}
const char *::RooGaussEfficiencyModel::ImplFileName() {return "";}
int ::RooGaussEfficiencyModel::ImplFileLine() {return 1;}
void ::RooGaussEfficiencyModel::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooGaussEfficiencyModel::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_flatSFInt", &_flatSFInt);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "eff", &eff);
   R__insp.InspectMember(eff, "eff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "mean", &mean);
   R__insp.InspectMember(mean, "mean.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "sigma", &sigma);
   R__insp.InspectMember(sigma, "sigma.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "msf", &msf);
   R__insp.InspectMember(msf, "msf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ssf", &ssf);
   R__insp.InspectMember(ssf, "ssf.");
   RooResolutionModel::ShowMembers(R__insp);
   R__insp.GenericShowMembers("RooAbsEffResModel", ( ::RooAbsEffResModel *)(this), false);
}
void ::RooGaussEfficiencyModel::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooGaussEfficiencyModel::Class(),this);
   } else {
      b.WriteClassBuffer(::RooGaussEfficiencyModel::Class(),this);
   }
}
TClass* ::RooGaussEfficiencyModel::fgIsA = 0;

template<> TClass* RooGeneralisedSmearingBase<RooAbsPdf>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooGeneralisedSmearingBase<RooAbsPdf>");
   return fgIsA;
}
template<> const char * RooGeneralisedSmearingBase<RooAbsPdf>::Class_Name() {return "RooGeneralisedSmearingBase<RooAbsPdf>";}
template<> void RooGeneralisedSmearingBase<RooAbsPdf>::Dictionary() {}
template<> const char *RooGeneralisedSmearingBase<RooAbsPdf>::ImplFileName() {return "";}
template<> int RooGeneralisedSmearingBase<RooAbsPdf>::ImplFileLine() {return 1;}
template<> void RooGeneralisedSmearingBase<RooAbsPdf>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooGeneralisedSmearingBase<RooAbsPdf>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_init", &_init);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_convIntConfig", &_convIntConfig);
   R__insp.InspectMember(_convIntConfig, "_convIntConfig.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_integrator", &_integrator);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_integrand", &_integrand);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origVar", &_origVar);
   R__insp.InspectMember(_origVar, "_origVar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origPdf", &_origPdf);
   R__insp.InspectMember(_origPdf, "_origPdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origModel", &_origModel);
   R__insp.InspectMember(_origModel, "_origModel.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_cloneVar", &_cloneVar);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_clonePdf", &_clonePdf);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_cloneModel", &_cloneModel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integvarset", &_integvarset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooArgSet> >", (void*)&_integvarset, "_integvarset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integralset", &_integralset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooAbsReal*> >", (void*)&_integralset, "_integralset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integrandset", &_integrandset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> >", (void*)&_integrandset, "_integrandset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integratorset", &_integratorset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> >", (void*)&_integratorset, "_integratorset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_binning", &_binning);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedvar", &_binnedvar);
   R__insp.InspectMember(_binnedvar, "_binnedvar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_binnedvarClone", &_binnedvarClone);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcats", &_binnedcats);
   R__insp.InspectMember(_binnedcats, "_binnedcats.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcache", &_binnedcache);
   R__insp.InspectMember("std::vector<std::vector<double> >", (void*)&_binnedcache, "_binnedcache.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcacheLastVal", &_binnedcacheLastVal);
   R__insp.InspectMember("std::vector<std::map<void*,double> >", (void*)&_binnedcacheLastVal, "_binnedcacheLastVal.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_preferBinnedIntegrals", &_preferBinnedIntegrals);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_useWindow", &_useWindow);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_windowScale", &_windowScale);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_windowParam", &_windowParam);
   R__insp.InspectMember(_windowParam, "_windowParam.");
   RooAbsPdf::ShowMembers(R__insp);
}
template<> void RooGeneralisedSmearingBase<RooAbsPdf>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooGeneralisedSmearingBase<RooAbsPdf>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooGeneralisedSmearingBase<RooAbsPdf>::Class(),this);
   }
}
template<> TClass* RooGeneralisedSmearingBase<RooAbsPdf>::fgIsA = 0;

template<> TClass* RooBinned1DQuinticBase<RooAbsPdf>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinned1DQuinticBase<RooAbsPdf>");
   return fgIsA;
}
template<> const char * RooBinned1DQuinticBase<RooAbsPdf>::Class_Name() {return "RooBinned1DQuinticBase<RooAbsPdf>";}
template<> void RooBinned1DQuinticBase<RooAbsPdf>::Dictionary() {}
template<> const char *RooBinned1DQuinticBase<RooAbsPdf>::ImplFileName() {return "";}
template<> int RooBinned1DQuinticBase<RooAbsPdf>::ImplFileLine() {return 1;}
template<> void RooBinned1DQuinticBase<RooAbsPdf>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinned1DQuinticBase<RooAbsPdf>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsX", &nBinsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeX", &binSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "isIntegral", &isIntegral);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "coeffs", &coeffs);
   R__insp.InspectMember(coeffs, "coeffs.");
   RooAbsPdf::ShowMembers(R__insp);
}
template<> void RooBinned1DQuinticBase<RooAbsPdf>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinned1DQuinticBase<RooAbsPdf>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinned1DQuinticBase<RooAbsPdf>::Class(),this);
   }
}
template<> TClass* RooBinned1DQuinticBase<RooAbsPdf>::fgIsA = 0;

TClass* ::RooEffHistProd::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooEffHistProd");
   return fgIsA;
}
const char * ::RooEffHistProd::Class_Name() {return "RooEffHistProd";}
void ::RooEffHistProd::Dictionary() {}
const char *::RooEffHistProd::ImplFileName() {return "";}
int ::RooEffHistProd::ImplFileLine() {return 1;}
void ::RooEffHistProd::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooEffHistProd::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binboundaries", &_binboundaries);
   R__insp.InspectMember("std::vector<double>", (void*)&_binboundaries, "_binboundaries.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_pdf", &_pdf);
   R__insp.InspectMember(_pdf, "_pdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_eff", &_eff);
   R__insp.InspectMember(_eff, "_eff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_observables", &_observables);
   R__insp.InspectMember(_observables, "_observables.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_pdfGenVars", &_pdfGenVars);
   R__insp.InspectMember(_pdfGenVars, "_pdfGenVars.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_pdfGenCode", &_pdfGenCode);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_maxEff", &_maxEff);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_levels", &_levels);
   R__insp.InspectMember("std::vector<std::pair<double,TString> >", (void*)&_levels, "_levels.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_pdfObs", &_pdfObs);
   R__insp.InspectMember("std::map<std::basic_string<char>,RooArgSet*>", (void*)&_pdfObs, "_pdfObs.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_pdfNormSet", &_pdfNormSet);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_fixedNormSet", &_fixedNormSet);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_cacheMgr", &_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&_cacheMgr, "_cacheMgr.", false);
   RooAbsPdf::ShowMembers(R__insp);
}
void ::RooEffHistProd::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooEffHistProd::Class(),this);
   } else {
      b.WriteClassBuffer(::RooEffHistProd::Class(),this);
   }
}
TClass* ::RooEffHistProd::fgIsA = 0;

TClass* ::RooAbsGaussModelEfficiency::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooAbsGaussModelEfficiency");
   return fgIsA;
}
const char * ::RooAbsGaussModelEfficiency::Class_Name() {return "RooAbsGaussModelEfficiency";}
void ::RooAbsGaussModelEfficiency::Dictionary() {}
const char *::RooAbsGaussModelEfficiency::ImplFileName() {return "";}
int ::RooAbsGaussModelEfficiency::ImplFileLine() {return 1;}
void ::RooAbsGaussModelEfficiency::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooAbsGaussModelEfficiency::IsA();
   if (R__cl || R__insp.IsA()) { }
   RooAbsReal::ShowMembers(R__insp);
}
void ::RooAbsGaussModelEfficiency::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooAbsGaussModelEfficiency::Class(),this);
   } else {
      b.WriteClassBuffer(::RooAbsGaussModelEfficiency::Class(),this);
   }
}
TClass* ::RooAbsGaussModelEfficiency::fgIsA = 0;

template<> TClass* RooGeneralisedSmearingBase<RooAbsReal>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooGeneralisedSmearingBase<RooAbsReal>");
   return fgIsA;
}
template<> const char * RooGeneralisedSmearingBase<RooAbsReal>::Class_Name() {return "RooGeneralisedSmearingBase<RooAbsReal>";}
template<> void RooGeneralisedSmearingBase<RooAbsReal>::Dictionary() {}
template<> const char *RooGeneralisedSmearingBase<RooAbsReal>::ImplFileName() {return "";}
template<> int RooGeneralisedSmearingBase<RooAbsReal>::ImplFileLine() {return 1;}
template<> void RooGeneralisedSmearingBase<RooAbsReal>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooGeneralisedSmearingBase<RooAbsReal>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_init", &_init);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_convIntConfig", &_convIntConfig);
   R__insp.InspectMember(_convIntConfig, "_convIntConfig.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_integrator", &_integrator);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_integrand", &_integrand);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origVar", &_origVar);
   R__insp.InspectMember(_origVar, "_origVar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origPdf", &_origPdf);
   R__insp.InspectMember(_origPdf, "_origPdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origModel", &_origModel);
   R__insp.InspectMember(_origModel, "_origModel.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_cloneVar", &_cloneVar);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_clonePdf", &_clonePdf);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_cloneModel", &_cloneModel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integvarset", &_integvarset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooArgSet> >", (void*)&_integvarset, "_integvarset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integralset", &_integralset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooAbsReal*> >", (void*)&_integralset, "_integralset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integrandset", &_integrandset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> >", (void*)&_integrandset, "_integrandset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integratorset", &_integratorset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> >", (void*)&_integratorset, "_integratorset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_binning", &_binning);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedvar", &_binnedvar);
   R__insp.InspectMember(_binnedvar, "_binnedvar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_binnedvarClone", &_binnedvarClone);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcats", &_binnedcats);
   R__insp.InspectMember(_binnedcats, "_binnedcats.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcache", &_binnedcache);
   R__insp.InspectMember("std::vector<std::vector<double> >", (void*)&_binnedcache, "_binnedcache.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcacheLastVal", &_binnedcacheLastVal);
   R__insp.InspectMember("std::vector<std::map<void*,double> >", (void*)&_binnedcacheLastVal, "_binnedcacheLastVal.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_preferBinnedIntegrals", &_preferBinnedIntegrals);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_useWindow", &_useWindow);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_windowScale", &_windowScale);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_windowParam", &_windowParam);
   R__insp.InspectMember(_windowParam, "_windowParam.");
   RooAbsReal::ShowMembers(R__insp);
}
template<> void RooGeneralisedSmearingBase<RooAbsReal>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooGeneralisedSmearingBase<RooAbsReal>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooGeneralisedSmearingBase<RooAbsReal>::Class(),this);
   }
}
template<> TClass* RooGeneralisedSmearingBase<RooAbsReal>::fgIsA = 0;

TClass* ::TagEfficiencyWeightNoCat::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("TagEfficiencyWeightNoCat");
   return fgIsA;
}
const char * ::TagEfficiencyWeightNoCat::Class_Name() {return "TagEfficiencyWeightNoCat";}
void ::TagEfficiencyWeightNoCat::Dictionary() {}
const char *::TagEfficiencyWeightNoCat::ImplFileName() {return "";}
int ::TagEfficiencyWeightNoCat::ImplFileLine() {return 1;}
void ::TagEfficiencyWeightNoCat::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TagEfficiencyWeightNoCat::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "tag", &tag);
   R__insp.InspectMember(tag, "tag.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "eff", &eff);
   R__insp.InspectMember(eff, "eff.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::TagEfficiencyWeightNoCat::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TagEfficiencyWeightNoCat::Class(),this);
   } else {
      b.WriteClassBuffer(::TagEfficiencyWeightNoCat::Class(),this);
   }
}
TClass* ::TagEfficiencyWeightNoCat::fgIsA = 0;

TClass* ::FinalStateChargePdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("FinalStateChargePdf");
   return fgIsA;
}
const char * ::FinalStateChargePdf::Class_Name() {return "FinalStateChargePdf";}
void ::FinalStateChargePdf::Dictionary() {}
const char *::FinalStateChargePdf::ImplFileName() {return "";}
int ::FinalStateChargePdf::ImplFileLine() {return 1;}
void ::FinalStateChargePdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::FinalStateChargePdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qf", &m_qf);
   R__insp.InspectMember(m_qf, "m_qf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_asymm", &m_asymm);
   R__insp.InspectMember(m_asymm, "m_asymm.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::FinalStateChargePdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::FinalStateChargePdf::Class(),this);
   } else {
      b.WriteClassBuffer(::FinalStateChargePdf::Class(),this);
   }
}
TClass* ::FinalStateChargePdf::fgIsA = 0;

TClass* ::TaggingCat::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("TaggingCat");
   return fgIsA;
}
const char * ::TaggingCat::Class_Name() {return "TaggingCat";}
void ::TaggingCat::Dictionary() {}
const char *::TaggingCat::ImplFileName() {return "";}
int ::TaggingCat::ImplFileLine() {return 1;}
void ::TaggingCat::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TaggingCat::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "qt", &qt);
   R__insp.InspectMember(qt, "qt.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cat", &cat);
   R__insp.InspectMember(cat, "cat.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "catlist", &catlist);
   R__insp.InspectMember(catlist, "catlist.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::TaggingCat::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TaggingCat::Class(),this);
   } else {
      b.WriteClassBuffer(::TaggingCat::Class(),this);
   }
}
TClass* ::TaggingCat::fgIsA = 0;

TClass* ::RangeAcceptance::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RangeAcceptance");
   return fgIsA;
}
const char * ::RangeAcceptance::Class_Name() {return "RangeAcceptance";}
void ::RangeAcceptance::Dictionary() {}
const char *::RangeAcceptance::ImplFileName() {return "";}
int ::RangeAcceptance::ImplFileLine() {return 1;}
void ::RangeAcceptance::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RangeAcceptance::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   RooAbsReal::ShowMembers(R__insp);
}
void ::RangeAcceptance::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RangeAcceptance::Class(),this);
   } else {
      b.WriteClassBuffer(::RangeAcceptance::Class(),this);
   }
}
TClass* ::RangeAcceptance::fgIsA = 0;

TClass* ::PowLawAcceptance::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("PowLawAcceptance");
   return fgIsA;
}
const char * ::PowLawAcceptance::Class_Name() {return "PowLawAcceptance";}
void ::PowLawAcceptance::Dictionary() {}
const char *::PowLawAcceptance::ImplFileName() {return "";}
int ::PowLawAcceptance::ImplFileLine() {return 1;}
void ::PowLawAcceptance::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::PowLawAcceptance::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_turnon", &_turnon);
   R__insp.InspectMember(_turnon, "_turnon.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_time", &_time);
   R__insp.InspectMember(_time, "_time.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_offset", &_offset);
   R__insp.InspectMember(_offset, "_offset.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_exponent", &_exponent);
   R__insp.InspectMember(_exponent, "_exponent.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_beta", &_beta);
   R__insp.InspectMember(_beta, "_beta.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_correction", &_correction);
   R__insp.InspectMember(_correction, "_correction.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::PowLawAcceptance::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::PowLawAcceptance::Class(),this);
   } else {
      b.WriteClassBuffer(::PowLawAcceptance::Class(),this);
   }
}
TClass* ::PowLawAcceptance::fgIsA = 0;

TClass* ::MistagCalibration::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("MistagCalibration");
   return fgIsA;
}
const char * ::MistagCalibration::Class_Name() {return "MistagCalibration";}
void ::MistagCalibration::Dictionary() {}
const char *::MistagCalibration::ImplFileName() {return "";}
int ::MistagCalibration::ImplFileLine() {return 1;}
void ::MistagCalibration::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::MistagCalibration::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_eta", &m_eta);
   R__insp.InspectMember(m_eta, "m_eta.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_calibcoeffs", &m_calibcoeffs);
   R__insp.InspectMember(m_calibcoeffs, "m_calibcoeffs.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etaavg", &m_etaavg);
   R__insp.InspectMember(m_etaavg, "m_etaavg.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::MistagCalibration::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::MistagCalibration::Class(),this);
   } else {
      b.WriteClassBuffer(::MistagCalibration::Class(),this);
   }
}
TClass* ::MistagCalibration::fgIsA = 0;

template<> TClass* SharedArrayImp<double>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<double>");
   return fgIsA;
}
template<> const char * SharedArrayImp<double>::Class_Name() {return "SharedArrayImp<double>";}
template<> void SharedArrayImp<double>::Dictionary() {}
template<> const char *SharedArrayImp<double>::ImplFileName() {return "";}
template<> int SharedArrayImp<double>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<double>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<double>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<double>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<double>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<double>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<double>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<double>::fgIsA = 0;

template<> TClass* SharedArrayImp<float>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<float>");
   return fgIsA;
}
template<> const char * SharedArrayImp<float>::Class_Name() {return "SharedArrayImp<float>";}
template<> void SharedArrayImp<float>::Dictionary() {}
template<> const char *SharedArrayImp<float>::ImplFileName() {return "";}
template<> int SharedArrayImp<float>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<float>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<float>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<float>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<float>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<float>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<float>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<float>::fgIsA = 0;

template<> TClass* SharedArrayImp<long long unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned long long>");
   return fgIsA;
}
template<> const char * SharedArrayImp<long long unsigned int>::Class_Name() {return "SharedArrayImp<unsigned long long>";}
template<> void SharedArrayImp<long long unsigned int>::Dictionary() {}
template<> const char *SharedArrayImp<long long unsigned int>::ImplFileName() {return "";}
template<> int SharedArrayImp<long long unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<long long unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned long long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned long long>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<long long unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned long long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned long long>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<long long unsigned int>::fgIsA = 0;

template<> TClass* SharedArrayImp<long unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned long>");
   return fgIsA;
}
template<> const char * SharedArrayImp<long unsigned int>::Class_Name() {return "SharedArrayImp<unsigned long>";}
template<> void SharedArrayImp<long unsigned int>::Dictionary() {}
template<> const char *SharedArrayImp<long unsigned int>::ImplFileName() {return "";}
template<> int SharedArrayImp<long unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<long unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned long>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<long unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned long>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<long unsigned int>::fgIsA = 0;

template<> TClass* SharedArrayImp<unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned int>");
   return fgIsA;
}
template<> const char * SharedArrayImp<unsigned int>::Class_Name() {return "SharedArrayImp<unsigned int>";}
template<> void SharedArrayImp<unsigned int>::Dictionary() {}
template<> const char *SharedArrayImp<unsigned int>::ImplFileName() {return "";}
template<> int SharedArrayImp<unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned int>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned int>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned int>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned int>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<unsigned int>::fgIsA = 0;

template<> TClass* SharedArrayImp<short unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned short>");
   return fgIsA;
}
template<> const char * SharedArrayImp<short unsigned int>::Class_Name() {return "SharedArrayImp<unsigned short>";}
template<> void SharedArrayImp<short unsigned int>::Dictionary() {}
template<> const char *SharedArrayImp<short unsigned int>::ImplFileName() {return "";}
template<> int SharedArrayImp<short unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<short unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned short>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned short>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<short unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned short>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned short>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<short unsigned int>::fgIsA = 0;

template<> TClass* SharedArrayImp<unsigned char>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned char>");
   return fgIsA;
}
template<> const char * SharedArrayImp<unsigned char>::Class_Name() {return "SharedArrayImp<unsigned char>";}
template<> void SharedArrayImp<unsigned char>::Dictionary() {}
template<> const char *SharedArrayImp<unsigned char>::ImplFileName() {return "";}
template<> int SharedArrayImp<unsigned char>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<unsigned char>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned char>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned char>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<unsigned char>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned char>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned char>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<unsigned char>::fgIsA = 0;

template<> TClass* SharedArrayImp<long long int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<long long>");
   return fgIsA;
}
template<> const char * SharedArrayImp<long long int>::Class_Name() {return "SharedArrayImp<long long>";}
template<> void SharedArrayImp<long long int>::Dictionary() {}
template<> const char *SharedArrayImp<long long int>::ImplFileName() {return "";}
template<> int SharedArrayImp<long long int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<long long int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<long long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<long long>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<long long int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<long long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<long long>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<long long int>::fgIsA = 0;

template<> TClass* SharedArrayImp<long int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<long>");
   return fgIsA;
}
template<> const char * SharedArrayImp<long int>::Class_Name() {return "SharedArrayImp<long>";}
template<> void SharedArrayImp<long int>::Dictionary() {}
template<> const char *SharedArrayImp<long int>::ImplFileName() {return "";}
template<> int SharedArrayImp<long int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<long int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<long>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<long int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<long>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<long int>::fgIsA = 0;

template<> TClass* SharedArrayImp<int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<int>");
   return fgIsA;
}
template<> const char * SharedArrayImp<int>::Class_Name() {return "SharedArrayImp<int>";}
template<> void SharedArrayImp<int>::Dictionary() {}
template<> const char *SharedArrayImp<int>::ImplFileName() {return "";}
template<> int SharedArrayImp<int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<int>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<int>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<int>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<int>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<int>::fgIsA = 0;

template<> TClass* SharedArrayImp<short int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<short>");
   return fgIsA;
}
template<> const char * SharedArrayImp<short int>::Class_Name() {return "SharedArrayImp<short>";}
template<> void SharedArrayImp<short int>::Dictionary() {}
template<> const char *SharedArrayImp<short int>::ImplFileName() {return "";}
template<> int SharedArrayImp<short int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<short int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<short>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<short>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<short int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<short>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<short>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<short int>::fgIsA = 0;

template<> TClass* SharedArrayImp<char>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<char>");
   return fgIsA;
}
template<> const char * SharedArrayImp<char>::Class_Name() {return "SharedArrayImp<char>";}
template<> void SharedArrayImp<char>::Dictionary() {}
template<> const char *SharedArrayImp<char>::ImplFileName() {return "";}
template<> int SharedArrayImp<char>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<char>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<char>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<char>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<char>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<char>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<char>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<char>::fgIsA = 0;

TClass* ::Dilution::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("Dilution");
   return fgIsA;
}
const char * ::Dilution::Class_Name() {return "Dilution";}
void ::Dilution::Dictionary() {}
const char *::Dilution::ImplFileName() {return "";}
int ::Dilution::ImplFileLine() {return 1;}
void ::Dilution::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::Dilution::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "omega", &omega);
   R__insp.InspectMember(omega, "omega.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::Dilution::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::Dilution::Class(),this);
   } else {
      b.WriteClassBuffer(::Dilution::Class(),this);
   }
}
TClass* ::Dilution::fgIsA = 0;

TClass* ::FitMeTool::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("FitMeTool");
   return fgIsA;
}
const char * ::FitMeTool::Class_Name() {return "FitMeTool";}
void ::FitMeTool::Dictionary() {}
const char *::FitMeTool::ImplFileName() {return "";}
int ::FitMeTool::ImplFileLine() {return 1;}
void ::FitMeTool::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::FitMeTool::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_observables", &m_observables);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_conditionalObservables", &m_conditionalObservables);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_externalConstraints", &m_externalConstraints);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_debug", &m_config_debug);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_toyNumber", &m_config_toyNumber);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_seed", &m_config_seed);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_seedSet", &m_config_seedSet);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_saveFitResult2File", &m_config_saveFitResult2File);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_modelPDF", &m_modelPDF);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_data", &m_data);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_fitResult", &m_fitResult);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_outputFile", &m_outputFile);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_workSpace", &m_workSpace);
}
void ::FitMeTool::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::FitMeTool::Class(),this);
   } else {
      b.WriteClassBuffer(::FitMeTool::Class(),this);
   }
}
TClass* ::FitMeTool::fgIsA = 0;

TClass* ::RooCubicSplineFun::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooCubicSplineFun");
   return fgIsA;
}
const char * ::RooCubicSplineFun::Class_Name() {return "RooCubicSplineFun";}
void ::RooCubicSplineFun::Dictionary() {}
const char *::RooCubicSplineFun::ImplFileName() {return "";}
int ::RooCubicSplineFun::ImplFileLine() {return 1;}
void ::RooCubicSplineFun::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooCubicSplineFun::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_x", &_x);
   R__insp.InspectMember(_x, "_x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_coefList", &_coefList);
   R__insp.InspectMember(_coefList, "_coefList.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_aux", &_aux);
   R__insp.InspectMember("RooCubicSplineKnot", (void*)&_aux, "_aux.", false);
   RooAbsGaussModelEfficiency::ShowMembers(R__insp);
}
void ::RooCubicSplineFun::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooCubicSplineFun::Class(),this);
   } else {
      b.WriteClassBuffer(::RooCubicSplineFun::Class(),this);
   }
}
TClass* ::RooCubicSplineFun::fgIsA = 0;

TClass* ::CPObservable::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("CPObservable");
   return fgIsA;
}
const char * ::CPObservable::Class_Name() {return "CPObservable";}
void ::CPObservable::Dictionary() {}
const char *::CPObservable::ImplFileName() {return "";}
int ::CPObservable::ImplFileLine() {return 1;}
void ::CPObservable::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::CPObservable::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lambda", &lambda);
   R__insp.InspectMember(lambda, "lambda.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "phi_strong", &phi_strong);
   R__insp.InspectMember(phi_strong, "phi_strong.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "phi_weak", &phi_weak);
   R__insp.InspectMember(phi_weak, "phi_weak.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "what", &what);
   RooAbsReal::ShowMembers(R__insp);
}
void ::CPObservable::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::CPObservable::Class(),this);
   } else {
      b.WriteClassBuffer(::CPObservable::Class(),this);
   }
}
TClass* ::CPObservable::fgIsA = 0;

TClass* ::RooComplementCoef::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooComplementCoef");
   return fgIsA;
}
const char * ::RooComplementCoef::Class_Name() {return "RooComplementCoef";}
void ::RooComplementCoef::Dictionary() {}
const char *::RooComplementCoef::ImplFileName() {return "";}
int ::RooComplementCoef::ImplFileLine() {return 1;}
void ::RooComplementCoef::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooComplementCoef::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_coefs", &_coefs);
   R__insp.InspectMember(_coefs, "_coefs.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::RooComplementCoef::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooComplementCoef::Class(),this);
   } else {
      b.WriteClassBuffer(::RooComplementCoef::Class(),this);
   }
}
TClass* ::RooComplementCoef::fgIsA = 0;

template<> TClass* SharedArray<double>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<double>");
   return fgIsA;
}
template<> const char * SharedArray<double>::Class_Name() {return "SharedArray<double>";}
template<> void SharedArray<double>::Dictionary() {}
template<> const char *SharedArray<double>::ImplFileName() {return "";}
template<> int SharedArray<double>::ImplFileLine() {return 1;}
template<> void SharedArray<double>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<double>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<double>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<double>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<double>::Class(),this);
   }
}
template<> TClass* SharedArray<double>::fgIsA = 0;

template<> TClass* SharedArray<float>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<float>");
   return fgIsA;
}
template<> const char * SharedArray<float>::Class_Name() {return "SharedArray<float>";}
template<> void SharedArray<float>::Dictionary() {}
template<> const char *SharedArray<float>::ImplFileName() {return "";}
template<> int SharedArray<float>::ImplFileLine() {return 1;}
template<> void SharedArray<float>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<float>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<float>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<float>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<float>::Class(),this);
   }
}
template<> TClass* SharedArray<float>::fgIsA = 0;

template<> TClass* SharedArray<long long unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned long long>");
   return fgIsA;
}
template<> const char * SharedArray<long long unsigned int>::Class_Name() {return "SharedArray<unsigned long long>";}
template<> void SharedArray<long long unsigned int>::Dictionary() {}
template<> const char *SharedArray<long long unsigned int>::ImplFileName() {return "";}
template<> int SharedArray<long long unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArray<long long unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned long long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<long long unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned long long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned long long>::Class(),this);
   }
}
template<> TClass* SharedArray<long long unsigned int>::fgIsA = 0;

template<> TClass* SharedArray<long unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned long>");
   return fgIsA;
}
template<> const char * SharedArray<long unsigned int>::Class_Name() {return "SharedArray<unsigned long>";}
template<> void SharedArray<long unsigned int>::Dictionary() {}
template<> const char *SharedArray<long unsigned int>::ImplFileName() {return "";}
template<> int SharedArray<long unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArray<long unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<long unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned long>::Class(),this);
   }
}
template<> TClass* SharedArray<long unsigned int>::fgIsA = 0;

template<> TClass* SharedArray<unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned int>");
   return fgIsA;
}
template<> const char * SharedArray<unsigned int>::Class_Name() {return "SharedArray<unsigned int>";}
template<> void SharedArray<unsigned int>::Dictionary() {}
template<> const char *SharedArray<unsigned int>::ImplFileName() {return "";}
template<> int SharedArray<unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArray<unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned int>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned int>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned int>::Class(),this);
   }
}
template<> TClass* SharedArray<unsigned int>::fgIsA = 0;

template<> TClass* SharedArray<short unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned short>");
   return fgIsA;
}
template<> const char * SharedArray<short unsigned int>::Class_Name() {return "SharedArray<unsigned short>";}
template<> void SharedArray<short unsigned int>::Dictionary() {}
template<> const char *SharedArray<short unsigned int>::ImplFileName() {return "";}
template<> int SharedArray<short unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArray<short unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned short>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<short unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned short>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned short>::Class(),this);
   }
}
template<> TClass* SharedArray<short unsigned int>::fgIsA = 0;

template<> TClass* SharedArray<unsigned char>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned char>");
   return fgIsA;
}
template<> const char * SharedArray<unsigned char>::Class_Name() {return "SharedArray<unsigned char>";}
template<> void SharedArray<unsigned char>::Dictionary() {}
template<> const char *SharedArray<unsigned char>::ImplFileName() {return "";}
template<> int SharedArray<unsigned char>::ImplFileLine() {return 1;}
template<> void SharedArray<unsigned char>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned char>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<unsigned char>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned char>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned char>::Class(),this);
   }
}
template<> TClass* SharedArray<unsigned char>::fgIsA = 0;

template<> TClass* SharedArray<long long int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<long long>");
   return fgIsA;
}
template<> const char * SharedArray<long long int>::Class_Name() {return "SharedArray<long long>";}
template<> void SharedArray<long long int>::Dictionary() {}
template<> const char *SharedArray<long long int>::ImplFileName() {return "";}
template<> int SharedArray<long long int>::ImplFileLine() {return 1;}
template<> void SharedArray<long long int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<long long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<long long int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<long long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<long long>::Class(),this);
   }
}
template<> TClass* SharedArray<long long int>::fgIsA = 0;

template<> TClass* SharedArray<long int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<long>");
   return fgIsA;
}
template<> const char * SharedArray<long int>::Class_Name() {return "SharedArray<long>";}
template<> void SharedArray<long int>::Dictionary() {}
template<> const char *SharedArray<long int>::ImplFileName() {return "";}
template<> int SharedArray<long int>::ImplFileLine() {return 1;}
template<> void SharedArray<long int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<long int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<long>::Class(),this);
   }
}
template<> TClass* SharedArray<long int>::fgIsA = 0;

template<> TClass* SharedArray<int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<int>");
   return fgIsA;
}
template<> const char * SharedArray<int>::Class_Name() {return "SharedArray<int>";}
template<> void SharedArray<int>::Dictionary() {}
template<> const char *SharedArray<int>::ImplFileName() {return "";}
template<> int SharedArray<int>::ImplFileLine() {return 1;}
template<> void SharedArray<int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<int>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<int>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<int>::Class(),this);
   }
}
template<> TClass* SharedArray<int>::fgIsA = 0;

template<> TClass* SharedArray<short int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<short>");
   return fgIsA;
}
template<> const char * SharedArray<short int>::Class_Name() {return "SharedArray<short>";}
template<> void SharedArray<short int>::Dictionary() {}
template<> const char *SharedArray<short int>::ImplFileName() {return "";}
template<> int SharedArray<short int>::ImplFileLine() {return 1;}
template<> void SharedArray<short int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<short>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<short int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<short>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<short>::Class(),this);
   }
}
template<> TClass* SharedArray<short int>::fgIsA = 0;

template<> TClass* SharedArray<char>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<char>");
   return fgIsA;
}
template<> const char * SharedArray<char>::Class_Name() {return "SharedArray<char>";}
template<> void SharedArray<char>::Dictionary() {}
template<> const char *SharedArray<char>::ImplFileName() {return "";}
template<> int SharedArray<char>::ImplFileLine() {return 1;}
template<> void SharedArray<char>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<char>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<char>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<char>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<char>::Class(),this);
   }
}
template<> TClass* SharedArray<char>::fgIsA = 0;

TClass* ::IfThreeWay::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("IfThreeWay");
   return fgIsA;
}
const char * ::IfThreeWay::Class_Name() {return "IfThreeWay";}
void ::IfThreeWay::Dictionary() {}
const char *::IfThreeWay::ImplFileName() {return "";}
int ::IfThreeWay::ImplFileLine() {return 1;}
void ::IfThreeWay::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::IfThreeWay::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cond", &cond);
   R__insp.InspectMember(cond, "cond.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "pos", &pos);
   R__insp.InspectMember(pos, "pos.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "zero", &zero);
   R__insp.InspectMember(zero, "zero.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "neg", &neg);
   R__insp.InspectMember(neg, "neg.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::IfThreeWay::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::IfThreeWay::Class(),this);
   } else {
      b.WriteClassBuffer(::IfThreeWay::Class(),this);
   }
}
TClass* ::IfThreeWay::fgIsA = 0;

TClass* ::RooCruijff::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooCruijff");
   return fgIsA;
}
const char * ::RooCruijff::Class_Name() {return "RooCruijff";}
void ::RooCruijff::Dictionary() {}
const char *::RooCruijff::ImplFileName() {return "";}
int ::RooCruijff::ImplFileLine() {return 1;}
void ::RooCruijff::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooCruijff::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m0", &m0);
   R__insp.InspectMember(m0, "m0.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "sigmaL", &sigmaL);
   R__insp.InspectMember(sigmaL, "sigmaL.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "sigmaR", &sigmaR);
   R__insp.InspectMember(sigmaR, "sigmaR.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "alphaL", &alphaL);
   R__insp.InspectMember(alphaL, "alphaL.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "alphaR", &alphaR);
   R__insp.InspectMember(alphaR, "alphaR.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::RooCruijff::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooCruijff::Class(),this);
   } else {
      b.WriteClassBuffer(::RooCruijff::Class(),this);
   }
}
TClass* ::RooCruijff::fgIsA = 0;

TClass* ::CombBkgPTPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("CombBkgPTPdf");
   return fgIsA;
}
const char * ::CombBkgPTPdf::Class_Name() {return "CombBkgPTPdf";}
void ::CombBkgPTPdf::Dictionary() {}
const char *::CombBkgPTPdf::ImplFileName() {return "";}
int ::CombBkgPTPdf::ImplFileLine() {return 1;}
void ::CombBkgPTPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::CombBkgPTPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "t", &t);
   R__insp.InspectMember(t, "t.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "a", &a);
   R__insp.InspectMember(a, "a.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "f", &f);
   R__insp.InspectMember(f, "f.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "alpha", &alpha);
   R__insp.InspectMember(alpha, "alpha.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "beta", &beta);
   R__insp.InspectMember(beta, "beta.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::CombBkgPTPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::CombBkgPTPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::CombBkgPTPdf::Class(),this);
   }
}
TClass* ::CombBkgPTPdf::fgIsA = 0;

TClass* ::RooBinnedFun::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinnedFun");
   return fgIsA;
}
const char * ::RooBinnedFun::Class_Name() {return "RooBinnedFun";}
void ::RooBinnedFun::Dictionary() {}
const char *::RooBinnedFun::ImplFileName() {return "";}
int ::RooBinnedFun::ImplFileLine() {return 1;}
void ::RooBinnedFun::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinnedFun::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_x", &_x);
   R__insp.InspectMember(_x, "_x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_coefList", &_coefList);
   R__insp.InspectMember(_coefList, "_coefList.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_u", &_u);
   R__insp.InspectMember("std::vector<double>", (void*)&_u, "_u.", false);
   RooAbsGaussModelEfficiency::ShowMembers(R__insp);
}
void ::RooBinnedFun::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinnedFun::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinnedFun::Class(),this);
   }
}
TClass* ::RooBinnedFun::fgIsA = 0;


namespace {
//------Stub functions for class TagEfficiencyWeight -------------------------------
static  void operator_4148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TagEfficiencyWeight*)o)->operator=)(*(const ::TagEfficiencyWeight*)arg[0]);
  else   (((::TagEfficiencyWeight*)o)->operator=)(*(const ::TagEfficiencyWeight*)arg[0]);
}

static void constructor_4149( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeight();
  else ::new(mem) ::TagEfficiencyWeight();
}

static void constructor_4150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeight((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::TagEfficiencyWeight((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_4151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeight(*(const ::TagEfficiencyWeight*)arg[0]);
  else ::new(mem) ::TagEfficiencyWeight(*(const ::TagEfficiencyWeight*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeight(*(const ::TagEfficiencyWeight*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::TagEfficiencyWeight(*(const ::TagEfficiencyWeight*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_4152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TagEfficiencyWeight*)o)->clone)((const char*)arg[0]));
  else   (((const ::TagEfficiencyWeight*)o)->clone)((const char*)arg[0]);
}

static void destructor_4153(void*, void * o, const std::vector<void*>&, void *) {
(((::TagEfficiencyWeight*)o)->::TagEfficiencyWeight::~TagEfficiencyWeight)();
}
static  void method_4155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeight*)o)->Class)());
  else   (((::TagEfficiencyWeight*)o)->Class)();
}

static  void method_4156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeight*)o)->Class_Name)());
  else   (((::TagEfficiencyWeight*)o)->Class_Name)();
}

static  void method_4157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TagEfficiencyWeight*)o)->Class_Version)());
  else   (((::TagEfficiencyWeight*)o)->Class_Version)();
}

static  void method_4158( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TagEfficiencyWeight*)o)->Dictionary)();
}

static  void method_4159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TagEfficiencyWeight*)o)->IsA)());
  else   (((const ::TagEfficiencyWeight*)o)->IsA)();
}

static  void method_4160( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeight*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4161( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeight*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeight*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeight*)o)->DeclFileName)());
  else   (((::TagEfficiencyWeight*)o)->DeclFileName)();
}

static  void method_4164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TagEfficiencyWeight*)o)->ImplFileLine)());
  else   (((::TagEfficiencyWeight*)o)->ImplFileLine)();
}

static  void method_4165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeight*)o)->ImplFileName)());
  else   (((::TagEfficiencyWeight*)o)->ImplFileName)();
}

static  void method_4166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TagEfficiencyWeight*)o)->DeclFileLine)());
  else   (((::TagEfficiencyWeight*)o)->DeclFileLine)();
}

static void method_newdel_12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagEfficiencyWeight -------------------------------
void __TagEfficiencyWeight_db_datamem(Reflex::Class*);
void __TagEfficiencyWeight_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TagEfficiencyWeight_datamem_bld(&__TagEfficiencyWeight_db_datamem);
Reflex::GenreflexMemberBuilder __TagEfficiencyWeight_funcmem_bld(&__TagEfficiencyWeight_db_funcmem);
void __TagEfficiencyWeight_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TagEfficiencyWeight"), typeid(::TagEfficiencyWeight), sizeof(::TagEfficiencyWeight), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TagEfficiencyWeight::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::TagEfficiencyWeight, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27790, type_27791), Reflex::Literal("operator="), operator_4148, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TagEfficiencyWeight"), constructor_4149, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27792, type_27793), Reflex::Literal("TagEfficiencyWeight"), constructor_4150, 0, "name;title;_tag;_eff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27791, type_4138), Reflex::Literal("TagEfficiencyWeight"), constructor_4151, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagEfficiencyWeight"), destructor_4153, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TagEfficiencyWeight_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TagEfficiencyWeight_funcmem_bld);
}

//------Delayed data member builder for class TagEfficiencyWeight -------------------
void __TagEfficiencyWeight_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("tag"), OffsetOf(__shadow__::__TagEfficiencyWeight, tag), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("eff"), OffsetOf(__shadow__::__TagEfficiencyWeight, eff), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TagEfficiencyWeight -------------------
void __TagEfficiencyWeight_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_4152, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_4155, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_4156, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_4157, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_4158, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_4159, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_4160, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_4161, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_4162, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_4163, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_4164, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_4165, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_4166, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinned1DQuinticBase<RooAbsReal> -------------------------------
static void constructor_4564( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>();
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>();
}

static void constructor_4565( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(bool*)arg[4]);
  }
}

static void constructor_4566( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_4567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinned1DQuinticBase<RooAbsReal>*)o)->operator=)(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0]);
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->operator=)(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0]);
}

static  void method_4568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->clone)());
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->clone)((const char*)arg[0]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->clone)((const char*)arg[0]);
  }
}

static void destructor_4569(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinned1DQuinticBase<RooAbsReal>*)o)->::RooBinned1DQuinticBase<RooAbsReal>::~RooBinned1DQuinticBase)();
}
static  void method_4570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->evaluate)());
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->evaluate)();
}

static  void method_4571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_4572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_4573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->isBinnedDistribution)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->isBinnedDistribution)(*(const ::RooArgSet*)arg[0]);
}

static  void method_4574( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_4575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_4586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class)();
}

static  void method_4587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class_Name)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class_Name)();
}

static  void method_4588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class_Version)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class_Version)();
}

static  void method_4589( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Dictionary)();
}

static  void method_4590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->IsA)());
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->IsA)();
}

static  void method_4591( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4592( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->DeclFileName)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->DeclFileName)();
}

static  void method_4595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ImplFileLine)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ImplFileLine)();
}

static  void method_4596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ImplFileName)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ImplFileName)();
}

static  void method_4597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->DeclFileLine)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->DeclFileLine)();
}

static void method_newdel_130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinned1DQuinticBase<RooAbsReal> -------------------------------
void __RooBinned1DQuinticBase_RooAbsReal__db_datamem(Reflex::Class*);
void __RooBinned1DQuinticBase_RooAbsReal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinned1DQuinticBase_RooAbsReal__datamem_bld(&__RooBinned1DQuinticBase_RooAbsReal__db_datamem);
Reflex::GenreflexMemberBuilder __RooBinned1DQuinticBase_RooAbsReal__funcmem_bld(&__RooBinned1DQuinticBase_RooAbsReal__db_funcmem);
void __RooBinned1DQuinticBase_RooAbsReal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinned1DQuinticBase<RooAbsReal>"), typeid(::RooBinned1DQuinticBase<RooAbsReal>), sizeof(::RooBinned1DQuinticBase<RooAbsReal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinned1DQuinticBase<RooAbsPdf>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooBinned1DQuinticBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_148"), Reflex::Literal("NCoeff=6;CoeffRecLen=7"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinned1DQuinticBase"), constructor_4564, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27878, type_27793, type_667), Reflex::Literal("RooBinned1DQuinticBase"), constructor_4565, 0, "name;title;h;xvar;integral=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27879, type_4138), Reflex::Literal("RooBinned1DQuinticBase"), constructor_4566, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinned1DQuinticBase"), destructor_4569, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinned1DQuinticBase_RooAbsReal__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinned1DQuinticBase_RooAbsReal__funcmem_bld);
}

//------Delayed data member builder for class RooBinned1DQuinticBase<RooAbsReal> -------------------
void __RooBinned1DQuinticBase_RooAbsReal__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, x), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsX"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, nBinsX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeX"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, binSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, xmin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, xmax), ::Reflex::PRIVATE)
  .AddDataMember(type_667, Reflex::Literal("isIntegral"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, isIntegral), ::Reflex::PRIVATE)
  .AddDataMember(type_2203, Reflex::Literal("coeffs"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, coeffs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinned1DQuinticBase<RooAbsReal> -------------------
void __RooBinned1DQuinticBase_RooAbsReal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27880, type_27879), Reflex::Literal("operator="), operator_4567, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27881, type_4138), Reflex::Literal("clone"), method_4568, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_4570, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_4571, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_4572, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_27806), Reflex::Literal("isBinnedDistribution"), method_4573, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27882, type_27883, type_2317, type_2317), Reflex::Literal("binBoundaries"), method_4574, 0, "var;lo;hi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27882, type_27883, type_2317, type_2317), Reflex::Literal("plotSamplingHint"), method_4575, 0, "var;lo;hi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_4586, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_4587, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_4588, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_4589, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_4590, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_4591, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_4592, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_4593, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_4594, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_4595, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_4596, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_4597, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class DecRateCoeff -------------------------------
static  void operator_5207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DecRateCoeff*)o)->operator=)(*(const ::DecRateCoeff*)arg[0]);
  else   (((::DecRateCoeff*)o)->operator=)(*(const ::DecRateCoeff*)arg[0]);
}

static void constructor_5208( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff();
  else ::new(mem) ::DecRateCoeff();
}

static void constructor_5209( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsRealLValue*)arg[7],
      *(::RooAbsPdf*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12],
      *(::RooAbsReal*)arg[13]);
  else ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsRealLValue*)arg[7],
      *(::RooAbsPdf*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12],
      *(::RooAbsReal*)arg[13]);
}

static void constructor_5210( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsRealLValue*)arg[7],
      *(::RooAbsPdf*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12],
      *(::RooAbsReal*)arg[13],
      *(::RooAbsReal*)arg[14]);
  else ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsRealLValue*)arg[7],
      *(::RooAbsPdf*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12],
      *(::RooAbsReal*)arg[13],
      *(::RooAbsReal*)arg[14]);
}

static void constructor_5211( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11]);
  else ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11]);
}

static void constructor_5212( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12]);
  else ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12]);
}

static void constructor_5213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff(*(const ::DecRateCoeff*)arg[0]);
  else ::new(mem) ::DecRateCoeff(*(const ::DecRateCoeff*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff(*(const ::DecRateCoeff*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::DecRateCoeff(*(const ::DecRateCoeff*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DecRateCoeff*)o)->clone)((const char*)arg[0]));
  else   (((const ::DecRateCoeff*)o)->clone)((const char*)arg[0]);
}

static void destructor_5215(void*, void * o, const std::vector<void*>&, void *) {
(((::DecRateCoeff*)o)->::DecRateCoeff::~DecRateCoeff)();
}
static  void method_5216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->getValV)((const ::RooArgSet*)arg[0]));
  else   (((const ::DecRateCoeff*)o)->getValV)((const ::RooArgSet*)arg[0]);
}

static  void method_5217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::DecRateCoeff*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::DecRateCoeff*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_5218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const ::RooArgSet*)arg[2]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const ::RooArgSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const ::RooArgSet*)arg[2],
      (const char*)arg[3]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const ::RooArgSet*)arg[2],
      (const char*)arg[3]);
  }
}

static  void method_5221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
      (const ::RooArgSet*)arg[1]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
      (const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
      (const ::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
      (const ::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DecRateCoeff*)o)->Class)());
  else   (((::DecRateCoeff*)o)->Class)();
}

static  void method_5226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DecRateCoeff*)o)->Class_Name)());
  else   (((::DecRateCoeff*)o)->Class_Name)();
}

static  void method_5227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::DecRateCoeff*)o)->Class_Version)());
  else   (((::DecRateCoeff*)o)->Class_Version)();
}

static  void method_5228( void*, void* o, const std::vector<void*>&, void*)
{
  (((::DecRateCoeff*)o)->Dictionary)();
}

static  void method_5229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DecRateCoeff*)o)->IsA)());
  else   (((const ::DecRateCoeff*)o)->IsA)();
}

static  void method_5230( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DecRateCoeff*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DecRateCoeff*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5232( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DecRateCoeff*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DecRateCoeff*)o)->DeclFileName)());
  else   (((::DecRateCoeff*)o)->DeclFileName)();
}

static  void method_5234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DecRateCoeff*)o)->ImplFileLine)());
  else   (((::DecRateCoeff*)o)->ImplFileLine)();
}

static  void method_5235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DecRateCoeff*)o)->ImplFileName)());
  else   (((::DecRateCoeff*)o)->ImplFileName)();
}

static  void method_5236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DecRateCoeff*)o)->DeclFileLine)());
  else   (((::DecRateCoeff*)o)->DeclFileLine)();
}

static void method_newdel_259( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::DecRateCoeff,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::DecRateCoeff,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::DecRateCoeff,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::DecRateCoeff,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::DecRateCoeff,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DecRateCoeff -------------------------------
void __DecRateCoeff_db_datamem(Reflex::Class*);
void __DecRateCoeff_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __DecRateCoeff_datamem_bld(&__DecRateCoeff_db_datamem);
Reflex::GenreflexMemberBuilder __DecRateCoeff_funcmem_bld(&__DecRateCoeff_db_funcmem);
void __DecRateCoeff_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("DecRateCoeff"), typeid(::DecRateCoeff), sizeof(::DecRateCoeff), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::DecRateCoeff::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::DecRateCoeff, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3486, Reflex::Literal("DecRateCoeff::CacheElemPair"))
  .AddEnum(Reflex::Literal("DecRateCoeff::Flags"), Reflex::Literal("CPEven=0;CPOdd=1;Minus=2;AvgDelta=4"), &typeid(DecRateCoeff::Flags), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27993, type_27994), Reflex::Literal("operator="), operator_5207, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DecRateCoeff"), constructor_5208, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_5206, type_27792, type_27792, type_27793, type_27793, type_27883, type_27995, type_27793, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("DecRateCoeff"), constructor_5209, 0, "name;title;flags;qf;qt;Cf;Cfbar;etaobs;etapdf;tageff;eta;aprod;adet;atageff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_5206, type_27792, type_27792, type_27793, type_27793, type_27883, type_27995, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("DecRateCoeff"), constructor_5210, 0, "name;title;flags;qf;qt;Cf;Cfbar;etaobs;etapdf;tageff;eta;etabar;aprod;adet;atageff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_5206, type_27792, type_27792, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("DecRateCoeff"), constructor_5211, 0, "name;title;flags;qf;qt;Cf;Cfbar;tageff;eta;aprod;adet;atageff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_5206, type_27792, type_27792, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("DecRateCoeff"), constructor_5212, 0, "name;title;flags;qf;qt;Cf;Cfbar;tageff;eta;etabar;aprod;adet;atageff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27994, type_4138), Reflex::Literal("DecRateCoeff"), constructor_5213, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DecRateCoeff"), destructor_5215, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_259, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__DecRateCoeff_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__DecRateCoeff_funcmem_bld);
}

//------Delayed data member builder for class DecRateCoeff -------------------
void __DecRateCoeff_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("m_qf"), OffsetOf(__shadow__::__DecRateCoeff, m_qf), ::Reflex::PRIVATE)
  .AddDataMember(type_1173, Reflex::Literal("m_qt"), OffsetOf(__shadow__::__DecRateCoeff, m_qt), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_Cf"), OffsetOf(__shadow__::__DecRateCoeff, m_Cf), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_Cfbar"), OffsetOf(__shadow__::__DecRateCoeff, m_Cfbar), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etaobs"), OffsetOf(__shadow__::__DecRateCoeff, m_etaobs), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etapdf"), OffsetOf(__shadow__::__DecRateCoeff, m_etapdf), ::Reflex::PRIVATE)
  .AddDataMember(type_1874, Reflex::Literal("m_etapdfutinstance"), OffsetOf(__shadow__::__DecRateCoeff, m_etapdfutinstance), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etapdfut"), OffsetOf(__shadow__::__DecRateCoeff, m_etapdfut), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_tageff"), OffsetOf(__shadow__::__DecRateCoeff, m_tageff), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_eta"), OffsetOf(__shadow__::__DecRateCoeff, m_eta), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etabar"), OffsetOf(__shadow__::__DecRateCoeff, m_etabar), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_aprod"), OffsetOf(__shadow__::__DecRateCoeff, m_aprod), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_adet"), OffsetOf(__shadow__::__DecRateCoeff, m_adet), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_atageff"), OffsetOf(__shadow__::__DecRateCoeff, m_atageff), ::Reflex::PRIVATE)
  .AddDataMember(type_2216, Reflex::Literal("m_cacheMgr"), OffsetOf(__shadow__::__DecRateCoeff, m_cacheMgr), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3352, Reflex::Literal("m_nsets"), OffsetOf(__shadow__::__DecRateCoeff, m_nsets), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_27808, Reflex::Literal("m_nset"), OffsetOf(__shadow__::__DecRateCoeff, m_nset), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2834, Reflex::Literal("m_nsethash"), OffsetOf(__shadow__::__DecRateCoeff, m_nsethash), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_5206, Reflex::Literal("m_flags"), OffsetOf(__shadow__::__DecRateCoeff, m_flags), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DecRateCoeff -------------------
void __DecRateCoeff_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_5214, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27808), Reflex::Literal("getValV"), method_5216, 0, "nset", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9895), Reflex::Literal("forceAnalyticalInt"), method_5217, 0, "dep", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_5218, 0, "allVars;anaIntVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_5219, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_27808, type_4138), Reflex::Literal("getAnalyticalIntegralWN"), method_5220, 0, "allVars;anaIntVars;nset=0;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_27808, type_4138), Reflex::Literal("analyticalIntegralWN"), method_5221, 0, "code;nset=0;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_5225, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_5226, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5227, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5228, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_5229, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_5230, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_5231, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_5232, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_5233, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5234, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_5235, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5236, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IfThreeWayPdf -------------------------------
static  void operator_5339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IfThreeWayPdf*)o)->operator=)(*(const ::IfThreeWayPdf*)arg[0]);
  else   (((::IfThreeWayPdf*)o)->operator=)(*(const ::IfThreeWayPdf*)arg[0]);
}

static void constructor_5340( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayPdf();
  else ::new(mem) ::IfThreeWayPdf();
}

static void constructor_5341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::IfThreeWayPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_5342( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayPdf(*(const ::IfThreeWayPdf*)arg[0]);
  else ::new(mem) ::IfThreeWayPdf(*(const ::IfThreeWayPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayPdf(*(const ::IfThreeWayPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::IfThreeWayPdf(*(const ::IfThreeWayPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::IfThreeWayPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_5344(void*, void * o, const std::vector<void*>&, void *) {
(((::IfThreeWayPdf*)o)->::IfThreeWayPdf::~IfThreeWayPdf)();
}
static  void method_5346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayPdf*)o)->Class)());
  else   (((::IfThreeWayPdf*)o)->Class)();
}

static  void method_5347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayPdf*)o)->Class_Name)());
  else   (((::IfThreeWayPdf*)o)->Class_Name)();
}

static  void method_5348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::IfThreeWayPdf*)o)->Class_Version)());
  else   (((::IfThreeWayPdf*)o)->Class_Version)();
}

static  void method_5349( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IfThreeWayPdf*)o)->Dictionary)();
}

static  void method_5350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayPdf*)o)->IsA)());
  else   (((const ::IfThreeWayPdf*)o)->IsA)();
}

static  void method_5351( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5352( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5353( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayPdf*)o)->DeclFileName)());
  else   (((::IfThreeWayPdf*)o)->DeclFileName)();
}

static  void method_5355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayPdf*)o)->ImplFileLine)());
  else   (((::IfThreeWayPdf*)o)->ImplFileLine)();
}

static  void method_5356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayPdf*)o)->ImplFileName)());
  else   (((::IfThreeWayPdf*)o)->ImplFileName)();
}

static  void method_5357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayPdf*)o)->DeclFileLine)());
  else   (((::IfThreeWayPdf*)o)->DeclFileLine)();
}

static void method_newdel_266( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IfThreeWayPdf -------------------------------
void __IfThreeWayPdf_db_datamem(Reflex::Class*);
void __IfThreeWayPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IfThreeWayPdf_datamem_bld(&__IfThreeWayPdf_db_datamem);
Reflex::GenreflexMemberBuilder __IfThreeWayPdf_funcmem_bld(&__IfThreeWayPdf_db_funcmem);
void __IfThreeWayPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IfThreeWayPdf"), typeid(::IfThreeWayPdf), sizeof(::IfThreeWayPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::IfThreeWayPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::IfThreeWayPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28000, type_28001), Reflex::Literal("operator="), operator_5339, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IfThreeWayPdf"), constructor_5340, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("IfThreeWayPdf"), constructor_5341, 0, "name;title;_cond;_pos;_zero;_neg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28001, type_4138), Reflex::Literal("IfThreeWayPdf"), constructor_5342, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IfThreeWayPdf"), destructor_5344, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_266, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IfThreeWayPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IfThreeWayPdf_funcmem_bld);
}

//------Delayed data member builder for class IfThreeWayPdf -------------------
void __IfThreeWayPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("cond"), OffsetOf(__shadow__::__IfThreeWayPdf, cond), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("pos"), OffsetOf(__shadow__::__IfThreeWayPdf, pos), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("zero"), OffsetOf(__shadow__::__IfThreeWayPdf, zero), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("neg"), OffsetOf(__shadow__::__IfThreeWayPdf, neg), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class IfThreeWayPdf -------------------
void __IfThreeWayPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_5343, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_5346, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_5347, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5348, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5349, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_5350, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_5351, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_5352, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_5353, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_5354, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5355, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_5356, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5357, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Inverse -------------------------------
static  void operator_5368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Inverse*)o)->operator=)(*(const ::Inverse*)arg[0]);
  else   (((::Inverse*)o)->operator=)(*(const ::Inverse*)arg[0]);
}

static void constructor_5369( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Inverse();
  else ::new(mem) ::Inverse();
}

static void constructor_5370( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Inverse((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2]);
  else ::new(mem) ::Inverse((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2]);
}

static void constructor_5371( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Inverse(*(const ::Inverse*)arg[0]);
  else ::new(mem) ::Inverse(*(const ::Inverse*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Inverse(*(const ::Inverse*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::Inverse(*(const ::Inverse*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Inverse*)o)->clone)((const char*)arg[0]));
  else   (((const ::Inverse*)o)->clone)((const char*)arg[0]);
}

static void destructor_5373(void*, void * o, const std::vector<void*>&, void *) {
(((::Inverse*)o)->::Inverse::~Inverse)();
}
static  void method_5375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Inverse*)o)->Class)());
  else   (((::Inverse*)o)->Class)();
}

static  void method_5376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Inverse*)o)->Class_Name)());
  else   (((::Inverse*)o)->Class_Name)();
}

static  void method_5377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::Inverse*)o)->Class_Version)());
  else   (((::Inverse*)o)->Class_Version)();
}

static  void method_5378( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Inverse*)o)->Dictionary)();
}

static  void method_5379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Inverse*)o)->IsA)());
  else   (((const ::Inverse*)o)->IsA)();
}

static  void method_5380( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Inverse*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5381( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Inverse*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5382( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Inverse*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Inverse*)o)->DeclFileName)());
  else   (((::Inverse*)o)->DeclFileName)();
}

static  void method_5384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Inverse*)o)->ImplFileLine)());
  else   (((::Inverse*)o)->ImplFileLine)();
}

static  void method_5385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Inverse*)o)->ImplFileName)());
  else   (((::Inverse*)o)->ImplFileName)();
}

static  void method_5386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Inverse*)o)->DeclFileLine)());
  else   (((::Inverse*)o)->DeclFileLine)();
}

static void method_newdel_286( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Inverse >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Inverse >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Inverse >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Inverse >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Inverse >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::Inverse,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::Inverse,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::Inverse,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::Inverse,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::Inverse,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Inverse -------------------------------
void __Inverse_db_datamem(Reflex::Class*);
void __Inverse_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Inverse_datamem_bld(&__Inverse_db_datamem);
Reflex::GenreflexMemberBuilder __Inverse_funcmem_bld(&__Inverse_db_funcmem);
void __Inverse_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Inverse"), typeid(::Inverse), sizeof(::Inverse), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::Inverse::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::Inverse, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28005, type_28006), Reflex::Literal("operator="), operator_5368, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Inverse"), constructor_5369, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793), Reflex::Literal("Inverse"), constructor_5370, 0, "name;title;_val", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28006, type_4138), Reflex::Literal("Inverse"), constructor_5371, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Inverse"), destructor_5373, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_286, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Inverse_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Inverse_funcmem_bld);
}

//------Delayed data member builder for class Inverse -------------------
void __Inverse_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("val"), OffsetOf(__shadow__::__Inverse, val), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Inverse -------------------
void __Inverse_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_5372, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_5375, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_5376, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5377, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5378, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_5379, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_5380, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_5381, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_5382, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_5383, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5384, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_5385, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5386, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooEffConvGenContext -------------------------------
static  void operator_5497( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooEffConvGenContext*)o)->operator=)(*(const ::RooEffConvGenContext*)arg[0]);
  else   (((::RooEffConvGenContext*)o)->operator=)(*(const ::RooEffConvGenContext*)arg[0]);
}

static void constructor_5498( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void constructor_5499( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void constructor_5500( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void destructor_5501(void*, void * o, const std::vector<void*>&, void *) {
(((::RooEffConvGenContext*)o)->::RooEffConvGenContext::~RooEffConvGenContext)();
}
static  void method_5502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffConvGenContext*)o)->attach)(*(const ::RooArgSet*)arg[0]);
}

static  void method_5507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffConvGenContext*)o)->Class)());
  else   (((::RooEffConvGenContext*)o)->Class)();
}

static  void method_5508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffConvGenContext*)o)->Class_Name)());
  else   (((::RooEffConvGenContext*)o)->Class_Name)();
}

static  void method_5509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooEffConvGenContext*)o)->Class_Version)());
  else   (((::RooEffConvGenContext*)o)->Class_Version)();
}

static  void method_5510( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooEffConvGenContext*)o)->Dictionary)();
}

static  void method_5511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffConvGenContext*)o)->IsA)());
  else   (((const ::RooEffConvGenContext*)o)->IsA)();
}

static  void method_5512( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffConvGenContext*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5513( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffConvGenContext*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5514( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffConvGenContext*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffConvGenContext*)o)->DeclFileName)());
  else   (((::RooEffConvGenContext*)o)->DeclFileName)();
}

static  void method_5516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffConvGenContext*)o)->ImplFileLine)());
  else   (((::RooEffConvGenContext*)o)->ImplFileLine)();
}

static  void method_5517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffConvGenContext*)o)->ImplFileName)());
  else   (((::RooEffConvGenContext*)o)->ImplFileName)();
}

static  void method_5518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffConvGenContext*)o)->DeclFileLine)());
  else   (((::RooEffConvGenContext*)o)->DeclFileLine)();
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooConvGenContext")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::RooConvGenContext >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGenContext")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::RooAbsGenContext >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooEffConvGenContext -------------------------------
void __RooEffConvGenContext_db_datamem(Reflex::Class*);
void __RooEffConvGenContext_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooEffConvGenContext_datamem_bld(&__RooEffConvGenContext_db_datamem);
Reflex::GenreflexMemberBuilder __RooEffConvGenContext_funcmem_bld(&__RooEffConvGenContext_db_funcmem);
void __RooEffConvGenContext_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooEffConvGenContext"), typeid(::RooEffConvGenContext), sizeof(::RooEffConvGenContext), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooEffConvGenContext::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_755, ::Reflex::BaseOffset< ::RooEffConvGenContext, ::RooConvGenContext >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28020, type_28021), Reflex::Literal("operator="), operator_5497, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28022, type_27806, type_27807, type_27808, type_668), Reflex::Literal("RooEffConvGenContext"), constructor_5498, 0, "model;vars;prototype=0;auxProto=0;_verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28023, type_27806, type_27807, type_27808, type_668), Reflex::Literal("RooEffConvGenContext"), constructor_5499, 0, "model;vars;prototype=0;auxProto=0;_verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27805, type_27806, type_27807, type_27808, type_668), Reflex::Literal("RooEffConvGenContext"), constructor_5500, 0, "model;vars;prototype=0;auxProto=0;_verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooEffConvGenContext"), destructor_5501, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooEffConvGenContext_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooEffConvGenContext_funcmem_bld);
}

//------Delayed data member builder for class RooEffConvGenContext -------------------
void __RooEffConvGenContext_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_694, Reflex::Literal("_maxEff"), OffsetOf(__shadow__::__RooEffConvGenContext, _maxEff), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooEffConvGenContext -------------------
void __RooEffConvGenContext_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27806), Reflex::Literal("attach"), method_5502, 0, "params", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_5507, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_5508, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5509, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5510, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_5511, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_5512, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_5513, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_5514, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_5515, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5516, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_5517, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5518, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class BdPTAcceptance -------------------------------
static  void operator_5524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BdPTAcceptance*)o)->operator=)(*(const ::BdPTAcceptance*)arg[0]);
  else   (((::BdPTAcceptance*)o)->operator=)(*(const ::BdPTAcceptance*)arg[0]);
}

static void constructor_5525( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BdPTAcceptance();
  else ::new(mem) ::BdPTAcceptance();
}

static void constructor_5526( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BdPTAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::BdPTAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_5527( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::BdPTAcceptance(*(const ::BdPTAcceptance*)arg[0]);
  else ::new(mem) ::BdPTAcceptance(*(const ::BdPTAcceptance*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::BdPTAcceptance(*(const ::BdPTAcceptance*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::BdPTAcceptance(*(const ::BdPTAcceptance*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::BdPTAcceptance*)o)->clone)((const char*)arg[0]));
  else   (((const ::BdPTAcceptance*)o)->clone)((const char*)arg[0]);
}

static void destructor_5529(void*, void * o, const std::vector<void*>&, void *) {
(((::BdPTAcceptance*)o)->::BdPTAcceptance::~BdPTAcceptance)();
}
static  void method_5530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::BdPTAcceptance*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::BdPTAcceptance*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::BdPTAcceptance*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::BdPTAcceptance*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::BdPTAcceptance*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::BdPTAcceptance*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::BdPTAcceptance*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::BdPTAcceptance*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::BdPTAcceptance*)o)->Class)());
  else   (((::BdPTAcceptance*)o)->Class)();
}

static  void method_5535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::BdPTAcceptance*)o)->Class_Name)());
  else   (((::BdPTAcceptance*)o)->Class_Name)();
}

static  void method_5536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::BdPTAcceptance*)o)->Class_Version)());
  else   (((::BdPTAcceptance*)o)->Class_Version)();
}

static  void method_5537( void*, void* o, const std::vector<void*>&, void*)
{
  (((::BdPTAcceptance*)o)->Dictionary)();
}

static  void method_5538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::BdPTAcceptance*)o)->IsA)());
  else   (((const ::BdPTAcceptance*)o)->IsA)();
}

static  void method_5539( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::BdPTAcceptance*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5540( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::BdPTAcceptance*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5541( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::BdPTAcceptance*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::BdPTAcceptance*)o)->DeclFileName)());
  else   (((::BdPTAcceptance*)o)->DeclFileName)();
}

static  void method_5543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::BdPTAcceptance*)o)->ImplFileLine)());
  else   (((::BdPTAcceptance*)o)->ImplFileLine)();
}

static  void method_5544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::BdPTAcceptance*)o)->ImplFileName)());
  else   (((::BdPTAcceptance*)o)->ImplFileName)();
}

static  void method_5545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::BdPTAcceptance*)o)->DeclFileLine)());
  else   (((::BdPTAcceptance*)o)->DeclFileLine)();
}

static void method_newdel_327( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::BdPTAcceptance,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::BdPTAcceptance,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::BdPTAcceptance,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::BdPTAcceptance,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::BdPTAcceptance,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class BdPTAcceptance -------------------------------
void __BdPTAcceptance_db_datamem(Reflex::Class*);
void __BdPTAcceptance_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BdPTAcceptance_datamem_bld(&__BdPTAcceptance_db_datamem);
Reflex::GenreflexMemberBuilder __BdPTAcceptance_funcmem_bld(&__BdPTAcceptance_db_funcmem);
void __BdPTAcceptance_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BdPTAcceptance"), typeid(::BdPTAcceptance), sizeof(::BdPTAcceptance), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::BdPTAcceptance::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::BdPTAcceptance, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28025, type_28026), Reflex::Literal("operator="), operator_5524, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BdPTAcceptance"), constructor_5525, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("BdPTAcceptance"), constructor_5526, 0, "name;title;_t;_beta;_slope;_offset", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28026, type_4138), Reflex::Literal("BdPTAcceptance"), constructor_5527, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BdPTAcceptance"), destructor_5529, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_327, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BdPTAcceptance_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__BdPTAcceptance_funcmem_bld);
}

//------Delayed data member builder for class BdPTAcceptance -------------------
void __BdPTAcceptance_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("t"), OffsetOf(__shadow__::__BdPTAcceptance, t), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("beta"), OffsetOf(__shadow__::__BdPTAcceptance, beta), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("slope"), OffsetOf(__shadow__::__BdPTAcceptance, slope), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("offset"), OffsetOf(__shadow__::__BdPTAcceptance, offset), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class BdPTAcceptance -------------------
void __BdPTAcceptance_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_5528, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_5530, 0, "integ;anaIntSet;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_5531, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_5534, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_5535, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5536, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5537, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_5538, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_5539, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_5540, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_5541, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_5542, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5543, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_5544, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5545, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinned2DBicubicBase<RooAbsPdf> -------------------------------
static void constructor_5717( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>();
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>();
}

static void constructor_5718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH2*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH2*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_5719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_5720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->operator=)(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0]);
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->operator=)(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0]);
}

static  void method_5721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->clone)());
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]);
  }
}

static void destructor_5722(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->::RooBinned2DBicubicBase<RooAbsPdf>::~RooBinned2DBicubicBase)();
}
static  void method_5723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->evaluate)());
  else   (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->evaluate)();
}

static  void method_5724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5725( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class)();
}

static  void method_5739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class_Name)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class_Name)();
}

static  void method_5740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class_Version)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class_Version)();
}

static  void method_5741( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Dictionary)();
}

static  void method_5742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->IsA)());
  else   (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->IsA)();
}

static  void method_5743( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5744( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5745( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->DeclFileName)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->DeclFileName)();
}

static  void method_5747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ImplFileLine)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ImplFileLine)();
}

static  void method_5748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ImplFileName)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ImplFileName)();
}

static  void method_5749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->DeclFileLine)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->DeclFileLine)();
}

static void method_newdel_449( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinned2DBicubicBase<RooAbsPdf> -------------------------------
void __RooBinned2DBicubicBase_RooAbsPdf__db_datamem(Reflex::Class*);
void __RooBinned2DBicubicBase_RooAbsPdf__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinned2DBicubicBase_RooAbsPdf__datamem_bld(&__RooBinned2DBicubicBase_RooAbsPdf__db_datamem);
Reflex::GenreflexMemberBuilder __RooBinned2DBicubicBase_RooAbsPdf__funcmem_bld(&__RooBinned2DBicubicBase_RooAbsPdf__db_funcmem);
void __RooBinned2DBicubicBase_RooAbsPdf__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinned2DBicubicBase<RooAbsPdf>"), typeid(::RooBinned2DBicubicBase<RooAbsPdf>), sizeof(::RooBinned2DBicubicBase<RooAbsPdf>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinned2DBicubicBase<RooAbsReal>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooBinned2DBicubicBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_147"), Reflex::Literal("NCoeff=16;CoeffRecLen=17"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5717, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_28081, type_27793, type_27793), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5718, 0, "name;title;h;xvar;yvar", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28082, type_4138), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5719, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinned2DBicubicBase"), destructor_5722, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_449, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinned2DBicubicBase_RooAbsPdf__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinned2DBicubicBase_RooAbsPdf__funcmem_bld);
}

//------Delayed data member builder for class RooBinned2DBicubicBase<RooAbsPdf> -------------------
void __RooBinned2DBicubicBase_RooAbsPdf__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, x), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("y"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, y), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsX"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, nBinsX), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsY"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, nBinsY), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeX"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, binSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeY"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, binSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, xmin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, xmax), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("ymin"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, ymin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("ymax"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, ymax), ::Reflex::PRIVATE)
  .AddDataMember(type_2203, Reflex::Literal("coeffs"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, coeffs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinned2DBicubicBase<RooAbsPdf> -------------------
void __RooBinned2DBicubicBase_RooAbsPdf__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28083, type_28082), Reflex::Literal("operator="), operator_5720, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28084, type_4138), Reflex::Literal("clone"), method_5721, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_5723, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_5724, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_5725, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_5738, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_5739, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5740, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5741, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_5742, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_5743, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_5744, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_5745, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_5746, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5747, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_5748, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5749, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinned2DBicubicBase<RooAbsReal> -------------------------------
static void constructor_5764( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>();
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>();
}

static void constructor_5765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH2*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH2*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_5766( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_5767( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinned2DBicubicBase<RooAbsReal>*)o)->operator=)(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0]);
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->operator=)(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0]);
}

static  void method_5768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->clone)());
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->clone)((const char*)arg[0]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->clone)((const char*)arg[0]);
  }
}

static void destructor_5769(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinned2DBicubicBase<RooAbsReal>*)o)->::RooBinned2DBicubicBase<RooAbsReal>::~RooBinned2DBicubicBase)();
}
static  void method_5770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->evaluate)());
  else   (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->evaluate)();
}

static  void method_5771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class)();
}

static  void method_5786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class_Name)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class_Name)();
}

static  void method_5787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class_Version)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class_Version)();
}

static  void method_5788( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Dictionary)();
}

static  void method_5789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->IsA)());
  else   (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->IsA)();
}

static  void method_5790( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->DeclFileName)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->DeclFileName)();
}

static  void method_5794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ImplFileLine)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ImplFileLine)();
}

static  void method_5795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ImplFileName)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ImplFileName)();
}

static  void method_5796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->DeclFileLine)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->DeclFileLine)();
}

static void method_newdel_450( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinned2DBicubicBase<RooAbsReal> -------------------------------
void __RooBinned2DBicubicBase_RooAbsReal__db_datamem(Reflex::Class*);
void __RooBinned2DBicubicBase_RooAbsReal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinned2DBicubicBase_RooAbsReal__datamem_bld(&__RooBinned2DBicubicBase_RooAbsReal__db_datamem);
Reflex::GenreflexMemberBuilder __RooBinned2DBicubicBase_RooAbsReal__funcmem_bld(&__RooBinned2DBicubicBase_RooAbsReal__db_funcmem);
void __RooBinned2DBicubicBase_RooAbsReal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinned2DBicubicBase<RooAbsReal>"), typeid(::RooBinned2DBicubicBase<RooAbsReal>), sizeof(::RooBinned2DBicubicBase<RooAbsReal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinned2DBicubicBase<RooAbsReal>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooBinned2DBicubicBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_147"), Reflex::Literal("NCoeff=16;CoeffRecLen=17"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5764, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_28081, type_27793, type_27793), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5765, 0, "name;title;h;xvar;yvar", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28090, type_4138), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5766, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinned2DBicubicBase"), destructor_5769, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_450, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinned2DBicubicBase_RooAbsReal__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinned2DBicubicBase_RooAbsReal__funcmem_bld);
}

//------Delayed data member builder for class RooBinned2DBicubicBase<RooAbsReal> -------------------
void __RooBinned2DBicubicBase_RooAbsReal__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, x), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("y"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, y), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsX"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, nBinsX), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsY"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, nBinsY), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeX"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, binSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeY"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, binSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, xmin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, xmax), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("ymin"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, ymin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("ymax"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, ymax), ::Reflex::PRIVATE)
  .AddDataMember(type_2203, Reflex::Literal("coeffs"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, coeffs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinned2DBicubicBase<RooAbsReal> -------------------
void __RooBinned2DBicubicBase_RooAbsReal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28091, type_28090), Reflex::Literal("operator="), operator_5767, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28092, type_4138), Reflex::Literal("clone"), method_5768, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_5770, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_5771, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_5772, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_5785, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_5786, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5787, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5788, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_5789, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_5790, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_5791, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_5792, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_5793, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5794, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_5795, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5796, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IfThreeWayCatPdf -------------------------------
static  void operator_5856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IfThreeWayCatPdf*)o)->operator=)(*(const ::IfThreeWayCatPdf*)arg[0]);
  else   (((::IfThreeWayCatPdf*)o)->operator=)(*(const ::IfThreeWayCatPdf*)arg[0]);
}

static void constructor_5857( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCatPdf();
  else ::new(mem) ::IfThreeWayCatPdf();
}

static void constructor_5858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCatPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::IfThreeWayCatPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_5859( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCatPdf(*(const ::IfThreeWayCatPdf*)arg[0]);
  else ::new(mem) ::IfThreeWayCatPdf(*(const ::IfThreeWayCatPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCatPdf(*(const ::IfThreeWayCatPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::IfThreeWayCatPdf(*(const ::IfThreeWayCatPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayCatPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::IfThreeWayCatPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_5861(void*, void * o, const std::vector<void*>&, void *) {
(((::IfThreeWayCatPdf*)o)->::IfThreeWayCatPdf::~IfThreeWayCatPdf)();
}
static  void method_5863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCatPdf*)o)->Class)());
  else   (((::IfThreeWayCatPdf*)o)->Class)();
}

static  void method_5864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCatPdf*)o)->Class_Name)());
  else   (((::IfThreeWayCatPdf*)o)->Class_Name)();
}

static  void method_5865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::IfThreeWayCatPdf*)o)->Class_Version)());
  else   (((::IfThreeWayCatPdf*)o)->Class_Version)();
}

static  void method_5866( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IfThreeWayCatPdf*)o)->Dictionary)();
}

static  void method_5867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayCatPdf*)o)->IsA)());
  else   (((const ::IfThreeWayCatPdf*)o)->IsA)();
}

static  void method_5868( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCatPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5869( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCatPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCatPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCatPdf*)o)->DeclFileName)());
  else   (((::IfThreeWayCatPdf*)o)->DeclFileName)();
}

static  void method_5872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayCatPdf*)o)->ImplFileLine)());
  else   (((::IfThreeWayCatPdf*)o)->ImplFileLine)();
}

static  void method_5873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCatPdf*)o)->ImplFileName)());
  else   (((::IfThreeWayCatPdf*)o)->ImplFileName)();
}

static  void method_5874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayCatPdf*)o)->DeclFileLine)());
  else   (((::IfThreeWayCatPdf*)o)->DeclFileLine)();
}

static void method_newdel_485( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IfThreeWayCatPdf -------------------------------
void __IfThreeWayCatPdf_db_datamem(Reflex::Class*);
void __IfThreeWayCatPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IfThreeWayCatPdf_datamem_bld(&__IfThreeWayCatPdf_db_datamem);
Reflex::GenreflexMemberBuilder __IfThreeWayCatPdf_funcmem_bld(&__IfThreeWayCatPdf_db_funcmem);
void __IfThreeWayCatPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IfThreeWayCatPdf"), typeid(::IfThreeWayCatPdf), sizeof(::IfThreeWayCatPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::IfThreeWayCatPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::IfThreeWayCatPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28105, type_28106), Reflex::Literal("operator="), operator_5856, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IfThreeWayCatPdf"), constructor_5857, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27792, type_27793, type_27793, type_27793), Reflex::Literal("IfThreeWayCatPdf"), constructor_5858, 0, "name;title;_cond;_pos;_zero;_neg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28106, type_4138), Reflex::Literal("IfThreeWayCatPdf"), constructor_5859, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IfThreeWayCatPdf"), destructor_5861, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_485, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IfThreeWayCatPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IfThreeWayCatPdf_funcmem_bld);
}

//------Delayed data member builder for class IfThreeWayCatPdf -------------------
void __IfThreeWayCatPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("cond"), OffsetOf(__shadow__::__IfThreeWayCatPdf, cond), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("pos"), OffsetOf(__shadow__::__IfThreeWayCatPdf, pos), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("zero"), OffsetOf(__shadow__::__IfThreeWayCatPdf, zero), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("neg"), OffsetOf(__shadow__::__IfThreeWayCatPdf, neg), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class IfThreeWayCatPdf -------------------
void __IfThreeWayCatPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_5860, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_5863, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_5864, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5865, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5866, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_5867, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_5868, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_5869, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_5870, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_5871, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5872, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_5873, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5874, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class NonOscTaggingPdf -------------------------------
static  void operator_5997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NonOscTaggingPdf*)o)->operator=)(*(const ::NonOscTaggingPdf*)arg[0]);
  else   (((::NonOscTaggingPdf*)o)->operator=)(*(const ::NonOscTaggingPdf*)arg[0]);
}

static void constructor_5998( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf();
  else ::new(mem) ::NonOscTaggingPdf();
}

static void constructor_5999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsRealLValue*)arg[4],
      *(::RooAbsPdf*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9]);
  else ::new(mem) ::NonOscTaggingPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsRealLValue*)arg[4],
      *(::RooAbsPdf*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9]);
}

static void constructor_6000( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
  else ::new(mem) ::NonOscTaggingPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
}

static void constructor_6001( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf(*(const ::NonOscTaggingPdf*)arg[0]);
  else ::new(mem) ::NonOscTaggingPdf(*(const ::NonOscTaggingPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf(*(const ::NonOscTaggingPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::NonOscTaggingPdf(*(const ::NonOscTaggingPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_6002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::NonOscTaggingPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::NonOscTaggingPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_6003(void*, void * o, const std::vector<void*>&, void *) {
(((::NonOscTaggingPdf*)o)->::NonOscTaggingPdf::~NonOscTaggingPdf)();
}
static  void method_6004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::NonOscTaggingPdf*)o)->selfNormalized)());
  else   (((const ::NonOscTaggingPdf*)o)->selfNormalized)();
}

static  void method_6005( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::NonOscTaggingPdf*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::NonOscTaggingPdf*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_6006( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_6007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::NonOscTaggingPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::NonOscTaggingPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::NonOscTaggingPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::NonOscTaggingPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_6008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const ::RooArgSet*)arg[2],
    (const char*)arg[3]));
  else   (((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const ::RooArgSet*)arg[2],
    (const char*)arg[3]);
}

static  void method_6009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::NonOscTaggingPdf*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
    (const ::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::NonOscTaggingPdf*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
    (const ::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_6012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::NonOscTaggingPdf*)o)->Class)());
  else   (((::NonOscTaggingPdf*)o)->Class)();
}

static  void method_6013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::NonOscTaggingPdf*)o)->Class_Name)());
  else   (((::NonOscTaggingPdf*)o)->Class_Name)();
}

static  void method_6014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::NonOscTaggingPdf*)o)->Class_Version)());
  else   (((::NonOscTaggingPdf*)o)->Class_Version)();
}

static  void method_6015( void*, void* o, const std::vector<void*>&, void*)
{
  (((::NonOscTaggingPdf*)o)->Dictionary)();
}

static  void method_6016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::NonOscTaggingPdf*)o)->IsA)());
  else   (((const ::NonOscTaggingPdf*)o)->IsA)();
}

static  void method_6017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NonOscTaggingPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6018( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NonOscTaggingPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6019( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NonOscTaggingPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::NonOscTaggingPdf*)o)->DeclFileName)());
  else   (((::NonOscTaggingPdf*)o)->DeclFileName)();
}

static  void method_6021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::NonOscTaggingPdf*)o)->ImplFileLine)());
  else   (((::NonOscTaggingPdf*)o)->ImplFileLine)();
}

static  void method_6022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::NonOscTaggingPdf*)o)->ImplFileName)());
  else   (((::NonOscTaggingPdf*)o)->ImplFileName)();
}

static  void method_6023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::NonOscTaggingPdf*)o)->DeclFileLine)());
  else   (((::NonOscTaggingPdf*)o)->DeclFileLine)();
}

static void method_newdel_515( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NonOscTaggingPdf -------------------------------
void __NonOscTaggingPdf_db_datamem(Reflex::Class*);
void __NonOscTaggingPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NonOscTaggingPdf_datamem_bld(&__NonOscTaggingPdf_db_datamem);
Reflex::GenreflexMemberBuilder __NonOscTaggingPdf_funcmem_bld(&__NonOscTaggingPdf_db_funcmem);
void __NonOscTaggingPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NonOscTaggingPdf"), typeid(::NonOscTaggingPdf), sizeof(::NonOscTaggingPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::NonOscTaggingPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::NonOscTaggingPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3487, Reflex::Literal("NonOscTaggingPdf::CacheElemPair"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28133, type_28134), Reflex::Literal("operator="), operator_5997, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("NonOscTaggingPdf"), constructor_5998, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27792, type_27792, type_27883, type_27995, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("NonOscTaggingPdf"), constructor_5999, 0, "name;title;qf;qt;etaobs;etapdf;epsilon;adet;atageff_f;atageff_t", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27792, type_27792, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("NonOscTaggingPdf"), constructor_6000, 0, "name;title;qf;qt;epsilon;adet;atageff_f;atageff_t", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28134, type_4138), Reflex::Literal("NonOscTaggingPdf"), constructor_6001, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NonOscTaggingPdf"), destructor_6003, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_515, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__NonOscTaggingPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__NonOscTaggingPdf_funcmem_bld);
}

//------Delayed data member builder for class NonOscTaggingPdf -------------------
void __NonOscTaggingPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("m_qf"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_qf), ::Reflex::PRIVATE)
  .AddDataMember(type_1173, Reflex::Literal("m_qt"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_qt), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etaobs"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_etaobs), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etapdf"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_etapdf), ::Reflex::PRIVATE)
  .AddDataMember(type_1874, Reflex::Literal("m_etapdfutinstance"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_etapdfutinstance), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etapdfut"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_etapdfut), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_epsilon"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_epsilon), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_adet"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_adet), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_atageff_f"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_atageff_f), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_atageff_t"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_atageff_t), ::Reflex::PRIVATE)
  .AddDataMember(type_2216, Reflex::Literal("m_cacheMgr"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_cacheMgr), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class NonOscTaggingPdf -------------------
void __NonOscTaggingPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_6002, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("selfNormalized"), method_6004, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9895), Reflex::Literal("forceAnalyticalInt"), method_6005, 0, "dep", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_6006, 0, "allVars;anaIntVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_6007, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_27808, type_4138), Reflex::Literal("getAnalyticalIntegralWN"), method_6008, 0, "allVars;anaIntVars;nset;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_27808, type_4138), Reflex::Literal("analyticalIntegralWN"), method_6009, 0, "code;nset;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_6012, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_6013, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_6014, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_6015, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_6016, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_6017, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_6018, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_6019, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_6020, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_6021, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_6022, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_6023, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class DTAcceptanceLHCbNote2007041 -------------------------------
static  void operator_6087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DTAcceptanceLHCbNote2007041*)o)->operator=)(*(const ::DTAcceptanceLHCbNote2007041*)arg[0]);
  else   (((::DTAcceptanceLHCbNote2007041*)o)->operator=)(*(const ::DTAcceptanceLHCbNote2007041*)arg[0]);
}

static void constructor_6088( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DTAcceptanceLHCbNote2007041();
  else ::new(mem) ::DTAcceptanceLHCbNote2007041();
}

static void constructor_6089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DTAcceptanceLHCbNote2007041((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
  else ::new(mem) ::DTAcceptanceLHCbNote2007041((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
}

static void constructor_6090( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::DTAcceptanceLHCbNote2007041(*(const ::DTAcceptanceLHCbNote2007041*)arg[0]);
  else ::new(mem) ::DTAcceptanceLHCbNote2007041(*(const ::DTAcceptanceLHCbNote2007041*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DTAcceptanceLHCbNote2007041(*(const ::DTAcceptanceLHCbNote2007041*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::DTAcceptanceLHCbNote2007041(*(const ::DTAcceptanceLHCbNote2007041*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_6091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DTAcceptanceLHCbNote2007041*)o)->clone)((const char*)arg[0]));
  else   (((const ::DTAcceptanceLHCbNote2007041*)o)->clone)((const char*)arg[0]);
}

static void destructor_6092(void*, void * o, const std::vector<void*>&, void *) {
(((::DTAcceptanceLHCbNote2007041*)o)->::DTAcceptanceLHCbNote2007041::~DTAcceptanceLHCbNote2007041)();
}
static  void method_6094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DTAcceptanceLHCbNote2007041*)o)->Class)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->Class)();
}

static  void method_6095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DTAcceptanceLHCbNote2007041*)o)->Class_Name)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->Class_Name)();
}

static  void method_6096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::DTAcceptanceLHCbNote2007041*)o)->Class_Version)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->Class_Version)();
}

static  void method_6097( void*, void* o, const std::vector<void*>&, void*)
{
  (((::DTAcceptanceLHCbNote2007041*)o)->Dictionary)();
}

static  void method_6098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DTAcceptanceLHCbNote2007041*)o)->IsA)());
  else   (((const ::DTAcceptanceLHCbNote2007041*)o)->IsA)();
}

static  void method_6099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DTAcceptanceLHCbNote2007041*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DTAcceptanceLHCbNote2007041*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DTAcceptanceLHCbNote2007041*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DTAcceptanceLHCbNote2007041*)o)->DeclFileName)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->DeclFileName)();
}

static  void method_6103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DTAcceptanceLHCbNote2007041*)o)->ImplFileLine)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->ImplFileLine)();
}

static  void method_6104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DTAcceptanceLHCbNote2007041*)o)->ImplFileName)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->ImplFileName)();
}

static  void method_6105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DTAcceptanceLHCbNote2007041*)o)->DeclFileLine)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->DeclFileLine)();
}

static void method_newdel_577( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DTAcceptanceLHCbNote2007041 -------------------------------
void __DTAcceptanceLHCbNote2007041_db_datamem(Reflex::Class*);
void __DTAcceptanceLHCbNote2007041_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __DTAcceptanceLHCbNote2007041_datamem_bld(&__DTAcceptanceLHCbNote2007041_db_datamem);
Reflex::GenreflexMemberBuilder __DTAcceptanceLHCbNote2007041_funcmem_bld(&__DTAcceptanceLHCbNote2007041_db_funcmem);
void __DTAcceptanceLHCbNote2007041_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("DTAcceptanceLHCbNote2007041"), typeid(::DTAcceptanceLHCbNote2007041), sizeof(::DTAcceptanceLHCbNote2007041), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::DTAcceptanceLHCbNote2007041::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28143, type_28144), Reflex::Literal("operator="), operator_6087, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DTAcceptanceLHCbNote2007041"), constructor_6088, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("DTAcceptanceLHCbNote2007041"), constructor_6089, 0, "name;title;_t;_s_low;_s_high;_n;_limit", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28144, type_4138), Reflex::Literal("DTAcceptanceLHCbNote2007041"), constructor_6090, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DTAcceptanceLHCbNote2007041"), destructor_6092, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_577, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__DTAcceptanceLHCbNote2007041_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__DTAcceptanceLHCbNote2007041_funcmem_bld);
}

//------Delayed data member builder for class DTAcceptanceLHCbNote2007041 -------------------
void __DTAcceptanceLHCbNote2007041_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("t"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, t), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("s_low"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, s_low), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("s_high"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, s_high), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("n"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, n), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("limit"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, limit), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class DTAcceptanceLHCbNote2007041 -------------------
void __DTAcceptanceLHCbNote2007041_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_6091, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_6094, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_6095, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_6096, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_6097, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_6098, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_6099, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_6100, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_6101, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_6102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_6103, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_6104, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_6105, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooEffResModel -------------------------------
static  void operator_6360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooEffResModel*)o)->operator=)(*(const ::RooEffResModel*)arg[0]);
  else   (((::RooEffResModel*)o)->operator=)(*(const ::RooEffResModel*)arg[0]);
}

static void constructor_6361( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffResModel();
  else ::new(mem) ::RooEffResModel();
}

static void constructor_6362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffResModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooResolutionModel*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::RooEffResModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooResolutionModel*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_6363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffResModel(*(const ::RooEffResModel*)arg[0]);
  else ::new(mem) ::RooEffResModel(*(const ::RooEffResModel*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffResModel(*(const ::RooEffResModel*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooEffResModel(*(const ::RooEffResModel*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_6364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooEffResModel*)o)->clone)((const char*)arg[0]);
}

static void destructor_6365(void*, void * o, const std::vector<void*>&, void *) {
(((::RooEffResModel*)o)->::RooEffResModel::~RooEffResModel)();
}
static  void method_6366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->basisCode)((const char*)arg[0]));
  else   (((const ::RooEffResModel*)o)->basisCode)((const char*)arg[0]);
}

static  void method_6367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooEffResModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooEffResModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_6368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooEffResModel*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::RooEffResModel*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_6369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooEffResModel*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooEffResModel*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_6370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooEffResModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((const ::RooEffResModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      *(::Bool_t*)arg[2]);
  }
}

static  void method_6371( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->initGenerator)(*(::Int_t*)arg[0]);
}

static  void method_6372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->generateEvent)(*(::Int_t*)arg[0]);
}

static  void method_6373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]));
    else     (((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]));
    else     (((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]));
    else     (((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_6374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->efficiency)());
  else   (((const ::RooEffResModel*)o)->efficiency)();
}

static  void method_6375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<RooAbsReal*>)((((const ::RooEffResModel*)o)->efficiencies)());
  else   (((const ::RooEffResModel*)o)->efficiencies)();
}

static  void method_6376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooEffResModel*)o)->model)();
  else   (((const ::RooEffResModel*)o)->model)();
}

static  void method_6377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->observables)());
  else   (((const ::RooEffResModel*)o)->observables)();
}

static  void method_6381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffResModel*)o)->Class)());
  else   (((::RooEffResModel*)o)->Class)();
}

static  void method_6382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffResModel*)o)->Class_Name)());
  else   (((::RooEffResModel*)o)->Class_Name)();
}

static  void method_6383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooEffResModel*)o)->Class_Version)());
  else   (((::RooEffResModel*)o)->Class_Version)();
}

static  void method_6384( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooEffResModel*)o)->Dictionary)();
}

static  void method_6385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->IsA)());
  else   (((const ::RooEffResModel*)o)->IsA)();
}

static  void method_6386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6388( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffResModel*)o)->DeclFileName)());
  else   (((::RooEffResModel*)o)->DeclFileName)();
}

static  void method_6390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffResModel*)o)->ImplFileLine)());
  else   (((::RooEffResModel*)o)->ImplFileLine)();
}

static  void method_6391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffResModel*)o)->ImplFileName)());
  else   (((::RooEffResModel*)o)->ImplFileName)();
}

static  void method_6392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffResModel*)o)->DeclFileLine)());
  else   (((::RooEffResModel*)o)->DeclFileLine)();
}

static void method_newdel_664( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooResolutionModel")), ::Reflex::BaseOffset< ::RooEffResModel,::RooResolutionModel >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooEffResModel,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooEffResModel,::RooAbsReal >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooEffResModel,::RooAbsArg >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooEffResModel,::TNamed >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooEffResModel,::TObject >::Get(),::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooEffResModel,::RooPrintable >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsEffResModel")), ::Reflex::BaseOffset< ::RooEffResModel,::RooAbsEffResModel >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooEffResModel -------------------------------
void __RooEffResModel_db_datamem(Reflex::Class*);
void __RooEffResModel_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooEffResModel_datamem_bld(&__RooEffResModel_db_datamem);
Reflex::GenreflexMemberBuilder __RooEffResModel_funcmem_bld(&__RooEffResModel_db_funcmem);
void __RooEffResModel_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooEffResModel"), typeid(::RooEffResModel), sizeof(::RooEffResModel), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooEffResModel::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_39, ::Reflex::BaseOffset< ::RooEffResModel, ::RooResolutionModel >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_670, ::Reflex::BaseOffset< ::RooEffResModel, ::RooAbsEffResModel >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28194, type_28195), Reflex::Literal("operator="), operator_6360, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooEffResModel"), constructor_6361, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27801, type_27793), Reflex::Literal("RooEffResModel"), constructor_6362, 0, "name;title;model;eff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28195, type_4138), Reflex::Literal("RooEffResModel"), constructor_6363, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooEffResModel"), destructor_6365, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_664, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooEffResModel_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooEffResModel_funcmem_bld);
}

//------Delayed data member builder for class RooEffResModel -------------------
void __RooEffResModel_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_878, Reflex::Literal("_observables"), OffsetOf(__shadow__::__RooEffResModel, _observables), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("_model"), OffsetOf(__shadow__::__RooEffResModel, _model), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("_eff"), OffsetOf(__shadow__::__RooEffResModel, _eff), ::Reflex::PRIVATE)
  .AddDataMember(type_2216, Reflex::Literal("_cacheMgr"), OffsetOf(__shadow__::__RooEffResModel, _cacheMgr), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class RooEffResModel -------------------
void __RooEffResModel_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28196, type_4138), Reflex::Literal("clone"), method_6364, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_4138), Reflex::Literal("basisCode"), method_6366, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_6367, 0, "allVars;analVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_6368, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9895), Reflex::Literal("forceAnalyticalInt"), method_6369, 0, "dep", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27806, type_27811, type_668), Reflex::Literal("getGenerator"), method_6370, 0, "directVars;generateVars;staticInitOK=kTRUE", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("initGenerator"), method_6371, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("generateEvent"), method_6372, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27804, type_27805, type_27806, type_27807, type_27808, type_668), Reflex::Literal("modelGenContext"), method_6373, 0, "convPdf;vars;prototype=0;auxProto=0;verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28158), Reflex::Literal("efficiency"), method_6374, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3113), Reflex::Literal("efficiencies"), method_6375, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27801), Reflex::Literal("model"), method_6376, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2835), Reflex::Literal("observables"), method_6377, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_6381, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_6382, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_6383, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_6384, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_6385, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_6386, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_6387, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_6388, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_6389, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_6390, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_6391, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_6392, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooAbsEffResModel -------------------------------
static  void operator_6393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooAbsEffResModel*)o)->operator=)(*(const ::RooAbsEffResModel*)arg[0]);
  else   (((::RooAbsEffResModel*)o)->operator=)(*(const ::RooAbsEffResModel*)arg[0]);
}

static void destructor_6396(void*, void * o, const std::vector<void*>&, void *) {
(((::RooAbsEffResModel*)o)->::RooAbsEffResModel::~RooAbsEffResModel)();
}
static  void method_6397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooAbsEffResModel*)o)->observables)());
  else   (((const ::RooAbsEffResModel*)o)->observables)();
}

static  void method_6398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooAbsEffResModel*)o)->efficiency)());
  else   (((const ::RooAbsEffResModel*)o)->efficiency)();
}

//------Dictionary for class RooAbsEffResModel -------------------------------
void __RooAbsEffResModel_db_datamem(Reflex::Class*);
void __RooAbsEffResModel_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooAbsEffResModel_datamem_bld(&__RooAbsEffResModel_db_datamem);
Reflex::GenreflexMemberBuilder __RooAbsEffResModel_funcmem_bld(&__RooAbsEffResModel_db_funcmem);
void __RooAbsEffResModel_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooAbsEffResModel"), typeid(::RooAbsEffResModel), sizeof(::RooAbsEffResModel), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28198, type_28199), Reflex::Literal("operator="), operator_6393, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooAbsEffResModel"), destructor_6396, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__RooAbsEffResModel_funcmem_bld);
}

//------Delayed data member builder for class RooAbsEffResModel -------------------
void __RooAbsEffResModel_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RooAbsEffResModel -------------------
void __RooAbsEffResModel_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2835), Reflex::Literal("observables"), method_6397, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28024), Reflex::Literal("efficiency"), method_6398, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IfThreeWayCat -------------------------------
static  void operator_6451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IfThreeWayCat*)o)->operator=)(*(const ::IfThreeWayCat*)arg[0]);
  else   (((::IfThreeWayCat*)o)->operator=)(*(const ::IfThreeWayCat*)arg[0]);
}

static void constructor_6452( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCat();
  else ::new(mem) ::IfThreeWayCat();
}

static void constructor_6453( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::IfThreeWayCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_6454( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCat(*(const ::IfThreeWayCat*)arg[0]);
  else ::new(mem) ::IfThreeWayCat(*(const ::IfThreeWayCat*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCat(*(const ::IfThreeWayCat*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::IfThreeWayCat(*(const ::IfThreeWayCat*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_6455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayCat*)o)->clone)((const char*)arg[0]));
  else   (((const ::IfThreeWayCat*)o)->clone)((const char*)arg[0]);
}

static void destructor_6456(void*, void * o, const std::vector<void*>&, void *) {
(((::IfThreeWayCat*)o)->::IfThreeWayCat::~IfThreeWayCat)();
}
static  void method_6458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCat*)o)->Class)());
  else   (((::IfThreeWayCat*)o)->Class)();
}

static  void method_6459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCat*)o)->Class_Name)());
  else   (((::IfThreeWayCat*)o)->Class_Name)();
}

static  void method_6460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::IfThreeWayCat*)o)->Class_Version)());
  else   (((::IfThreeWayCat*)o)->Class_Version)();
}

static  void method_6461( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IfThreeWayCat*)o)->Dictionary)();
}

static  void method_6462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayCat*)o)->IsA)());
  else   (((const ::IfThreeWayCat*)o)->IsA)();
}

static  void method_6463( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCat*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6464( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCat*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6465( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCat*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCat*)o)->DeclFileName)());
  else   (((::IfThreeWayCat*)o)->DeclFileName)();
}

static  void method_6467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayCat*)o)->ImplFileLine)());
  else   (((::IfThreeWayCat*)o)->ImplFileLine)();
}

static  void method_6468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCat*)o)->ImplFileName)());
  else   (((::IfThreeWayCat*)o)->ImplFileName)();
}

static  void method_6469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayCat*)o)->DeclFileLine)());
  else   (((::IfThreeWayCat*)o)->DeclFileLine)();
}

static void method_newdel_723( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::IfThreeWayCat,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::IfThreeWayCat,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::IfThreeWayCat,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::IfThreeWayCat,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::IfThreeWayCat,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IfThreeWayCat -------------------------------
void __IfThreeWayCat_db_datamem(Reflex::Class*);
void __IfThreeWayCat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IfThreeWayCat_datamem_bld(&__IfThreeWayCat_db_datamem);
Reflex::GenreflexMemberBuilder __IfThreeWayCat_funcmem_bld(&__IfThreeWayCat_db_funcmem);
void __IfThreeWayCat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IfThreeWayCat"), typeid(::IfThreeWayCat), sizeof(::IfThreeWayCat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::IfThreeWayCat::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::IfThreeWayCat, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28211, type_28212), Reflex::Literal("operator="), operator_6451, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IfThreeWayCat"), constructor_6452, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27792, type_27793, type_27793, type_27793), Reflex::Literal("IfThreeWayCat"), constructor_6453, 0, "name;title;_cond;_pos;_zero;_neg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28212, type_4138), Reflex::Literal("IfThreeWayCat"), constructor_6454, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IfThreeWayCat"), destructor_6456, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_723, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IfThreeWayCat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IfThreeWayCat_funcmem_bld);
}

//------Delayed data member builder for class IfThreeWayCat -------------------
void __IfThreeWayCat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("cond"), OffsetOf(__shadow__::__IfThreeWayCat, cond), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("pos"), OffsetOf(__shadow__::__IfThreeWayCat, pos), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("zero"), OffsetOf(__shadow__::__IfThreeWayCat, zero), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("neg"), OffsetOf(__shadow__::__IfThreeWayCat, neg), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class IfThreeWayCat -------------------
void __IfThreeWayCat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_6455, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_6458, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_6459, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_6460, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_6461, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_6462, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_6463, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_6464, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_6465, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_6466, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_6467, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_6468, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_6469, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooCubicSplineKnot -------------------------------
static void destructor_7161(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineKnot*)o)->::RooCubicSplineKnot::~RooCubicSplineKnot)();
}
static  void operator_7162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot*)o)->operator=)(*(const ::RooCubicSplineKnot*)arg[0]);
  else   (((::RooCubicSplineKnot*)o)->operator=)(*(const ::RooCubicSplineKnot*)arg[0]);
}

static void constructor_7163( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot(*(const ::RooCubicSplineKnot*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot(*(const ::RooCubicSplineKnot*)arg[0]);
}

static void constructor_7164( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot((const double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot((const double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_7165( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot(*(const ::std::vector<double>*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot(*(const ::std::vector<double>*)arg[0]);
}

static  void method_7166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot*)o)->u)(*(int*)arg[0]));
  else   (((const ::RooCubicSplineKnot*)o)->u)(*(int*)arg[0]);
}

static  void method_7167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RooCubicSplineKnot*)o)->size)());
  else   (((const ::RooCubicSplineKnot*)o)->size)();
}

static  void method_7168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot*)o)->evaluate)(*(double*)arg[0],
    *(const ::RooArgList*)arg[1]));
  else   (((const ::RooCubicSplineKnot*)o)->evaluate)(*(double*)arg[0],
    *(const ::RooArgList*)arg[1]);
}

static  void method_7169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot*)o)->analyticalIntegral)(*(const ::RooArgList*)arg[0]));
  else   (((const ::RooCubicSplineKnot*)o)->analyticalIntegral)(*(const ::RooArgList*)arg[0]);
}

static  void method_7170( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::RooCubicSplineKnot*)o)->computeCoefficients)(*(::std::vector<double>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::RooCubicSplineKnot*)o)->computeCoefficients)(*(::std::vector<double>*)arg[0],
      *(::RooCubicSplineKnot::BoundaryConditions*)arg[1]);
  }
}

static  void method_7171( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::RooCubicSplineKnot*)o)->smooth)(*(::std::vector<double>*)arg[0],
    *(const ::std::vector<double>*)arg[1],
    *(double*)arg[2]);
}

static  void method_7172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooCubicSplineKnot*)o)->knots)();
  else   (((const ::RooCubicSplineKnot*)o)->knots)();
}

static  void method_7173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot*)o)->S_jk_sum)(*(int*)arg[0],
    *(const ::RooArgList*)arg[1]));
  else   (((const ::RooCubicSplineKnot*)o)->S_jk_sum)(*(int*)arg[0],
    *(const ::RooArgList*)arg[1]);
}

static  void method_7174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_edge)((((const ::RooCubicSplineKnot*)o)->S_jk_edge)(*(bool*)arg[0],
    *(const ::RooArgList*)arg[1]));
  else   (((const ::RooCubicSplineKnot*)o)->S_jk_edge)(*(bool*)arg[0],
    *(const ::RooArgList*)arg[1]);
}

static  void method_7175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot*)o)->expIntegral)((const ::TH1*)arg[0],
    *(double*)arg[1],
    *(::TVectorD*)arg[2],
    *(::TMatrixD*)arg[3]));
  else   (((const ::RooCubicSplineKnot*)o)->expIntegral)((const ::TH1*)arg[0],
    *(double*)arg[1],
    *(::TVectorD*)arg[2],
    *(::TMatrixD*)arg[3]);
}

static  void method_7199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineKnot*)o)->Class)());
  else   (((::RooCubicSplineKnot*)o)->Class)();
}

static  void method_7200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineKnot*)o)->Class_Name)());
  else   (((::RooCubicSplineKnot*)o)->Class_Name)();
}

static  void method_7201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooCubicSplineKnot*)o)->Class_Version)());
  else   (((::RooCubicSplineKnot*)o)->Class_Version)();
}

static  void method_7202( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooCubicSplineKnot*)o)->Dictionary)();
}

static  void method_7203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCubicSplineKnot*)o)->IsA)());
  else   (((const ::RooCubicSplineKnot*)o)->IsA)();
}

static  void method_7204( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineKnot*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7205( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineKnot*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7206( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineKnot*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineKnot*)o)->DeclFileName)());
  else   (((::RooCubicSplineKnot*)o)->DeclFileName)();
}

static  void method_7208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCubicSplineKnot*)o)->ImplFileLine)());
  else   (((::RooCubicSplineKnot*)o)->ImplFileLine)();
}

static  void method_7209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineKnot*)o)->ImplFileName)());
  else   (((::RooCubicSplineKnot*)o)->ImplFileName)();
}

static  void method_7210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCubicSplineKnot*)o)->DeclFileLine)());
  else   (((::RooCubicSplineKnot*)o)->DeclFileLine)();
}

//------Dictionary for class RooCubicSplineKnot -------------------------------
void __RooCubicSplineKnot_db_datamem(Reflex::Class*);
void __RooCubicSplineKnot_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot_datamem_bld(&__RooCubicSplineKnot_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot_funcmem_bld(&__RooCubicSplineKnot_db_funcmem);
void __RooCubicSplineKnot_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineKnot"), typeid(::RooCubicSplineKnot), sizeof(::RooCubicSplineKnot), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooCubicSplineKnot::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 0)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooCubicSplineKnot"), destructor_7161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28359, type_28360), Reflex::Literal("operator="), operator_7162, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28360), Reflex::Literal("RooCubicSplineKnot"), constructor_7163, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17964, type_141), Reflex::Literal("RooCubicSplineKnot"), constructor_7164, 0, "array;nEntries", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19008), Reflex::Literal("RooCubicSplineKnot"), constructor_7165, 0, "_knots", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineKnot_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCubicSplineKnot_funcmem_bld);
}

//------Delayed data member builder for class RooCubicSplineKnot -------------------
void __RooCubicSplineKnot_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3092, Reflex::Literal("_u"), OffsetOf(__shadow__::__RooCubicSplineKnot, _u), ::Reflex::PRIVATE)
  .AddDataMember(type_3092, Reflex::Literal("_PQRS"), OffsetOf(__shadow__::__RooCubicSplineKnot, _PQRS), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3092, Reflex::Literal("_IABCD"), OffsetOf(__shadow__::__RooCubicSplineKnot, _IABCD), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3093, Reflex::Literal("_S_jk"), OffsetOf(__shadow__::__RooCubicSplineKnot, _S_jk), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class RooCubicSplineKnot -------------------
void __RooCubicSplineKnot_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_141), Reflex::Literal("u"), method_7166, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("size"), method_7167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_694, type_27954), Reflex::Literal("evaluate"), method_7168, 0, "_u;b", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_27954), Reflex::Literal("analyticalIntegral"), method_7169, 0, "b", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19006, type_7158), Reflex::Literal("computeCoefficients"), method_7170, 0, "y;bc=RooCubicSplineKnot::BoundaryConditions(1, 1, 0.0, 0.0)", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19006, type_19008, type_694), Reflex::Literal("smooth"), method_7171, 0, "y;dy;lambda", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19008), Reflex::Literal("knots"), method_7172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7159, type_141, type_27954), Reflex::Literal("S_jk_sum"), method_7173, 0, "i;b", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7160, type_667, type_27954), Reflex::Literal("S_jk_edge"), method_7174, 0, "left;b", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_28266, type_694, type_28361, type_28362), Reflex::Literal("expIntegral"), method_7175, 0, "hist;gamma;coefficients;covarianceMatrix", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_7199, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_7200, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_7201, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_7202, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_7203, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_7204, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_7205, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_7206, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_7207, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_7208, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_7209, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_7210, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinnedPdf -------------------------------
static  void operator_7946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinnedPdf*)o)->operator=)(*(const ::RooBinnedPdf*)arg[0]);
  else   (((::RooBinnedPdf*)o)->operator=)(*(const ::RooBinnedPdf*)arg[0]);
}

static void constructor_7947( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf();
  else ::new(mem) ::RooBinnedPdf();
}

static void constructor_7948( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(const ::RooArgList*)arg[3]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(const ::RooArgList*)arg[3]);
}

static void constructor_7949( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::RooArgList*)arg[3]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::RooArgList*)arg[3]);
}

static void constructor_7950( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void constructor_7951( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsRealLValue*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsRealLValue*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsRealLValue*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4],
      *(::Bool_t*)arg[5]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsRealLValue*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static void constructor_7952( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::RooArgList*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::RooArgList*)arg[4],
      *(::Bool_t*)arg[5]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::RooArgList*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static void constructor_7953( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4],
      *(::Bool_t*)arg[5]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4],
      *(::Bool_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Bool_t*)arg[6]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Bool_t*)arg[6]);
  }
}

static void constructor_7954( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsArg*)arg[2],
      (const char*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsArg*)arg[2],
      (const char*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_7955( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_7956( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf(*(const ::RooBinnedPdf*)arg[0]);
  else ::new(mem) ::RooBinnedPdf(*(const ::RooBinnedPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf(*(const ::RooBinnedPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinnedPdf(*(const ::RooBinnedPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_7957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooBinnedPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_7958(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinnedPdf*)o)->::RooBinnedPdf::~RooBinnedPdf)();
}
static  void method_7959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedPdf*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinnedPdf*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_7960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedPdf*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinnedPdf*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_7961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->baseVariables)());
  else   (((::RooBinnedPdf*)o)->baseVariables)();
}

static  void method_7962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinnedPdf*)o)->continuousBase)());
  else   (((const ::RooBinnedPdf*)o)->continuousBase)();
}

static  void method_7963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::RooBinnedPdf*)o)->forceUnitIntegral)());
  else   (((::RooBinnedPdf*)o)->forceUnitIntegral)();
}

static  void method_7964( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooBinnedPdf*)o)->setForceUnitIntegral)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooBinnedPdf*)o)->setForceUnitIntegral)(*(::Bool_t*)arg[0]);
  }
}

static  void method_7965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinnedPdf*)o)->binIntegralCoefs)());
  else   (((const ::RooBinnedPdf*)o)->binIntegralCoefs)();
}

static  void method_7966( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooBinnedPdf*)o)->setBinIntegralCoefs)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooBinnedPdf*)o)->setBinIntegralCoefs)(*(::Bool_t*)arg[0]);
  }
}

static  void method_7967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinnedPdf*)o)->ignoreFirstBin)());
  else   (((const ::RooBinnedPdf*)o)->ignoreFirstBin)();
}

static  void method_7968( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooBinnedPdf*)o)->setIgnoreFirstBin)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooBinnedPdf*)o)->setIgnoreFirstBin)(*(::Bool_t*)arg[0]);
  }
}

static  void method_7969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinnedPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinnedPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_7970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinnedPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinnedPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_7971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedPdf*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinnedPdf*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_7972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedPdf*)o)->maxVal)(*(::Int_t*)arg[0]));
  else   (((const ::RooBinnedPdf*)o)->maxVal)(*(::Int_t*)arg[0]);
}

static  void method_7973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedPdf*)o)->getValV)((const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinnedPdf*)o)->getValV)((const ::RooArgSet*)arg[0]);
}

static  void method_7984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->Class)());
  else   (((::RooBinnedPdf*)o)->Class)();
}

static  void method_7985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->Class_Name)());
  else   (((::RooBinnedPdf*)o)->Class_Name)();
}

static  void method_7986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinnedPdf*)o)->Class_Version)());
  else   (((::RooBinnedPdf*)o)->Class_Version)();
}

static  void method_7987( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinnedPdf*)o)->Dictionary)();
}

static  void method_7988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedPdf*)o)->IsA)());
  else   (((const ::RooBinnedPdf*)o)->IsA)();
}

static  void method_7989( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7990( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7991( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->DeclFileName)());
  else   (((::RooBinnedPdf*)o)->DeclFileName)();
}

static  void method_7993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinnedPdf*)o)->ImplFileLine)());
  else   (((::RooBinnedPdf*)o)->ImplFileLine)();
}

static  void method_7994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->ImplFileName)());
  else   (((::RooBinnedPdf*)o)->ImplFileName)();
}

static  void method_7995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinnedPdf*)o)->DeclFileLine)());
  else   (((::RooBinnedPdf*)o)->DeclFileLine)();
}

static void method_newdel_995( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooBinnedPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinnedPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinnedPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinnedPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinnedPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinnedPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinnedPdf -------------------------------
void __RooBinnedPdf_db_datamem(Reflex::Class*);
void __RooBinnedPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinnedPdf_datamem_bld(&__RooBinnedPdf_db_datamem);
Reflex::GenreflexMemberBuilder __RooBinnedPdf_funcmem_bld(&__RooBinnedPdf_db_funcmem);
void __RooBinnedPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinnedPdf"), typeid(::RooBinnedPdf), sizeof(::RooBinnedPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinnedPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooBinnedPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28425, type_28426), Reflex::Literal("operator="), operator_7946, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinnedPdf"), constructor_7947, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27792, type_27954), Reflex::Literal("RooBinnedPdf"), constructor_7948, 0, "name;title;baseCat;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27954, type_27954), Reflex::Literal("RooBinnedPdf"), constructor_7949, 0, "name;title;baseCats;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27954, type_28427, type_668), Reflex::Literal("RooBinnedPdf"), constructor_7950, 0, "name;title;baseCats;coefLists;ignoreFirstBin=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27883, type_4138, type_27954, type_668), Reflex::Literal("RooBinnedPdf"), constructor_7951, 0, "name;title;baseVar;binning;coefList;binIntegralCoefs=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27954, type_28427, type_27954, type_668), Reflex::Literal("RooBinnedPdf"), constructor_7952, 0, "name;title;baseVars;binningNames;coefList;binIntegralCoefs=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27954, type_28427, type_28427, type_668, type_668), Reflex::Literal("RooBinnedPdf"), constructor_7953, 0, "name;title;baseVars;binningNames;coefLists;binIntegralCoefs=kFALSE;ignoreFirstBin=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_6064, type_4138, type_27793), Reflex::Literal("RooBinnedPdf"), constructor_7954, 0, "name;title;baseVar;binning;function", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27954, type_28427, type_27793), Reflex::Literal("RooBinnedPdf"), constructor_7955, 0, "name;title;baseVars;binningNames;function", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28426, type_4138), Reflex::Literal("RooBinnedPdf"), constructor_7956, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinnedPdf"), destructor_7958, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_995, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinnedPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinnedPdf_funcmem_bld);
}

//------Delayed data member builder for class RooBinnedPdf -------------------
void __RooBinnedPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_646, Reflex::Literal("_baseCatsList"), OffsetOf(__shadow__::__RooBinnedPdf, _baseCatsList), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("_baseVarsList"), OffsetOf(__shadow__::__RooBinnedPdf, _baseVarsList), ::Reflex::PRIVATE)
  .AddDataMember(type_2579, Reflex::Literal("_coefLists"), OffsetOf(__shadow__::__RooBinnedPdf, _coefLists), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("_function"), OffsetOf(__shadow__::__RooBinnedPdf, _function), ::Reflex::PRIVATE)
  .AddDataMember(type_3115, Reflex::Literal("_indexPositions"), OffsetOf(__shadow__::__RooBinnedPdf, _indexPositions), ::Reflex::PRIVATE)
  .AddDataMember(type_3114, Reflex::Literal("_binningNames"), OffsetOf(__shadow__::__RooBinnedPdf, _binningNames), ::Reflex::PRIVATE)
  .AddDataMember(type_3118, Reflex::Literal("_calcCoefZeros"), OffsetOf(__shadow__::__RooBinnedPdf, _calcCoefZeros), ::Reflex::PRIVATE)
  .AddDataMember(type_1309, Reflex::Literal("_numCats"), OffsetOf(__shadow__::__RooBinnedPdf, _numCats), ::Reflex::PRIVATE)
  .AddDataMember(type_668, Reflex::Literal("_continuousBase"), OffsetOf(__shadow__::__RooBinnedPdf, _continuousBase), ::Reflex::PRIVATE)
  .AddDataMember(type_668, Reflex::Literal("_forceUnitIntegral"), OffsetOf(__shadow__::__RooBinnedPdf, _forceUnitIntegral), ::Reflex::PRIVATE)
  .AddDataMember(type_668, Reflex::Literal("_binIntegralCoefs"), OffsetOf(__shadow__::__RooBinnedPdf, _binIntegralCoefs), ::Reflex::PRIVATE)
  .AddDataMember(type_668, Reflex::Literal("_ignoreFirstBin"), OffsetOf(__shadow__::__RooBinnedPdf, _ignoreFirstBin), ::Reflex::PRIVATE)
  .AddDataMember(type_2216, Reflex::Literal("m_cacheMgr"), OffsetOf(__shadow__::__RooBinnedPdf, m_cacheMgr), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2835, Reflex::Literal("m_nset"), OffsetOf(__shadow__::__RooBinnedPdf, m_nset), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2834, Reflex::Literal("m_nsethash"), OffsetOf(__shadow__::__RooBinnedPdf, m_nsethash), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3352, Reflex::Literal("m_nsets"), OffsetOf(__shadow__::__RooBinnedPdf, m_nsets), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class RooBinnedPdf -------------------
void __RooBinnedPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_7957, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27882, type_27883, type_2317, type_2317), Reflex::Literal("binBoundaries"), method_7959, 0, "obs;xlo;xhi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27882, type_27883, type_2317, type_2317), Reflex::Literal("plotSamplingHint"), method_7960, 0, "obs;xlo;xhi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2013), Reflex::Literal("baseVariables"), method_7961, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("continuousBase"), method_7962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("forceUnitIntegral"), method_7963, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_668), Reflex::Literal("setForceUnitIntegral"), method_7964, 0, "force=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("binIntegralCoefs"), method_7965, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_668), Reflex::Literal("setBinIntegralCoefs"), method_7966, 0, "integralCoefs=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("ignoreFirstBin"), method_7967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_668), Reflex::Literal("setIgnoreFirstBin"), method_7968, 0, "ignFirstBin=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_7969, 0, "allVars;analVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_7970, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27806), Reflex::Literal("getMaxVal"), method_7971, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("maxVal"), method_7972, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27808), Reflex::Literal("getValV"), method_7973, 0, "nset", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_7984, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_7985, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_7986, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_7987, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_7988, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_7989, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_7990, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_7991, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_7992, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_7993, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_7994, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_7995, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class MistagDistribution -------------------------------
static  void operator_8081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MistagDistribution*)o)->operator=)(*(const ::MistagDistribution*)arg[0]);
  else   (((::MistagDistribution*)o)->operator=)(*(const ::MistagDistribution*)arg[0]);
}

static void constructor_8082( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagDistribution();
  else ::new(mem) ::MistagDistribution();
}

static void constructor_8083( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagDistribution((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::MistagDistribution((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_8084( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::MistagDistribution(*(const ::MistagDistribution*)arg[0]);
  else ::new(mem) ::MistagDistribution(*(const ::MistagDistribution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MistagDistribution(*(const ::MistagDistribution*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::MistagDistribution(*(const ::MistagDistribution*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_8085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MistagDistribution*)o)->clone)((const char*)arg[0]));
  else   (((const ::MistagDistribution*)o)->clone)((const char*)arg[0]);
}

static void destructor_8086(void*, void * o, const std::vector<void*>&, void *) {
(((::MistagDistribution*)o)->::MistagDistribution::~MistagDistribution)();
}
static  void method_8087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::MistagDistribution*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::MistagDistribution*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::MistagDistribution*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::MistagDistribution*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_8088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::MistagDistribution*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::MistagDistribution*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::MistagDistribution*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::MistagDistribution*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_8091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagDistribution*)o)->Class)());
  else   (((::MistagDistribution*)o)->Class)();
}

static  void method_8092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagDistribution*)o)->Class_Name)());
  else   (((::MistagDistribution*)o)->Class_Name)();
}

static  void method_8093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::MistagDistribution*)o)->Class_Version)());
  else   (((::MistagDistribution*)o)->Class_Version)();
}

static  void method_8094( void*, void* o, const std::vector<void*>&, void*)
{
  (((::MistagDistribution*)o)->Dictionary)();
}

static  void method_8095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MistagDistribution*)o)->IsA)());
  else   (((const ::MistagDistribution*)o)->IsA)();
}

static  void method_8096( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagDistribution*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_8097( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagDistribution*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_8098( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagDistribution*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_8099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagDistribution*)o)->DeclFileName)());
  else   (((::MistagDistribution*)o)->DeclFileName)();
}

static  void method_8100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MistagDistribution*)o)->ImplFileLine)());
  else   (((::MistagDistribution*)o)->ImplFileLine)();
}

static  void method_8101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagDistribution*)o)->ImplFileName)());
  else   (((::MistagDistribution*)o)->ImplFileName)();
}

static  void method_8102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MistagDistribution*)o)->DeclFileLine)());
  else   (((::MistagDistribution*)o)->DeclFileLine)();
}

static void method_newdel_1073( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::MistagDistribution,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::MistagDistribution,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::MistagDistribution,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::MistagDistribution,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::MistagDistribution,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::MistagDistribution,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MistagDistribution -------------------------------
void __MistagDistribution_db_datamem(Reflex::Class*);
void __MistagDistribution_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MistagDistribution_datamem_bld(&__MistagDistribution_db_datamem);
Reflex::GenreflexMemberBuilder __MistagDistribution_funcmem_bld(&__MistagDistribution_db_funcmem);
void __MistagDistribution_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MistagDistribution"), typeid(::MistagDistribution), sizeof(::MistagDistribution), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::MistagDistribution::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::MistagDistribution, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28442, type_28443), Reflex::Literal("operator="), operator_8081, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MistagDistribution"), constructor_8082, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("MistagDistribution"), constructor_8083, 0, "name;title;_w;_w0;_wa;_f", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28443, type_4138), Reflex::Literal("MistagDistribution"), constructor_8084, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MistagDistribution"), destructor_8086, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1073, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__MistagDistribution_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__MistagDistribution_funcmem_bld);
}

//------Delayed data member builder for class MistagDistribution -------------------
void __MistagDistribution_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("w"), OffsetOf(__shadow__::__MistagDistribution, w), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("w0"), OffsetOf(__shadow__::__MistagDistribution, w0), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("wa"), OffsetOf(__shadow__::__MistagDistribution, wa), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("f"), OffsetOf(__shadow__::__MistagDistribution, f), ::Reflex::PROTECTED)
  .AddDataMember(type_694, Reflex::Literal("lastw0"), OffsetOf(__shadow__::__MistagDistribution, lastw0), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_694, Reflex::Literal("lastwa"), OffsetOf(__shadow__::__MistagDistribution, lastwa), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_694, Reflex::Literal("lastf"), OffsetOf(__shadow__::__MistagDistribution, lastf), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_694, Reflex::Literal("lastwc"), OffsetOf(__shadow__::__MistagDistribution, lastwc), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class MistagDistribution -------------------
void __MistagDistribution_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_8085, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_8087, 0, "integ;anaIntSet;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_8088, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_8091, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_8092, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_8093, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_8094, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_8095, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_8096, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_8097, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_8098, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_8099, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_8100, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_8101, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_8102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SquaredSum -------------------------------
static  void operator_9173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SquaredSum*)o)->operator=)(*(const ::SquaredSum*)arg[0]);
  else   (((::SquaredSum*)o)->operator=)(*(const ::SquaredSum*)arg[0]);
}

static void constructor_9174( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SquaredSum();
  else ::new(mem) ::SquaredSum();
}

static void constructor_9175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SquaredSum((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::SquaredSum((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_9176( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SquaredSum(*(const ::SquaredSum*)arg[0]);
  else ::new(mem) ::SquaredSum(*(const ::SquaredSum*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SquaredSum(*(const ::SquaredSum*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::SquaredSum(*(const ::SquaredSum*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_9177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SquaredSum*)o)->clone)((const char*)arg[0]));
  else   (((const ::SquaredSum*)o)->clone)((const char*)arg[0]);
}

static void destructor_9178(void*, void * o, const std::vector<void*>&, void *) {
(((::SquaredSum*)o)->::SquaredSum::~SquaredSum)();
}
static  void method_9180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SquaredSum*)o)->Class)());
  else   (((::SquaredSum*)o)->Class)();
}

static  void method_9181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SquaredSum*)o)->Class_Name)());
  else   (((::SquaredSum*)o)->Class_Name)();
}

static  void method_9182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SquaredSum*)o)->Class_Version)());
  else   (((::SquaredSum*)o)->Class_Version)();
}

static  void method_9183( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SquaredSum*)o)->Dictionary)();
}

static  void method_9184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SquaredSum*)o)->IsA)());
  else   (((const ::SquaredSum*)o)->IsA)();
}

static  void method_9185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SquaredSum*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SquaredSum*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SquaredSum*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SquaredSum*)o)->DeclFileName)());
  else   (((::SquaredSum*)o)->DeclFileName)();
}

static  void method_9189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SquaredSum*)o)->ImplFileLine)());
  else   (((::SquaredSum*)o)->ImplFileLine)();
}

static  void method_9190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SquaredSum*)o)->ImplFileName)());
  else   (((::SquaredSum*)o)->ImplFileName)();
}

static  void method_9191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SquaredSum*)o)->DeclFileLine)());
  else   (((::SquaredSum*)o)->DeclFileLine)();
}

static void method_newdel_1305( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SquaredSum >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SquaredSum >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SquaredSum >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SquaredSum >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SquaredSum >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x32( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::SquaredSum,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::SquaredSum,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::SquaredSum,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SquaredSum,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::SquaredSum,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SquaredSum -------------------------------
void __SquaredSum_db_datamem(Reflex::Class*);
void __SquaredSum_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SquaredSum_datamem_bld(&__SquaredSum_db_datamem);
Reflex::GenreflexMemberBuilder __SquaredSum_funcmem_bld(&__SquaredSum_db_funcmem);
void __SquaredSum_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SquaredSum"), typeid(::SquaredSum), sizeof(::SquaredSum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SquaredSum::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::SquaredSum, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28562, type_28563), Reflex::Literal("operator="), operator_9173, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SquaredSum"), constructor_9174, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793), Reflex::Literal("SquaredSum"), constructor_9175, 0, "name;title;_C;_D;_S", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28563, type_4138), Reflex::Literal("SquaredSum"), constructor_9176, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SquaredSum"), destructor_9178, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1305, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x32, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SquaredSum_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SquaredSum_funcmem_bld);
}

//------Delayed data member builder for class SquaredSum -------------------
void __SquaredSum_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("C"), OffsetOf(__shadow__::__SquaredSum, C), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("D"), OffsetOf(__shadow__::__SquaredSum, D), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("S"), OffsetOf(__shadow__::__SquaredSum, S), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class SquaredSum -------------------
void __SquaredSum_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_9177, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_9180, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_9181, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_9182, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_9183, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_9184, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_9185, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_9186, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_9187, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_9188, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_9189, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_9190, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_9191, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooGenSmearIntegrandBinding -------------------------------
static  void operator_9495( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGenSmearIntegrandBinding*)o)->operator=)(*(const ::RooGenSmearIntegrandBinding*)arg[0]);
  else   (((::RooGenSmearIntegrandBinding*)o)->operator=)(*(const ::RooGenSmearIntegrandBinding*)arg[0]);
}

static void constructor_9496( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooGenSmearIntegrandBinding*)arg[0]);
  else ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooGenSmearIntegrandBinding*)arg[0]);
}

static void constructor_9497( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2]);
  else ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      (const ::RooArgSet*)arg[3]);
  else ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void destructor_9498(void*, void * o, const std::vector<void*>&, void *) {
(((::RooGenSmearIntegrandBinding*)o)->::RooGenSmearIntegrandBinding::~RooGenSmearIntegrandBinding)();
}
static  void operator_9499( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGenSmearIntegrandBinding*)o)->operator())((const ::Double_t*)arg[0]));
  else   (((const ::RooGenSmearIntegrandBinding*)o)->operator())((const ::Double_t*)arg[0]);
}

static  void method_9500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGenSmearIntegrandBinding*)o)->getMinLimit)(*(::UInt_t*)arg[0]));
  else   (((const ::RooGenSmearIntegrandBinding*)o)->getMinLimit)(*(::UInt_t*)arg[0]);
}

static  void method_9501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGenSmearIntegrandBinding*)o)->getMaxLimit)(*(::UInt_t*)arg[0]));
  else   (((const ::RooGenSmearIntegrandBinding*)o)->getMaxLimit)(*(::UInt_t*)arg[0]);
}

static  void method_9502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->setNormalizationSet)((const ::RooArgSet*)arg[0]);
}

static  void method_9504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGenSmearIntegrandBinding*)o)->Class)());
  else   (((::RooGenSmearIntegrandBinding*)o)->Class)();
}

static  void method_9505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGenSmearIntegrandBinding*)o)->Class_Name)());
  else   (((::RooGenSmearIntegrandBinding*)o)->Class_Name)();
}

static  void method_9506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooGenSmearIntegrandBinding*)o)->Class_Version)());
  else   (((::RooGenSmearIntegrandBinding*)o)->Class_Version)();
}

static  void method_9507( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->Dictionary)();
}

static  void method_9508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGenSmearIntegrandBinding*)o)->IsA)());
  else   (((const ::RooGenSmearIntegrandBinding*)o)->IsA)();
}

static  void method_9509( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9510( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9511( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGenSmearIntegrandBinding*)o)->DeclFileName)());
  else   (((::RooGenSmearIntegrandBinding*)o)->DeclFileName)();
}

static  void method_9513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGenSmearIntegrandBinding*)o)->ImplFileLine)());
  else   (((::RooGenSmearIntegrandBinding*)o)->ImplFileLine)();
}

static  void method_9514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGenSmearIntegrandBinding*)o)->ImplFileName)());
  else   (((::RooGenSmearIntegrandBinding*)o)->ImplFileName)();
}

static  void method_9515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGenSmearIntegrandBinding*)o)->DeclFileLine)());
  else   (((::RooGenSmearIntegrandBinding*)o)->DeclFileLine)();
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsFunc")), ::Reflex::BaseOffset< ::RooGenSmearIntegrandBinding,::RooAbsFunc >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooGenSmearIntegrandBinding -------------------------------
void __RooGenSmearIntegrandBinding_db_datamem(Reflex::Class*);
void __RooGenSmearIntegrandBinding_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooGenSmearIntegrandBinding_datamem_bld(&__RooGenSmearIntegrandBinding_db_datamem);
Reflex::GenreflexMemberBuilder __RooGenSmearIntegrandBinding_funcmem_bld(&__RooGenSmearIntegrandBinding_db_funcmem);
void __RooGenSmearIntegrandBinding_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooGenSmearIntegrandBinding"), typeid(::RooGenSmearIntegrandBinding), sizeof(::RooGenSmearIntegrandBinding), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooGenSmearIntegrandBinding::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 0)
  .AddBase(type_2683, ::Reflex::BaseOffset< ::RooGenSmearIntegrandBinding, ::RooAbsFunc >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28612, type_28613), Reflex::Literal("operator="), operator_9495, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28613), Reflex::Literal("RooGenSmearIntegrandBinding"), constructor_9496, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27884, type_27884, type_27793, type_27808, type_668), Reflex::Literal("RooGenSmearIntegrandBinding"), constructor_9497, 0, "func;model;k;nset=0;clipInvalid=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooGenSmearIntegrandBinding"), destructor_9498, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooGenSmearIntegrandBinding_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooGenSmearIntegrandBinding_funcmem_bld);
}

//------Delayed data member builder for class RooGenSmearIntegrandBinding -------------------
void __RooGenSmearIntegrandBinding_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_28024, Reflex::Literal("_func"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _func), ::Reflex::PROTECTED)
  .AddDataMember(type_28024, Reflex::Literal("_model"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _model), ::Reflex::PROTECTED)
  .AddDataMember(type_19447, Reflex::Literal("_var"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _var), ::Reflex::PROTECTED)
  .AddDataMember(type_27808, Reflex::Literal("_nset"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _nset), ::Reflex::PROTECTED)
  .AddDataMember(type_668, Reflex::Literal("_xvecValid"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _xvecValid), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_668, Reflex::Literal("_clipInvalid"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _clipInvalid), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooGenSmearIntegrandBinding -------------------
void __RooGenSmearIntegrandBinding_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27858), Reflex::Literal("operator()"), operator_9499, 0, "xvector", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_2834), Reflex::Literal("getMinLimit"), method_9500, 0, "dimension", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_2834), Reflex::Literal("getMaxLimit"), method_9501, 0, "dimension", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27808), Reflex::Literal("setNormalizationSet"), method_9502, 0, "nset", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_9504, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_9505, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_9506, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_9507, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_9508, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_9509, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_9510, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_9511, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_9512, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_9513, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_9514, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_9515, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooGaussEfficiencyModel -------------------------------
static  void operator_9763( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGaussEfficiencyModel*)o)->operator=)(*(const ::RooGaussEfficiencyModel*)arg[0]);
  else   (((::RooGaussEfficiencyModel*)o)->operator=)(*(const ::RooGaussEfficiencyModel*)arg[0]);
}

static void constructor_9764( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel();
  else ::new(mem) ::RooGaussEfficiencyModel();
}

static void constructor_9765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsGaussModelEfficiency*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::RooGaussEfficiencyModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsGaussModelEfficiency*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_9766( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsGaussModelEfficiency*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
  else ::new(mem) ::RooGaussEfficiencyModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsGaussModelEfficiency*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
}

static void constructor_9767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel(*(const ::RooGaussEfficiencyModel*)arg[0]);
  else ::new(mem) ::RooGaussEfficiencyModel(*(const ::RooGaussEfficiencyModel*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel(*(const ::RooGaussEfficiencyModel*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooGaussEfficiencyModel(*(const ::RooGaussEfficiencyModel*)arg[0],
      (const char*)arg[1]);
  }
}

static void destructor_9768(void*, void * o, const std::vector<void*>&, void *) {
(((::RooGaussEfficiencyModel*)o)->::RooGaussEfficiencyModel::~RooGaussEfficiencyModel)();
}
static  void method_9769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooGaussEfficiencyModel*)o)->clone)((const char*)arg[0]);
}

static  void method_9770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooGaussEfficiencyModel*)o)->basisCode)((const char*)arg[0]));
  else   (((const ::RooGaussEfficiencyModel*)o)->basisCode)((const char*)arg[0]);
}

static  void method_9771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGaussEfficiencyModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooGaussEfficiencyModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGaussEfficiencyModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooGaussEfficiencyModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_9772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGaussEfficiencyModel*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::RooGaussEfficiencyModel*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_9773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]));
    else     (((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]));
    else     (((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]));
    else     (((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_9774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooGaussEfficiencyModel*)o)->isDirectGenSafe)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooGaussEfficiencyModel*)o)->isDirectGenSafe)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_9775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooGaussEfficiencyModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    *(::Bool_t*)arg[2]));
  else   (((const ::RooGaussEfficiencyModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    *(::Bool_t*)arg[2]);
}

static  void method_9776( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->generateEvent)(*(::Int_t*)arg[0]);
}

static  void method_9777( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->advertiseFlatScaleFactorIntegral)(*(::Bool_t*)arg[0]);
}

static  void method_9778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->efficiency)());
  else   (((const ::RooGaussEfficiencyModel*)o)->efficiency)();
}

static  void method_9779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->observables)());
  else   (((const ::RooGaussEfficiencyModel*)o)->observables)();
}

static  void method_9782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGaussEfficiencyModel*)o)->Class)());
  else   (((::RooGaussEfficiencyModel*)o)->Class)();
}

static  void method_9783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGaussEfficiencyModel*)o)->Class_Name)());
  else   (((::RooGaussEfficiencyModel*)o)->Class_Name)();
}

static  void method_9784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooGaussEfficiencyModel*)o)->Class_Version)());
  else   (((::RooGaussEfficiencyModel*)o)->Class_Version)();
}

static  void method_9785( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGaussEfficiencyModel*)o)->Dictionary)();
}

static  void method_9786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->IsA)());
  else   (((const ::RooGaussEfficiencyModel*)o)->IsA)();
}

static  void method_9787( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9788( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9789( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGaussEfficiencyModel*)o)->DeclFileName)());
  else   (((::RooGaussEfficiencyModel*)o)->DeclFileName)();
}

static  void method_9791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGaussEfficiencyModel*)o)->ImplFileLine)());
  else   (((::RooGaussEfficiencyModel*)o)->ImplFileLine)();
}

static  void method_9792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGaussEfficiencyModel*)o)->ImplFileName)());
  else   (((::RooGaussEfficiencyModel*)o)->ImplFileName)();
}

static  void method_9793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGaussEfficiencyModel*)o)->DeclFileLine)());
  else   (((::RooGaussEfficiencyModel*)o)->DeclFileLine)();
}

static void method_newdel_1438( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooResolutionModel")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooResolutionModel >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooAbsReal >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooAbsArg >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::TNamed >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::TObject >::Get(),::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooPrintable >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsEffResModel")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooAbsEffResModel >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooGaussEfficiencyModel -------------------------------
void __RooGaussEfficiencyModel_db_datamem(Reflex::Class*);
void __RooGaussEfficiencyModel_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooGaussEfficiencyModel_datamem_bld(&__RooGaussEfficiencyModel_db_datamem);
Reflex::GenreflexMemberBuilder __RooGaussEfficiencyModel_funcmem_bld(&__RooGaussEfficiencyModel_db_funcmem);
void __RooGaussEfficiencyModel_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooGaussEfficiencyModel"), typeid(::RooGaussEfficiencyModel), sizeof(::RooGaussEfficiencyModel), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooGaussEfficiencyModel::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_39, ::Reflex::BaseOffset< ::RooGaussEfficiencyModel, ::RooResolutionModel >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_670, ::Reflex::BaseOffset< ::RooGaussEfficiencyModel, ::RooAbsEffResModel >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28647, type_28648), Reflex::Literal("operator="), operator_9763, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooGaussEfficiencyModel"), constructor_9764, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_28649, type_27793, type_27793), Reflex::Literal("RooGaussEfficiencyModel"), constructor_9765, 0, "name;title;x;spline;mean;sigma", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_28649, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("RooGaussEfficiencyModel"), constructor_9766, 0, "name;title;x;spline;mean;sigma;meanSF;sigmaSF", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28648, type_4138), Reflex::Literal("RooGaussEfficiencyModel"), constructor_9767, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooGaussEfficiencyModel"), destructor_9768, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1438, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooGaussEfficiencyModel_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooGaussEfficiencyModel_funcmem_bld);
}

//------Delayed data member builder for class RooGaussEfficiencyModel -------------------
void __RooGaussEfficiencyModel_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_668, Reflex::Literal("_flatSFInt"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, _flatSFInt), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("eff"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, eff), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("mean"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, mean), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("sigma"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, sigma), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("msf"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, msf), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("ssf"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, ssf), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooGaussEfficiencyModel -------------------
void __RooGaussEfficiencyModel_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_9769, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_4138), Reflex::Literal("basisCode"), method_9770, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_9771, 0, "allVars;analVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_9772, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27804, type_27805, type_27806, type_27807, type_27808, type_668), Reflex::Literal("modelGenContext"), method_9773, 0, "convPdf;vars;prototype=0;auxProto=0;verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9895), Reflex::Literal("isDirectGenSafe"), method_9774, 0, "arg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27806, type_27811, type_668), Reflex::Literal("getGenerator"), method_9775, 0, "directVars;generateVars;staticInitOK", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("generateEvent"), method_9776, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_668), Reflex::Literal("advertiseFlatScaleFactorIntegral"), method_9777, 0, "flag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28024), Reflex::Literal("efficiency"), method_9778, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2835), Reflex::Literal("observables"), method_9779, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_9782, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_9783, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_9784, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_9785, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_9786, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_9787, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_9788, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_9789, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_9790, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_9791, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_9792, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_9793, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooGeneralisedSmearingBase<RooAbsPdf> -------------------------------
static void constructor_9838( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>();
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>();
}

static void constructor_9839( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_9840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_9841( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->operator=)(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0]);
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->operator=)(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0]);
}

static  void method_9842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]);
}

static void destructor_9843(void*, void * o, const std::vector<void*>&, void *) {
(((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->::RooGeneralisedSmearingBase<RooAbsPdf>::~RooGeneralisedSmearingBase)();
}
static  void method_9844( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)((::RooRealVar*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1],
      (const ::RooArgSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1],
      (const ::RooArgSet*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_9845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->evaluate)());
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->evaluate)();
}

static  void method_9846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->convIntConfig)();
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->convIntConfig)();
}

static  void method_9847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->convIntConfig)();
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->convIntConfig)();
}

static  void method_9848( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->clearConvolutionWindow)();
}

static  void method_9849( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setConvolutionWindow)(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setConvolutionWindow)(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::Double_t*)arg[2]);
  }
}

static  void method_9850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_9851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_9852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_9853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_9854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getMax)(*(::Int_t*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getMax)(*(::Int_t*)arg[0]);
}

static  void method_9875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class)();
}

static  void method_9876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class_Name)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class_Name)();
}

static  void method_9877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class_Version)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class_Version)();
}

static  void method_9878( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Dictionary)();
}

static  void method_9879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->IsA)());
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->IsA)();
}

static  void method_9880( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9881( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->DeclFileName)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->DeclFileName)();
}

static  void method_9884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ImplFileLine)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ImplFileLine)();
}

static  void method_9885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ImplFileName)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ImplFileName)();
}

static  void method_9886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->DeclFileLine)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->DeclFileLine)();
}

static void method_newdel_1473( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooGeneralisedSmearingBase<RooAbsPdf> -------------------------------
void __RooGeneralisedSmearingBase_RooAbsPdf__db_datamem(Reflex::Class*);
void __RooGeneralisedSmearingBase_RooAbsPdf__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooGeneralisedSmearingBase_RooAbsPdf__datamem_bld(&__RooGeneralisedSmearingBase_RooAbsPdf__db_datamem);
Reflex::GenreflexMemberBuilder __RooGeneralisedSmearingBase_RooAbsPdf__funcmem_bld(&__RooGeneralisedSmearingBase_RooAbsPdf__db_funcmem);
void __RooGeneralisedSmearingBase_RooAbsPdf__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooGeneralisedSmearingBase<RooAbsPdf>"), typeid(::RooGeneralisedSmearingBase<RooAbsPdf>), sizeof(::RooGeneralisedSmearingBase<RooAbsPdf>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooGeneralisedSmearingBase<RooAbsReal>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooGeneralisedSmearingBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_9838, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_27793, type_27793), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_9839, 0, "name;title;k;pdf;resmodel", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28658, type_4138), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_9840, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooGeneralisedSmearingBase"), destructor_9843, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1473, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooGeneralisedSmearingBase_RooAbsPdf__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooGeneralisedSmearingBase_RooAbsPdf__funcmem_bld);
}

//------Delayed data member builder for class RooGeneralisedSmearingBase<RooAbsPdf> -------------------
void __RooGeneralisedSmearingBase_RooAbsPdf__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_668, Reflex::Literal("_init"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _init), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_2970, Reflex::Literal("_convIntConfig"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _convIntConfig), ::Reflex::PROTECTED)
  .AddDataMember(type_28656, Reflex::Literal("_integrator"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integrator), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_28657, Reflex::Literal("_integrand"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integrand), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1249, Reflex::Literal("_origVar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _origVar), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_origPdf"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _origPdf), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_origModel"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _origModel), ::Reflex::PROTECTED)
  .AddDataMember(type_28158, Reflex::Literal("_cloneVar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _cloneVar), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_28158, Reflex::Literal("_clonePdf"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _clonePdf), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_28158, Reflex::Literal("_cloneModel"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _cloneModel), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_3360, Reflex::Literal("_integvarset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integvarset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3358, Reflex::Literal("_integralset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integralset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3356, Reflex::Literal("_integrandset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integrandset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3354, Reflex::Literal("_integratorset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integratorset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2786, Reflex::Literal("_binning"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binning), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_binnedvar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedvar), ::Reflex::PROTECTED)
  .AddDataMember(type_22942, Reflex::Literal("_binnedvarClone"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedvarClone), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1126, Reflex::Literal("_binnedcats"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedcats), ::Reflex::PROTECTED)
  .AddDataMember(type_3108, Reflex::Literal("_binnedcache"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedcache), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3107, Reflex::Literal("_binnedcacheLastVal"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedcacheLastVal), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_667, Reflex::Literal("_preferBinnedIntegrals"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _preferBinnedIntegrals), ::Reflex::PROTECTED)
  .AddDataMember(type_668, Reflex::Literal("_useWindow"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _useWindow), ::Reflex::PROTECTED)
  .AddDataMember(type_2317, Reflex::Literal("_windowScale"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _windowScale), ::Reflex::PROTECTED)
  .AddDataMember(type_646, Reflex::Literal("_windowParam"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _windowParam), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooGeneralisedSmearingBase<RooAbsPdf> -------------------
void __RooGeneralisedSmearingBase_RooAbsPdf__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28659, type_28658), Reflex::Literal("operator="), operator_9841, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_9842, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_22942, type_4138, type_27808, type_667), Reflex::Literal("setBinnedCache"), method_9844, 0, "var=0;binningName=0;binnedcats=0;preferBinnedIntegrals=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_9845, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28660), Reflex::Literal("convIntConfig"), method_9846, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28661), Reflex::Literal("convIntConfig"), method_9847, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clearConvolutionWindow"), method_9848, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27793, type_27793, type_2317), Reflex::Literal("setConvolutionWindow"), method_9849, 0, "centerParam;widthParam;widthScaleFactor=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_9850, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_9851, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9895), Reflex::Literal("forceAnalyticalInt"), method_9852, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27806), Reflex::Literal("getMaxVal"), method_9853, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("getMax"), method_9854, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_9875, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_9876, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_9877, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_9878, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_9879, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_9880, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_9881, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_9882, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_9883, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_9884, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_9885, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_9886, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinned1DQuinticBase<RooAbsPdf> -------------------------------
static void constructor_10071( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>();
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>();
}

static void constructor_10072( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(bool*)arg[4]);
  }
}

static void constructor_10073( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_10074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->operator=)(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0]);
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->operator=)(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0]);
}

static  void method_10075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->clone)());
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]);
  }
}

static void destructor_10076(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->::RooBinned1DQuinticBase<RooAbsPdf>::~RooBinned1DQuinticBase)();
}
static  void method_10077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->evaluate)());
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->evaluate)();
}

static  void method_10078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_10079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->isBinnedDistribution)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->isBinnedDistribution)(*(const ::RooArgSet*)arg[0]);
}

static  void method_10081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_10082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_10093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class)();
}

static  void method_10094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class_Name)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class_Name)();
}

static  void method_10095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class_Version)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class_Version)();
}

static  void method_10096( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Dictionary)();
}

static  void method_10097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->IsA)());
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->IsA)();
}

static  void method_10098( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->DeclFileName)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->DeclFileName)();
}

static  void method_10102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ImplFileLine)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ImplFileLine)();
}

static  void method_10103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ImplFileName)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ImplFileName)();
}

static  void method_10104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->DeclFileLine)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->DeclFileLine)();
}

static void method_newdel_1576( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinned1DQuinticBase<RooAbsPdf> -------------------------------
void __RooBinned1DQuinticBase_RooAbsPdf__db_datamem(Reflex::Class*);
void __RooBinned1DQuinticBase_RooAbsPdf__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinned1DQuinticBase_RooAbsPdf__datamem_bld(&__RooBinned1DQuinticBase_RooAbsPdf__db_datamem);
Reflex::GenreflexMemberBuilder __RooBinned1DQuinticBase_RooAbsPdf__funcmem_bld(&__RooBinned1DQuinticBase_RooAbsPdf__db_funcmem);
void __RooBinned1DQuinticBase_RooAbsPdf__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinned1DQuinticBase<RooAbsPdf>"), typeid(::RooBinned1DQuinticBase<RooAbsPdf>), sizeof(::RooBinned1DQuinticBase<RooAbsPdf>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinned1DQuinticBase<RooAbsPdf>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooBinned1DQuinticBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_148"), Reflex::Literal("NCoeff=6;CoeffRecLen=7"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinned1DQuinticBase"), constructor_10071, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27878, type_27793, type_667), Reflex::Literal("RooBinned1DQuinticBase"), constructor_10072, 0, "name;title;h;xvar;integral=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28691, type_4138), Reflex::Literal("RooBinned1DQuinticBase"), constructor_10073, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinned1DQuinticBase"), destructor_10076, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1576, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinned1DQuinticBase_RooAbsPdf__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinned1DQuinticBase_RooAbsPdf__funcmem_bld);
}

//------Delayed data member builder for class RooBinned1DQuinticBase<RooAbsPdf> -------------------
void __RooBinned1DQuinticBase_RooAbsPdf__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, x), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsX"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, nBinsX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeX"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, binSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, xmin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, xmax), ::Reflex::PRIVATE)
  .AddDataMember(type_667, Reflex::Literal("isIntegral"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, isIntegral), ::Reflex::PRIVATE)
  .AddDataMember(type_2203, Reflex::Literal("coeffs"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, coeffs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinned1DQuinticBase<RooAbsPdf> -------------------
void __RooBinned1DQuinticBase_RooAbsPdf__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28692, type_28691), Reflex::Literal("operator="), operator_10074, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28693, type_4138), Reflex::Literal("clone"), method_10075, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_10077, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_10078, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_10079, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_27806), Reflex::Literal("isBinnedDistribution"), method_10080, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27882, type_27883, type_2317, type_2317), Reflex::Literal("binBoundaries"), method_10081, 0, "var;lo;hi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27882, type_27883, type_2317, type_2317), Reflex::Literal("plotSamplingHint"), method_10082, 0, "var;lo;hi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_10093, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_10094, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10095, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10096, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_10097, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_10098, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_10099, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_10100, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_10101, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_10103, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10104, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooEffHistProd -------------------------------
static  void operator_10353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooEffHistProd*)o)->operator=)(*(const ::RooEffHistProd*)arg[0]);
  else   (((::RooEffHistProd*)o)->operator=)(*(const ::RooEffHistProd*)arg[0]);
}

static void constructor_10354( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffHistProd();
  else ::new(mem) ::RooEffHistProd();
}

static void destructor_10355(void*, void * o, const std::vector<void*>&, void *) {
(((::RooEffHistProd*)o)->::RooEffHistProd::~RooEffHistProd)();
}
static void constructor_10356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffHistProd((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsPdf*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::RooEffHistProd((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsPdf*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_10357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffHistProd(*(const ::RooEffHistProd*)arg[0]);
  else ::new(mem) ::RooEffHistProd(*(const ::RooEffHistProd*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffHistProd(*(const ::RooEffHistProd*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooEffHistProd(*(const ::RooEffHistProd*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooEffHistProd*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooEffHistProd*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_10359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooEffHistProd*)o)->clone)((const char*)arg[0]);
}

static  void method_10360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->genContext)(*(const ::RooArgSet*)arg[0],
    (const ::RooDataSet*)arg[1],
    (const ::RooArgSet*)arg[2],
    *(::Bool_t*)arg[3]));
  else   (((const ::RooEffHistProd*)o)->genContext)(*(const ::RooArgSet*)arg[0],
    (const ::RooDataSet*)arg[1],
    (const ::RooArgSet*)arg[2],
    *(::Bool_t*)arg[3]);
}

static  void method_10361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooEffHistProd*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    *(::Bool_t*)arg[2]));
  else   (((const ::RooEffHistProd*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    *(::Bool_t*)arg[2]);
}

static  void method_10362( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->initGenerator)(*(::Int_t*)arg[0]);
}

static  void method_10363( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->generateEvent)(*(::Int_t*)arg[0]);
}

static  void method_10364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffHistProd*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooEffHistProd*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffHistProd*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooEffHistProd*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_10365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooEffHistProd*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooEffHistProd*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10366( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->selectNormalization)((const ::RooArgSet*)arg[0],
    *(::Bool_t*)arg[1]);
}

static  void method_10367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RooEffHistProd*)o)->extendMode)());
  else   (((const ::RooEffHistProd*)o)->extendMode)();
}

static  void method_10368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->expectedEvents)((const ::RooArgSet*)arg[0]));
  else   (((const ::RooEffHistProd*)o)->expectedEvents)((const ::RooArgSet*)arg[0]);
}

static  void method_10369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->getValV)());
    else     (((const ::RooEffHistProd*)o)->getValV)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->getValV)((const ::RooArgSet*)arg[0]));
    else     (((const ::RooEffHistProd*)o)->getValV)((const ::RooArgSet*)arg[0]);
  }
}

static  void method_10370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->pdf)());
  else   (((const ::RooEffHistProd*)o)->pdf)();
}

static  void method_10371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->efficiency)());
  else   (((const ::RooEffHistProd*)o)->efficiency)();
}

static  void method_10372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->observables)());
  else   (((const ::RooEffHistProd*)o)->observables)();
}

static  void method_10373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::RooEffHistProd*)o)->getIntegralBins)((const ::RooArgSet*)arg[0]);
    else     (((const ::RooEffHistProd*)o)->getIntegralBins)((const ::RooArgSet*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::RooEffHistProd*)o)->getIntegralBins)((const ::RooArgSet*)arg[0],
      (const char*)arg[1]);
    else     (((const ::RooEffHistProd*)o)->getIntegralBins)((const ::RooArgSet*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffHistProd*)o)->Class)());
  else   (((::RooEffHistProd*)o)->Class)();
}

static  void method_10381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffHistProd*)o)->Class_Name)());
  else   (((::RooEffHistProd*)o)->Class_Name)();
}

static  void method_10382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooEffHistProd*)o)->Class_Version)());
  else   (((::RooEffHistProd*)o)->Class_Version)();
}

static  void method_10383( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooEffHistProd*)o)->Dictionary)();
}

static  void method_10384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->IsA)());
  else   (((const ::RooEffHistProd*)o)->IsA)();
}

static  void method_10385( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffHistProd*)o)->DeclFileName)());
  else   (((::RooEffHistProd*)o)->DeclFileName)();
}

static  void method_10389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffHistProd*)o)->ImplFileLine)());
  else   (((::RooEffHistProd*)o)->ImplFileLine)();
}

static  void method_10390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffHistProd*)o)->ImplFileName)());
  else   (((::RooEffHistProd*)o)->ImplFileName)();
}

static  void method_10391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffHistProd*)o)->DeclFileLine)());
  else   (((::RooEffHistProd*)o)->DeclFileLine)();
}

static void method_newdel_1630( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooEffHistProd,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooEffHistProd,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooEffHistProd,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooEffHistProd,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooEffHistProd,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooEffHistProd,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooEffHistProd -------------------------------
void __RooEffHistProd_db_datamem(Reflex::Class*);
void __RooEffHistProd_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooEffHistProd_datamem_bld(&__RooEffHistProd_db_datamem);
Reflex::GenreflexMemberBuilder __RooEffHistProd_funcmem_bld(&__RooEffHistProd_db_funcmem);
void __RooEffHistProd_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooEffHistProd"), typeid(::RooEffHistProd), sizeof(::RooEffHistProd), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooEffHistProd::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooEffHistProd, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3092, Reflex::Literal("RooEffHistProd::BinBoundaries"))
  .AddTypedef(type_3112, Reflex::Literal("RooEffHistProd::Levels"))
  .AddTypedef(type_3364, Reflex::Literal("RooEffHistProd::argMap_t"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28728, type_28729), Reflex::Literal("operator="), operator_10353, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooEffHistProd"), constructor_10354, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooEffHistProd"), destructor_10355, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27995, type_27793), Reflex::Literal("RooEffHistProd"), constructor_10356, 0, "name;title;pdf;efficiency", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28729, type_4138), Reflex::Literal("RooEffHistProd"), constructor_10357, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1630, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooEffHistProd_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooEffHistProd_funcmem_bld);
}

//------Delayed data member builder for class RooEffHistProd -------------------
void __RooEffHistProd_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3092, Reflex::Literal("_binboundaries"), OffsetOf(__shadow__::__RooEffHistProd, _binboundaries), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_pdf"), OffsetOf(__shadow__::__RooEffHistProd, _pdf), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("_eff"), OffsetOf(__shadow__::__RooEffHistProd, _eff), ::Reflex::PRIVATE)
  .AddDataMember(type_878, Reflex::Literal("_observables"), OffsetOf(__shadow__::__RooEffHistProd, _observables), ::Reflex::PRIVATE)
  .AddDataMember(type_1126, Reflex::Literal("_pdfGenVars"), OffsetOf(__shadow__::__RooEffHistProd, _pdfGenVars), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1309, Reflex::Literal("_pdfGenCode"), OffsetOf(__shadow__::__RooEffHistProd, _pdfGenCode), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_2317, Reflex::Literal("_maxEff"), OffsetOf(__shadow__::__RooEffHistProd, _maxEff), ::Reflex::PRIVATE)
  .AddDataMember(type_3112, Reflex::Literal("_levels"), OffsetOf(__shadow__::__RooEffHistProd, _levels), ::Reflex::PRIVATE)
  .AddDataMember(type_3364, Reflex::Literal("_pdfObs"), OffsetOf(__shadow__::__RooEffHistProd, _pdfObs), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_27808, Reflex::Literal("_pdfNormSet"), OffsetOf(__shadow__::__RooEffHistProd, _pdfNormSet), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_27808, Reflex::Literal("_fixedNormSet"), OffsetOf(__shadow__::__RooEffHistProd, _fixedNormSet), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_2216, Reflex::Literal("_cacheMgr"), OffsetOf(__shadow__::__RooEffHistProd, _cacheMgr), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class RooEffHistProd -------------------
void __RooEffHistProd_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9895), Reflex::Literal("forceAnalyticalInt"), method_10358, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_10359, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27804, type_27806, type_27807, type_27808, type_668), Reflex::Literal("genContext"), method_10360, 0, "vars;prototype;auxProto;verbose", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27806, type_27811, type_668), Reflex::Literal("getGenerator"), method_10361, 0, "dv;gv;si", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("initGenerator"), method_10362, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("generateEvent"), method_10363, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_10364, 0, "allVars;analVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_10365, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27808, type_668), Reflex::Literal("selectNormalization"), method_10366, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12441), Reflex::Literal("extendMode"), method_10367, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27808), Reflex::Literal("expectedEvents"), method_10368, 0, "nset", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27808), Reflex::Literal("getValV"), method_10369, 0, "set=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28050), Reflex::Literal("pdf"), method_10370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28158), Reflex::Literal("efficiency"), method_10371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27808), Reflex::Literal("observables"), method_10372, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27954, type_27808, type_4138), Reflex::Literal("getIntegralBins"), method_10373, 0, "iset;rangeName=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_10380, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_10381, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10382, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10383, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_10384, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_10385, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_10386, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_10387, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_10388, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10389, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_10390, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10391, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooAbsGaussModelEfficiency -------------------------------
static  void operator_10503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooAbsGaussModelEfficiency*)o)->operator=)(*(const ::RooAbsGaussModelEfficiency*)arg[0]);
  else   (((::RooAbsGaussModelEfficiency*)o)->operator=)(*(const ::RooAbsGaussModelEfficiency*)arg[0]);
}

static void destructor_10507(void*, void * o, const std::vector<void*>&, void *) {
(((::RooAbsGaussModelEfficiency*)o)->::RooAbsGaussModelEfficiency::~RooAbsGaussModelEfficiency)();
}
static  void method_10508( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::complex<double>)((((const ::RooAbsGaussModelEfficiency*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]));
  else   (((const ::RooAbsGaussModelEfficiency*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]);
}

static  void method_10509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooAbsGaussModelEfficiency*)o)->Class)());
  else   (((::RooAbsGaussModelEfficiency*)o)->Class)();
}

static  void method_10510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooAbsGaussModelEfficiency*)o)->Class_Name)());
  else   (((::RooAbsGaussModelEfficiency*)o)->Class_Name)();
}

static  void method_10511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooAbsGaussModelEfficiency*)o)->Class_Version)());
  else   (((::RooAbsGaussModelEfficiency*)o)->Class_Version)();
}

static  void method_10512( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooAbsGaussModelEfficiency*)o)->Dictionary)();
}

static  void method_10513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooAbsGaussModelEfficiency*)o)->IsA)());
  else   (((const ::RooAbsGaussModelEfficiency*)o)->IsA)();
}

static  void method_10514( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooAbsGaussModelEfficiency*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10515( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooAbsGaussModelEfficiency*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooAbsGaussModelEfficiency*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooAbsGaussModelEfficiency*)o)->DeclFileName)());
  else   (((::RooAbsGaussModelEfficiency*)o)->DeclFileName)();
}

static  void method_10518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooAbsGaussModelEfficiency*)o)->ImplFileLine)());
  else   (((::RooAbsGaussModelEfficiency*)o)->ImplFileLine)();
}

static  void method_10519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooAbsGaussModelEfficiency*)o)->ImplFileName)());
  else   (((::RooAbsGaussModelEfficiency*)o)->ImplFileName)();
}

static  void method_10520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooAbsGaussModelEfficiency*)o)->DeclFileLine)());
  else   (((::RooAbsGaussModelEfficiency*)o)->DeclFileLine)();
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooAbsGaussModelEfficiency -------------------------------
void __RooAbsGaussModelEfficiency_db_datamem(Reflex::Class*);
void __RooAbsGaussModelEfficiency_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooAbsGaussModelEfficiency_datamem_bld(&__RooAbsGaussModelEfficiency_db_datamem);
Reflex::GenreflexMemberBuilder __RooAbsGaussModelEfficiency_funcmem_bld(&__RooAbsGaussModelEfficiency_db_funcmem);
void __RooAbsGaussModelEfficiency_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooAbsGaussModelEfficiency"), typeid(::RooAbsGaussModelEfficiency), sizeof(::RooAbsGaussModelEfficiency), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooAbsGaussModelEfficiency::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28649, type_28741), Reflex::Literal("operator="), operator_10503, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooAbsGaussModelEfficiency"), destructor_10507, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__RooAbsGaussModelEfficiency_funcmem_bld);
}

//------Delayed data member builder for class RooAbsGaussModelEfficiency -------------------
void __RooAbsGaussModelEfficiency_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RooAbsGaussModelEfficiency -------------------
void __RooAbsGaussModelEfficiency_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3638, type_2317, type_2317, type_2317, type_2317, type_22832), Reflex::Literal("productAnalyticalIntegral"), method_10508, 0, "umin;umax;scale;offset;z", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_10509, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_10510, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10511, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10512, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_10513, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_10514, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_10515, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_10516, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_10517, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10518, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_10519, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10520, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooGeneralisedSmearingBase<RooAbsReal> -------------------------------
static void constructor_10546( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>();
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>();
}

static void constructor_10547( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_10548( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_10549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->operator=)(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0]);
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->operator=)(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0]);
}

static  void method_10550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->clone)((const char*)arg[0]);
}

static void destructor_10551(void*, void * o, const std::vector<void*>&, void *) {
(((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->::RooGeneralisedSmearingBase<RooAbsReal>::~RooGeneralisedSmearingBase)();
}
static  void method_10552( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)((::RooRealVar*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1],
      (const ::RooArgSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1],
      (const ::RooArgSet*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_10553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->evaluate)());
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->evaluate)();
}

static  void method_10554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->convIntConfig)();
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->convIntConfig)();
}

static  void method_10555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->convIntConfig)();
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->convIntConfig)();
}

static  void method_10556( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->clearConvolutionWindow)();
}

static  void method_10557( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setConvolutionWindow)(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setConvolutionWindow)(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::Double_t*)arg[2]);
  }
}

static  void method_10558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_10559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_10561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_10562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getMax)(*(::Int_t*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getMax)(*(::Int_t*)arg[0]);
}

static  void method_10583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class)();
}

static  void method_10584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class_Name)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class_Name)();
}

static  void method_10585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class_Version)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class_Version)();
}

static  void method_10586( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Dictionary)();
}

static  void method_10587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->IsA)());
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->IsA)();
}

static  void method_10588( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10589( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10590( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->DeclFileName)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->DeclFileName)();
}

static  void method_10592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ImplFileLine)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ImplFileLine)();
}

static  void method_10593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ImplFileName)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ImplFileName)();
}

static  void method_10594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->DeclFileLine)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->DeclFileLine)();
}

static void method_newdel_1675( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooGeneralisedSmearingBase<RooAbsReal> -------------------------------
void __RooGeneralisedSmearingBase_RooAbsReal__db_datamem(Reflex::Class*);
void __RooGeneralisedSmearingBase_RooAbsReal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooGeneralisedSmearingBase_RooAbsReal__datamem_bld(&__RooGeneralisedSmearingBase_RooAbsReal__db_datamem);
Reflex::GenreflexMemberBuilder __RooGeneralisedSmearingBase_RooAbsReal__funcmem_bld(&__RooGeneralisedSmearingBase_RooAbsReal__db_funcmem);
void __RooGeneralisedSmearingBase_RooAbsReal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooGeneralisedSmearingBase<RooAbsReal>"), typeid(::RooGeneralisedSmearingBase<RooAbsReal>), sizeof(::RooGeneralisedSmearingBase<RooAbsReal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooGeneralisedSmearingBase<RooAbsReal>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooGeneralisedSmearingBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_10546, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_27793, type_27793), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_10547, 0, "name;title;k;pdf;resmodel", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28742, type_4138), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_10548, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooGeneralisedSmearingBase"), destructor_10551, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1675, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooGeneralisedSmearingBase_RooAbsReal__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooGeneralisedSmearingBase_RooAbsReal__funcmem_bld);
}

//------Delayed data member builder for class RooGeneralisedSmearingBase<RooAbsReal> -------------------
void __RooGeneralisedSmearingBase_RooAbsReal__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_668, Reflex::Literal("_init"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _init), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_2970, Reflex::Literal("_convIntConfig"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _convIntConfig), ::Reflex::PROTECTED)
  .AddDataMember(type_28656, Reflex::Literal("_integrator"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integrator), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_28657, Reflex::Literal("_integrand"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integrand), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1249, Reflex::Literal("_origVar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _origVar), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_origPdf"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _origPdf), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_origModel"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _origModel), ::Reflex::PROTECTED)
  .AddDataMember(type_28158, Reflex::Literal("_cloneVar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _cloneVar), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_28158, Reflex::Literal("_clonePdf"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _clonePdf), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_28158, Reflex::Literal("_cloneModel"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _cloneModel), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_3360, Reflex::Literal("_integvarset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integvarset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3358, Reflex::Literal("_integralset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integralset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3356, Reflex::Literal("_integrandset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integrandset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3354, Reflex::Literal("_integratorset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integratorset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2786, Reflex::Literal("_binning"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binning), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_binnedvar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedvar), ::Reflex::PROTECTED)
  .AddDataMember(type_22942, Reflex::Literal("_binnedvarClone"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedvarClone), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1126, Reflex::Literal("_binnedcats"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedcats), ::Reflex::PROTECTED)
  .AddDataMember(type_3108, Reflex::Literal("_binnedcache"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedcache), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3107, Reflex::Literal("_binnedcacheLastVal"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedcacheLastVal), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_667, Reflex::Literal("_preferBinnedIntegrals"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _preferBinnedIntegrals), ::Reflex::PROTECTED)
  .AddDataMember(type_668, Reflex::Literal("_useWindow"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _useWindow), ::Reflex::PROTECTED)
  .AddDataMember(type_2317, Reflex::Literal("_windowScale"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _windowScale), ::Reflex::PROTECTED)
  .AddDataMember(type_646, Reflex::Literal("_windowParam"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _windowParam), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooGeneralisedSmearingBase<RooAbsReal> -------------------
void __RooGeneralisedSmearingBase_RooAbsReal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28743, type_28742), Reflex::Literal("operator="), operator_10549, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_10550, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_22942, type_4138, type_27808, type_667), Reflex::Literal("setBinnedCache"), method_10552, 0, "var=0;binningName=0;binnedcats=0;preferBinnedIntegrals=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_10553, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28660), Reflex::Literal("convIntConfig"), method_10554, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28661), Reflex::Literal("convIntConfig"), method_10555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clearConvolutionWindow"), method_10556, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27793, type_27793, type_2317), Reflex::Literal("setConvolutionWindow"), method_10557, 0, "centerParam;widthParam;widthScaleFactor=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_10558, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_10559, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9895), Reflex::Literal("forceAnalyticalInt"), method_10560, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27806), Reflex::Literal("getMaxVal"), method_10561, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("getMax"), method_10562, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_10583, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_10584, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10585, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10586, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_10587, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_10588, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_10589, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_10590, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_10591, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10592, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_10593, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10594, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TagEfficiencyWeightNoCat -------------------------------
static  void operator_10599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TagEfficiencyWeightNoCat*)o)->operator=)(*(const ::TagEfficiencyWeightNoCat*)arg[0]);
  else   (((::TagEfficiencyWeightNoCat*)o)->operator=)(*(const ::TagEfficiencyWeightNoCat*)arg[0]);
}

static void constructor_10600( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeightNoCat();
  else ::new(mem) ::TagEfficiencyWeightNoCat();
}

static void constructor_10601( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeightNoCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::TagEfficiencyWeightNoCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_10602( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeightNoCat(*(const ::TagEfficiencyWeightNoCat*)arg[0]);
  else ::new(mem) ::TagEfficiencyWeightNoCat(*(const ::TagEfficiencyWeightNoCat*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeightNoCat(*(const ::TagEfficiencyWeightNoCat*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::TagEfficiencyWeightNoCat(*(const ::TagEfficiencyWeightNoCat*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TagEfficiencyWeightNoCat*)o)->clone)((const char*)arg[0]));
  else   (((const ::TagEfficiencyWeightNoCat*)o)->clone)((const char*)arg[0]);
}

static void destructor_10604(void*, void * o, const std::vector<void*>&, void *) {
(((::TagEfficiencyWeightNoCat*)o)->::TagEfficiencyWeightNoCat::~TagEfficiencyWeightNoCat)();
}
static  void method_10606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeightNoCat*)o)->Class)());
  else   (((::TagEfficiencyWeightNoCat*)o)->Class)();
}

static  void method_10607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeightNoCat*)o)->Class_Name)());
  else   (((::TagEfficiencyWeightNoCat*)o)->Class_Name)();
}

static  void method_10608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TagEfficiencyWeightNoCat*)o)->Class_Version)());
  else   (((::TagEfficiencyWeightNoCat*)o)->Class_Version)();
}

static  void method_10609( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TagEfficiencyWeightNoCat*)o)->Dictionary)();
}

static  void method_10610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TagEfficiencyWeightNoCat*)o)->IsA)());
  else   (((const ::TagEfficiencyWeightNoCat*)o)->IsA)();
}

static  void method_10611( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeightNoCat*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10612( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeightNoCat*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10613( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeightNoCat*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeightNoCat*)o)->DeclFileName)());
  else   (((::TagEfficiencyWeightNoCat*)o)->DeclFileName)();
}

static  void method_10615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TagEfficiencyWeightNoCat*)o)->ImplFileLine)());
  else   (((::TagEfficiencyWeightNoCat*)o)->ImplFileLine)();
}

static  void method_10616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeightNoCat*)o)->ImplFileName)());
  else   (((::TagEfficiencyWeightNoCat*)o)->ImplFileName)();
}

static  void method_10617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TagEfficiencyWeightNoCat*)o)->DeclFileLine)());
  else   (((::TagEfficiencyWeightNoCat*)o)->DeclFileLine)();
}

static void method_newdel_1679( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagEfficiencyWeightNoCat -------------------------------
void __TagEfficiencyWeightNoCat_db_datamem(Reflex::Class*);
void __TagEfficiencyWeightNoCat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TagEfficiencyWeightNoCat_datamem_bld(&__TagEfficiencyWeightNoCat_db_datamem);
Reflex::GenreflexMemberBuilder __TagEfficiencyWeightNoCat_funcmem_bld(&__TagEfficiencyWeightNoCat_db_funcmem);
void __TagEfficiencyWeightNoCat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TagEfficiencyWeightNoCat"), typeid(::TagEfficiencyWeightNoCat), sizeof(::TagEfficiencyWeightNoCat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TagEfficiencyWeightNoCat::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28744, type_28745), Reflex::Literal("operator="), operator_10599, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TagEfficiencyWeightNoCat"), constructor_10600, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793), Reflex::Literal("TagEfficiencyWeightNoCat"), constructor_10601, 0, "name;title;_tag;_eff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28745, type_4138), Reflex::Literal("TagEfficiencyWeightNoCat"), constructor_10602, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagEfficiencyWeightNoCat"), destructor_10604, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1679, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TagEfficiencyWeightNoCat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TagEfficiencyWeightNoCat_funcmem_bld);
}

//------Delayed data member builder for class TagEfficiencyWeightNoCat -------------------
void __TagEfficiencyWeightNoCat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("tag"), OffsetOf(__shadow__::__TagEfficiencyWeightNoCat, tag), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("eff"), OffsetOf(__shadow__::__TagEfficiencyWeightNoCat, eff), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TagEfficiencyWeightNoCat -------------------
void __TagEfficiencyWeightNoCat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_10603, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_10606, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_10607, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10608, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10609, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_10610, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_10611, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_10612, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_10613, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_10614, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10615, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_10616, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10617, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class FinalStateChargePdf -------------------------------
static  void operator_11099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::FinalStateChargePdf*)o)->operator=)(*(const ::FinalStateChargePdf*)arg[0]);
  else   (((::FinalStateChargePdf*)o)->operator=)(*(const ::FinalStateChargePdf*)arg[0]);
}

static void constructor_11100( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::FinalStateChargePdf();
  else ::new(mem) ::FinalStateChargePdf();
}

static void constructor_11101( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::FinalStateChargePdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::FinalStateChargePdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_11102( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::FinalStateChargePdf(*(const ::FinalStateChargePdf*)arg[0]);
  else ::new(mem) ::FinalStateChargePdf(*(const ::FinalStateChargePdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::FinalStateChargePdf(*(const ::FinalStateChargePdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::FinalStateChargePdf(*(const ::FinalStateChargePdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FinalStateChargePdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::FinalStateChargePdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_11104(void*, void * o, const std::vector<void*>&, void *) {
(((::FinalStateChargePdf*)o)->::FinalStateChargePdf::~FinalStateChargePdf)();
}
static  void method_11105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::FinalStateChargePdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::FinalStateChargePdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::FinalStateChargePdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::FinalStateChargePdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_11106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::FinalStateChargePdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::FinalStateChargePdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::FinalStateChargePdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::FinalStateChargePdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FinalStateChargePdf*)o)->Class)());
  else   (((::FinalStateChargePdf*)o)->Class)();
}

static  void method_11110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FinalStateChargePdf*)o)->Class_Name)());
  else   (((::FinalStateChargePdf*)o)->Class_Name)();
}

static  void method_11111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::FinalStateChargePdf*)o)->Class_Version)());
  else   (((::FinalStateChargePdf*)o)->Class_Version)();
}

static  void method_11112( void*, void* o, const std::vector<void*>&, void*)
{
  (((::FinalStateChargePdf*)o)->Dictionary)();
}

static  void method_11113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FinalStateChargePdf*)o)->IsA)());
  else   (((const ::FinalStateChargePdf*)o)->IsA)();
}

static  void method_11114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FinalStateChargePdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11115( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FinalStateChargePdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FinalStateChargePdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FinalStateChargePdf*)o)->DeclFileName)());
  else   (((::FinalStateChargePdf*)o)->DeclFileName)();
}

static  void method_11118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FinalStateChargePdf*)o)->ImplFileLine)());
  else   (((::FinalStateChargePdf*)o)->ImplFileLine)();
}

static  void method_11119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FinalStateChargePdf*)o)->ImplFileName)());
  else   (((::FinalStateChargePdf*)o)->ImplFileName)();
}

static  void method_11120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FinalStateChargePdf*)o)->DeclFileLine)());
  else   (((::FinalStateChargePdf*)o)->DeclFileLine)();
}

static void method_newdel_1744( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FinalStateChargePdf -------------------------------
void __FinalStateChargePdf_db_datamem(Reflex::Class*);
void __FinalStateChargePdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __FinalStateChargePdf_datamem_bld(&__FinalStateChargePdf_db_datamem);
Reflex::GenreflexMemberBuilder __FinalStateChargePdf_funcmem_bld(&__FinalStateChargePdf_db_funcmem);
void __FinalStateChargePdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("FinalStateChargePdf"), typeid(::FinalStateChargePdf), sizeof(::FinalStateChargePdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::FinalStateChargePdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::FinalStateChargePdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31095, type_31096), Reflex::Literal("operator="), operator_11099, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FinalStateChargePdf"), constructor_11100, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27792, type_27793), Reflex::Literal("FinalStateChargePdf"), constructor_11101, 0, "name;title;qf;asymm", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31096, type_4138), Reflex::Literal("FinalStateChargePdf"), constructor_11102, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FinalStateChargePdf"), destructor_11104, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1744, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__FinalStateChargePdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__FinalStateChargePdf_funcmem_bld);
}

//------Delayed data member builder for class FinalStateChargePdf -------------------
void __FinalStateChargePdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("m_qf"), OffsetOf(__shadow__::__FinalStateChargePdf, m_qf), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("m_asymm"), OffsetOf(__shadow__::__FinalStateChargePdf, m_asymm), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class FinalStateChargePdf -------------------
void __FinalStateChargePdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_11103, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_11105, 0, "allVars;anaIntVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_11106, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11109, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11110, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11111, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11112, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11113, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11114, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11115, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11116, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11117, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11118, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11119, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11120, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TaggingCat -------------------------------
static  void operator_11442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TaggingCat*)o)->operator=)(*(const ::TaggingCat*)arg[0]);
  else   (((::TaggingCat*)o)->operator=)(*(const ::TaggingCat*)arg[0]);
}

static void constructor_11443( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TaggingCat();
  else ::new(mem) ::TaggingCat();
}

static void constructor_11444( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TaggingCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooArgList*)arg[4]);
  else ::new(mem) ::TaggingCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooArgList*)arg[4]);
}

static void constructor_11445( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TaggingCat(*(const ::TaggingCat*)arg[0]);
  else ::new(mem) ::TaggingCat(*(const ::TaggingCat*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TaggingCat(*(const ::TaggingCat*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::TaggingCat(*(const ::TaggingCat*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TaggingCat*)o)->clone)((const char*)arg[0]));
  else   (((const ::TaggingCat*)o)->clone)((const char*)arg[0]);
}

static void destructor_11447(void*, void * o, const std::vector<void*>&, void *) {
(((::TaggingCat*)o)->::TaggingCat::~TaggingCat)();
}
static  void method_11449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TaggingCat*)o)->Class)());
  else   (((::TaggingCat*)o)->Class)();
}

static  void method_11450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TaggingCat*)o)->Class_Name)());
  else   (((::TaggingCat*)o)->Class_Name)();
}

static  void method_11451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TaggingCat*)o)->Class_Version)());
  else   (((::TaggingCat*)o)->Class_Version)();
}

static  void method_11452( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TaggingCat*)o)->Dictionary)();
}

static  void method_11453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TaggingCat*)o)->IsA)());
  else   (((const ::TaggingCat*)o)->IsA)();
}

static  void method_11454( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TaggingCat*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11455( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TaggingCat*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11456( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TaggingCat*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TaggingCat*)o)->DeclFileName)());
  else   (((::TaggingCat*)o)->DeclFileName)();
}

static  void method_11458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TaggingCat*)o)->ImplFileLine)());
  else   (((::TaggingCat*)o)->ImplFileLine)();
}

static  void method_11459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TaggingCat*)o)->ImplFileName)());
  else   (((::TaggingCat*)o)->ImplFileName)();
}

static  void method_11460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TaggingCat*)o)->DeclFileLine)());
  else   (((::TaggingCat*)o)->DeclFileLine)();
}

static void method_newdel_1831( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TaggingCat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TaggingCat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TaggingCat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TaggingCat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TaggingCat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::TaggingCat,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::TaggingCat,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TaggingCat,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TaggingCat,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::TaggingCat,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TaggingCat -------------------------------
void __TaggingCat_db_datamem(Reflex::Class*);
void __TaggingCat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TaggingCat_datamem_bld(&__TaggingCat_db_datamem);
Reflex::GenreflexMemberBuilder __TaggingCat_funcmem_bld(&__TaggingCat_db_funcmem);
void __TaggingCat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TaggingCat"), typeid(::TaggingCat), sizeof(::TaggingCat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TaggingCat::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::TaggingCat, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31129, type_31130), Reflex::Literal("operator="), operator_11442, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TaggingCat"), constructor_11443, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27792, type_27792, type_28642), Reflex::Literal("TaggingCat"), constructor_11444, 0, "name;title;_qt;_cat;_vars", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31130, type_4138), Reflex::Literal("TaggingCat"), constructor_11445, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TaggingCat"), destructor_11447, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1831, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TaggingCat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TaggingCat_funcmem_bld);
}

//------Delayed data member builder for class TaggingCat -------------------
void __TaggingCat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("qt"), OffsetOf(__shadow__::__TaggingCat, qt), ::Reflex::PROTECTED)
  .AddDataMember(type_1173, Reflex::Literal("cat"), OffsetOf(__shadow__::__TaggingCat, cat), ::Reflex::PROTECTED)
  .AddDataMember(type_646, Reflex::Literal("catlist"), OffsetOf(__shadow__::__TaggingCat, catlist), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TaggingCat -------------------
void __TaggingCat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_11446, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11449, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11450, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11451, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11452, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11453, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11454, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11455, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11456, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11457, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11458, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11459, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11460, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RangeAcceptance -------------------------------
static  void operator_11517( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RangeAcceptance*)o)->operator=)(*(const ::RangeAcceptance*)arg[0]);
  else   (((::RangeAcceptance*)o)->operator=)(*(const ::RangeAcceptance*)arg[0]);
}

static void constructor_11518( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RangeAcceptance();
  else ::new(mem) ::RangeAcceptance();
}

static void constructor_11519( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RangeAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::RangeAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
}

static void constructor_11520( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RangeAcceptance(*(const ::RangeAcceptance*)arg[0]);
  else ::new(mem) ::RangeAcceptance(*(const ::RangeAcceptance*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RangeAcceptance(*(const ::RangeAcceptance*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RangeAcceptance(*(const ::RangeAcceptance*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RangeAcceptance*)o)->clone)((const char*)arg[0]));
  else   (((const ::RangeAcceptance*)o)->clone)((const char*)arg[0]);
}

static void destructor_11522(void*, void * o, const std::vector<void*>&, void *) {
(((::RangeAcceptance*)o)->::RangeAcceptance::~RangeAcceptance)();
}
static  void method_11524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RangeAcceptance*)o)->Class)());
  else   (((::RangeAcceptance*)o)->Class)();
}

static  void method_11525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RangeAcceptance*)o)->Class_Name)());
  else   (((::RangeAcceptance*)o)->Class_Name)();
}

static  void method_11526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RangeAcceptance*)o)->Class_Version)());
  else   (((::RangeAcceptance*)o)->Class_Version)();
}

static  void method_11527( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RangeAcceptance*)o)->Dictionary)();
}

static  void method_11528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RangeAcceptance*)o)->IsA)());
  else   (((const ::RangeAcceptance*)o)->IsA)();
}

static  void method_11529( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RangeAcceptance*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11530( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RangeAcceptance*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11531( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RangeAcceptance*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RangeAcceptance*)o)->DeclFileName)());
  else   (((::RangeAcceptance*)o)->DeclFileName)();
}

static  void method_11533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RangeAcceptance*)o)->ImplFileLine)());
  else   (((::RangeAcceptance*)o)->ImplFileLine)();
}

static  void method_11534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RangeAcceptance*)o)->ImplFileName)());
  else   (((::RangeAcceptance*)o)->ImplFileName)();
}

static  void method_11535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RangeAcceptance*)o)->DeclFileLine)());
  else   (((::RangeAcceptance*)o)->DeclFileLine)();
}

static void method_newdel_1880( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RangeAcceptance,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RangeAcceptance,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RangeAcceptance,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RangeAcceptance,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RangeAcceptance,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RangeAcceptance -------------------------------
void __RangeAcceptance_db_datamem(Reflex::Class*);
void __RangeAcceptance_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RangeAcceptance_datamem_bld(&__RangeAcceptance_db_datamem);
Reflex::GenreflexMemberBuilder __RangeAcceptance_funcmem_bld(&__RangeAcceptance_db_funcmem);
void __RangeAcceptance_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RangeAcceptance"), typeid(::RangeAcceptance), sizeof(::RangeAcceptance), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RangeAcceptance::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RangeAcceptance, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31137, type_31138), Reflex::Literal("operator="), operator_11517, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RangeAcceptance"), constructor_11518, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_694, type_694), Reflex::Literal("RangeAcceptance"), constructor_11519, 0, "name;title;_x;_xmin;_xmax", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31138, type_4138), Reflex::Literal("RangeAcceptance"), constructor_11520, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RangeAcceptance"), destructor_11522, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1880, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RangeAcceptance_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RangeAcceptance_funcmem_bld);
}

//------Delayed data member builder for class RangeAcceptance -------------------
void __RangeAcceptance_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RangeAcceptance, x), ::Reflex::PROTECTED)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RangeAcceptance, xmin), ::Reflex::PROTECTED)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RangeAcceptance, xmax), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RangeAcceptance -------------------
void __RangeAcceptance_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_11521, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11524, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11525, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11526, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11527, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11528, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11529, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11530, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11531, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11532, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11533, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11534, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11535, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PowLawAcceptance -------------------------------
static void constructor_11591( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance();
  else ::new(mem) ::PowLawAcceptance();
}

static void constructor_11592( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 7 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
  else ::new(mem) ::PowLawAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      (::RooAbsReal*)arg[7]);
  else ::new(mem) ::PowLawAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      (::RooAbsReal*)arg[7]);
  }
}

static void constructor_11593( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0]);
  else ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0],
      (const char*)arg[1]);
  }
}

static void constructor_11594( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0],
      (const char*)arg[1],
      (::RooAbsReal*)arg[2]);
  else ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0],
      (const char*)arg[1],
      (::RooAbsReal*)arg[2]);
}

static void destructor_11595(void*, void * o, const std::vector<void*>&, void *) {
(((::PowLawAcceptance*)o)->::PowLawAcceptance::~PowLawAcceptance)();
}
static  void method_11596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PowLawAcceptance*)o)->clone)((const char*)arg[0]));
  else   (((const ::PowLawAcceptance*)o)->clone)((const char*)arg[0]);
}

static  void operator_11597( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PowLawAcceptance*)o)->operator=)(*(const ::PowLawAcceptance*)arg[0]);
  else   (((::PowLawAcceptance*)o)->operator=)(*(const ::PowLawAcceptance*)arg[0]);
}

static  void method_11599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PowLawAcceptance*)o)->Class)());
  else   (((::PowLawAcceptance*)o)->Class)();
}

static  void method_11600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PowLawAcceptance*)o)->Class_Name)());
  else   (((::PowLawAcceptance*)o)->Class_Name)();
}

static  void method_11601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::PowLawAcceptance*)o)->Class_Version)());
  else   (((::PowLawAcceptance*)o)->Class_Version)();
}

static  void method_11602( void*, void* o, const std::vector<void*>&, void*)
{
  (((::PowLawAcceptance*)o)->Dictionary)();
}

static  void method_11603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PowLawAcceptance*)o)->IsA)());
  else   (((const ::PowLawAcceptance*)o)->IsA)();
}

static  void method_11604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PowLawAcceptance*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11605( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PowLawAcceptance*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11606( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PowLawAcceptance*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PowLawAcceptance*)o)->DeclFileName)());
  else   (((::PowLawAcceptance*)o)->DeclFileName)();
}

static  void method_11608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::PowLawAcceptance*)o)->ImplFileLine)());
  else   (((::PowLawAcceptance*)o)->ImplFileLine)();
}

static  void method_11609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PowLawAcceptance*)o)->ImplFileName)());
  else   (((::PowLawAcceptance*)o)->ImplFileName)();
}

static  void method_11610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::PowLawAcceptance*)o)->DeclFileLine)());
  else   (((::PowLawAcceptance*)o)->DeclFileLine)();
}

static void method_newdel_1909( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x54( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::PowLawAcceptance,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::PowLawAcceptance,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::PowLawAcceptance,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::PowLawAcceptance,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::PowLawAcceptance,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PowLawAcceptance -------------------------------
void __PowLawAcceptance_db_datamem(Reflex::Class*);
void __PowLawAcceptance_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PowLawAcceptance_datamem_bld(&__PowLawAcceptance_db_datamem);
Reflex::GenreflexMemberBuilder __PowLawAcceptance_funcmem_bld(&__PowLawAcceptance_db_funcmem);
void __PowLawAcceptance_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PowLawAcceptance"), typeid(::PowLawAcceptance), sizeof(::PowLawAcceptance), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::PowLawAcceptance::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::PowLawAcceptance, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PowLawAcceptance"), constructor_11591, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_27793, type_27793, type_28158), Reflex::Literal("PowLawAcceptance"), constructor_11592, 0, "name;title;turnon;time;__offset;exponent;beta;correction=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31143, type_4138), Reflex::Literal("PowLawAcceptance"), constructor_11593, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31143, type_4138, type_28158), Reflex::Literal("PowLawAcceptance"), constructor_11594, 0, "other;name;correction", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PowLawAcceptance"), destructor_11595, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1909, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x54, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PowLawAcceptance_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PowLawAcceptance_funcmem_bld);
}

//------Delayed data member builder for class PowLawAcceptance -------------------
void __PowLawAcceptance_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("_turnon"), OffsetOf(__shadow__::__PowLawAcceptance, _turnon), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_time"), OffsetOf(__shadow__::__PowLawAcceptance, _time), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_offset"), OffsetOf(__shadow__::__PowLawAcceptance, _offset), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_exponent"), OffsetOf(__shadow__::__PowLawAcceptance, _exponent), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_beta"), OffsetOf(__shadow__::__PowLawAcceptance, _beta), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_correction"), OffsetOf(__shadow__::__PowLawAcceptance, _correction), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PowLawAcceptance -------------------
void __PowLawAcceptance_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_11596, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31144, type_31143), Reflex::Literal("operator="), operator_11597, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11599, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11600, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11601, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11602, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11603, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11604, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11605, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11606, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11607, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11608, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11609, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11610, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class MistagCalibration -------------------------------
static  void operator_11655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MistagCalibration*)o)->operator=)(*(const ::MistagCalibration*)arg[0]);
  else   (((::MistagCalibration*)o)->operator=)(*(const ::MistagCalibration*)arg[0]);
}

static void constructor_11656( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration();
  else ::new(mem) ::MistagCalibration();
}

static void constructor_11657( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_11658( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_11659( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooArgList*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooArgList*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_11660( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration(*(const ::MistagCalibration*)arg[0]);
  else ::new(mem) ::MistagCalibration(*(const ::MistagCalibration*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration(*(const ::MistagCalibration*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::MistagCalibration(*(const ::MistagCalibration*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MistagCalibration*)o)->clone)((const char*)arg[0]));
  else   (((const ::MistagCalibration*)o)->clone)((const char*)arg[0]);
}

static void destructor_11662(void*, void * o, const std::vector<void*>&, void *) {
(((::MistagCalibration*)o)->::MistagCalibration::~MistagCalibration)();
}
static  void method_11663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::MistagCalibration*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::MistagCalibration*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_11664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::MistagCalibration*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::MistagCalibration*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_11668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagCalibration*)o)->Class)());
  else   (((::MistagCalibration*)o)->Class)();
}

static  void method_11669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagCalibration*)o)->Class_Name)());
  else   (((::MistagCalibration*)o)->Class_Name)();
}

static  void method_11670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::MistagCalibration*)o)->Class_Version)());
  else   (((::MistagCalibration*)o)->Class_Version)();
}

static  void method_11671( void*, void* o, const std::vector<void*>&, void*)
{
  (((::MistagCalibration*)o)->Dictionary)();
}

static  void method_11672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MistagCalibration*)o)->IsA)());
  else   (((const ::MistagCalibration*)o)->IsA)();
}

static  void method_11673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagCalibration*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11674( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagCalibration*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11675( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagCalibration*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagCalibration*)o)->DeclFileName)());
  else   (((::MistagCalibration*)o)->DeclFileName)();
}

static  void method_11677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MistagCalibration*)o)->ImplFileLine)());
  else   (((::MistagCalibration*)o)->ImplFileLine)();
}

static  void method_11678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagCalibration*)o)->ImplFileName)());
  else   (((::MistagCalibration*)o)->ImplFileName)();
}

static  void method_11679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MistagCalibration*)o)->DeclFileLine)());
  else   (((::MistagCalibration*)o)->DeclFileLine)();
}

static void method_newdel_1927( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x56( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::MistagCalibration,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::MistagCalibration,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::MistagCalibration,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::MistagCalibration,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::MistagCalibration,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MistagCalibration -------------------------------
void __MistagCalibration_db_datamem(Reflex::Class*);
void __MistagCalibration_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MistagCalibration_datamem_bld(&__MistagCalibration_db_datamem);
Reflex::GenreflexMemberBuilder __MistagCalibration_funcmem_bld(&__MistagCalibration_db_funcmem);
void __MistagCalibration_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MistagCalibration"), typeid(::MistagCalibration), sizeof(::MistagCalibration), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::MistagCalibration::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::MistagCalibration, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31145, type_31146), Reflex::Literal("operator="), operator_11655, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MistagCalibration"), constructor_11656, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793), Reflex::Literal("MistagCalibration"), constructor_11657, 0, "name;title;eta;p0;p1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("MistagCalibration"), constructor_11658, 0, "name;title;eta;p0;p1;etaavg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_28642, type_27793), Reflex::Literal("MistagCalibration"), constructor_11659, 0, "name;title;eta;calibcoeffs;etaavg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31146, type_4138), Reflex::Literal("MistagCalibration"), constructor_11660, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MistagCalibration"), destructor_11662, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1927, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x56, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__MistagCalibration_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__MistagCalibration_funcmem_bld);
}

//------Delayed data member builder for class MistagCalibration -------------------
void __MistagCalibration_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("m_eta"), OffsetOf(__shadow__::__MistagCalibration, m_eta), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("m_calibcoeffs"), OffsetOf(__shadow__::__MistagCalibration, m_calibcoeffs), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etaavg"), OffsetOf(__shadow__::__MistagCalibration, m_etaavg), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class MistagCalibration -------------------
void __MistagCalibration_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_11661, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_11663, 0, "allVars;anaIntVars;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_11664, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11668, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11669, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11670, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11671, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11672, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11673, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11674, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11675, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11676, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11677, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11678, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11679, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<double> -------------------------------
static  void operator_11722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<double>*)o)->operator=)(*(const ::SharedArrayImp<double>*)arg[0]);
  else   (((::SharedArrayImp<double>*)o)->operator=)(*(const ::SharedArrayImp<double>*)arg[0]);
}

static void constructor_11723( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<double>();
  else ::new(mem) ::SharedArrayImp<double>();
}

static void constructor_11724( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<double>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<double>(*(unsigned int*)arg[0]);
}

static void constructor_11725( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<double>(*(const ::SharedArrayImp<double>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<double>(*(const ::SharedArrayImp<double>*)arg[0]);
}

static  void method_11726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<double>*)o)->Clone)());
    else     (((const ::SharedArrayImp<double>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<double>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<double>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11727(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<double>*)o)->::SharedArrayImp<double>::~SharedArrayImp)();
}
static  void method_11728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<double>*)o)->refCount)());
  else   (((const ::SharedArrayImp<double>*)o)->refCount)();
}

static  void method_11729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->acquire)());
  else   (((::SharedArrayImp<double>*)o)->acquire)();
}

static  void method_11730( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<double>*)o)->release)();
}

static  void method_11731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<double>*)o)->size)());
  else   (((const ::SharedArrayImp<double>*)o)->size)();
}

static  void operator_11732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<double>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<double>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<double>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<double>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->Class)());
  else   (((::SharedArrayImp<double>*)o)->Class)();
}

static  void method_11735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->Class_Name)());
  else   (((::SharedArrayImp<double>*)o)->Class_Name)();
}

static  void method_11736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<double>*)o)->Class_Version)());
  else   (((::SharedArrayImp<double>*)o)->Class_Version)();
}

static  void method_11737( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<double>*)o)->Dictionary)();
}

static  void method_11738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<double>*)o)->IsA)());
  else   (((const ::SharedArrayImp<double>*)o)->IsA)();
}

static  void method_11739( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<double>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11740( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<double>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11741( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<double>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<double>*)o)->DeclFileName)();
}

static  void method_11743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<double>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<double>*)o)->ImplFileLine)();
}

static  void method_11744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<double>*)o)->ImplFileName)();
}

static  void method_11745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<double>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<double>*)o)->DeclFileLine)();
}

static void method_newdel_1939( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x58( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<double>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<double> -------------------------------
void __SharedArrayImp_double__db_datamem(Reflex::Class*);
void __SharedArrayImp_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_double__datamem_bld(&__SharedArrayImp_double__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_double__funcmem_bld(&__SharedArrayImp_double__db_funcmem);
void __SharedArrayImp_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<double>"), typeid(::SharedArrayImp<double>), sizeof(::SharedArrayImp<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<double>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31149, type_31150), Reflex::Literal("operator="), operator_11722, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11723, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11724, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31150), Reflex::Literal("SharedArrayImp"), constructor_11725, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11727, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1939, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x58, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_double__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<double> -------------------
void __SharedArrayImp_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_double_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3092, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_double_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<double> -------------------
void __SharedArrayImp_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31151, type_4138), Reflex::Literal("Clone"), method_11726, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31151), Reflex::Literal("acquire"), method_11729, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11730, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17968, type_211), Reflex::Literal("operator[]"), operator_11732, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17966, type_211), Reflex::Literal("operator[]"), operator_11733, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11734, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11735, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11736, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11737, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11738, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11739, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11740, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11741, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11742, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11743, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11744, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11745, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<float> -------------------------------
static  void operator_11749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<float>*)o)->operator=)(*(const ::SharedArrayImp<float>*)arg[0]);
  else   (((::SharedArrayImp<float>*)o)->operator=)(*(const ::SharedArrayImp<float>*)arg[0]);
}

static void constructor_11750( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<float>();
  else ::new(mem) ::SharedArrayImp<float>();
}

static void constructor_11751( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<float>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<float>(*(unsigned int*)arg[0]);
}

static void constructor_11752( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<float>(*(const ::SharedArrayImp<float>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<float>(*(const ::SharedArrayImp<float>*)arg[0]);
}

static  void method_11753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<float>*)o)->Clone)());
    else     (((const ::SharedArrayImp<float>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<float>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<float>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11754(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<float>*)o)->::SharedArrayImp<float>::~SharedArrayImp)();
}
static  void method_11755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<float>*)o)->refCount)());
  else   (((const ::SharedArrayImp<float>*)o)->refCount)();
}

static  void method_11756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->acquire)());
  else   (((::SharedArrayImp<float>*)o)->acquire)();
}

static  void method_11757( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<float>*)o)->release)();
}

static  void method_11758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<float>*)o)->size)());
  else   (((const ::SharedArrayImp<float>*)o)->size)();
}

static  void operator_11759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<float>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<float>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11760( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<float>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<float>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->Class)());
  else   (((::SharedArrayImp<float>*)o)->Class)();
}

static  void method_11762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->Class_Name)());
  else   (((::SharedArrayImp<float>*)o)->Class_Name)();
}

static  void method_11763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<float>*)o)->Class_Version)());
  else   (((::SharedArrayImp<float>*)o)->Class_Version)();
}

static  void method_11764( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<float>*)o)->Dictionary)();
}

static  void method_11765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<float>*)o)->IsA)());
  else   (((const ::SharedArrayImp<float>*)o)->IsA)();
}

static  void method_11766( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<float>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11767( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<float>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11768( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<float>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<float>*)o)->DeclFileName)();
}

static  void method_11770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<float>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<float>*)o)->ImplFileLine)();
}

static  void method_11771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<float>*)o)->ImplFileName)();
}

static  void method_11772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<float>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<float>*)o)->DeclFileLine)();
}

static void method_newdel_1940( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x60( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<float>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<float> -------------------------------
void __SharedArrayImp_float__db_datamem(Reflex::Class*);
void __SharedArrayImp_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_float__datamem_bld(&__SharedArrayImp_float__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_float__funcmem_bld(&__SharedArrayImp_float__db_funcmem);
void __SharedArrayImp_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<float>"), typeid(::SharedArrayImp<float>), sizeof(::SharedArrayImp<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<float>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31152, type_31153), Reflex::Literal("operator="), operator_11749, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11750, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11751, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31153), Reflex::Literal("SharedArrayImp"), constructor_11752, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11754, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1940, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x60, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_float__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<float> -------------------
void __SharedArrayImp_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_float_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3094, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_float_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<float> -------------------
void __SharedArrayImp_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31154, type_4138), Reflex::Literal("Clone"), method_11753, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31154), Reflex::Literal("acquire"), method_11756, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11757, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11758, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18098, type_211), Reflex::Literal("operator[]"), operator_11759, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18096, type_211), Reflex::Literal("operator[]"), operator_11760, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11761, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11762, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11763, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11764, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11765, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11766, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11767, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11768, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11769, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11770, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11771, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11772, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<long long unsigned int> -------------------------------
static  void operator_11776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned long long>*)o)->operator=)(*(const ::SharedArrayImp<unsigned long long>*)arg[0]);
  else   (((::SharedArrayImp<unsigned long long>*)o)->operator=)(*(const ::SharedArrayImp<unsigned long long>*)arg[0]);
}

static void constructor_11777( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long long>();
  else ::new(mem) ::SharedArrayImp<unsigned long long>();
}

static void constructor_11778( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned long long>(*(unsigned int*)arg[0]);
}

static void constructor_11779( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long long>(*(const ::SharedArrayImp<unsigned long long>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned long long>(*(const ::SharedArrayImp<unsigned long long>*)arg[0]);
}

static  void method_11780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long long>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned long long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned long long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11781(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned long long>*)o)->::SharedArrayImp<unsigned long long>::~SharedArrayImp)();
}
static  void method_11782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned long long>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned long long>*)o)->refCount)();
}

static  void method_11783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->acquire)();
}

static  void method_11784( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->release)();
}

static  void method_11785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned long long>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned long long>*)o)->size)();
}

static  void operator_11786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->Class)();
}

static  void method_11789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->Class_Name)();
}

static  void method_11790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned long long>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->Class_Version)();
}

static  void method_11791( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->Dictionary)();
}

static  void method_11792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long long>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned long long>*)o)->IsA)();
}

static  void method_11793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11795( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->DeclFileName)();
}

static  void method_11797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned long long>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->ImplFileLine)();
}

static  void method_11798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->ImplFileName)();
}

static  void method_11799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned long long>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->DeclFileLine)();
}

static void method_newdel_1941( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x62( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned long long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<long long unsigned int> -------------------------------
void __SharedArrayImp_unsignedslongslong__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedslongslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedslongslong__datamem_bld(&__SharedArrayImp_unsignedslongslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedslongslong__funcmem_bld(&__SharedArrayImp_unsignedslongslong__db_funcmem);
void __SharedArrayImp_unsignedslongslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned long long>"), typeid(::SharedArrayImp<unsigned long long>), sizeof(::SharedArrayImp<unsigned long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned long long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31155, type_31156), Reflex::Literal("operator="), operator_11776, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11777, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11778, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31156), Reflex::Literal("SharedArrayImp"), constructor_11779, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11781, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1941, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x62, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedslongslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedslongslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<long long unsigned int> -------------------
void __SharedArrayImp_unsignedslongslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedslongslong_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3095, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedslongslong_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<long long unsigned int> -------------------
void __SharedArrayImp_unsignedslongslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31157, type_4138), Reflex::Literal("Clone"), method_11780, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31157), Reflex::Literal("acquire"), method_11783, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11784, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18163, type_211), Reflex::Literal("operator[]"), operator_11786, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18161, type_211), Reflex::Literal("operator[]"), operator_11787, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11788, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11789, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11790, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11791, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11792, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11793, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11794, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11795, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11796, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11797, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11798, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11799, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<long unsigned int> -------------------------------
static  void operator_11803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned long>*)o)->operator=)(*(const ::SharedArrayImp<unsigned long>*)arg[0]);
  else   (((::SharedArrayImp<unsigned long>*)o)->operator=)(*(const ::SharedArrayImp<unsigned long>*)arg[0]);
}

static void constructor_11804( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long>();
  else ::new(mem) ::SharedArrayImp<unsigned long>();
}

static void constructor_11805( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned long>(*(unsigned int*)arg[0]);
}

static void constructor_11806( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long>(*(const ::SharedArrayImp<unsigned long>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned long>(*(const ::SharedArrayImp<unsigned long>*)arg[0]);
}

static  void method_11807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11808(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned long>*)o)->::SharedArrayImp<unsigned long>::~SharedArrayImp)();
}
static  void method_11809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned long>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned long>*)o)->refCount)();
}

static  void method_11810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned long>*)o)->acquire)();
}

static  void method_11811( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->release)();
}

static  void method_11812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned long>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned long>*)o)->size)();
}

static  void operator_11813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned long>*)o)->Class)();
}

static  void method_11816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned long>*)o)->Class_Name)();
}

static  void method_11817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned long>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned long>*)o)->Class_Version)();
}

static  void method_11818( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->Dictionary)();
}

static  void method_11819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned long>*)o)->IsA)();
}

static  void method_11820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11821( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned long>*)o)->DeclFileName)();
}

static  void method_11824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned long>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned long>*)o)->ImplFileLine)();
}

static  void method_11825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned long>*)o)->ImplFileName)();
}

static  void method_11826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned long>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned long>*)o)->DeclFileLine)();
}

static void method_newdel_1942( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x64( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<long unsigned int> -------------------------------
void __SharedArrayImp_unsignedslong__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedslong__datamem_bld(&__SharedArrayImp_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedslong__funcmem_bld(&__SharedArrayImp_unsignedslong__db_funcmem);
void __SharedArrayImp_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned long>"), typeid(::SharedArrayImp<unsigned long>), sizeof(::SharedArrayImp<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31158, type_31159), Reflex::Literal("operator="), operator_11803, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11804, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11805, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31159), Reflex::Literal("SharedArrayImp"), constructor_11806, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11808, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1942, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x64, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<long unsigned int> -------------------
void __SharedArrayImp_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedslong_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3096, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedslong_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<long unsigned int> -------------------
void __SharedArrayImp_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31160, type_4138), Reflex::Literal("Clone"), method_11807, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31160), Reflex::Literal("acquire"), method_11810, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11811, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18228, type_211), Reflex::Literal("operator[]"), operator_11813, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18226, type_211), Reflex::Literal("operator[]"), operator_11814, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11815, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11816, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11817, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11818, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11819, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11820, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11821, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11822, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11823, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11824, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11825, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11826, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<unsigned int> -------------------------------
static  void operator_11830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned int>*)o)->operator=)(*(const ::SharedArrayImp<unsigned int>*)arg[0]);
  else   (((::SharedArrayImp<unsigned int>*)o)->operator=)(*(const ::SharedArrayImp<unsigned int>*)arg[0]);
}

static void constructor_11831( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned int>();
  else ::new(mem) ::SharedArrayImp<unsigned int>();
}

static void constructor_11832( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned int>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned int>(*(unsigned int*)arg[0]);
}

static void constructor_11833( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned int>(*(const ::SharedArrayImp<unsigned int>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned int>(*(const ::SharedArrayImp<unsigned int>*)arg[0]);
}

static  void method_11834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned int>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned int>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned int>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned int>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11835(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned int>*)o)->::SharedArrayImp<unsigned int>::~SharedArrayImp)();
}
static  void method_11836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned int>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned int>*)o)->refCount)();
}

static  void method_11837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned int>*)o)->acquire)();
}

static  void method_11838( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->release)();
}

static  void method_11839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned int>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned int>*)o)->size)();
}

static  void operator_11840( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11841( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned int>*)o)->Class)();
}

static  void method_11843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned int>*)o)->Class_Name)();
}

static  void method_11844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned int>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned int>*)o)->Class_Version)();
}

static  void method_11845( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->Dictionary)();
}

static  void method_11846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned int>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned int>*)o)->IsA)();
}

static  void method_11847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11848( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11849( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned int>*)o)->DeclFileName)();
}

static  void method_11851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned int>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned int>*)o)->ImplFileLine)();
}

static  void method_11852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned int>*)o)->ImplFileName)();
}

static  void method_11853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned int>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned int>*)o)->DeclFileLine)();
}

static void method_newdel_1943( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x66( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned int>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<unsigned int> -------------------------------
void __SharedArrayImp_unsignedsint__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedsint__datamem_bld(&__SharedArrayImp_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedsint__funcmem_bld(&__SharedArrayImp_unsignedsint__db_funcmem);
void __SharedArrayImp_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned int>"), typeid(::SharedArrayImp<unsigned int>), sizeof(::SharedArrayImp<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned int>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31161, type_31162), Reflex::Literal("operator="), operator_11830, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11831, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11832, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31162), Reflex::Literal("SharedArrayImp"), constructor_11833, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11835, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1943, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x66, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<unsigned int> -------------------
void __SharedArrayImp_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedsint_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3097, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedsint_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<unsigned int> -------------------
void __SharedArrayImp_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31163, type_4138), Reflex::Literal("Clone"), method_11834, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11836, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31163), Reflex::Literal("acquire"), method_11837, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11838, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18293, type_211), Reflex::Literal("operator[]"), operator_11840, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18291, type_211), Reflex::Literal("operator[]"), operator_11841, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11842, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11843, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11844, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11845, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11846, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11847, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11848, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11849, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11850, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11851, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11852, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11853, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<short unsigned int> -------------------------------
static  void operator_11857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned short>*)o)->operator=)(*(const ::SharedArrayImp<unsigned short>*)arg[0]);
  else   (((::SharedArrayImp<unsigned short>*)o)->operator=)(*(const ::SharedArrayImp<unsigned short>*)arg[0]);
}

static void constructor_11858( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned short>();
  else ::new(mem) ::SharedArrayImp<unsigned short>();
}

static void constructor_11859( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned short>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned short>(*(unsigned int*)arg[0]);
}

static void constructor_11860( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned short>(*(const ::SharedArrayImp<unsigned short>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned short>(*(const ::SharedArrayImp<unsigned short>*)arg[0]);
}

static  void method_11861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned short>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned short>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned short>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned short>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11862(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned short>*)o)->::SharedArrayImp<unsigned short>::~SharedArrayImp)();
}
static  void method_11863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned short>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned short>*)o)->refCount)();
}

static  void method_11864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned short>*)o)->acquire)();
}

static  void method_11865( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->release)();
}

static  void method_11866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned short>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned short>*)o)->size)();
}

static  void operator_11867( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned short>*)o)->Class)();
}

static  void method_11870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned short>*)o)->Class_Name)();
}

static  void method_11871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned short>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned short>*)o)->Class_Version)();
}

static  void method_11872( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->Dictionary)();
}

static  void method_11873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned short>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned short>*)o)->IsA)();
}

static  void method_11874( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11875( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11876( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned short>*)o)->DeclFileName)();
}

static  void method_11878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned short>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned short>*)o)->ImplFileLine)();
}

static  void method_11879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned short>*)o)->ImplFileName)();
}

static  void method_11880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned short>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned short>*)o)->DeclFileLine)();
}

static void method_newdel_1944( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x68( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned short>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<short unsigned int> -------------------------------
void __SharedArrayImp_unsignedsshort__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedsshort__datamem_bld(&__SharedArrayImp_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedsshort__funcmem_bld(&__SharedArrayImp_unsignedsshort__db_funcmem);
void __SharedArrayImp_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned short>"), typeid(::SharedArrayImp<unsigned short>), sizeof(::SharedArrayImp<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned short>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31164, type_31165), Reflex::Literal("operator="), operator_11857, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11858, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11859, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31165), Reflex::Literal("SharedArrayImp"), constructor_11860, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11862, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1944, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x68, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedsshort__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedsshort__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<short unsigned int> -------------------
void __SharedArrayImp_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedsshort_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3098, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedsshort_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<short unsigned int> -------------------
void __SharedArrayImp_unsignedsshort__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31166, type_4138), Reflex::Literal("Clone"), method_11861, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31166), Reflex::Literal("acquire"), method_11864, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11865, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18358, type_211), Reflex::Literal("operator[]"), operator_11867, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18356, type_211), Reflex::Literal("operator[]"), operator_11868, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11869, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11870, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11871, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11872, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11873, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11874, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11875, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11876, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11877, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11878, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11879, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11880, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<unsigned char> -------------------------------
static  void operator_11884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned char>*)o)->operator=)(*(const ::SharedArrayImp<unsigned char>*)arg[0]);
  else   (((::SharedArrayImp<unsigned char>*)o)->operator=)(*(const ::SharedArrayImp<unsigned char>*)arg[0]);
}

static void constructor_11885( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned char>();
  else ::new(mem) ::SharedArrayImp<unsigned char>();
}

static void constructor_11886( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned char>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned char>(*(unsigned int*)arg[0]);
}

static void constructor_11887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned char>(*(const ::SharedArrayImp<unsigned char>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned char>(*(const ::SharedArrayImp<unsigned char>*)arg[0]);
}

static  void method_11888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned char>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned char>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned char>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned char>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11889(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned char>*)o)->::SharedArrayImp<unsigned char>::~SharedArrayImp)();
}
static  void method_11890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned char>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned char>*)o)->refCount)();
}

static  void method_11891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned char>*)o)->acquire)();
}

static  void method_11892( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->release)();
}

static  void method_11893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned char>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned char>*)o)->size)();
}

static  void operator_11894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned char>*)o)->Class)();
}

static  void method_11897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned char>*)o)->Class_Name)();
}

static  void method_11898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned char>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned char>*)o)->Class_Version)();
}

static  void method_11899( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->Dictionary)();
}

static  void method_11900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned char>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned char>*)o)->IsA)();
}

static  void method_11901( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned char>*)o)->DeclFileName)();
}

static  void method_11905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned char>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned char>*)o)->ImplFileLine)();
}

static  void method_11906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned char>*)o)->ImplFileName)();
}

static  void method_11907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned char>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned char>*)o)->DeclFileLine)();
}

static void method_newdel_1945( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x70( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned char>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<unsigned char> -------------------------------
void __SharedArrayImp_unsignedschar__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedschar__datamem_bld(&__SharedArrayImp_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedschar__funcmem_bld(&__SharedArrayImp_unsignedschar__db_funcmem);
void __SharedArrayImp_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned char>"), typeid(::SharedArrayImp<unsigned char>), sizeof(::SharedArrayImp<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned char>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31167, type_31168), Reflex::Literal("operator="), operator_11884, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11885, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11886, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31168), Reflex::Literal("SharedArrayImp"), constructor_11887, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11889, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1945, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x70, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedschar__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedschar__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<unsigned char> -------------------
void __SharedArrayImp_unsignedschar__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedschar_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3099, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedschar_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<unsigned char> -------------------
void __SharedArrayImp_unsignedschar__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31169, type_4138), Reflex::Literal("Clone"), method_11888, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31169), Reflex::Literal("acquire"), method_11891, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11892, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18423, type_211), Reflex::Literal("operator[]"), operator_11894, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18421, type_211), Reflex::Literal("operator[]"), operator_11895, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11896, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11897, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11898, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11899, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11900, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11901, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11902, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11903, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11904, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11905, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11906, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11907, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<long long int> -------------------------------
static  void operator_11911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<long long>*)o)->operator=)(*(const ::SharedArrayImp<long long>*)arg[0]);
  else   (((::SharedArrayImp<long long>*)o)->operator=)(*(const ::SharedArrayImp<long long>*)arg[0]);
}

static void constructor_11912( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long long>();
  else ::new(mem) ::SharedArrayImp<long long>();
}

static void constructor_11913( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<long long>(*(unsigned int*)arg[0]);
}

static void constructor_11914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long long>(*(const ::SharedArrayImp<long long>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<long long>(*(const ::SharedArrayImp<long long>*)arg[0]);
}

static  void method_11915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long long>*)o)->Clone)());
    else     (((const ::SharedArrayImp<long long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<long long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11916(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<long long>*)o)->::SharedArrayImp<long long>::~SharedArrayImp)();
}
static  void method_11917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<long long>*)o)->refCount)());
  else   (((const ::SharedArrayImp<long long>*)o)->refCount)();
}

static  void method_11918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->acquire)());
  else   (((::SharedArrayImp<long long>*)o)->acquire)();
}

static  void method_11919( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<long long>*)o)->release)();
}

static  void method_11920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<long long>*)o)->size)());
  else   (((const ::SharedArrayImp<long long>*)o)->size)();
}

static  void operator_11921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->Class)());
  else   (((::SharedArrayImp<long long>*)o)->Class)();
}

static  void method_11924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->Class_Name)());
  else   (((::SharedArrayImp<long long>*)o)->Class_Name)();
}

static  void method_11925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<long long>*)o)->Class_Version)());
  else   (((::SharedArrayImp<long long>*)o)->Class_Version)();
}

static  void method_11926( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<long long>*)o)->Dictionary)();
}

static  void method_11927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long long>*)o)->IsA)());
  else   (((const ::SharedArrayImp<long long>*)o)->IsA)();
}

static  void method_11928( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11929( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11930( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<long long>*)o)->DeclFileName)();
}

static  void method_11932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<long long>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<long long>*)o)->ImplFileLine)();
}

static  void method_11933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<long long>*)o)->ImplFileName)();
}

static  void method_11934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<long long>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<long long>*)o)->DeclFileLine)();
}

static void method_newdel_1946( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x72( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<long long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<long long int> -------------------------------
void __SharedArrayImp_longslong__db_datamem(Reflex::Class*);
void __SharedArrayImp_longslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_longslong__datamem_bld(&__SharedArrayImp_longslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_longslong__funcmem_bld(&__SharedArrayImp_longslong__db_funcmem);
void __SharedArrayImp_longslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<long long>"), typeid(::SharedArrayImp<long long>), sizeof(::SharedArrayImp<long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<long long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31170, type_31171), Reflex::Literal("operator="), operator_11911, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11912, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11913, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31171), Reflex::Literal("SharedArrayImp"), constructor_11914, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11916, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1946, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x72, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_longslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_longslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<long long int> -------------------
void __SharedArrayImp_longslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_longslong_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3100, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_longslong_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<long long int> -------------------
void __SharedArrayImp_longslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31172, type_4138), Reflex::Literal("Clone"), method_11915, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31172), Reflex::Literal("acquire"), method_11918, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11919, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18488, type_211), Reflex::Literal("operator[]"), operator_11921, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18486, type_211), Reflex::Literal("operator[]"), operator_11922, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11923, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11924, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11925, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11926, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11927, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11928, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11929, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11930, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11931, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11932, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11933, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11934, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<long int> -------------------------------
static  void operator_11938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<long>*)o)->operator=)(*(const ::SharedArrayImp<long>*)arg[0]);
  else   (((::SharedArrayImp<long>*)o)->operator=)(*(const ::SharedArrayImp<long>*)arg[0]);
}

static void constructor_11939( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long>();
  else ::new(mem) ::SharedArrayImp<long>();
}

static void constructor_11940( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<long>(*(unsigned int*)arg[0]);
}

static void constructor_11941( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long>(*(const ::SharedArrayImp<long>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<long>(*(const ::SharedArrayImp<long>*)arg[0]);
}

static  void method_11942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long>*)o)->Clone)());
    else     (((const ::SharedArrayImp<long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11943(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<long>*)o)->::SharedArrayImp<long>::~SharedArrayImp)();
}
static  void method_11944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<long>*)o)->refCount)());
  else   (((const ::SharedArrayImp<long>*)o)->refCount)();
}

static  void method_11945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->acquire)());
  else   (((::SharedArrayImp<long>*)o)->acquire)();
}

static  void method_11946( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<long>*)o)->release)();
}

static  void method_11947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<long>*)o)->size)());
  else   (((const ::SharedArrayImp<long>*)o)->size)();
}

static  void operator_11948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->Class)());
  else   (((::SharedArrayImp<long>*)o)->Class)();
}

static  void method_11951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->Class_Name)());
  else   (((::SharedArrayImp<long>*)o)->Class_Name)();
}

static  void method_11952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<long>*)o)->Class_Version)());
  else   (((::SharedArrayImp<long>*)o)->Class_Version)();
}

static  void method_11953( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<long>*)o)->Dictionary)();
}

static  void method_11954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long>*)o)->IsA)());
  else   (((const ::SharedArrayImp<long>*)o)->IsA)();
}

static  void method_11955( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11956( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11957( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<long>*)o)->DeclFileName)();
}

static  void method_11959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<long>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<long>*)o)->ImplFileLine)();
}

static  void method_11960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<long>*)o)->ImplFileName)();
}

static  void method_11961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<long>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<long>*)o)->DeclFileLine)();
}

static void method_newdel_1947( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x74( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<long int> -------------------------------
void __SharedArrayImp_long__db_datamem(Reflex::Class*);
void __SharedArrayImp_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_long__datamem_bld(&__SharedArrayImp_long__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_long__funcmem_bld(&__SharedArrayImp_long__db_funcmem);
void __SharedArrayImp_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<long>"), typeid(::SharedArrayImp<long>), sizeof(::SharedArrayImp<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31173, type_31174), Reflex::Literal("operator="), operator_11938, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11939, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11940, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31174), Reflex::Literal("SharedArrayImp"), constructor_11941, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11943, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1947, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x74, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_long__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_long__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<long int> -------------------
void __SharedArrayImp_long__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_long_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3101, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_long_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<long int> -------------------
void __SharedArrayImp_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31175, type_4138), Reflex::Literal("Clone"), method_11942, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11944, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31175), Reflex::Literal("acquire"), method_11945, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11946, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18553, type_211), Reflex::Literal("operator[]"), operator_11948, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18551, type_211), Reflex::Literal("operator[]"), operator_11949, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11950, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11951, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11952, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11953, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11954, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11955, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11956, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11957, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11958, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11959, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11960, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11961, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<int> -------------------------------
static  void operator_11965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<int>*)o)->operator=)(*(const ::SharedArrayImp<int>*)arg[0]);
  else   (((::SharedArrayImp<int>*)o)->operator=)(*(const ::SharedArrayImp<int>*)arg[0]);
}

static void constructor_11966( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<int>();
  else ::new(mem) ::SharedArrayImp<int>();
}

static void constructor_11967( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<int>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<int>(*(unsigned int*)arg[0]);
}

static void constructor_11968( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<int>(*(const ::SharedArrayImp<int>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<int>(*(const ::SharedArrayImp<int>*)arg[0]);
}

static  void method_11969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<int>*)o)->Clone)());
    else     (((const ::SharedArrayImp<int>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<int>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<int>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11970(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<int>*)o)->::SharedArrayImp<int>::~SharedArrayImp)();
}
static  void method_11971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<int>*)o)->refCount)());
  else   (((const ::SharedArrayImp<int>*)o)->refCount)();
}

static  void method_11972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->acquire)());
  else   (((::SharedArrayImp<int>*)o)->acquire)();
}

static  void method_11973( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<int>*)o)->release)();
}

static  void method_11974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<int>*)o)->size)());
  else   (((const ::SharedArrayImp<int>*)o)->size)();
}

static  void operator_11975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<int>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<int>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->Class)());
  else   (((::SharedArrayImp<int>*)o)->Class)();
}

static  void method_11978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->Class_Name)());
  else   (((::SharedArrayImp<int>*)o)->Class_Name)();
}

static  void method_11979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<int>*)o)->Class_Version)());
  else   (((::SharedArrayImp<int>*)o)->Class_Version)();
}

static  void method_11980( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<int>*)o)->Dictionary)();
}

static  void method_11981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<int>*)o)->IsA)());
  else   (((const ::SharedArrayImp<int>*)o)->IsA)();
}

static  void method_11982( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<int>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<int>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11984( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<int>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<int>*)o)->DeclFileName)();
}

static  void method_11986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<int>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<int>*)o)->ImplFileLine)();
}

static  void method_11987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<int>*)o)->ImplFileName)();
}

static  void method_11988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<int>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<int>*)o)->DeclFileLine)();
}

static void method_newdel_1948( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x76( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<int>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<int> -------------------------------
void __SharedArrayImp_int__db_datamem(Reflex::Class*);
void __SharedArrayImp_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_int__datamem_bld(&__SharedArrayImp_int__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_int__funcmem_bld(&__SharedArrayImp_int__db_funcmem);
void __SharedArrayImp_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<int>"), typeid(::SharedArrayImp<int>), sizeof(::SharedArrayImp<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<int>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31176, type_31177), Reflex::Literal("operator="), operator_11965, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11966, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11967, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31177), Reflex::Literal("SharedArrayImp"), constructor_11968, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11970, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1948, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x76, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_int__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<int> -------------------
void __SharedArrayImp_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_int_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3102, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_int_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<int> -------------------
void __SharedArrayImp_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31178, type_4138), Reflex::Literal("Clone"), method_11969, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31178), Reflex::Literal("acquire"), method_11972, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11973, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618, type_211), Reflex::Literal("operator[]"), operator_11975, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18616, type_211), Reflex::Literal("operator[]"), operator_11976, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_11977, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_11978, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11979, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11980, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_11981, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_11982, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_11983, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_11984, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_11985, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11986, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_11987, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11988, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<short int> -------------------------------
static  void operator_11992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<short>*)o)->operator=)(*(const ::SharedArrayImp<short>*)arg[0]);
  else   (((::SharedArrayImp<short>*)o)->operator=)(*(const ::SharedArrayImp<short>*)arg[0]);
}

static void constructor_11993( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<short>();
  else ::new(mem) ::SharedArrayImp<short>();
}

static void constructor_11994( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<short>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<short>(*(unsigned int*)arg[0]);
}

static void constructor_11995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<short>(*(const ::SharedArrayImp<short>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<short>(*(const ::SharedArrayImp<short>*)arg[0]);
}

static  void method_11996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<short>*)o)->Clone)());
    else     (((const ::SharedArrayImp<short>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<short>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<short>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11997(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<short>*)o)->::SharedArrayImp<short>::~SharedArrayImp)();
}
static  void method_11998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<short>*)o)->refCount)());
  else   (((const ::SharedArrayImp<short>*)o)->refCount)();
}

static  void method_11999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->acquire)());
  else   (((::SharedArrayImp<short>*)o)->acquire)();
}

static  void method_12000( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<short>*)o)->release)();
}

static  void method_12001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<short>*)o)->size)());
  else   (((const ::SharedArrayImp<short>*)o)->size)();
}

static  void operator_12002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<short>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_12003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<short>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_12004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->Class)());
  else   (((::SharedArrayImp<short>*)o)->Class)();
}

static  void method_12005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->Class_Name)());
  else   (((::SharedArrayImp<short>*)o)->Class_Name)();
}

static  void method_12006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<short>*)o)->Class_Version)());
  else   (((::SharedArrayImp<short>*)o)->Class_Version)();
}

static  void method_12007( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<short>*)o)->Dictionary)();
}

static  void method_12008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<short>*)o)->IsA)());
  else   (((const ::SharedArrayImp<short>*)o)->IsA)();
}

static  void method_12009( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<short>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_12010( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<short>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_12011( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<short>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_12012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<short>*)o)->DeclFileName)();
}

static  void method_12013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<short>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<short>*)o)->ImplFileLine)();
}

static  void method_12014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<short>*)o)->ImplFileName)();
}

static  void method_12015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<short>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<short>*)o)->DeclFileLine)();
}

static void method_newdel_1949( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x78( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<short>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<short int> -------------------------------
void __SharedArrayImp_short__db_datamem(Reflex::Class*);
void __SharedArrayImp_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_short__datamem_bld(&__SharedArrayImp_short__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_short__funcmem_bld(&__SharedArrayImp_short__db_funcmem);
void __SharedArrayImp_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<short>"), typeid(::SharedArrayImp<short>), sizeof(::SharedArrayImp<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<short>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31179, type_31180), Reflex::Literal("operator="), operator_11992, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11993, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11994, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31180), Reflex::Literal("SharedArrayImp"), constructor_11995, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11997, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1949, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x78, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_short__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_short__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<short int> -------------------
void __SharedArrayImp_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_short_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3103, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_short_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<short int> -------------------
void __SharedArrayImp_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31181, type_4138), Reflex::Literal("Clone"), method_11996, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31181), Reflex::Literal("acquire"), method_11999, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_12000, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_12001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18683, type_211), Reflex::Literal("operator[]"), operator_12002, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18681, type_211), Reflex::Literal("operator[]"), operator_12003, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_12004, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_12005, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_12006, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_12007, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_12008, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_12009, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_12010, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_12011, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_12012, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_12013, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_12014, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_12015, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<char> -------------------------------
static  void operator_12019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<char>*)o)->operator=)(*(const ::SharedArrayImp<char>*)arg[0]);
  else   (((::SharedArrayImp<char>*)o)->operator=)(*(const ::SharedArrayImp<char>*)arg[0]);
}

static void constructor_12020( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<char>();
  else ::new(mem) ::SharedArrayImp<char>();
}

static void constructor_12021( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<char>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<char>(*(unsigned int*)arg[0]);
}

static void constructor_12022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<char>(*(const ::SharedArrayImp<char>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<char>(*(const ::SharedArrayImp<char>*)arg[0]);
}

static  void method_12023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<char>*)o)->Clone)());
    else     (((const ::SharedArrayImp<char>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<char>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<char>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_12024(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<char>*)o)->::SharedArrayImp<char>::~SharedArrayImp)();
}
static  void method_12025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<char>*)o)->refCount)());
  else   (((const ::SharedArrayImp<char>*)o)->refCount)();
}

static  void method_12026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->acquire)());
  else   (((::SharedArrayImp<char>*)o)->acquire)();
}

static  void method_12027( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<char>*)o)->release)();
}

static  void method_12028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<char>*)o)->size)());
  else   (((const ::SharedArrayImp<char>*)o)->size)();
}

static  void operator_12029( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<char>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_12030( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<char>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_12031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->Class)());
  else   (((::SharedArrayImp<char>*)o)->Class)();
}

static  void method_12032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->Class_Name)());
  else   (((::SharedArrayImp<char>*)o)->Class_Name)();
}

static  void method_12033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<char>*)o)->Class_Version)());
  else   (((::SharedArrayImp<char>*)o)->Class_Version)();
}

static  void method_12034( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<char>*)o)->Dictionary)();
}

static  void method_12035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<char>*)o)->IsA)());
  else   (((const ::SharedArrayImp<char>*)o)->IsA)();
}

static  void method_12036( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<char>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_12037( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<char>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_12038( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<char>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_12039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<char>*)o)->DeclFileName)();
}

static  void method_12040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<char>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<char>*)o)->ImplFileLine)();
}

static  void method_12041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<char>*)o)->ImplFileName)();
}

static  void method_12042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<char>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<char>*)o)->DeclFileLine)();
}

static void method_newdel_1950( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x80( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<char>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<char> -------------------------------
void __SharedArrayImp_char__db_datamem(Reflex::Class*);
void __SharedArrayImp_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_char__datamem_bld(&__SharedArrayImp_char__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_char__funcmem_bld(&__SharedArrayImp_char__db_funcmem);
void __SharedArrayImp_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<char>"), typeid(::SharedArrayImp<char>), sizeof(::SharedArrayImp<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<char>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31182, type_31183), Reflex::Literal("operator="), operator_12019, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_12020, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_12021, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31183), Reflex::Literal("SharedArrayImp"), constructor_12022, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_12024, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1950, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x80, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_char__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<char> -------------------
void __SharedArrayImp_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_char_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3104, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_char_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<char> -------------------
void __SharedArrayImp_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31184, type_4138), Reflex::Literal("Clone"), method_12023, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_12025, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31184), Reflex::Literal("acquire"), method_12026, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_12027, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_12028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18747, type_211), Reflex::Literal("operator[]"), operator_12029, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18745, type_211), Reflex::Literal("operator[]"), operator_12030, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_12031, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_12032, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_12033, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_12034, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_12035, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_12036, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_12037, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_12038, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_12039, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_12040, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_12041, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_12042, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Dilution -------------------------------
static  void operator_12878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Dilution*)o)->operator=)(*(const ::Dilution*)arg[0]);
  else   (((::Dilution*)o)->operator=)(*(const ::Dilution*)arg[0]);
}

static void constructor_12879( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Dilution();
  else ::new(mem) ::Dilution();
}

static void constructor_12880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Dilution((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2]);
  else ::new(mem) ::Dilution((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2]);
}

static void constructor_12881( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Dilution(*(const ::Dilution*)arg[0]);
  else ::new(mem) ::Dilution(*(const ::Dilution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Dilution(*(const ::Dilution*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::Dilution(*(const ::Dilution*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_12882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Dilution*)o)->clone)((const char*)arg[0]));
  else   (((const ::Dilution*)o)->clone)((const char*)arg[0]);
}

static void destructor_12883(void*, void * o, const std::vector<void*>&, void *) {
(((::Dilution*)o)->::Dilution::~Dilution)();
}
static  void method_12885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Dilution*)o)->Class)());
  else   (((::Dilution*)o)->Class)();
}

static  void method_12886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Dilution*)o)->Class_Name)());
  else   (((::Dilution*)o)->Class_Name)();
}

static  void method_12887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::Dilution*)o)->Class_Version)());
  else   (((::Dilution*)o)->Class_Version)();
}

static  void method_12888( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Dilution*)o)->Dictionary)();
}

static  void method_12889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Dilution*)o)->IsA)());
  else   (((const ::Dilution*)o)->IsA)();
}

static  void method_12890( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Dilution*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_12891( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Dilution*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_12892( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Dilution*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_12893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Dilution*)o)->DeclFileName)());
  else   (((::Dilution*)o)->DeclFileName)();
}

static  void method_12894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Dilution*)o)->ImplFileLine)());
  else   (((::Dilution*)o)->ImplFileLine)();
}

static  void method_12895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Dilution*)o)->ImplFileName)());
  else   (((::Dilution*)o)->ImplFileName)();
}

static  void method_12896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Dilution*)o)->DeclFileLine)());
  else   (((::Dilution*)o)->DeclFileLine)();
}

static void method_newdel_2072( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Dilution >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Dilution >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Dilution >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Dilution >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Dilution >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x82( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::Dilution,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::Dilution,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::Dilution,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::Dilution,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::Dilution,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Dilution -------------------------------
void __Dilution_db_datamem(Reflex::Class*);
void __Dilution_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Dilution_datamem_bld(&__Dilution_db_datamem);
Reflex::GenreflexMemberBuilder __Dilution_funcmem_bld(&__Dilution_db_funcmem);
void __Dilution_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Dilution"), typeid(::Dilution), sizeof(::Dilution), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::Dilution::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::Dilution, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31285, type_31286), Reflex::Literal("operator="), operator_12878, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Dilution"), constructor_12879, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793), Reflex::Literal("Dilution"), constructor_12880, 0, "name;title;_omega", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31286, type_4138), Reflex::Literal("Dilution"), constructor_12881, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Dilution"), destructor_12883, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2072, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x82, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Dilution_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Dilution_funcmem_bld);
}

//------Delayed data member builder for class Dilution -------------------
void __Dilution_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("omega"), OffsetOf(__shadow__::__Dilution, omega), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Dilution -------------------
void __Dilution_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_12882, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_12885, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_12886, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_12887, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_12888, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_12889, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_12890, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_12891, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_12892, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_12893, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_12894, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_12895, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_12896, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class FitMeTool -------------------------------
static  void operator_12911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::FitMeTool*)o)->operator=)(*(const ::FitMeTool*)arg[0]);
  else   (((::FitMeTool*)o)->operator=)(*(const ::FitMeTool*)arg[0]);
}

static void constructor_12912( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool(*(const ::FitMeTool*)arg[0]);
  else ::new(mem) ::FitMeTool(*(const ::FitMeTool*)arg[0]);
}

static void constructor_12913( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool();
  else ::new(mem) ::FitMeTool();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool(*(bool*)arg[0]);
  else ::new(mem) ::FitMeTool(*(bool*)arg[0]);
  }
}

static void constructor_12914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool(*(int*)arg[0]);
  else ::new(mem) ::FitMeTool(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool(*(int*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::FitMeTool(*(int*)arg[0],
      *(bool*)arg[1]);
  }
}

static void destructor_12915(void*, void * o, const std::vector<void*>&, void *) {
(((::FitMeTool*)o)->::FitMeTool::~FitMeTool)();
}
static  void method_12916( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->generate)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0],
      *(const ::RooCmdArg*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4]);
  }
}

static  void method_12917( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->fit)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4],
      *(const ::RooCmdArg*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4],
      *(const ::RooCmdArg*)arg[5],
      *(const ::RooCmdArg*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4],
      *(const ::RooCmdArg*)arg[5],
      *(const ::RooCmdArg*)arg[6],
      *(const ::RooCmdArg*)arg[7]);
  }
}

static  void method_12918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->getFitResult)());
  else   (((::FitMeTool*)o)->getFitResult)();
}

static  void method_12919( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->setSeed)(*(int*)arg[0]);
}

static  void method_12920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FitMeTool*)o)->getSeed)());
  else   (((::FitMeTool*)o)->getSeed)();
}

static  void method_12921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->setDebug)(*(bool*)arg[0]);
}

static  void method_12922( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setObservables)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setObservables)((::RooArgSet*)arg[0]);
  }
}

static  void method_12923( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setConditionalObservables)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setConditionalObservables)((::RooArgSet*)arg[0]);
  }
}

static  void method_12924( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setExternalConstraints)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setExternalConstraints)((::RooArgSet*)arg[0]);
  }
}

static  void method_12925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FitMeTool*)o)->getObservables)());
  else   (((const ::FitMeTool*)o)->getObservables)();
}

static  void method_12926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FitMeTool*)o)->getConditionalObservables)());
  else   (((const ::FitMeTool*)o)->getConditionalObservables)();
}

static  void method_12927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FitMeTool*)o)->getExternalConstraints)());
  else   (((const ::FitMeTool*)o)->getExternalConstraints)();
}

static  void method_12928( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setModelPDFandData)((::RooWorkspace*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setModelPDFandData)((::RooWorkspace*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setModelPDFandData)((::RooWorkspace*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_12929( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setModelPDF)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setModelPDF)((::RooAbsPdf*)arg[0]);
  }
}

static  void method_12930( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setModelPDF)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setModelPDF)((const char*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setModelPDF)((const char*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_12931( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setModelPDF)((::RooWorkspace*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setModelPDF)((::RooWorkspace*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_12932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->getModelPDF)());
  else   (((::FitMeTool*)o)->getModelPDF)();
}

static  void method_12933( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setData)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setData)((::RooAbsData*)arg[0]);
  }
}

static  void method_12934( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setData)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setData)((const char*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setData)((const char*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_12935( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setData)((::RooWorkspace*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setData)((::RooWorkspace*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_12936( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::FitMeTool*)o)->setDataSet)((const char*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setDataSet)((const char*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::FitMeTool*)o)->setDataSet)((const char*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2],
      (const char*)arg[3]);
  }
}

static  void method_12937( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::FitMeTool*)o)->setDataSet)(*(::std::vector<std::basic_string<char> >*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setDataSet)(*(::std::vector<std::basic_string<char> >*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::FitMeTool*)o)->setDataSet)(*(::std::vector<std::basic_string<char> >*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2],
      (const char*)arg[3]);
  }
}

static  void method_12938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->getData)());
  else   (((::FitMeTool*)o)->getData)();
}

static  void method_12939( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->saveModelPDF)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->saveModelPDF)((const char*)arg[0]);
  }
}

static  void method_12940( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->saveData)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->saveData)((const char*)arg[0]);
  }
}

static  void method_12941( void*, void* o, const std::vector<void*>&, void*)
{
  (((::FitMeTool*)o)->printModelStructure)();
}

static  void method_12942( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->produceGraphicalModelStructure)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->produceGraphicalModelStructure)((const char*)arg[0]);
  }
}

static  void method_12943( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::FitMeTool*)o)->printYieldsInRange)((const char*)arg[0],
      (const char*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::FitMeTool*)o)->printYieldsInRange)((const char*)arg[0],
      (const char*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4]);
  }
}

static  void method_12944( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::FitMeTool*)o)->printYieldInRange)((const char*)arg[0],
      (const char*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::FitMeTool*)o)->printYieldInRange)((const char*)arg[0],
      (const char*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4]);
  }
}

static  void method_12945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->blindValue)(*(::RooRealVar*)arg[0],
      *(::RooCategory*)arg[1]));
    else     (((::FitMeTool*)o)->blindValue)(*(::RooRealVar*)arg[0],
      *(::RooCategory*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->blindValue)(*(::RooRealVar*)arg[0],
      *(::RooCategory*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((::FitMeTool*)o)->blindValue)(*(::RooRealVar*)arg[0],
      *(::RooCategory*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_12946( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->savesWeights)((const char*)arg[0],
    (::RooDataSet*)arg[1],
    *(::TString*)arg[2]);
}

static  void method_12953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->Class)());
  else   (((::FitMeTool*)o)->Class)();
}

static  void method_12954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->Class_Name)());
  else   (((::FitMeTool*)o)->Class_Name)();
}

static  void method_12955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::FitMeTool*)o)->Class_Version)());
  else   (((::FitMeTool*)o)->Class_Version)();
}

static  void method_12956( void*, void* o, const std::vector<void*>&, void*)
{
  (((::FitMeTool*)o)->Dictionary)();
}

static  void method_12957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FitMeTool*)o)->IsA)());
  else   (((const ::FitMeTool*)o)->IsA)();
}

static  void method_12958( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_12959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_12960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_12961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->DeclFileName)());
  else   (((::FitMeTool*)o)->DeclFileName)();
}

static  void method_12962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FitMeTool*)o)->ImplFileLine)());
  else   (((::FitMeTool*)o)->ImplFileLine)();
}

static  void method_12963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->ImplFileName)());
  else   (((::FitMeTool*)o)->ImplFileName)();
}

static  void method_12964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FitMeTool*)o)->DeclFileLine)());
  else   (((::FitMeTool*)o)->DeclFileLine)();
}

static void constructor_x83( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool();
  else ::new(mem) ::FitMeTool();
}

static void method_newdel_2078( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::FitMeTool >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::FitMeTool >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::FitMeTool >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::FitMeTool >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::FitMeTool >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FitMeTool -------------------------------
void __FitMeTool_db_datamem(Reflex::Class*);
void __FitMeTool_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __FitMeTool_datamem_bld(&__FitMeTool_db_datamem);
Reflex::GenreflexMemberBuilder __FitMeTool_funcmem_bld(&__FitMeTool_db_funcmem);
void __FitMeTool_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("FitMeTool"), typeid(::FitMeTool), sizeof(::FitMeTool), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::FitMeTool::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 0)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31287, type_31288), Reflex::Literal("operator="), operator_12911, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31288), Reflex::Literal("FitMeTool"), constructor_12912, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_667), Reflex::Literal("FitMeTool"), constructor_12913, 0, "debug=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_141, type_667), Reflex::Literal("FitMeTool"), constructor_12914, 0, "toyNumber;debug=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FitMeTool"), destructor_12915, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FitMeTool"), constructor_x83, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2078, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__FitMeTool_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__FitMeTool_funcmem_bld);
}

//------Delayed data member builder for class FitMeTool -------------------
void __FitMeTool_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2835, Reflex::Literal("m_observables"), OffsetOf(__shadow__::__FitMeTool, m_observables), ::Reflex::PROTECTED)
  .AddDataMember(type_2835, Reflex::Literal("m_conditionalObservables"), OffsetOf(__shadow__::__FitMeTool, m_conditionalObservables), ::Reflex::PROTECTED)
  .AddDataMember(type_2835, Reflex::Literal("m_externalConstraints"), OffsetOf(__shadow__::__FitMeTool, m_externalConstraints), ::Reflex::PROTECTED)
  .AddDataMember(type_667, Reflex::Literal("m_config_debug"), OffsetOf(__shadow__::__FitMeTool, m_config_debug), ::Reflex::PROTECTED)
  .AddDataMember(type_141, Reflex::Literal("m_config_toyNumber"), OffsetOf(__shadow__::__FitMeTool, m_config_toyNumber), ::Reflex::PROTECTED)
  .AddDataMember(type_141, Reflex::Literal("m_config_seed"), OffsetOf(__shadow__::__FitMeTool, m_config_seed), ::Reflex::PROTECTED)
  .AddDataMember(type_667, Reflex::Literal("m_config_seedSet"), OffsetOf(__shadow__::__FitMeTool, m_config_seedSet), ::Reflex::PROTECTED)
  .AddDataMember(type_667, Reflex::Literal("m_config_saveFitResult2File"), OffsetOf(__shadow__::__FitMeTool, m_config_saveFitResult2File), ::Reflex::PROTECTED)
  .AddDataMember(type_28050, Reflex::Literal("m_modelPDF"), OffsetOf(__shadow__::__FitMeTool, m_modelPDF), ::Reflex::PROTECTED)
  .AddDataMember(type_22409, Reflex::Literal("m_data"), OffsetOf(__shadow__::__FitMeTool, m_data), ::Reflex::PROTECTED)
  .AddDataMember(type_18802, Reflex::Literal("m_fitResult"), OffsetOf(__shadow__::__FitMeTool, m_fitResult), ::Reflex::PROTECTED)
  .AddDataMember(type_28320, Reflex::Literal("m_outputFile"), OffsetOf(__shadow__::__FitMeTool, m_outputFile), ::Reflex::PROTECTED)
  .AddDataMember(type_27832, Reflex::Literal("m_workSpace"), OffsetOf(__shadow__::__FitMeTool, m_workSpace), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class FitMeTool -------------------
void __FitMeTool_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_194, type_27854, type_27854, type_27854, type_27854), Reflex::Literal("generate"), method_12916, 0, "nevents=0;arg1=RooCmdArg::none();arg2=RooCmdArg::none();arg3=RooCmdArg::none();arg4=RooCmdArg::none()", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_667, type_27854, type_27854, type_27854, type_27854, type_27854, type_27854, type_27854), Reflex::Literal("fit"), method_12917, 0, "save2file=true;arg1=RooCmdArg::none();arg2=RooCmdArg::none();arg3=RooCmdArg::none();arg4=RooCmdArg::none();arg5=RooCmdArg::none();arg6=RooCmdArg::none();arg7=RooCmdArg::none()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18802), Reflex::Literal("getFitResult"), method_12918, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_141), Reflex::Literal("setSeed"), method_12919, 0, "seed", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("getSeed"), method_12920, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_667), Reflex::Literal("setDebug"), method_12921, 0, "yesNo", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_2835), Reflex::Literal("setObservables"), method_12922, 0, "observables=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_2835), Reflex::Literal("setConditionalObservables"), method_12923, 0, "condObs=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_2835), Reflex::Literal("setExternalConstraints"), method_12924, 0, "extConstraints=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27808), Reflex::Literal("getObservables"), method_12925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27808), Reflex::Literal("getConditionalObservables"), method_12926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27808), Reflex::Literal("getExternalConstraints"), method_12927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27832, type_4138, type_4138), Reflex::Literal("setModelPDFandData"), method_12928, 0, "ws;modelName=\"UNSPECIFIED\";dataName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_28050), Reflex::Literal("setModelPDF"), method_12929, 0, "modelPDF=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4138, type_4138, type_4138), Reflex::Literal("setModelPDF"), method_12930, 0, "fileName;wsName=\"UNSPECIFIED\";modelName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27832, type_4138), Reflex::Literal("setModelPDF"), method_12931, 0, "ws;modelName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28050), Reflex::Literal("getModelPDF"), method_12932, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_22409), Reflex::Literal("setData"), method_12933, 0, "data=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4138, type_4138, type_4138), Reflex::Literal("setData"), method_12934, 0, "fileName;wsName=\"UNSPECIFIED\";dataName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27832, type_4138), Reflex::Literal("setData"), method_12935, 0, "ws;dataName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4138, type_4138, type_4138, type_4138), Reflex::Literal("setDataSet"), method_12936, 0, "fileName;treeName;subDir=0l;cuts=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3109, type_4138, type_4138, type_4138), Reflex::Literal("setDataSet"), method_12937, 0, "filesList;treeName;subDir=0l;cuts=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22409), Reflex::Literal("getData"), method_12938, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4138), Reflex::Literal("saveModelPDF"), method_12939, 0, "workspaceFileName=\"FitMeTool\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4138), Reflex::Literal("saveData"), method_12940, 0, "workspaceFileName=\"FitMeTool\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("printModelStructure"), method_12941, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4138), Reflex::Literal("produceGraphicalModelStructure"), method_12942, 0, "fileName=\"model.gif\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4138, type_4138, type_694, type_694, type_4138), Reflex::Literal("printYieldsInRange"), method_12943, 0, "wildcard;observableName;low;high;rangeName=\"SignalRegion\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4138, type_4138, type_694, type_694, type_4138), Reflex::Literal("printYieldInRange"), method_12944, 0, "yieldVarName;observableName;low;high;rangeName=\"SignalRegion\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31289, type_27803, type_28738, type_3159c), Reflex::Literal("blindValue"), method_12945, 0, "varToBeBlinded;category;prefix=\"blinded\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4138, type_28052, type_6066), Reflex::Literal("savesWeights"), method_12946, 0, "observableName;data;mode", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_12953, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_12954, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_12955, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_12956, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_12957, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_12958, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_12959, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_12960, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_12961, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_12962, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_12963, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_12964, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooCubicSplineFun -------------------------------
static  void operator_13071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineFun*)o)->operator=)(*(const ::RooCubicSplineFun*)arg[0]);
  else   (((::RooCubicSplineFun*)o)->operator=)(*(const ::RooCubicSplineFun*)arg[0]);
}

static void constructor_13072( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun();
  else ::new(mem) ::RooCubicSplineFun();
}

static void constructor_13073( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5],
      *(double*)arg[6]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5],
      *(double*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5],
      *(double*)arg[6],
      *(bool*)arg[7]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5],
      *(double*)arg[6],
      *(bool*)arg[7]);
  }
}

static void constructor_13074( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraph*)arg[3]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraph*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraph*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraph*)arg[3],
      *(bool*)arg[4]);
  }
}

static void constructor_13075( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  }
}

static void constructor_13076( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3],
      *(double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  }
}

static void constructor_13077( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
}

static void constructor_13078( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::RooArgList*)arg[4]);
}

static void destructor_13079(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineFun*)o)->::RooCubicSplineFun::~RooCubicSplineFun)();
}
static void constructor_13080( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun(*(const ::RooCubicSplineFun*)arg[0]);
  else ::new(mem) ::RooCubicSplineFun(*(const ::RooCubicSplineFun*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun(*(const ::RooCubicSplineFun*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooCubicSplineFun(*(const ::RooCubicSplineFun*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_13081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCubicSplineFun*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooCubicSplineFun*)o)->clone)((const char*)arg[0]);
}

static  void method_13082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooCubicSplineFun*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::RooCubicSplineFun*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_13083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooCubicSplineFun*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::RooCubicSplineFun*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_13084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooCubicSplineFun*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooCubicSplineFun*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_13085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooCubicSplineFun*)o)->maxVal)(*(::Int_t*)arg[0]));
  else   (((const ::RooCubicSplineFun*)o)->maxVal)(*(::Int_t*)arg[0]);
}

static  void method_13086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::complex<double>)((((const ::RooCubicSplineFun*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]));
  else   (((const ::RooCubicSplineFun*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]);
}

static  void method_13087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::RooCubicSplineFun*)o)->knotSize)());
  else   (((const ::RooCubicSplineFun*)o)->knotSize)();
}

static  void method_13088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineFun*)o)->u)(*(int*)arg[0]));
  else   (((const ::RooCubicSplineFun*)o)->u)(*(int*)arg[0]);
}

static  void method_13089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooCubicSplineFun*)o)->knots)();
  else   (((const ::RooCubicSplineFun*)o)->knots)();
}

static  void method_13090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooCubicSplineFun*)o)->coefficients)();
  else   (((const ::RooCubicSplineFun*)o)->coefficients)();
}

static  void method_13094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineFun*)o)->Class)());
  else   (((::RooCubicSplineFun*)o)->Class)();
}

static  void method_13095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineFun*)o)->Class_Name)());
  else   (((::RooCubicSplineFun*)o)->Class_Name)();
}

static  void method_13096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooCubicSplineFun*)o)->Class_Version)());
  else   (((::RooCubicSplineFun*)o)->Class_Version)();
}

static  void method_13097( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooCubicSplineFun*)o)->Dictionary)();
}

static  void method_13098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCubicSplineFun*)o)->IsA)());
  else   (((const ::RooCubicSplineFun*)o)->IsA)();
}

static  void method_13099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineFun*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineFun*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineFun*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineFun*)o)->DeclFileName)());
  else   (((::RooCubicSplineFun*)o)->DeclFileName)();
}

static  void method_13103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCubicSplineFun*)o)->ImplFileLine)());
  else   (((::RooCubicSplineFun*)o)->ImplFileLine)();
}

static  void method_13104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineFun*)o)->ImplFileName)());
  else   (((::RooCubicSplineFun*)o)->ImplFileName)();
}

static  void method_13105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCubicSplineFun*)o)->DeclFileLine)());
  else   (((::RooCubicSplineFun*)o)->DeclFileLine)();
}

static void method_newdel_2117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x86( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGaussModelEfficiency")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::RooAbsGaussModelEfficiency >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooCubicSplineFun -------------------------------
void __RooCubicSplineFun_db_datamem(Reflex::Class*);
void __RooCubicSplineFun_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineFun_datamem_bld(&__RooCubicSplineFun_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineFun_funcmem_bld(&__RooCubicSplineFun_db_funcmem);
void __RooCubicSplineFun_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineFun"), typeid(::RooCubicSplineFun), sizeof(::RooCubicSplineFun), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooCubicSplineFun::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1672, ::Reflex::BaseOffset< ::RooCubicSplineFun, ::RooAbsGaussModelEfficiency >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31300, type_31301), Reflex::Literal("operator="), operator_13071, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooCubicSplineFun"), constructor_13072, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_19008, type_19008, type_19008, type_694, type_667), Reflex::Literal("RooCubicSplineFun"), constructor_13073, 0, "name;title;x;knots;values;errors=std::vector<double, std::allocator<double> >();smooth=0;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_31123, type_667), Reflex::Literal("RooCubicSplineFun"), constructor_13074, 0, "name;title;x;graph;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_28266, type_694, type_667), Reflex::Literal("RooCubicSplineFun"), constructor_13075, 0, "name;title;x;hist;smooth=0;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_31302, type_694, type_667), Reflex::Literal("RooCubicSplineFun"), constructor_13076, 0, "name;title;x;graph;smooth=0;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_4138, type_27954), Reflex::Literal("RooCubicSplineFun"), constructor_13077, 0, "name;title;x;knotBinningName;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_19008, type_27954), Reflex::Literal("RooCubicSplineFun"), constructor_13078, 0, "name;title;x;knots;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooCubicSplineFun"), destructor_13079, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31301, type_4138), Reflex::Literal("RooCubicSplineFun"), constructor_13080, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x86, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineFun_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCubicSplineFun_funcmem_bld);
}

//------Delayed data member builder for class RooCubicSplineFun -------------------
void __RooCubicSplineFun_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("_x"), OffsetOf(__shadow__::__RooCubicSplineFun, _x), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("_coefList"), OffsetOf(__shadow__::__RooCubicSplineFun, _coefList), ::Reflex::PRIVATE)
  .AddDataMember(type_855, Reflex::Literal("_aux"), OffsetOf(__shadow__::__RooCubicSplineFun, _aux), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooCubicSplineFun -------------------
void __RooCubicSplineFun_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_13081, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_13082, 0, "allVars;analVars;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_13083, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27806), Reflex::Literal("getMaxVal"), method_13084, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("maxVal"), method_13085, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3638, type_2317, type_2317, type_2317, type_2317, type_22832), Reflex::Literal("productAnalyticalIntegral"), method_13086, 0, "umin;umax;scale;offset;z", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("knotSize"), method_13087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_141), Reflex::Literal("u"), method_13088, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19008), Reflex::Literal("knots"), method_13089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27954), Reflex::Literal("coefficients"), method_13090, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13094, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13095, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13096, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13097, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13098, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13099, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13100, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13101, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13103, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13104, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13105, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class CPObservable -------------------------------
static void constructor_13490( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CPObservable();
  else ::new(mem) ::CPObservable();
}

static void constructor_13491( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CPObservable((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::CPObservable::which*)arg[5]);
  else ::new(mem) ::CPObservable((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::CPObservable::which*)arg[5]);
}

static void constructor_13492( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::CPObservable(*(const ::CPObservable*)arg[0]);
  else ::new(mem) ::CPObservable(*(const ::CPObservable*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::CPObservable(*(const ::CPObservable*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::CPObservable(*(const ::CPObservable*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_13493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CPObservable*)o)->operator=)(*(const ::CPObservable*)arg[0]);
  else   (((::CPObservable*)o)->operator=)(*(const ::CPObservable*)arg[0]);
}

static  void method_13494( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::CPObservable*)o)->clone)((const char*)arg[0]));
  else   (((const ::CPObservable*)o)->clone)((const char*)arg[0]);
}

static void destructor_13495(void*, void * o, const std::vector<void*>&, void *) {
(((::CPObservable*)o)->::CPObservable::~CPObservable)();
}
static  void method_13497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CPObservable*)o)->Class)());
  else   (((::CPObservable*)o)->Class)();
}

static  void method_13498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CPObservable*)o)->Class_Name)());
  else   (((::CPObservable*)o)->Class_Name)();
}

static  void method_13499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::CPObservable*)o)->Class_Version)());
  else   (((::CPObservable*)o)->Class_Version)();
}

static  void method_13500( void*, void* o, const std::vector<void*>&, void*)
{
  (((::CPObservable*)o)->Dictionary)();
}

static  void method_13501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::CPObservable*)o)->IsA)());
  else   (((const ::CPObservable*)o)->IsA)();
}

static  void method_13502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CPObservable*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CPObservable*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13504( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CPObservable*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CPObservable*)o)->DeclFileName)());
  else   (((::CPObservable*)o)->DeclFileName)();
}

static  void method_13506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::CPObservable*)o)->ImplFileLine)());
  else   (((::CPObservable*)o)->ImplFileLine)();
}

static  void method_13507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CPObservable*)o)->ImplFileName)());
  else   (((::CPObservable*)o)->ImplFileName)();
}

static  void method_13508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::CPObservable*)o)->DeclFileLine)());
  else   (((::CPObservable*)o)->DeclFileLine)();
}

static void method_newdel_2165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CPObservable >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CPObservable >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CPObservable >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CPObservable >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CPObservable >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x88( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::CPObservable,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::CPObservable,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::CPObservable,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::CPObservable,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::CPObservable,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CPObservable -------------------------------
void __CPObservable_db_datamem(Reflex::Class*);
void __CPObservable_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CPObservable_datamem_bld(&__CPObservable_db_datamem);
Reflex::GenreflexMemberBuilder __CPObservable_funcmem_bld(&__CPObservable_db_funcmem);
void __CPObservable_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CPObservable"), typeid(::CPObservable), sizeof(::CPObservable), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::CPObservable::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::CPObservable, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("CPObservable::which"), Reflex::Literal("C=0;D=1;S=2;Dbar=3;Sbar=4"), &typeid(CPObservable::which), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CPObservable"), constructor_13490, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_13489), Reflex::Literal("CPObservable"), constructor_13491, 0, "name;title;_lambda;_phi_strong;_phi_weak;_what", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31429, type_4138), Reflex::Literal("CPObservable"), constructor_13492, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CPObservable"), destructor_13495, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x88, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CPObservable_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CPObservable_funcmem_bld);
}

//------Delayed data member builder for class CPObservable -------------------
void __CPObservable_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("lambda"), OffsetOf(__shadow__::__CPObservable, lambda), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("phi_strong"), OffsetOf(__shadow__::__CPObservable, phi_strong), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("phi_weak"), OffsetOf(__shadow__::__CPObservable, phi_weak), ::Reflex::PROTECTED)
  .AddDataMember(type_141, Reflex::Literal("what"), OffsetOf(__shadow__::__CPObservable, what), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class CPObservable -------------------
void __CPObservable_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31430, type_31429), Reflex::Literal("operator="), operator_13493, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_13494, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13497, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13498, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13499, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13500, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13501, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13502, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13503, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13504, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13505, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13506, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13507, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13508, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooComplementCoef -------------------------------
static  void operator_13557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooComplementCoef*)o)->operator=)(*(const ::RooComplementCoef*)arg[0]);
  else   (((::RooComplementCoef*)o)->operator=)(*(const ::RooComplementCoef*)arg[0]);
}

static void constructor_13558( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooComplementCoef();
  else ::new(mem) ::RooComplementCoef();
}

static void constructor_13559( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooComplementCoef((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2]);
  else ::new(mem) ::RooComplementCoef((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2]);
}

static void constructor_13560( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooComplementCoef(*(const ::RooComplementCoef*)arg[0]);
  else ::new(mem) ::RooComplementCoef(*(const ::RooComplementCoef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooComplementCoef(*(const ::RooComplementCoef*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooComplementCoef(*(const ::RooComplementCoef*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_13561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooComplementCoef*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooComplementCoef*)o)->clone)((const char*)arg[0]);
}

static void destructor_13562(void*, void * o, const std::vector<void*>&, void *) {
(((::RooComplementCoef*)o)->::RooComplementCoef::~RooComplementCoef)();
}
static  void method_13563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RooArgList)((((const ::RooComplementCoef*)o)->coefficients)());
  else   (((const ::RooComplementCoef*)o)->coefficients)();
}

static  void method_13564( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::RooComplementCoef*)o)->printArgs)(*(::std::ostream*)arg[0]);
}

static  void method_13566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooComplementCoef*)o)->Class)());
  else   (((::RooComplementCoef*)o)->Class)();
}

static  void method_13567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooComplementCoef*)o)->Class_Name)());
  else   (((::RooComplementCoef*)o)->Class_Name)();
}

static  void method_13568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooComplementCoef*)o)->Class_Version)());
  else   (((::RooComplementCoef*)o)->Class_Version)();
}

static  void method_13569( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooComplementCoef*)o)->Dictionary)();
}

static  void method_13570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooComplementCoef*)o)->IsA)());
  else   (((const ::RooComplementCoef*)o)->IsA)();
}

static  void method_13571( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooComplementCoef*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13572( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooComplementCoef*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooComplementCoef*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooComplementCoef*)o)->DeclFileName)());
  else   (((::RooComplementCoef*)o)->DeclFileName)();
}

static  void method_13575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooComplementCoef*)o)->ImplFileLine)());
  else   (((::RooComplementCoef*)o)->ImplFileLine)();
}

static  void method_13576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooComplementCoef*)o)->ImplFileName)());
  else   (((::RooComplementCoef*)o)->ImplFileName)();
}

static  void method_13577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooComplementCoef*)o)->DeclFileLine)());
  else   (((::RooComplementCoef*)o)->DeclFileLine)();
}

static void method_newdel_2200( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x90( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooComplementCoef,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooComplementCoef,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooComplementCoef,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooComplementCoef,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooComplementCoef,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooComplementCoef -------------------------------
void __RooComplementCoef_db_datamem(Reflex::Class*);
void __RooComplementCoef_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooComplementCoef_datamem_bld(&__RooComplementCoef_db_datamem);
Reflex::GenreflexMemberBuilder __RooComplementCoef_funcmem_bld(&__RooComplementCoef_db_funcmem);
void __RooComplementCoef_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooComplementCoef"), typeid(::RooComplementCoef), sizeof(::RooComplementCoef), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooComplementCoef::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooComplementCoef, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31432, type_31433), Reflex::Literal("operator="), operator_13557, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooComplementCoef"), constructor_13558, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27954), Reflex::Literal("RooComplementCoef"), constructor_13559, 0, "name;title;coefficients", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31433, type_4138), Reflex::Literal("RooComplementCoef"), constructor_13560, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooComplementCoef"), destructor_13562, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x90, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooComplementCoef_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooComplementCoef_funcmem_bld);
}

//------Delayed data member builder for class RooComplementCoef -------------------
void __RooComplementCoef_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_646, Reflex::Literal("_coefs"), OffsetOf(__shadow__::__RooComplementCoef, _coefs), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooComplementCoef -------------------
void __RooComplementCoef_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_13561, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1620), Reflex::Literal("coefficients"), method_13563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_9893), Reflex::Literal("printArgs"), method_13564, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13566, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13567, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13568, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13569, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13570, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13571, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13572, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13573, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13574, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13575, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13576, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13577, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<double> -------------------------------
static void constructor_13582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<double>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<double>(*(unsigned int*)arg[0]);
}

static void constructor_13583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<double>(*(const ::SharedArray<double>*)arg[0]);
  else ::new(mem) ::SharedArray<double>(*(const ::SharedArray<double>*)arg[0]);
}

static  void method_13584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<double>*)o)->Clone)());
    else     (((const ::SharedArray<double>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<double>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<double>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13585(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<double>*)o)->::SharedArray<double>::~SharedArray)();
}
static  void operator_13586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<double>*)o)->operator=)(*(const ::SharedArray<double>*)arg[0]);
  else   (((::SharedArray<double>*)o)->operator=)(*(const ::SharedArray<double>*)arg[0]);
}

static  void method_13587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<double>*)o)->size)());
  else   (((const ::SharedArray<double>*)o)->size)();
}

static  void operator_13588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<double>::RWProxy)((((const ::SharedArray<double>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<double>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<double>::RWProxy)((((::SharedArray<double>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<double>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<double>*)o)->Class)());
  else   (((::SharedArray<double>*)o)->Class)();
}

static  void method_13592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<double>*)o)->Class_Name)());
  else   (((::SharedArray<double>*)o)->Class_Name)();
}

static  void method_13593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<double>*)o)->Class_Version)());
  else   (((::SharedArray<double>*)o)->Class_Version)();
}

static  void method_13594( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<double>*)o)->Dictionary)();
}

static  void method_13595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<double>*)o)->IsA)());
  else   (((const ::SharedArray<double>*)o)->IsA)();
}

static  void method_13596( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<double>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<double>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13598( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<double>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<double>*)o)->DeclFileName)());
  else   (((::SharedArray<double>*)o)->DeclFileName)();
}

static  void method_13600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<double>*)o)->ImplFileLine)());
  else   (((::SharedArray<double>*)o)->ImplFileLine)();
}

static  void method_13601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<double>*)o)->ImplFileName)());
  else   (((::SharedArray<double>*)o)->ImplFileName)();
}

static  void method_13602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<double>*)o)->DeclFileLine)());
  else   (((::SharedArray<double>*)o)->DeclFileLine)();
}

static void method_x91( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<double>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<double> -------------------------------
void __SharedArray_double__db_datamem(Reflex::Class*);
void __SharedArray_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_double__datamem_bld(&__SharedArray_double__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_double__funcmem_bld(&__SharedArray_double__db_funcmem);
void __SharedArray_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<double>"), typeid(::SharedArray<double>), sizeof(::SharedArray<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<double>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13582, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31466), Reflex::Literal("SharedArray"), constructor_13583, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13585, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x91, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_double__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<double> -------------------
void __SharedArray_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31151, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_double_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<double> -------------------
void __SharedArray_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31467, type_4138), Reflex::Literal("Clone"), method_13584, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31468, type_31466), Reflex::Literal("operator="), operator_13586, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13580c, type_211), Reflex::Literal("operator[]"), operator_13588, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13580, type_211), Reflex::Literal("operator[]"), operator_13589, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13591, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13592, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13593, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13594, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13595, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13596, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13597, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13598, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13599, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13600, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13601, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13602, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<float> -------------------------------
static void constructor_13607( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<float>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<float>(*(unsigned int*)arg[0]);
}

static void constructor_13608( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<float>(*(const ::SharedArray<float>*)arg[0]);
  else ::new(mem) ::SharedArray<float>(*(const ::SharedArray<float>*)arg[0]);
}

static  void method_13609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<float>*)o)->Clone)());
    else     (((const ::SharedArray<float>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<float>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<float>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13610(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<float>*)o)->::SharedArray<float>::~SharedArray)();
}
static  void operator_13611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<float>*)o)->operator=)(*(const ::SharedArray<float>*)arg[0]);
  else   (((::SharedArray<float>*)o)->operator=)(*(const ::SharedArray<float>*)arg[0]);
}

static  void method_13612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<float>*)o)->size)());
  else   (((const ::SharedArray<float>*)o)->size)();
}

static  void operator_13613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<float>::RWProxy)((((const ::SharedArray<float>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<float>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<float>::RWProxy)((((::SharedArray<float>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<float>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<float>*)o)->Class)());
  else   (((::SharedArray<float>*)o)->Class)();
}

static  void method_13617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<float>*)o)->Class_Name)());
  else   (((::SharedArray<float>*)o)->Class_Name)();
}

static  void method_13618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<float>*)o)->Class_Version)());
  else   (((::SharedArray<float>*)o)->Class_Version)();
}

static  void method_13619( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<float>*)o)->Dictionary)();
}

static  void method_13620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<float>*)o)->IsA)());
  else   (((const ::SharedArray<float>*)o)->IsA)();
}

static  void method_13621( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<float>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13622( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<float>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13623( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<float>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<float>*)o)->DeclFileName)());
  else   (((::SharedArray<float>*)o)->DeclFileName)();
}

static  void method_13625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<float>*)o)->ImplFileLine)());
  else   (((::SharedArray<float>*)o)->ImplFileLine)();
}

static  void method_13626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<float>*)o)->ImplFileName)());
  else   (((::SharedArray<float>*)o)->ImplFileName)();
}

static  void method_13627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<float>*)o)->DeclFileLine)());
  else   (((::SharedArray<float>*)o)->DeclFileLine)();
}

static void method_x92( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<float>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<float> -------------------------------
void __SharedArray_float__db_datamem(Reflex::Class*);
void __SharedArray_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_float__datamem_bld(&__SharedArray_float__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_float__funcmem_bld(&__SharedArray_float__db_funcmem);
void __SharedArray_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<float>"), typeid(::SharedArray<float>), sizeof(::SharedArray<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<float>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13607, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31502), Reflex::Literal("SharedArray"), constructor_13608, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13610, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x92, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_float__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<float> -------------------
void __SharedArray_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31154, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_float_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<float> -------------------
void __SharedArray_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31503, type_4138), Reflex::Literal("Clone"), method_13609, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31504, type_31502), Reflex::Literal("operator="), operator_13611, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13612, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13605c, type_211), Reflex::Literal("operator[]"), operator_13613, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13605, type_211), Reflex::Literal("operator[]"), operator_13614, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13616, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13617, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13618, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13619, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13620, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13621, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13622, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13623, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13624, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13625, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13626, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13627, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<long long unsigned int> -------------------------------
static void constructor_13632( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned long long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned long long>(*(unsigned int*)arg[0]);
}

static void constructor_13633( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned long long>(*(const ::SharedArray<unsigned long long>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned long long>(*(const ::SharedArray<unsigned long long>*)arg[0]);
}

static  void method_13634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long long>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned long long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned long long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13635(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned long long>*)o)->::SharedArray<unsigned long long>::~SharedArray)();
}
static  void operator_13636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned long long>*)o)->operator=)(*(const ::SharedArray<unsigned long long>*)arg[0]);
  else   (((::SharedArray<unsigned long long>*)o)->operator=)(*(const ::SharedArray<unsigned long long>*)arg[0]);
}

static  void method_13637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned long long>*)o)->size)());
  else   (((const ::SharedArray<unsigned long long>*)o)->size)();
}

static  void operator_13638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned long long>::RWProxy)((((const ::SharedArray<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned long long>::RWProxy)((((::SharedArray<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long long>*)o)->Class)());
  else   (((::SharedArray<unsigned long long>*)o)->Class)();
}

static  void method_13642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long long>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned long long>*)o)->Class_Name)();
}

static  void method_13643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned long long>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned long long>*)o)->Class_Version)();
}

static  void method_13644( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned long long>*)o)->Dictionary)();
}

static  void method_13645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long long>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned long long>*)o)->IsA)();
}

static  void method_13646( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13647( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13648( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long long>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned long long>*)o)->DeclFileName)();
}

static  void method_13650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned long long>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned long long>*)o)->ImplFileLine)();
}

static  void method_13651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long long>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned long long>*)o)->ImplFileName)();
}

static  void method_13652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned long long>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned long long>*)o)->DeclFileLine)();
}

static void method_x93( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned long long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<long long unsigned int> -------------------------------
void __SharedArray_unsignedslongslong__db_datamem(Reflex::Class*);
void __SharedArray_unsignedslongslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedslongslong__datamem_bld(&__SharedArray_unsignedslongslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedslongslong__funcmem_bld(&__SharedArray_unsignedslongslong__db_funcmem);
void __SharedArray_unsignedslongslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned long long>"), typeid(::SharedArray<unsigned long long>), sizeof(::SharedArray<unsigned long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned long long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13632, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31538), Reflex::Literal("SharedArray"), constructor_13633, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13635, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x93, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedslongslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedslongslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<long long unsigned int> -------------------
void __SharedArray_unsignedslongslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31157, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedslongslong_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<long long unsigned int> -------------------
void __SharedArray_unsignedslongslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31539, type_4138), Reflex::Literal("Clone"), method_13634, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31540, type_31538), Reflex::Literal("operator="), operator_13636, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13630c, type_211), Reflex::Literal("operator[]"), operator_13638, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13630, type_211), Reflex::Literal("operator[]"), operator_13639, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13641, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13642, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13643, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13644, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13645, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13646, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13647, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13648, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13649, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13650, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13651, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13652, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<long unsigned int> -------------------------------
static void constructor_13657( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned long>(*(unsigned int*)arg[0]);
}

static void constructor_13658( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned long>(*(const ::SharedArray<unsigned long>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned long>(*(const ::SharedArray<unsigned long>*)arg[0]);
}

static  void method_13659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13660(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned long>*)o)->::SharedArray<unsigned long>::~SharedArray)();
}
static  void operator_13661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned long>*)o)->operator=)(*(const ::SharedArray<unsigned long>*)arg[0]);
  else   (((::SharedArray<unsigned long>*)o)->operator=)(*(const ::SharedArray<unsigned long>*)arg[0]);
}

static  void method_13662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned long>*)o)->size)());
  else   (((const ::SharedArray<unsigned long>*)o)->size)();
}

static  void operator_13663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned long>::RWProxy)((((const ::SharedArray<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned long>::RWProxy)((((::SharedArray<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long>*)o)->Class)());
  else   (((::SharedArray<unsigned long>*)o)->Class)();
}

static  void method_13667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned long>*)o)->Class_Name)();
}

static  void method_13668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned long>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned long>*)o)->Class_Version)();
}

static  void method_13669( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned long>*)o)->Dictionary)();
}

static  void method_13670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned long>*)o)->IsA)();
}

static  void method_13671( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13672( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned long>*)o)->DeclFileName)();
}

static  void method_13675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned long>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned long>*)o)->ImplFileLine)();
}

static  void method_13676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned long>*)o)->ImplFileName)();
}

static  void method_13677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned long>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned long>*)o)->DeclFileLine)();
}

static void method_x94( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<long unsigned int> -------------------------------
void __SharedArray_unsignedslong__db_datamem(Reflex::Class*);
void __SharedArray_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedslong__datamem_bld(&__SharedArray_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedslong__funcmem_bld(&__SharedArray_unsignedslong__db_funcmem);
void __SharedArray_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned long>"), typeid(::SharedArray<unsigned long>), sizeof(::SharedArray<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13657, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31574), Reflex::Literal("SharedArray"), constructor_13658, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13660, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x94, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<long unsigned int> -------------------
void __SharedArray_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31160, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedslong_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<long unsigned int> -------------------
void __SharedArray_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31575, type_4138), Reflex::Literal("Clone"), method_13659, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31576, type_31574), Reflex::Literal("operator="), operator_13661, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13655c, type_211), Reflex::Literal("operator[]"), operator_13663, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13655, type_211), Reflex::Literal("operator[]"), operator_13664, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13666, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13667, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13668, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13669, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13670, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13671, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13672, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13673, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13674, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13675, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13676, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13677, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<unsigned int> -------------------------------
static void constructor_13682( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned int>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned int>(*(unsigned int*)arg[0]);
}

static void constructor_13683( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned int>(*(const ::SharedArray<unsigned int>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned int>(*(const ::SharedArray<unsigned int>*)arg[0]);
}

static  void method_13684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned int>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned int>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned int>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned int>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13685(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned int>*)o)->::SharedArray<unsigned int>::~SharedArray)();
}
static  void operator_13686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned int>*)o)->operator=)(*(const ::SharedArray<unsigned int>*)arg[0]);
  else   (((::SharedArray<unsigned int>*)o)->operator=)(*(const ::SharedArray<unsigned int>*)arg[0]);
}

static  void method_13687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned int>*)o)->size)());
  else   (((const ::SharedArray<unsigned int>*)o)->size)();
}

static  void operator_13688( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned int>::RWProxy)((((const ::SharedArray<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned int>::RWProxy)((((::SharedArray<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned int>*)o)->Class)());
  else   (((::SharedArray<unsigned int>*)o)->Class)();
}

static  void method_13692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned int>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned int>*)o)->Class_Name)();
}

static  void method_13693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned int>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned int>*)o)->Class_Version)();
}

static  void method_13694( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned int>*)o)->Dictionary)();
}

static  void method_13695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned int>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned int>*)o)->IsA)();
}

static  void method_13696( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned int>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13697( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned int>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13698( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned int>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned int>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned int>*)o)->DeclFileName)();
}

static  void method_13700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned int>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned int>*)o)->ImplFileLine)();
}

static  void method_13701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned int>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned int>*)o)->ImplFileName)();
}

static  void method_13702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned int>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned int>*)o)->DeclFileLine)();
}

static void method_x95( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned int>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<unsigned int> -------------------------------
void __SharedArray_unsignedsint__db_datamem(Reflex::Class*);
void __SharedArray_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedsint__datamem_bld(&__SharedArray_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedsint__funcmem_bld(&__SharedArray_unsignedsint__db_funcmem);
void __SharedArray_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned int>"), typeid(::SharedArray<unsigned int>), sizeof(::SharedArray<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned int>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13682, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31610), Reflex::Literal("SharedArray"), constructor_13683, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13685, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x95, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<unsigned int> -------------------
void __SharedArray_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31163, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedsint_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<unsigned int> -------------------
void __SharedArray_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31611, type_4138), Reflex::Literal("Clone"), method_13684, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31612, type_31610), Reflex::Literal("operator="), operator_13686, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13680c, type_211), Reflex::Literal("operator[]"), operator_13688, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13680, type_211), Reflex::Literal("operator[]"), operator_13689, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13691, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13692, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13693, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13694, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13695, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13696, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13697, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13698, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13699, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13700, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13701, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13702, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<short unsigned int> -------------------------------
static void constructor_13707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned short>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned short>(*(unsigned int*)arg[0]);
}

static void constructor_13708( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned short>(*(const ::SharedArray<unsigned short>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned short>(*(const ::SharedArray<unsigned short>*)arg[0]);
}

static  void method_13709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned short>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned short>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned short>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned short>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13710(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned short>*)o)->::SharedArray<unsigned short>::~SharedArray)();
}
static  void operator_13711( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned short>*)o)->operator=)(*(const ::SharedArray<unsigned short>*)arg[0]);
  else   (((::SharedArray<unsigned short>*)o)->operator=)(*(const ::SharedArray<unsigned short>*)arg[0]);
}

static  void method_13712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned short>*)o)->size)());
  else   (((const ::SharedArray<unsigned short>*)o)->size)();
}

static  void operator_13713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned short>::RWProxy)((((const ::SharedArray<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned short>::RWProxy)((((::SharedArray<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned short>*)o)->Class)());
  else   (((::SharedArray<unsigned short>*)o)->Class)();
}

static  void method_13717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned short>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned short>*)o)->Class_Name)();
}

static  void method_13718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned short>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned short>*)o)->Class_Version)();
}

static  void method_13719( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned short>*)o)->Dictionary)();
}

static  void method_13720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned short>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned short>*)o)->IsA)();
}

static  void method_13721( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned short>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13722( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned short>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13723( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned short>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned short>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned short>*)o)->DeclFileName)();
}

static  void method_13725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned short>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned short>*)o)->ImplFileLine)();
}

static  void method_13726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned short>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned short>*)o)->ImplFileName)();
}

static  void method_13727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned short>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned short>*)o)->DeclFileLine)();
}

static void method_x96( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned short>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<short unsigned int> -------------------------------
void __SharedArray_unsignedsshort__db_datamem(Reflex::Class*);
void __SharedArray_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedsshort__datamem_bld(&__SharedArray_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedsshort__funcmem_bld(&__SharedArray_unsignedsshort__db_funcmem);
void __SharedArray_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned short>"), typeid(::SharedArray<unsigned short>), sizeof(::SharedArray<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned short>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13707, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31646), Reflex::Literal("SharedArray"), constructor_13708, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13710, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x96, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedsshort__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedsshort__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<short unsigned int> -------------------
void __SharedArray_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31166, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedsshort_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<short unsigned int> -------------------
void __SharedArray_unsignedsshort__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31647, type_4138), Reflex::Literal("Clone"), method_13709, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31648, type_31646), Reflex::Literal("operator="), operator_13711, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13705c, type_211), Reflex::Literal("operator[]"), operator_13713, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13705, type_211), Reflex::Literal("operator[]"), operator_13714, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13716, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13717, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13718, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13719, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13720, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13721, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13722, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13723, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13724, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13725, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13726, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13727, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<unsigned char> -------------------------------
static void constructor_13732( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned char>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned char>(*(unsigned int*)arg[0]);
}

static void constructor_13733( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned char>(*(const ::SharedArray<unsigned char>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned char>(*(const ::SharedArray<unsigned char>*)arg[0]);
}

static  void method_13734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned char>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned char>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned char>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned char>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13735(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned char>*)o)->::SharedArray<unsigned char>::~SharedArray)();
}
static  void operator_13736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned char>*)o)->operator=)(*(const ::SharedArray<unsigned char>*)arg[0]);
  else   (((::SharedArray<unsigned char>*)o)->operator=)(*(const ::SharedArray<unsigned char>*)arg[0]);
}

static  void method_13737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned char>*)o)->size)());
  else   (((const ::SharedArray<unsigned char>*)o)->size)();
}

static  void operator_13738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned char>::RWProxy)((((const ::SharedArray<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned char>::RWProxy)((((::SharedArray<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned char>*)o)->Class)());
  else   (((::SharedArray<unsigned char>*)o)->Class)();
}

static  void method_13742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned char>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned char>*)o)->Class_Name)();
}

static  void method_13743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned char>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned char>*)o)->Class_Version)();
}

static  void method_13744( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned char>*)o)->Dictionary)();
}

static  void method_13745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned char>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned char>*)o)->IsA)();
}

static  void method_13746( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned char>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13747( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned char>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13748( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned char>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned char>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned char>*)o)->DeclFileName)();
}

static  void method_13750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned char>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned char>*)o)->ImplFileLine)();
}

static  void method_13751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned char>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned char>*)o)->ImplFileName)();
}

static  void method_13752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned char>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned char>*)o)->DeclFileLine)();
}

static void method_x97( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned char>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<unsigned char> -------------------------------
void __SharedArray_unsignedschar__db_datamem(Reflex::Class*);
void __SharedArray_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedschar__datamem_bld(&__SharedArray_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedschar__funcmem_bld(&__SharedArray_unsignedschar__db_funcmem);
void __SharedArray_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned char>"), typeid(::SharedArray<unsigned char>), sizeof(::SharedArray<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned char>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13732, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31682), Reflex::Literal("SharedArray"), constructor_13733, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13735, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x97, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedschar__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedschar__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<unsigned char> -------------------
void __SharedArray_unsignedschar__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31169, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedschar_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<unsigned char> -------------------
void __SharedArray_unsignedschar__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31683, type_4138), Reflex::Literal("Clone"), method_13734, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31684, type_31682), Reflex::Literal("operator="), operator_13736, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13730c, type_211), Reflex::Literal("operator[]"), operator_13738, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13730, type_211), Reflex::Literal("operator[]"), operator_13739, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13741, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13742, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13743, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13744, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13745, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13746, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13747, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13748, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13749, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13750, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13751, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13752, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<long long int> -------------------------------
static void constructor_13757( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<long long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<long long>(*(unsigned int*)arg[0]);
}

static void constructor_13758( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<long long>(*(const ::SharedArray<long long>*)arg[0]);
  else ::new(mem) ::SharedArray<long long>(*(const ::SharedArray<long long>*)arg[0]);
}

static  void method_13759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long long>*)o)->Clone)());
    else     (((const ::SharedArray<long long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<long long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13760(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<long long>*)o)->::SharedArray<long long>::~SharedArray)();
}
static  void operator_13761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<long long>*)o)->operator=)(*(const ::SharedArray<long long>*)arg[0]);
  else   (((::SharedArray<long long>*)o)->operator=)(*(const ::SharedArray<long long>*)arg[0]);
}

static  void method_13762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<long long>*)o)->size)());
  else   (((const ::SharedArray<long long>*)o)->size)();
}

static  void operator_13763( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<long long>::RWProxy)((((const ::SharedArray<long long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<long long>::RWProxy)((((::SharedArray<long long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long long>*)o)->Class)());
  else   (((::SharedArray<long long>*)o)->Class)();
}

static  void method_13767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long long>*)o)->Class_Name)());
  else   (((::SharedArray<long long>*)o)->Class_Name)();
}

static  void method_13768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<long long>*)o)->Class_Version)());
  else   (((::SharedArray<long long>*)o)->Class_Version)();
}

static  void method_13769( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<long long>*)o)->Dictionary)();
}

static  void method_13770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long long>*)o)->IsA)());
  else   (((const ::SharedArray<long long>*)o)->IsA)();
}

static  void method_13771( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13772( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13773( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long long>*)o)->DeclFileName)());
  else   (((::SharedArray<long long>*)o)->DeclFileName)();
}

static  void method_13775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<long long>*)o)->ImplFileLine)());
  else   (((::SharedArray<long long>*)o)->ImplFileLine)();
}

static  void method_13776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long long>*)o)->ImplFileName)());
  else   (((::SharedArray<long long>*)o)->ImplFileName)();
}

static  void method_13777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<long long>*)o)->DeclFileLine)());
  else   (((::SharedArray<long long>*)o)->DeclFileLine)();
}

static void method_x98( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<long long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<long long int> -------------------------------
void __SharedArray_longslong__db_datamem(Reflex::Class*);
void __SharedArray_longslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_longslong__datamem_bld(&__SharedArray_longslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_longslong__funcmem_bld(&__SharedArray_longslong__db_funcmem);
void __SharedArray_longslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<long long>"), typeid(::SharedArray<long long>), sizeof(::SharedArray<long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<long long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13757, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31718), Reflex::Literal("SharedArray"), constructor_13758, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13760, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x98, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_longslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_longslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<long long int> -------------------
void __SharedArray_longslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31172, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_longslong_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<long long int> -------------------
void __SharedArray_longslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31719, type_4138), Reflex::Literal("Clone"), method_13759, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31720, type_31718), Reflex::Literal("operator="), operator_13761, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13762, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13755c, type_211), Reflex::Literal("operator[]"), operator_13763, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13755, type_211), Reflex::Literal("operator[]"), operator_13764, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13766, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13767, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13768, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13769, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13770, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13771, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13772, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13773, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13774, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13775, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13776, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13777, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<long int> -------------------------------
static void constructor_13782( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<long>(*(unsigned int*)arg[0]);
}

static void constructor_13783( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<long>(*(const ::SharedArray<long>*)arg[0]);
  else ::new(mem) ::SharedArray<long>(*(const ::SharedArray<long>*)arg[0]);
}

static  void method_13784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long>*)o)->Clone)());
    else     (((const ::SharedArray<long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13785(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<long>*)o)->::SharedArray<long>::~SharedArray)();
}
static  void operator_13786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<long>*)o)->operator=)(*(const ::SharedArray<long>*)arg[0]);
  else   (((::SharedArray<long>*)o)->operator=)(*(const ::SharedArray<long>*)arg[0]);
}

static  void method_13787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<long>*)o)->size)());
  else   (((const ::SharedArray<long>*)o)->size)();
}

static  void operator_13788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<long>::RWProxy)((((const ::SharedArray<long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<long>::RWProxy)((((::SharedArray<long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long>*)o)->Class)());
  else   (((::SharedArray<long>*)o)->Class)();
}

static  void method_13792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long>*)o)->Class_Name)());
  else   (((::SharedArray<long>*)o)->Class_Name)();
}

static  void method_13793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<long>*)o)->Class_Version)());
  else   (((::SharedArray<long>*)o)->Class_Version)();
}

static  void method_13794( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<long>*)o)->Dictionary)();
}

static  void method_13795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long>*)o)->IsA)());
  else   (((const ::SharedArray<long>*)o)->IsA)();
}

static  void method_13796( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long>*)o)->DeclFileName)());
  else   (((::SharedArray<long>*)o)->DeclFileName)();
}

static  void method_13800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<long>*)o)->ImplFileLine)());
  else   (((::SharedArray<long>*)o)->ImplFileLine)();
}

static  void method_13801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long>*)o)->ImplFileName)());
  else   (((::SharedArray<long>*)o)->ImplFileName)();
}

static  void method_13802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<long>*)o)->DeclFileLine)());
  else   (((::SharedArray<long>*)o)->DeclFileLine)();
}

static void method_x99( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<long int> -------------------------------
void __SharedArray_long__db_datamem(Reflex::Class*);
void __SharedArray_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_long__datamem_bld(&__SharedArray_long__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_long__funcmem_bld(&__SharedArray_long__db_funcmem);
void __SharedArray_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<long>"), typeid(::SharedArray<long>), sizeof(::SharedArray<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13782, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31754), Reflex::Literal("SharedArray"), constructor_13783, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13785, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x99, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_long__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_long__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<long int> -------------------
void __SharedArray_long__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31175, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_long_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<long int> -------------------
void __SharedArray_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31755, type_4138), Reflex::Literal("Clone"), method_13784, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31756, type_31754), Reflex::Literal("operator="), operator_13786, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13780c, type_211), Reflex::Literal("operator[]"), operator_13788, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13780, type_211), Reflex::Literal("operator[]"), operator_13789, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13791, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13792, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13793, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13794, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13795, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13796, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13797, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13798, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13799, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13800, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13801, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13802, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<int> -------------------------------
static void constructor_13807( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<int>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<int>(*(unsigned int*)arg[0]);
}

static void constructor_13808( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<int>(*(const ::SharedArray<int>*)arg[0]);
  else ::new(mem) ::SharedArray<int>(*(const ::SharedArray<int>*)arg[0]);
}

static  void method_13809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<int>*)o)->Clone)());
    else     (((const ::SharedArray<int>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<int>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<int>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13810(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<int>*)o)->::SharedArray<int>::~SharedArray)();
}
static  void operator_13811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<int>*)o)->operator=)(*(const ::SharedArray<int>*)arg[0]);
  else   (((::SharedArray<int>*)o)->operator=)(*(const ::SharedArray<int>*)arg[0]);
}

static  void method_13812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<int>*)o)->size)());
  else   (((const ::SharedArray<int>*)o)->size)();
}

static  void operator_13813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<int>::RWProxy)((((const ::SharedArray<int>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<int>::RWProxy)((((::SharedArray<int>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<int>*)o)->Class)());
  else   (((::SharedArray<int>*)o)->Class)();
}

static  void method_13817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<int>*)o)->Class_Name)());
  else   (((::SharedArray<int>*)o)->Class_Name)();
}

static  void method_13818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<int>*)o)->Class_Version)());
  else   (((::SharedArray<int>*)o)->Class_Version)();
}

static  void method_13819( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<int>*)o)->Dictionary)();
}

static  void method_13820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<int>*)o)->IsA)());
  else   (((const ::SharedArray<int>*)o)->IsA)();
}

static  void method_13821( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<int>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<int>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13823( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<int>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<int>*)o)->DeclFileName)());
  else   (((::SharedArray<int>*)o)->DeclFileName)();
}

static  void method_13825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<int>*)o)->ImplFileLine)());
  else   (((::SharedArray<int>*)o)->ImplFileLine)();
}

static  void method_13826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<int>*)o)->ImplFileName)());
  else   (((::SharedArray<int>*)o)->ImplFileName)();
}

static  void method_13827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<int>*)o)->DeclFileLine)());
  else   (((::SharedArray<int>*)o)->DeclFileLine)();
}

static void method_x100( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<int>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<int> -------------------------------
void __SharedArray_int__db_datamem(Reflex::Class*);
void __SharedArray_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_int__datamem_bld(&__SharedArray_int__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_int__funcmem_bld(&__SharedArray_int__db_funcmem);
void __SharedArray_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<int>"), typeid(::SharedArray<int>), sizeof(::SharedArray<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<int>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13807, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31790), Reflex::Literal("SharedArray"), constructor_13808, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13810, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_int__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<int> -------------------
void __SharedArray_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31178, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_int_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<int> -------------------
void __SharedArray_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31791, type_4138), Reflex::Literal("Clone"), method_13809, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31792, type_31790), Reflex::Literal("operator="), operator_13811, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13805c, type_211), Reflex::Literal("operator[]"), operator_13813, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13805, type_211), Reflex::Literal("operator[]"), operator_13814, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13816, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13817, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13818, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13819, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13820, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13821, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13822, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13823, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13824, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13825, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13826, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13827, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<short int> -------------------------------
static void constructor_13832( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<short>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<short>(*(unsigned int*)arg[0]);
}

static void constructor_13833( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<short>(*(const ::SharedArray<short>*)arg[0]);
  else ::new(mem) ::SharedArray<short>(*(const ::SharedArray<short>*)arg[0]);
}

static  void method_13834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<short>*)o)->Clone)());
    else     (((const ::SharedArray<short>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<short>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<short>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13835(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<short>*)o)->::SharedArray<short>::~SharedArray)();
}
static  void operator_13836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<short>*)o)->operator=)(*(const ::SharedArray<short>*)arg[0]);
  else   (((::SharedArray<short>*)o)->operator=)(*(const ::SharedArray<short>*)arg[0]);
}

static  void method_13837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<short>*)o)->size)());
  else   (((const ::SharedArray<short>*)o)->size)();
}

static  void operator_13838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<short>::RWProxy)((((const ::SharedArray<short>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<short>::RWProxy)((((::SharedArray<short>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<short>*)o)->Class)());
  else   (((::SharedArray<short>*)o)->Class)();
}

static  void method_13842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<short>*)o)->Class_Name)());
  else   (((::SharedArray<short>*)o)->Class_Name)();
}

static  void method_13843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<short>*)o)->Class_Version)());
  else   (((::SharedArray<short>*)o)->Class_Version)();
}

static  void method_13844( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<short>*)o)->Dictionary)();
}

static  void method_13845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<short>*)o)->IsA)());
  else   (((const ::SharedArray<short>*)o)->IsA)();
}

static  void method_13846( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<short>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<short>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13848( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<short>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<short>*)o)->DeclFileName)());
  else   (((::SharedArray<short>*)o)->DeclFileName)();
}

static  void method_13850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<short>*)o)->ImplFileLine)());
  else   (((::SharedArray<short>*)o)->ImplFileLine)();
}

static  void method_13851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<short>*)o)->ImplFileName)());
  else   (((::SharedArray<short>*)o)->ImplFileName)();
}

static  void method_13852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<short>*)o)->DeclFileLine)());
  else   (((::SharedArray<short>*)o)->DeclFileLine)();
}

static void method_x101( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<short>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<short int> -------------------------------
void __SharedArray_short__db_datamem(Reflex::Class*);
void __SharedArray_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_short__datamem_bld(&__SharedArray_short__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_short__funcmem_bld(&__SharedArray_short__db_funcmem);
void __SharedArray_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<short>"), typeid(::SharedArray<short>), sizeof(::SharedArray<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<short>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13832, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31826), Reflex::Literal("SharedArray"), constructor_13833, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13835, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_short__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_short__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<short int> -------------------
void __SharedArray_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31181, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_short_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<short int> -------------------
void __SharedArray_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31827, type_4138), Reflex::Literal("Clone"), method_13834, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31828, type_31826), Reflex::Literal("operator="), operator_13836, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13830c, type_211), Reflex::Literal("operator[]"), operator_13838, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13830, type_211), Reflex::Literal("operator[]"), operator_13839, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13841, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13842, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13843, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13844, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13845, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13846, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13847, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13848, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13849, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13850, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13851, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13852, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<char> -------------------------------
static void constructor_13857( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<char>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<char>(*(unsigned int*)arg[0]);
}

static void constructor_13858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<char>(*(const ::SharedArray<char>*)arg[0]);
  else ::new(mem) ::SharedArray<char>(*(const ::SharedArray<char>*)arg[0]);
}

static  void method_13859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<char>*)o)->Clone)());
    else     (((const ::SharedArray<char>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<char>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<char>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13860(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<char>*)o)->::SharedArray<char>::~SharedArray)();
}
static  void operator_13861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<char>*)o)->operator=)(*(const ::SharedArray<char>*)arg[0]);
  else   (((::SharedArray<char>*)o)->operator=)(*(const ::SharedArray<char>*)arg[0]);
}

static  void method_13862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<char>*)o)->size)());
  else   (((const ::SharedArray<char>*)o)->size)();
}

static  void operator_13863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<char>::RWProxy)((((const ::SharedArray<char>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<char>::RWProxy)((((::SharedArray<char>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<char>*)o)->Class)());
  else   (((::SharedArray<char>*)o)->Class)();
}

static  void method_13867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<char>*)o)->Class_Name)());
  else   (((::SharedArray<char>*)o)->Class_Name)();
}

static  void method_13868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<char>*)o)->Class_Version)());
  else   (((::SharedArray<char>*)o)->Class_Version)();
}

static  void method_13869( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<char>*)o)->Dictionary)();
}

static  void method_13870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<char>*)o)->IsA)());
  else   (((const ::SharedArray<char>*)o)->IsA)();
}

static  void method_13871( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<char>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<char>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13873( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<char>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<char>*)o)->DeclFileName)());
  else   (((::SharedArray<char>*)o)->DeclFileName)();
}

static  void method_13875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<char>*)o)->ImplFileLine)());
  else   (((::SharedArray<char>*)o)->ImplFileLine)();
}

static  void method_13876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<char>*)o)->ImplFileName)());
  else   (((::SharedArray<char>*)o)->ImplFileName)();
}

static  void method_13877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<char>*)o)->DeclFileLine)());
  else   (((::SharedArray<char>*)o)->DeclFileLine)();
}

static void method_x102( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<char>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<char> -------------------------------
void __SharedArray_char__db_datamem(Reflex::Class*);
void __SharedArray_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_char__datamem_bld(&__SharedArray_char__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_char__funcmem_bld(&__SharedArray_char__db_funcmem);
void __SharedArray_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<char>"), typeid(::SharedArray<char>), sizeof(::SharedArray<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<char>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13857, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31862), Reflex::Literal("SharedArray"), constructor_13858, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13860, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x102, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_char__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<char> -------------------
void __SharedArray_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31184, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_char_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<char> -------------------
void __SharedArray_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31863, type_4138), Reflex::Literal("Clone"), method_13859, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31864, type_31862), Reflex::Literal("operator="), operator_13861, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13855c, type_211), Reflex::Literal("operator[]"), operator_13863, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13855, type_211), Reflex::Literal("operator[]"), operator_13864, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13866, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13867, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13868, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13869, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13870, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13871, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13872, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13873, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13874, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13875, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13876, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13877, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IfThreeWay -------------------------------
static  void operator_13914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IfThreeWay*)o)->operator=)(*(const ::IfThreeWay*)arg[0]);
  else   (((::IfThreeWay*)o)->operator=)(*(const ::IfThreeWay*)arg[0]);
}

static void constructor_13915( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWay();
  else ::new(mem) ::IfThreeWay();
}

static void constructor_13916( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWay((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::IfThreeWay((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_13917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWay(*(const ::IfThreeWay*)arg[0]);
  else ::new(mem) ::IfThreeWay(*(const ::IfThreeWay*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWay(*(const ::IfThreeWay*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::IfThreeWay(*(const ::IfThreeWay*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_13918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWay*)o)->clone)((const char*)arg[0]));
  else   (((const ::IfThreeWay*)o)->clone)((const char*)arg[0]);
}

static void destructor_13919(void*, void * o, const std::vector<void*>&, void *) {
(((::IfThreeWay*)o)->::IfThreeWay::~IfThreeWay)();
}
static  void method_13921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWay*)o)->Class)());
  else   (((::IfThreeWay*)o)->Class)();
}

static  void method_13922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWay*)o)->Class_Name)());
  else   (((::IfThreeWay*)o)->Class_Name)();
}

static  void method_13923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::IfThreeWay*)o)->Class_Version)());
  else   (((::IfThreeWay*)o)->Class_Version)();
}

static  void method_13924( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IfThreeWay*)o)->Dictionary)();
}

static  void method_13925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWay*)o)->IsA)());
  else   (((const ::IfThreeWay*)o)->IsA)();
}

static  void method_13926( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWay*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13927( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWay*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13928( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWay*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWay*)o)->DeclFileName)());
  else   (((::IfThreeWay*)o)->DeclFileName)();
}

static  void method_13930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWay*)o)->ImplFileLine)());
  else   (((::IfThreeWay*)o)->ImplFileLine)();
}

static  void method_13931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWay*)o)->ImplFileName)());
  else   (((::IfThreeWay*)o)->ImplFileName)();
}

static  void method_13932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWay*)o)->DeclFileLine)());
  else   (((::IfThreeWay*)o)->DeclFileLine)();
}

static void method_newdel_2231( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::IfThreeWay,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::IfThreeWay,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::IfThreeWay,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::IfThreeWay,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::IfThreeWay,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IfThreeWay -------------------------------
void __IfThreeWay_db_datamem(Reflex::Class*);
void __IfThreeWay_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IfThreeWay_datamem_bld(&__IfThreeWay_db_datamem);
Reflex::GenreflexMemberBuilder __IfThreeWay_funcmem_bld(&__IfThreeWay_db_funcmem);
void __IfThreeWay_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IfThreeWay"), typeid(::IfThreeWay), sizeof(::IfThreeWay), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::IfThreeWay::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::IfThreeWay, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31869, type_31870), Reflex::Literal("operator="), operator_13914, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IfThreeWay"), constructor_13915, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("IfThreeWay"), constructor_13916, 0, "name;title;_cond;_pos;_zero;_neg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31870, type_4138), Reflex::Literal("IfThreeWay"), constructor_13917, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IfThreeWay"), destructor_13919, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2231, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IfThreeWay_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IfThreeWay_funcmem_bld);
}

//------Delayed data member builder for class IfThreeWay -------------------
void __IfThreeWay_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("cond"), OffsetOf(__shadow__::__IfThreeWay, cond), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("pos"), OffsetOf(__shadow__::__IfThreeWay, pos), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("zero"), OffsetOf(__shadow__::__IfThreeWay, zero), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("neg"), OffsetOf(__shadow__::__IfThreeWay, neg), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class IfThreeWay -------------------
void __IfThreeWay_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_13918, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_13921, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_13922, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13923, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13924, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_13925, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_13926, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_13927, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_13928, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_13929, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13930, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_13931, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13932, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooCruijff -------------------------------
static  void operator_14366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCruijff*)o)->operator=)(*(const ::RooCruijff*)arg[0]);
  else   (((::RooCruijff*)o)->operator=)(*(const ::RooCruijff*)arg[0]);
}

static void constructor_14367( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCruijff();
  else ::new(mem) ::RooCruijff();
}

static void constructor_14368( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCruijff((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
  else ::new(mem) ::RooCruijff((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
}

static void constructor_14369( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCruijff(*(const ::RooCruijff*)arg[0]);
  else ::new(mem) ::RooCruijff(*(const ::RooCruijff*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCruijff(*(const ::RooCruijff*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooCruijff(*(const ::RooCruijff*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_14370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCruijff*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooCruijff*)o)->clone)((const char*)arg[0]);
}

static void destructor_14371(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCruijff*)o)->::RooCruijff::~RooCruijff)();
}
static  void method_14373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCruijff*)o)->Class)());
  else   (((::RooCruijff*)o)->Class)();
}

static  void method_14374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCruijff*)o)->Class_Name)());
  else   (((::RooCruijff*)o)->Class_Name)();
}

static  void method_14375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooCruijff*)o)->Class_Version)());
  else   (((::RooCruijff*)o)->Class_Version)();
}

static  void method_14376( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooCruijff*)o)->Dictionary)();
}

static  void method_14377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCruijff*)o)->IsA)());
  else   (((const ::RooCruijff*)o)->IsA)();
}

static  void method_14378( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCruijff*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_14379( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCruijff*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_14380( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCruijff*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_14381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCruijff*)o)->DeclFileName)());
  else   (((::RooCruijff*)o)->DeclFileName)();
}

static  void method_14382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCruijff*)o)->ImplFileLine)());
  else   (((::RooCruijff*)o)->ImplFileLine)();
}

static  void method_14383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCruijff*)o)->ImplFileName)());
  else   (((::RooCruijff*)o)->ImplFileName)();
}

static  void method_14384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCruijff*)o)->DeclFileLine)());
  else   (((::RooCruijff*)o)->DeclFileLine)();
}

static void method_newdel_2502( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooCruijff >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooCruijff >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooCruijff >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooCruijff >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooCruijff >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x106( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooCruijff,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooCruijff,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooCruijff,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooCruijff,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooCruijff,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooCruijff,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooCruijff -------------------------------
void __RooCruijff_db_datamem(Reflex::Class*);
void __RooCruijff_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCruijff_datamem_bld(&__RooCruijff_db_datamem);
Reflex::GenreflexMemberBuilder __RooCruijff_funcmem_bld(&__RooCruijff_db_funcmem);
void __RooCruijff_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCruijff"), typeid(::RooCruijff), sizeof(::RooCruijff), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooCruijff::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooCruijff, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31921, type_31922), Reflex::Literal("operator="), operator_14366, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooCruijff"), constructor_14367, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("RooCruijff"), constructor_14368, 0, "name;title;_x;_m0;_sigmaL;_sigmaR;_alphaL;_alphaR", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31922, type_4138), Reflex::Literal("RooCruijff"), constructor_14369, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooCruijff"), destructor_14371, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2502, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooCruijff_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCruijff_funcmem_bld);
}

//------Delayed data member builder for class RooCruijff -------------------
void __RooCruijff_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooCruijff, x), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("m0"), OffsetOf(__shadow__::__RooCruijff, m0), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("sigmaL"), OffsetOf(__shadow__::__RooCruijff, sigmaL), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("sigmaR"), OffsetOf(__shadow__::__RooCruijff, sigmaR), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("alphaL"), OffsetOf(__shadow__::__RooCruijff, alphaL), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("alphaR"), OffsetOf(__shadow__::__RooCruijff, alphaR), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooCruijff -------------------
void __RooCruijff_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_14370, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_14373, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_14374, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_14375, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_14376, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_14377, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_14378, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_14379, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_14380, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_14381, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_14382, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_14383, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_14384, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class CombBkgPTPdf -------------------------------
static  void operator_14720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CombBkgPTPdf*)o)->operator=)(*(const ::CombBkgPTPdf*)arg[0]);
  else   (((::CombBkgPTPdf*)o)->operator=)(*(const ::CombBkgPTPdf*)arg[0]);
}

static void constructor_14721( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CombBkgPTPdf();
  else ::new(mem) ::CombBkgPTPdf();
}

static void constructor_14722( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CombBkgPTPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
  else ::new(mem) ::CombBkgPTPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
}

static void constructor_14723( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::CombBkgPTPdf(*(const ::CombBkgPTPdf*)arg[0]);
  else ::new(mem) ::CombBkgPTPdf(*(const ::CombBkgPTPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::CombBkgPTPdf(*(const ::CombBkgPTPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::CombBkgPTPdf(*(const ::CombBkgPTPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_14724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::CombBkgPTPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::CombBkgPTPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_14725(void*, void * o, const std::vector<void*>&, void *) {
(((::CombBkgPTPdf*)o)->::CombBkgPTPdf::~CombBkgPTPdf)();
}
static  void method_14726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::CombBkgPTPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::CombBkgPTPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_14727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::CombBkgPTPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::CombBkgPTPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_14730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CombBkgPTPdf*)o)->Class)());
  else   (((::CombBkgPTPdf*)o)->Class)();
}

static  void method_14731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CombBkgPTPdf*)o)->Class_Name)());
  else   (((::CombBkgPTPdf*)o)->Class_Name)();
}

static  void method_14732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::CombBkgPTPdf*)o)->Class_Version)());
  else   (((::CombBkgPTPdf*)o)->Class_Version)();
}

static  void method_14733( void*, void* o, const std::vector<void*>&, void*)
{
  (((::CombBkgPTPdf*)o)->Dictionary)();
}

static  void method_14734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::CombBkgPTPdf*)o)->IsA)());
  else   (((const ::CombBkgPTPdf*)o)->IsA)();
}

static  void method_14735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CombBkgPTPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_14736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CombBkgPTPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_14737( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CombBkgPTPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_14738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CombBkgPTPdf*)o)->DeclFileName)());
  else   (((::CombBkgPTPdf*)o)->DeclFileName)();
}

static  void method_14739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::CombBkgPTPdf*)o)->ImplFileLine)());
  else   (((::CombBkgPTPdf*)o)->ImplFileLine)();
}

static  void method_14740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CombBkgPTPdf*)o)->ImplFileName)());
  else   (((::CombBkgPTPdf*)o)->ImplFileName)();
}

static  void method_14741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::CombBkgPTPdf*)o)->DeclFileLine)());
  else   (((::CombBkgPTPdf*)o)->DeclFileLine)();
}

static void method_newdel_2590( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x108( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CombBkgPTPdf -------------------------------
void __CombBkgPTPdf_db_datamem(Reflex::Class*);
void __CombBkgPTPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CombBkgPTPdf_datamem_bld(&__CombBkgPTPdf_db_datamem);
Reflex::GenreflexMemberBuilder __CombBkgPTPdf_funcmem_bld(&__CombBkgPTPdf_db_funcmem);
void __CombBkgPTPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CombBkgPTPdf"), typeid(::CombBkgPTPdf), sizeof(::CombBkgPTPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::CombBkgPTPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::CombBkgPTPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31986, type_31987), Reflex::Literal("operator="), operator_14720, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CombBkgPTPdf"), constructor_14721, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27793, type_27793, type_27793, type_27793, type_27793), Reflex::Literal("CombBkgPTPdf"), constructor_14722, 0, "name;title;_t;_a;_f;_alpha;_beta", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31987, type_4138), Reflex::Literal("CombBkgPTPdf"), constructor_14723, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CombBkgPTPdf"), destructor_14725, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2590, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x108, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CombBkgPTPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CombBkgPTPdf_funcmem_bld);
}

//------Delayed data member builder for class CombBkgPTPdf -------------------
void __CombBkgPTPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("t"), OffsetOf(__shadow__::__CombBkgPTPdf, t), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("a"), OffsetOf(__shadow__::__CombBkgPTPdf, a), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("f"), OffsetOf(__shadow__::__CombBkgPTPdf, f), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("alpha"), OffsetOf(__shadow__::__CombBkgPTPdf, alpha), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("beta"), OffsetOf(__shadow__::__CombBkgPTPdf, beta), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class CombBkgPTPdf -------------------
void __CombBkgPTPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25556, type_4138), Reflex::Literal("clone"), method_14724, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_14726, 0, "allVars;integVars;range", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_14727, 0, "code;range", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_14730, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_14731, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_14732, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_14733, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_14734, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_14735, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_14736, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_14737, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_14738, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_14739, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_14740, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_14741, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinnedFun -------------------------------
static  void operator_15387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinnedFun*)o)->operator=)(*(const ::RooBinnedFun*)arg[0]);
  else   (((::RooBinnedFun*)o)->operator=)(*(const ::RooBinnedFun*)arg[0]);
}

static void constructor_15388( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun();
  else ::new(mem) ::RooBinnedFun();
}

static void constructor_15389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
}

static void constructor_15390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3]);
  else ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(bool*)arg[4]);
  }
}

static void destructor_15391(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinnedFun*)o)->::RooBinnedFun::~RooBinnedFun)();
}
static void constructor_15392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun(*(const ::RooBinnedFun*)arg[0]);
  else ::new(mem) ::RooBinnedFun(*(const ::RooBinnedFun*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun(*(const ::RooBinnedFun*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinnedFun(*(const ::RooBinnedFun*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_15393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedFun*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooBinnedFun*)o)->clone)((const char*)arg[0]);
}

static  void method_15394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedFun*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::RooBinnedFun*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_15395( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedFun*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::RooBinnedFun*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_15396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedFun*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinnedFun*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_15397( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedFun*)o)->maxVal)(*(::Int_t*)arg[0]));
  else   (((const ::RooBinnedFun*)o)->maxVal)(*(::Int_t*)arg[0]);
}

static  void method_15398( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedFun*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinnedFun*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_15399( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::complex<double>)((((const ::RooBinnedFun*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]));
  else   (((const ::RooBinnedFun*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]);
}

static  void method_15400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooBinnedFun*)o)->coefficients)();
  else   (((const ::RooBinnedFun*)o)->coefficients)();
}

static  void method_15402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedFun*)o)->Class)());
  else   (((::RooBinnedFun*)o)->Class)();
}

static  void method_15403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedFun*)o)->Class_Name)());
  else   (((::RooBinnedFun*)o)->Class_Name)();
}

static  void method_15404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinnedFun*)o)->Class_Version)());
  else   (((::RooBinnedFun*)o)->Class_Version)();
}

static  void method_15405( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinnedFun*)o)->Dictionary)();
}

static  void method_15406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedFun*)o)->IsA)());
  else   (((const ::RooBinnedFun*)o)->IsA)();
}

static  void method_15407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedFun*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_15408( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedFun*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_15409( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedFun*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_15410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedFun*)o)->DeclFileName)());
  else   (((::RooBinnedFun*)o)->DeclFileName)();
}

static  void method_15411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinnedFun*)o)->ImplFileLine)());
  else   (((::RooBinnedFun*)o)->ImplFileLine)();
}

static  void method_15412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedFun*)o)->ImplFileName)());
  else   (((::RooBinnedFun*)o)->ImplFileName)();
}

static  void method_15413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinnedFun*)o)->DeclFileLine)());
  else   (((::RooBinnedFun*)o)->DeclFileLine)();
}

static void method_newdel_2744( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGaussModelEfficiency")), ::Reflex::BaseOffset< ::RooBinnedFun,::RooAbsGaussModelEfficiency >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinnedFun,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinnedFun,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinnedFun,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinnedFun,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinnedFun,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinnedFun -------------------------------
void __RooBinnedFun_db_datamem(Reflex::Class*);
void __RooBinnedFun_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinnedFun_datamem_bld(&__RooBinnedFun_db_datamem);
Reflex::GenreflexMemberBuilder __RooBinnedFun_funcmem_bld(&__RooBinnedFun_db_funcmem);
void __RooBinnedFun_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinnedFun"), typeid(::RooBinnedFun), sizeof(::RooBinnedFun), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinnedFun::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1672, ::Reflex::BaseOffset< ::RooBinnedFun, ::RooAbsGaussModelEfficiency >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32060, type_32061), Reflex::Literal("operator="), operator_15387, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinnedFun"), constructor_15388, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_4138, type_27954), Reflex::Literal("RooBinnedFun"), constructor_15389, 0, "name;title;x;binningName;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4138, type_4138, type_27803, type_28266, type_667), Reflex::Literal("RooBinnedFun"), constructor_15390, 0, "name;title;x;hist;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinnedFun"), destructor_15391, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32061, type_4138), Reflex::Literal("RooBinnedFun"), constructor_15392, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2744, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinnedFun_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinnedFun_funcmem_bld);
}

//------Delayed data member builder for class RooBinnedFun -------------------
void __RooBinnedFun_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("_x"), OffsetOf(__shadow__::__RooBinnedFun, _x), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("_coefList"), OffsetOf(__shadow__::__RooBinnedFun, _coefList), ::Reflex::PRIVATE)
  .AddDataMember(type_3092, Reflex::Literal("_u"), OffsetOf(__shadow__::__RooBinnedFun, _u), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinnedFun -------------------
void __RooBinnedFun_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32062, type_4138), Reflex::Literal("clone"), method_15393, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27811, type_27811, type_4138), Reflex::Literal("getAnalyticalIntegral"), method_15394, 0, "allVars;analVars;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4138), Reflex::Literal("analyticalIntegral"), method_15395, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27806), Reflex::Literal("getMaxVal"), method_15396, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("maxVal"), method_15397, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27882, type_27883, type_2317, type_2317), Reflex::Literal("binBoundaries"), method_15398, 0, "obs;xlo;xhi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3638, type_2317, type_2317, type_2317, type_2317, type_22832), Reflex::Literal("productAnalyticalIntegral"), method_15399, 0, "umin;umax;scale;offset;z", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27954), Reflex::Literal("coefficients"), method_15400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("Class"), method_15402, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("Class_Name"), method_15403, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_15404, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_15405, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8028), Reflex::Literal("IsA"), method_15406, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27794), Reflex::Literal("ShowMembers"), method_15407, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("Streamer"), method_15408, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6055), Reflex::Literal("StreamerNVirtual"), method_15409, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("DeclFileName"), method_15410, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_15411, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("ImplFileName"), method_15412, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_15413, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<double,std::allocator<double> > -------------------------------
static void constructor_17977( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>();
  else ::new(mem) ::std::vector<double>();
}

static void constructor_17978( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(const ::std::allocator<double>*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(const ::std::allocator<double>*)arg[0]);
}

static void constructor_17979( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1],
      *(const ::std::allocator<double>*)arg[2]);
  else ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1],
      *(const ::std::allocator<double>*)arg[2]);
  }
}

static void constructor_17980( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(const ::std::vector<double>*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(const ::std::vector<double>*)arg[0]);
}

static void destructor_17981(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<double>*)o)->::std::vector<double>::~vector)();
}
static  void operator_17982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
  else   (((::std::vector<double>*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_17983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const double*)arg[1]);
}

static  void method_17984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->begin)());
  else   (((::std::vector<double>*)o)->begin)();
}

static  void method_17985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::std::vector<double>*)o)->begin)());
  else   (((const ::std::vector<double>*)o)->begin)();
}

static  void method_17986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->end)());
  else   (((::std::vector<double>*)o)->end)();
}

static  void method_17987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::std::vector<double>*)o)->end)());
  else   (((const ::std::vector<double>*)o)->end)();
}

static  void method_17992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<double>*)o)->size)());
  else   (((const ::std::vector<double>*)o)->size)();
}

static  void method_17993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<double>*)o)->max_size)());
  else   (((const ::std::vector<double>*)o)->max_size)();
}

static  void method_17994( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<double>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<double>*)o)->resize)(*(::std::size_t*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_17995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<double>*)o)->capacity)());
  else   (((const ::std::vector<double>*)o)->capacity)();
}

static  void method_17996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<double>*)o)->empty)());
  else   (((const ::std::vector<double>*)o)->empty)();
}

static  void method_17997( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_17998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_17999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->front)();
  else   (((::std::vector<double>*)o)->front)();
}

static  void method_18004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->front)();
  else   (((const ::std::vector<double>*)o)->front)();
}

static  void method_18005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->back)();
  else   (((::std::vector<double>*)o)->back)();
}

static  void method_18006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->back)();
  else   (((const ::std::vector<double>*)o)->back)();
}

static  void method_18007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<double>*)o)->data)());
  else   (((::std::vector<double>*)o)->data)();
}

static  void method_18008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<double>*)o)->data)());
  else   (((const ::std::vector<double>*)o)->data)();
}

static  void method_18009( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->push_back)(*(const double*)arg[0]);
}

static  void method_18010( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<double>*)o)->pop_back)();
}

static  void method_18011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(const double*)arg[1]));
  else   (((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(const double*)arg[1]);
}

static  void method_18012( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const double*)arg[2]);
}

static  void method_18013( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0]));
  else   (((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0]);
}

static  void method_18014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[1]));
  else   (((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[1]);
}

static  void method_18015( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->swap)(*(::std::vector<double>*)arg[0]);
}

static  void method_18016( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<double>*)o)->clear)();
}

static void method_newdel_3092( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<double,std::allocator<double> >")), ::Reflex::BaseOffset< ::std::vector<double>,::std::_Vector_base<double,std::allocator<double> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<double> >::Generate();
  else ::Reflex::Proxy< ::std::vector<double> >::Generate();
}

//------Dictionary for class vector<double,std::allocator<double> > -------------------------------
void __std__vector_double__db_datamem(Reflex::Class*);
void __std__vector_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_double__datamem_bld(&__std__vector_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_double__funcmem_bld(&__std__vector_double__db_funcmem);
void __std__vector_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<double>"), typeid(::std::vector<double>), sizeof(::std::vector<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3041, ::Reflex::BaseOffset< ::std::vector<double>, ::std::_Vector_base<double,std::allocator<double> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_694, Reflex::Literal("std::vector<double>::_Alloc_value_type"))
  .AddTypedef(type_3041, Reflex::Literal("std::vector<double>::_Base"))
  .AddTypedef(type_3681, Reflex::Literal("std::vector<double>::_Tp_alloc_type"))
  .AddTypedef(type_11042, Reflex::Literal("std::vector<double>::_Alloc_traits"))
  .AddTypedef(type_694, Reflex::Literal("std::vector<double>::value_type"))
  .AddTypedef(type_6346, Reflex::Literal("std::vector<double>::pointer"))
  .AddTypedef(type_17964, Reflex::Literal("std::vector<double>::const_pointer"))
  .AddTypedef(type_17966, Reflex::Literal("std::vector<double>::reference"))
  .AddTypedef(type_17968, Reflex::Literal("std::vector<double>::const_reference"))
  .AddTypedef(type_10888, Reflex::Literal("std::vector<double>::iterator"))
  .AddTypedef(type_10889, Reflex::Literal("std::vector<double>::const_iterator"))
  .AddTypedef(type_3950, Reflex::Literal("std::vector<double>::const_reverse_iterator"))
  .AddTypedef(type_3951, Reflex::Literal("std::vector<double>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<double>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<double>::difference_type"))
  .AddTypedef(type_3681, Reflex::Literal("std::vector<double>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_17977, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32471), Reflex::Literal("vector"), constructor_17978, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_17968, type_32471), Reflex::Literal("vector"), constructor_17979, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19008), Reflex::Literal("vector"), constructor_17980, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_17981, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3092, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_double__funcmem_bld);
}

//------Delayed data member builder for class vector<double,std::allocator<double> > -------------------
void __std__vector_double__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<double,std::allocator<double> > -------------------
void __std__vector_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19006, type_19008), Reflex::Literal("operator="), operator_17982, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_17968), Reflex::Literal("assign"), method_17983, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888), Reflex::Literal("begin"), method_17984, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10889), Reflex::Literal("begin"), method_17985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888), Reflex::Literal("end"), method_17986, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10889), Reflex::Literal("end"), method_17987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_17992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_17993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_694), Reflex::Literal("resize"), method_17994, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_17995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_17996, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_17997, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17966, type_3405), Reflex::Literal("operator[]"), operator_17998, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17968, type_3405), Reflex::Literal("operator[]"), operator_17999, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17966, type_3405), Reflex::Literal("at"), method_18001, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17968, type_3405), Reflex::Literal("at"), method_18002, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17966), Reflex::Literal("front"), method_18003, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17968), Reflex::Literal("front"), method_18004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17966), Reflex::Literal("back"), method_18005, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17968), Reflex::Literal("back"), method_18006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6346), Reflex::Literal("data"), method_18007, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17964), Reflex::Literal("data"), method_18008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_17968), Reflex::Literal("push_back"), method_18009, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18010, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888, type_10888, type_17968), Reflex::Literal("insert"), method_18011, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10888, type_3405, type_17968), Reflex::Literal("insert"), method_18012, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888, type_10888), Reflex::Literal("erase"), method_18013, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888, type_10888, type_10888), Reflex::Literal("erase"), method_18014, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19006), Reflex::Literal("swap"), method_18015, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18016, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class S_jk -------------------------------
static void destructor_28337(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineKnot::S_jk*)o)->::RooCubicSplineKnot::S_jk::~S_jk)();
}
static  void operator_28338( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static void constructor_28339( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_jk();
  else ::new(mem) ::RooCubicSplineKnot::S_jk();
}

static void constructor_28340( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_jk(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::RooCubicSplineKnot::S_jk(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void constructor_28341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_jk(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot::S_jk(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_jk(*(const ::RooCubicSplineKnot::S_jk*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot::S_jk(*(const ::RooCubicSplineKnot::S_jk*)arg[0],
      *(double*)arg[1]);
  }
}

static  void operator_28342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator*=)(*(double*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator*=)(*(double*)arg[0]);
}

static  void operator_28343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator/=)(*(double*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator/=)(*(double*)arg[0]);
}

static  void operator_28344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator-)();
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator-)();
}

static  void operator_28345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator+=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator+=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void operator_28346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator-=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator-=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void operator_28347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot::S_jk*)o)->operator*)(*(double*)arg[0]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator*)(*(double*)arg[0]);
}

static  void operator_28348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot::S_jk*)o)->operator/)(*(double*)arg[0]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator/)(*(double*)arg[0]);
}

static  void operator_28349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot::S_jk*)o)->operator+)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator+)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void operator_28350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot::S_jk*)o)->operator-)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator-)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void operator_28351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot::S_jk*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]);
}

static void method_newdel_7159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class S_jk -------------------------------
void __RooCubicSplineKnot__S_jk_db_datamem(Reflex::Class*);
void __RooCubicSplineKnot__S_jk_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__S_jk_datamem_bld(&__RooCubicSplineKnot__S_jk_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__S_jk_funcmem_bld(&__RooCubicSplineKnot__S_jk_db_funcmem);
void __RooCubicSplineKnot__S_jk_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineKnot::S_jk"), typeid(::RooCubicSplineKnot::S_jk), sizeof(::RooCubicSplineKnot::S_jk), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~S_jk"), destructor_28337, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031, type_18033), Reflex::Literal("operator="), operator_28338, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("S_jk"), constructor_28339, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_694, type_694, type_694), Reflex::Literal("S_jk"), constructor_28340, 0, "a;b;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18033, type_694), Reflex::Literal("S_jk"), constructor_28341, 0, "other;offset=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineKnot__S_jk_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCubicSplineKnot__S_jk_funcmem_bld);
}

//------Delayed data member builder for class S_jk -------------------
void __RooCubicSplineKnot__S_jk_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_694, Reflex::Literal("t"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_jk, t), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("d"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_jk, d), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("s"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_jk, s), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("o"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_jk, o), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class S_jk -------------------
void __RooCubicSplineKnot__S_jk_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031, type_694), Reflex::Literal("operator*="), operator_28342, 0, "z", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031, type_694), Reflex::Literal("operator/="), operator_28343, 0, "z", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031), Reflex::Literal("operator-"), operator_28344, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031, type_18033), Reflex::Literal("operator+="), operator_28345, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031, type_18033), Reflex::Literal("operator-="), operator_28346, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7159, type_694), Reflex::Literal("operator*"), operator_28347, 0, "z", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7159, type_694), Reflex::Literal("operator/"), operator_28348, 0, "z", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7159, type_18033), Reflex::Literal("operator+"), operator_28349, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7159, type_18033), Reflex::Literal("operator-"), operator_28350, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_141, type_141), Reflex::Literal("operator()"), operator_28351, 0, "j;k", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class vector<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > -------------------------------
static void constructor_18042( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>();
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>();
}

static void constructor_18043( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(const ::std::allocator<RooCubicSplineKnot::S_jk>*)arg[0]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(const ::std::allocator<RooCubicSplineKnot::S_jk>*)arg[0]);
}

static void constructor_18044( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0],
      *(const ::RooCubicSplineKnot::S_jk*)arg[1]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0],
      *(const ::RooCubicSplineKnot::S_jk*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0],
      *(const ::RooCubicSplineKnot::S_jk*)arg[1],
      *(const ::std::allocator<RooCubicSplineKnot::S_jk>*)arg[2]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0],
      *(const ::RooCubicSplineKnot::S_jk*)arg[1],
      *(const ::std::allocator<RooCubicSplineKnot::S_jk>*)arg[2]);
  }
}

static void constructor_18045( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(const ::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(const ::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
}

static void destructor_18046(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->::std::vector<RooCubicSplineKnot::S_jk>::~vector)();
}
static  void operator_18047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator=)(*(const ::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator=)(*(const ::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
}

static  void method_18048( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RooCubicSplineKnot::S_jk*)arg[1]);
}

static  void method_18049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->begin)());
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->begin)();
}

static  void method_18050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->begin)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->begin)();
}

static  void method_18051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->end)());
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->end)();
}

static  void method_18052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->end)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->end)();
}

static  void method_18057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->size)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->size)();
}

static  void method_18058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->max_size)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->max_size)();
}

static  void method_18059( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RooCubicSplineKnot::S_jk*)arg[1]);
  }
}

static  void method_18060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->capacity)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->capacity)();
}

static  void method_18061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->empty)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->empty)();
}

static  void method_18062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->front)();
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->front)();
}

static  void method_18069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->front)();
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->front)();
}

static  void method_18070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->back)();
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->back)();
}

static  void method_18071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->back)();
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->back)();
}

static  void method_18072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->data)());
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->data)();
}

static  void method_18073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->data)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->data)();
}

static  void method_18074( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->push_back)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void method_18075( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->pop_back)();
}

static  void method_18076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(const ::RooCubicSplineKnot::S_jk*)arg[1]));
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(const ::RooCubicSplineKnot::S_jk*)arg[1]);
}

static  void method_18077( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RooCubicSplineKnot::S_jk*)arg[2]);
}

static  void method_18078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0]));
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0]);
}

static  void method_18079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[1]));
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[1]);
}

static  void method_18080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->swap)(*(::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
}

static  void method_18081( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->clear)();
}

static void method_newdel_3093( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> >")), ::Reflex::BaseOffset< ::std::vector<RooCubicSplineKnot::S_jk>,::std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooCubicSplineKnot::S_jk> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooCubicSplineKnot::S_jk> >::Generate();
}

//------Dictionary for class vector<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > -------------------------------
void __std__vector_RooCubicSplineKnot__S_jk__db_datamem(Reflex::Class*);
void __std__vector_RooCubicSplineKnot__S_jk__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooCubicSplineKnot__S_jk__datamem_bld(&__std__vector_RooCubicSplineKnot__S_jk__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooCubicSplineKnot__S_jk__funcmem_bld(&__std__vector_RooCubicSplineKnot__S_jk__db_funcmem);
void __std__vector_RooCubicSplineKnot__S_jk__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>"), typeid(::std::vector<RooCubicSplineKnot::S_jk>), sizeof(::std::vector<RooCubicSplineKnot::S_jk>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3023, ::Reflex::BaseOffset< ::std::vector<RooCubicSplineKnot::S_jk>, ::std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7159, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::_Alloc_value_type"))
  .AddTypedef(type_3023, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::_Base"))
  .AddTypedef(type_3682, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::_Tp_alloc_type"))
  .AddTypedef(type_11024, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::_Alloc_traits"))
  .AddTypedef(type_7159, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::value_type"))
  .AddTypedef(type_17327, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::pointer"))
  .AddTypedef(type_18029, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::const_pointer"))
  .AddTypedef(type_18031, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::reference"))
  .AddTypedef(type_18033, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::const_reference"))
  .AddTypedef(type_10852, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::iterator"))
  .AddTypedef(type_10853, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::const_iterator"))
  .AddTypedef(type_3900, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::const_reverse_iterator"))
  .AddTypedef(type_3901, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::difference_type"))
  .AddTypedef(type_3682, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18042, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32237), Reflex::Literal("vector"), constructor_18043, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18033, type_32237), Reflex::Literal("vector"), constructor_18044, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32656), Reflex::Literal("vector"), constructor_18045, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18046, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3093, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooCubicSplineKnot__S_jk__funcmem_bld);
}

//------Delayed data member builder for class vector<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > -------------------
void __std__vector_RooCubicSplineKnot__S_jk__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > -------------------
void __std__vector_RooCubicSplineKnot__S_jk__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32657, type_32656), Reflex::Literal("operator="), operator_18047, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18033), Reflex::Literal("assign"), method_18048, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852), Reflex::Literal("begin"), method_18049, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10853), Reflex::Literal("begin"), method_18050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852), Reflex::Literal("end"), method_18051, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10853), Reflex::Literal("end"), method_18052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_7159), Reflex::Literal("resize"), method_18059, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18062, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031, type_3405), Reflex::Literal("operator[]"), operator_18063, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18033, type_3405), Reflex::Literal("operator[]"), operator_18064, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031, type_3405), Reflex::Literal("at"), method_18066, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18033, type_3405), Reflex::Literal("at"), method_18067, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031), Reflex::Literal("front"), method_18068, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18033), Reflex::Literal("front"), method_18069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18031), Reflex::Literal("back"), method_18070, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18033), Reflex::Literal("back"), method_18071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17327), Reflex::Literal("data"), method_18072, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18029), Reflex::Literal("data"), method_18073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18033), Reflex::Literal("push_back"), method_18074, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18075, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852, type_10852, type_18033), Reflex::Literal("insert"), method_18076, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10852, type_3405, type_18033), Reflex::Literal("insert"), method_18077, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852, type_10852), Reflex::Literal("erase"), method_18078, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852, type_10852, type_10852), Reflex::Literal("erase"), method_18079, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32657), Reflex::Literal("swap"), method_18080, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18081, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<float,std::allocator<float> > -------------------------------
static void constructor_18107( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>();
  else ::new(mem) ::std::vector<float>();
}

static void constructor_18108( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(const ::std::allocator<float>*)arg[0]);
  else ::new(mem) ::std::vector<float>(*(const ::std::allocator<float>*)arg[0]);
}

static void constructor_18109( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1],
      *(const ::std::allocator<float>*)arg[2]);
  else ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1],
      *(const ::std::allocator<float>*)arg[2]);
  }
}

static void constructor_18110( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(const ::std::vector<float>*)arg[0]);
  else ::new(mem) ::std::vector<float>(*(const ::std::vector<float>*)arg[0]);
}

static void destructor_18111(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<float>*)o)->::std::vector<float>::~vector)();
}
static  void operator_18112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->operator=)(*(const ::std::vector<float>*)arg[0]);
  else   (((::std::vector<float>*)o)->operator=)(*(const ::std::vector<float>*)arg[0]);
}

static  void method_18113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const float*)arg[1]);
}

static  void method_18114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->begin)());
  else   (((::std::vector<float>*)o)->begin)();
}

static  void method_18115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const float*,std::vector<float> >)((((const ::std::vector<float>*)o)->begin)());
  else   (((const ::std::vector<float>*)o)->begin)();
}

static  void method_18116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->end)());
  else   (((::std::vector<float>*)o)->end)();
}

static  void method_18117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const float*,std::vector<float> >)((((const ::std::vector<float>*)o)->end)());
  else   (((const ::std::vector<float>*)o)->end)();
}

static  void method_18122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<float>*)o)->size)());
  else   (((const ::std::vector<float>*)o)->size)();
}

static  void method_18123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<float>*)o)->max_size)());
  else   (((const ::std::vector<float>*)o)->max_size)();
}

static  void method_18124( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<float>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<float>*)o)->resize)(*(::std::size_t*)arg[0],
      *(float*)arg[1]);
  }
}

static  void method_18125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<float>*)o)->capacity)());
  else   (((const ::std::vector<float>*)o)->capacity)();
}

static  void method_18126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<float>*)o)->empty)());
  else   (((const ::std::vector<float>*)o)->empty)();
}

static  void method_18127( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->front)();
  else   (((::std::vector<float>*)o)->front)();
}

static  void method_18134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->front)();
  else   (((const ::std::vector<float>*)o)->front)();
}

static  void method_18135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->back)();
  else   (((::std::vector<float>*)o)->back)();
}

static  void method_18136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->back)();
  else   (((const ::std::vector<float>*)o)->back)();
}

static  void method_18137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<float>*)o)->data)());
  else   (((::std::vector<float>*)o)->data)();
}

static  void method_18138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<float>*)o)->data)());
  else   (((const ::std::vector<float>*)o)->data)();
}

static  void method_18139( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->push_back)(*(const float*)arg[0]);
}

static  void method_18140( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<float>*)o)->pop_back)();
}

static  void method_18141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(const float*)arg[1]));
  else   (((::std::vector<float>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(const float*)arg[1]);
}

static  void method_18142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const float*)arg[2]);
}

static  void method_18143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0]));
  else   (((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0]);
}

static  void method_18144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[1]));
  else   (((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[1]);
}

static  void method_18145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->swap)(*(::std::vector<float>*)arg[0]);
}

static  void method_18146( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<float>*)o)->clear)();
}

static void method_newdel_3094( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<float,std::allocator<float> >")), ::Reflex::BaseOffset< ::std::vector<float>,::std::_Vector_base<float,std::allocator<float> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<float> >::Generate();
  else ::Reflex::Proxy< ::std::vector<float> >::Generate();
}

//------Dictionary for class vector<float,std::allocator<float> > -------------------------------
void __std__vector_float__db_datamem(Reflex::Class*);
void __std__vector_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_float__datamem_bld(&__std__vector_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_float__funcmem_bld(&__std__vector_float__db_funcmem);
void __std__vector_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<float>"), typeid(::std::vector<float>), sizeof(::std::vector<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3024, ::Reflex::BaseOffset< ::std::vector<float>, ::std::_Vector_base<float,std::allocator<float> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_102, Reflex::Literal("std::vector<float>::_Alloc_value_type"))
  .AddTypedef(type_3024, Reflex::Literal("std::vector<float>::_Base"))
  .AddTypedef(type_3684, Reflex::Literal("std::vector<float>::_Tp_alloc_type"))
  .AddTypedef(type_11025, Reflex::Literal("std::vector<float>::_Alloc_traits"))
  .AddTypedef(type_102, Reflex::Literal("std::vector<float>::value_type"))
  .AddTypedef(type_6054, Reflex::Literal("std::vector<float>::pointer"))
  .AddTypedef(type_18094, Reflex::Literal("std::vector<float>::const_pointer"))
  .AddTypedef(type_18096, Reflex::Literal("std::vector<float>::reference"))
  .AddTypedef(type_18098, Reflex::Literal("std::vector<float>::const_reference"))
  .AddTypedef(type_10854, Reflex::Literal("std::vector<float>::iterator"))
  .AddTypedef(type_10855, Reflex::Literal("std::vector<float>::const_iterator"))
  .AddTypedef(type_3902, Reflex::Literal("std::vector<float>::const_reverse_iterator"))
  .AddTypedef(type_3903, Reflex::Literal("std::vector<float>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<float>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<float>::difference_type"))
  .AddTypedef(type_3684, Reflex::Literal("std::vector<float>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18107, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32250), Reflex::Literal("vector"), constructor_18108, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18098, type_32250), Reflex::Literal("vector"), constructor_18109, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32659), Reflex::Literal("vector"), constructor_18110, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18111, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3094, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_float__funcmem_bld);
}

//------Delayed data member builder for class vector<float,std::allocator<float> > -------------------
void __std__vector_float__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<float,std::allocator<float> > -------------------
void __std__vector_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32660, type_32659), Reflex::Literal("operator="), operator_18112, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18098), Reflex::Literal("assign"), method_18113, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854), Reflex::Literal("begin"), method_18114, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10855), Reflex::Literal("begin"), method_18115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854), Reflex::Literal("end"), method_18116, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10855), Reflex::Literal("end"), method_18117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_102), Reflex::Literal("resize"), method_18124, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18127, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18096, type_3405), Reflex::Literal("operator[]"), operator_18128, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18098, type_3405), Reflex::Literal("operator[]"), operator_18129, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18096, type_3405), Reflex::Literal("at"), method_18131, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18098, type_3405), Reflex::Literal("at"), method_18132, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18096), Reflex::Literal("front"), method_18133, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18098), Reflex::Literal("front"), method_18134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18096), Reflex::Literal("back"), method_18135, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18098), Reflex::Literal("back"), method_18136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6054), Reflex::Literal("data"), method_18137, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18094), Reflex::Literal("data"), method_18138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18098), Reflex::Literal("push_back"), method_18139, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18140, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854, type_10854, type_18098), Reflex::Literal("insert"), method_18141, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10854, type_3405, type_18098), Reflex::Literal("insert"), method_18142, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854, type_10854), Reflex::Literal("erase"), method_18143, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854, type_10854, type_10854), Reflex::Literal("erase"), method_18144, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32660), Reflex::Literal("swap"), method_18145, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18146, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------------------
static void constructor_18172( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>();
  else ::new(mem) ::std::vector<unsigned long long>();
}

static void constructor_18173( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(const ::std::allocator<unsigned long long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long long>(*(const ::std::allocator<unsigned long long>*)arg[0]);
}

static void constructor_18174( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1]);
  else ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1],
      *(const ::std::allocator<unsigned long long>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1],
      *(const ::std::allocator<unsigned long long>*)arg[2]);
  }
}

static void constructor_18175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(const ::std::vector<unsigned long long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long long>(*(const ::std::vector<unsigned long long>*)arg[0]);
}

static void destructor_18176(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned long long>*)o)->::std::vector<unsigned long long>::~vector)();
}
static  void operator_18177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->operator=)(*(const ::std::vector<unsigned long long>*)arg[0]);
  else   (((::std::vector<unsigned long long>*)o)->operator=)(*(const ::std::vector<unsigned long long>*)arg[0]);
}

static  void method_18178( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned long long*)arg[1]);
}

static  void method_18179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->begin)());
  else   (((::std::vector<unsigned long long>*)o)->begin)();
}

static  void method_18180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> >)((((const ::std::vector<unsigned long long>*)o)->begin)());
  else   (((const ::std::vector<unsigned long long>*)o)->begin)();
}

static  void method_18181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->end)());
  else   (((::std::vector<unsigned long long>*)o)->end)();
}

static  void method_18182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> >)((((const ::std::vector<unsigned long long>*)o)->end)());
  else   (((const ::std::vector<unsigned long long>*)o)->end)();
}

static  void method_18187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long long>*)o)->size)());
  else   (((const ::std::vector<unsigned long long>*)o)->size)();
}

static  void method_18188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long long>*)o)->max_size)());
  else   (((const ::std::vector<unsigned long long>*)o)->max_size)();
}

static  void method_18189( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned long long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned long long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned long long*)arg[1]);
  }
}

static  void method_18190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long long>*)o)->capacity)());
  else   (((const ::std::vector<unsigned long long>*)o)->capacity)();
}

static  void method_18191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned long long>*)o)->empty)());
  else   (((const ::std::vector<unsigned long long>*)o)->empty)();
}

static  void method_18192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->front)();
  else   (((::std::vector<unsigned long long>*)o)->front)();
}

static  void method_18199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->front)();
  else   (((const ::std::vector<unsigned long long>*)o)->front)();
}

static  void method_18200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->back)();
  else   (((::std::vector<unsigned long long>*)o)->back)();
}

static  void method_18201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->back)();
  else   (((const ::std::vector<unsigned long long>*)o)->back)();
}

static  void method_18202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned long long>*)o)->data)());
  else   (((::std::vector<unsigned long long>*)o)->data)();
}

static  void method_18203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned long long>*)o)->data)());
  else   (((const ::std::vector<unsigned long long>*)o)->data)();
}

static  void method_18204( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->push_back)(*(const unsigned long long*)arg[0]);
}

static  void method_18205( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long long>*)o)->pop_back)();
}

static  void method_18206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(const unsigned long long*)arg[1]));
  else   (((::std::vector<unsigned long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(const unsigned long long*)arg[1]);
}

static  void method_18207( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned long long*)arg[2]);
}

static  void method_18208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0]));
  else   (((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0]);
}

static  void method_18209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[1]));
  else   (((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[1]);
}

static  void method_18210( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->swap)(*(::std::vector<unsigned long long>*)arg[0]);
}

static  void method_18211( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long long>*)o)->clear)();
}

static void method_newdel_3095( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long long,std::allocator<unsigned long long> >")), ::Reflex::BaseOffset< ::std::vector<unsigned long long>,::std::_Vector_base<unsigned long long,std::allocator<unsigned long long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x123( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned long long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned long long> >::Generate();
}

//------Dictionary for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------------------
void __std__vector_unsignedslongslong__db_datamem(Reflex::Class*);
void __std__vector_unsignedslongslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslongslong__datamem_bld(&__std__vector_unsignedslongslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslongslong__funcmem_bld(&__std__vector_unsignedslongslong__db_funcmem);
void __std__vector_unsignedslongslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned long long>"), typeid(::std::vector<unsigned long long>), sizeof(::std::vector<unsigned long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3025, ::Reflex::BaseOffset< ::std::vector<unsigned long long>, ::std::_Vector_base<unsigned long long,std::allocator<unsigned long long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_820, Reflex::Literal("std::vector<unsigned long long>::_Alloc_value_type"))
  .AddTypedef(type_3025, Reflex::Literal("std::vector<unsigned long long>::_Base"))
  .AddTypedef(type_3685, Reflex::Literal("std::vector<unsigned long long>::_Tp_alloc_type"))
  .AddTypedef(type_11026, Reflex::Literal("std::vector<unsigned long long>::_Alloc_traits"))
  .AddTypedef(type_820, Reflex::Literal("std::vector<unsigned long long>::value_type"))
  .AddTypedef(type_17364, Reflex::Literal("std::vector<unsigned long long>::pointer"))
  .AddTypedef(type_18159, Reflex::Literal("std::vector<unsigned long long>::const_pointer"))
  .AddTypedef(type_18161, Reflex::Literal("std::vector<unsigned long long>::reference"))
  .AddTypedef(type_18163, Reflex::Literal("std::vector<unsigned long long>::const_reference"))
  .AddTypedef(type_10856, Reflex::Literal("std::vector<unsigned long long>::iterator"))
  .AddTypedef(type_10857, Reflex::Literal("std::vector<unsigned long long>::const_iterator"))
  .AddTypedef(type_3904, Reflex::Literal("std::vector<unsigned long long>::const_reverse_iterator"))
  .AddTypedef(type_3905, Reflex::Literal("std::vector<unsigned long long>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<unsigned long long>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<unsigned long long>::difference_type"))
  .AddTypedef(type_3685, Reflex::Literal("std::vector<unsigned long long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18172, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32263), Reflex::Literal("vector"), constructor_18173, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18163, type_32263), Reflex::Literal("vector"), constructor_18174, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32662), Reflex::Literal("vector"), constructor_18175, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18176, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3095, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedslongslong__funcmem_bld);
}

//------Delayed data member builder for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------
void __std__vector_unsignedslongslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------
void __std__vector_unsignedslongslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32663, type_32662), Reflex::Literal("operator="), operator_18177, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18163), Reflex::Literal("assign"), method_18178, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856), Reflex::Literal("begin"), method_18179, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10857), Reflex::Literal("begin"), method_18180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856), Reflex::Literal("end"), method_18181, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10857), Reflex::Literal("end"), method_18182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_820), Reflex::Literal("resize"), method_18189, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18192, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18161, type_3405), Reflex::Literal("operator[]"), operator_18193, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18163, type_3405), Reflex::Literal("operator[]"), operator_18194, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18161, type_3405), Reflex::Literal("at"), method_18196, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18163, type_3405), Reflex::Literal("at"), method_18197, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18161), Reflex::Literal("front"), method_18198, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18163), Reflex::Literal("front"), method_18199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18161), Reflex::Literal("back"), method_18200, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18163), Reflex::Literal("back"), method_18201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17364), Reflex::Literal("data"), method_18202, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18159), Reflex::Literal("data"), method_18203, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18163), Reflex::Literal("push_back"), method_18204, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18205, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856, type_10856, type_18163), Reflex::Literal("insert"), method_18206, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10856, type_3405, type_18163), Reflex::Literal("insert"), method_18207, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856, type_10856), Reflex::Literal("erase"), method_18208, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856, type_10856, type_10856), Reflex::Literal("erase"), method_18209, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32663), Reflex::Literal("swap"), method_18210, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18211, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------------------
static void constructor_18237( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>();
  else ::new(mem) ::std::vector<unsigned long>();
}

static void constructor_18238( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(const ::std::allocator<unsigned long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long>(*(const ::std::allocator<unsigned long>*)arg[0]);
}

static void constructor_18239( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1]);
  else ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::allocator<unsigned long>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::allocator<unsigned long>*)arg[2]);
  }
}

static void constructor_18240( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(const ::std::vector<unsigned long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long>(*(const ::std::vector<unsigned long>*)arg[0]);
}

static void destructor_18241(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned long>*)o)->::std::vector<unsigned long>::~vector)();
}
static  void operator_18242( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->operator=)(*(const ::std::vector<unsigned long>*)arg[0]);
  else   (((::std::vector<unsigned long>*)o)->operator=)(*(const ::std::vector<unsigned long>*)arg[0]);
}

static  void method_18243( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned long*)arg[1]);
}

static  void method_18244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->begin)());
  else   (((::std::vector<unsigned long>*)o)->begin)();
}

static  void method_18245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >)((((const ::std::vector<unsigned long>*)o)->begin)());
  else   (((const ::std::vector<unsigned long>*)o)->begin)();
}

static  void method_18246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->end)());
  else   (((::std::vector<unsigned long>*)o)->end)();
}

static  void method_18247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >)((((const ::std::vector<unsigned long>*)o)->end)());
  else   (((const ::std::vector<unsigned long>*)o)->end)();
}

static  void method_18252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long>*)o)->size)());
  else   (((const ::std::vector<unsigned long>*)o)->size)();
}

static  void method_18253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long>*)o)->max_size)());
  else   (((const ::std::vector<unsigned long>*)o)->max_size)();
}

static  void method_18254( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned long*)arg[1]);
  }
}

static  void method_18255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long>*)o)->capacity)());
  else   (((const ::std::vector<unsigned long>*)o)->capacity)();
}

static  void method_18256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned long>*)o)->empty)());
  else   (((const ::std::vector<unsigned long>*)o)->empty)();
}

static  void method_18257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->front)();
  else   (((::std::vector<unsigned long>*)o)->front)();
}

static  void method_18264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->front)();
  else   (((const ::std::vector<unsigned long>*)o)->front)();
}

static  void method_18265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->back)();
  else   (((::std::vector<unsigned long>*)o)->back)();
}

static  void method_18266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->back)();
  else   (((const ::std::vector<unsigned long>*)o)->back)();
}

static  void method_18267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned long>*)o)->data)());
  else   (((::std::vector<unsigned long>*)o)->data)();
}

static  void method_18268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned long>*)o)->data)());
  else   (((const ::std::vector<unsigned long>*)o)->data)();
}

static  void method_18269( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->push_back)(*(const unsigned long*)arg[0]);
}

static  void method_18270( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long>*)o)->pop_back)();
}

static  void method_18271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(const unsigned long*)arg[1]));
  else   (((::std::vector<unsigned long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(const unsigned long*)arg[1]);
}

static  void method_18272( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned long*)arg[2]);
}

static  void method_18273( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0]));
  else   (((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0]);
}

static  void method_18274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[1]));
  else   (((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[1]);
}

static  void method_18275( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->swap)(*(::std::vector<unsigned long>*)arg[0]);
}

static  void method_18276( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long>*)o)->clear)();
}

static void method_newdel_3096( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x125( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long,std::allocator<unsigned long> >")), ::Reflex::BaseOffset< ::std::vector<unsigned long>,::std::_Vector_base<unsigned long,std::allocator<unsigned long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned long> >::Generate();
}

//------Dictionary for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------------------
void __std__vector_unsignedslong__db_datamem(Reflex::Class*);
void __std__vector_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslong__datamem_bld(&__std__vector_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslong__funcmem_bld(&__std__vector_unsignedslong__db_funcmem);
void __std__vector_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned long>"), typeid(::std::vector<unsigned long>), sizeof(::std::vector<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3026, ::Reflex::BaseOffset< ::std::vector<unsigned long>, ::std::_Vector_base<unsigned long,std::allocator<unsigned long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_167, Reflex::Literal("std::vector<unsigned long>::_Alloc_value_type"))
  .AddTypedef(type_3026, Reflex::Literal("std::vector<unsigned long>::_Base"))
  .AddTypedef(type_3686, Reflex::Literal("std::vector<unsigned long>::_Tp_alloc_type"))
  .AddTypedef(type_11027, Reflex::Literal("std::vector<unsigned long>::_Alloc_traits"))
  .AddTypedef(type_167, Reflex::Literal("std::vector<unsigned long>::value_type"))
  .AddTypedef(type_17383, Reflex::Literal("std::vector<unsigned long>::pointer"))
  .AddTypedef(type_18224, Reflex::Literal("std::vector<unsigned long>::const_pointer"))
  .AddTypedef(type_18226, Reflex::Literal("std::vector<unsigned long>::reference"))
  .AddTypedef(type_18228, Reflex::Literal("std::vector<unsigned long>::const_reference"))
  .AddTypedef(type_10858, Reflex::Literal("std::vector<unsigned long>::iterator"))
  .AddTypedef(type_10859, Reflex::Literal("std::vector<unsigned long>::const_iterator"))
  .AddTypedef(type_3906, Reflex::Literal("std::vector<unsigned long>::const_reverse_iterator"))
  .AddTypedef(type_3907, Reflex::Literal("std::vector<unsigned long>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<unsigned long>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<unsigned long>::difference_type"))
  .AddTypedef(type_3686, Reflex::Literal("std::vector<unsigned long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18237, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32276), Reflex::Literal("vector"), constructor_18238, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18228, type_32276), Reflex::Literal("vector"), constructor_18239, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32665), Reflex::Literal("vector"), constructor_18240, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18241, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3096, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------
void __std__vector_unsignedslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------
void __std__vector_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32666, type_32665), Reflex::Literal("operator="), operator_18242, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18228), Reflex::Literal("assign"), method_18243, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858), Reflex::Literal("begin"), method_18244, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10859), Reflex::Literal("begin"), method_18245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858), Reflex::Literal("end"), method_18246, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10859), Reflex::Literal("end"), method_18247, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_167), Reflex::Literal("resize"), method_18254, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18257, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18226, type_3405), Reflex::Literal("operator[]"), operator_18258, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18228, type_3405), Reflex::Literal("operator[]"), operator_18259, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18226, type_3405), Reflex::Literal("at"), method_18261, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18228, type_3405), Reflex::Literal("at"), method_18262, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18226), Reflex::Literal("front"), method_18263, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18228), Reflex::Literal("front"), method_18264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18226), Reflex::Literal("back"), method_18265, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18228), Reflex::Literal("back"), method_18266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17383), Reflex::Literal("data"), method_18267, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18224), Reflex::Literal("data"), method_18268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18228), Reflex::Literal("push_back"), method_18269, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18270, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858, type_10858, type_18228), Reflex::Literal("insert"), method_18271, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10858, type_3405, type_18228), Reflex::Literal("insert"), method_18272, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858, type_10858), Reflex::Literal("erase"), method_18273, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858, type_10858, type_10858), Reflex::Literal("erase"), method_18274, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32666), Reflex::Literal("swap"), method_18275, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18276, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
static void constructor_18302( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>();
  else ::new(mem) ::std::vector<unsigned int>();
}

static void constructor_18303( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
}

static void constructor_18304( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  }
}

static void constructor_18305( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
}

static void destructor_18306(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned int>*)o)->::std::vector<unsigned int>::~vector)();
}
static  void operator_18307( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
}

static  void method_18308( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_18309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->begin)());
  else   (((::std::vector<unsigned int>*)o)->begin)();
}

static  void method_18310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->begin)());
  else   (((const ::std::vector<unsigned int>*)o)->begin)();
}

static  void method_18311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->end)());
  else   (((::std::vector<unsigned int>*)o)->end)();
}

static  void method_18312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->end)());
  else   (((const ::std::vector<unsigned int>*)o)->end)();
}

static  void method_18317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->size)());
  else   (((const ::std::vector<unsigned int>*)o)->size)();
}

static  void method_18318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->max_size)());
  else   (((const ::std::vector<unsigned int>*)o)->max_size)();
}

static  void method_18319( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned int*)arg[1]);
  }
}

static  void method_18320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->capacity)());
  else   (((const ::std::vector<unsigned int>*)o)->capacity)();
}

static  void method_18321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned int>*)o)->empty)());
  else   (((const ::std::vector<unsigned int>*)o)->empty)();
}

static  void method_18322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->front)();
  else   (((::std::vector<unsigned int>*)o)->front)();
}

static  void method_18329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->front)();
  else   (((const ::std::vector<unsigned int>*)o)->front)();
}

static  void method_18330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->back)();
  else   (((::std::vector<unsigned int>*)o)->back)();
}

static  void method_18331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->back)();
  else   (((const ::std::vector<unsigned int>*)o)->back)();
}

static  void method_18332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned int>*)o)->data)());
  else   (((::std::vector<unsigned int>*)o)->data)();
}

static  void method_18333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned int>*)o)->data)());
  else   (((const ::std::vector<unsigned int>*)o)->data)();
}

static  void method_18334( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->push_back)(*(const unsigned int*)arg[0]);
}

static  void method_18335( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->pop_back)();
}

static  void method_18336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_18337( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned int*)arg[2]);
}

static  void method_18338( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]);
}

static  void method_18339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void method_18340( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->swap)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_18341( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->clear)();
}

static void method_newdel_3097( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >")), ::Reflex::BaseOffset< ::std::vector<unsigned int>,::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x129( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
}

//------Dictionary for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*);
void __std__vector_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__datamem_bld(&__std__vector_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__funcmem_bld(&__std__vector_unsignedsint__db_funcmem);
void __std__vector_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned int>"), typeid(::std::vector<unsigned int>), sizeof(::std::vector<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3027, ::Reflex::BaseOffset< ::std::vector<unsigned int>, ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_211, Reflex::Literal("std::vector<unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_3027, Reflex::Literal("std::vector<unsigned int>::_Base"))
  .AddTypedef(type_3687, Reflex::Literal("std::vector<unsigned int>::_Tp_alloc_type"))
  .AddTypedef(type_11028, Reflex::Literal("std::vector<unsigned int>::_Alloc_traits"))
  .AddTypedef(type_211, Reflex::Literal("std::vector<unsigned int>::value_type"))
  .AddTypedef(type_13938, Reflex::Literal("std::vector<unsigned int>::pointer"))
  .AddTypedef(type_18289, Reflex::Literal("std::vector<unsigned int>::const_pointer"))
  .AddTypedef(type_18291, Reflex::Literal("std::vector<unsigned int>::reference"))
  .AddTypedef(type_18293, Reflex::Literal("std::vector<unsigned int>::const_reference"))
  .AddTypedef(type_10860, Reflex::Literal("std::vector<unsigned int>::iterator"))
  .AddTypedef(type_10861, Reflex::Literal("std::vector<unsigned int>::const_iterator"))
  .AddTypedef(type_3908, Reflex::Literal("std::vector<unsigned int>::const_reverse_iterator"))
  .AddTypedef(type_3909, Reflex::Literal("std::vector<unsigned int>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<unsigned int>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<unsigned int>::difference_type"))
  .AddTypedef(type_3687, Reflex::Literal("std::vector<unsigned int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18302, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32289), Reflex::Literal("vector"), constructor_18303, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18293, type_32289), Reflex::Literal("vector"), constructor_18304, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32668), Reflex::Literal("vector"), constructor_18305, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18306, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3097, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x129, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32669, type_32668), Reflex::Literal("operator="), operator_18307, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18293), Reflex::Literal("assign"), method_18308, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860), Reflex::Literal("begin"), method_18309, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10861), Reflex::Literal("begin"), method_18310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860), Reflex::Literal("end"), method_18311, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10861), Reflex::Literal("end"), method_18312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_211), Reflex::Literal("resize"), method_18319, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18320, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18321, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18322, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18291, type_3405), Reflex::Literal("operator[]"), operator_18323, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18293, type_3405), Reflex::Literal("operator[]"), operator_18324, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18291, type_3405), Reflex::Literal("at"), method_18326, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18293, type_3405), Reflex::Literal("at"), method_18327, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18291), Reflex::Literal("front"), method_18328, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18293), Reflex::Literal("front"), method_18329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18291), Reflex::Literal("back"), method_18330, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18293), Reflex::Literal("back"), method_18331, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13938), Reflex::Literal("data"), method_18332, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18289), Reflex::Literal("data"), method_18333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18293), Reflex::Literal("push_back"), method_18334, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18335, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860, type_10860, type_18293), Reflex::Literal("insert"), method_18336, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10860, type_3405, type_18293), Reflex::Literal("insert"), method_18337, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860, type_10860), Reflex::Literal("erase"), method_18338, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860, type_10860, type_10860), Reflex::Literal("erase"), method_18339, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32669), Reflex::Literal("swap"), method_18340, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18341, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------------------
static void constructor_18367( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>();
  else ::new(mem) ::std::vector<unsigned short>();
}

static void constructor_18368( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(const ::std::allocator<unsigned short>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short>(*(const ::std::allocator<unsigned short>*)arg[0]);
}

static void constructor_18369( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1]);
  else ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1],
      *(const ::std::allocator<unsigned short>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1],
      *(const ::std::allocator<unsigned short>*)arg[2]);
  }
}

static void constructor_18370( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(const ::std::vector<unsigned short>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short>(*(const ::std::vector<unsigned short>*)arg[0]);
}

static void destructor_18371(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned short>*)o)->::std::vector<unsigned short>::~vector)();
}
static  void operator_18372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->operator=)(*(const ::std::vector<unsigned short>*)arg[0]);
  else   (((::std::vector<unsigned short>*)o)->operator=)(*(const ::std::vector<unsigned short>*)arg[0]);
}

static  void method_18373( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned short*)arg[1]);
}

static  void method_18374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->begin)());
  else   (((::std::vector<unsigned short>*)o)->begin)();
}

static  void method_18375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >)((((const ::std::vector<unsigned short>*)o)->begin)());
  else   (((const ::std::vector<unsigned short>*)o)->begin)();
}

static  void method_18376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->end)());
  else   (((::std::vector<unsigned short>*)o)->end)();
}

static  void method_18377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >)((((const ::std::vector<unsigned short>*)o)->end)());
  else   (((const ::std::vector<unsigned short>*)o)->end)();
}

static  void method_18382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short>*)o)->size)());
  else   (((const ::std::vector<unsigned short>*)o)->size)();
}

static  void method_18383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short>*)o)->max_size)());
  else   (((const ::std::vector<unsigned short>*)o)->max_size)();
}

static  void method_18384( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned short>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned short>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned short*)arg[1]);
  }
}

static  void method_18385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short>*)o)->capacity)());
  else   (((const ::std::vector<unsigned short>*)o)->capacity)();
}

static  void method_18386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned short>*)o)->empty)());
  else   (((const ::std::vector<unsigned short>*)o)->empty)();
}

static  void method_18387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->front)();
  else   (((::std::vector<unsigned short>*)o)->front)();
}

static  void method_18394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->front)();
  else   (((const ::std::vector<unsigned short>*)o)->front)();
}

static  void method_18395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->back)();
  else   (((::std::vector<unsigned short>*)o)->back)();
}

static  void method_18396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->back)();
  else   (((const ::std::vector<unsigned short>*)o)->back)();
}

static  void method_18397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned short>*)o)->data)());
  else   (((::std::vector<unsigned short>*)o)->data)();
}

static  void method_18398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned short>*)o)->data)());
  else   (((const ::std::vector<unsigned short>*)o)->data)();
}

static  void method_18399( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->push_back)(*(const unsigned short*)arg[0]);
}

static  void method_18400( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned short>*)o)->pop_back)();
}

static  void method_18401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(const unsigned short*)arg[1]));
  else   (((::std::vector<unsigned short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(const unsigned short*)arg[1]);
}

static  void method_18402( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned short*)arg[2]);
}

static  void method_18403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0]));
  else   (((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0]);
}

static  void method_18404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[1]));
  else   (((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[1]);
}

static  void method_18405( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->swap)(*(::std::vector<unsigned short>*)arg[0]);
}

static  void method_18406( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned short>*)o)->clear)();
}

static void method_newdel_3098( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x131( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned short,std::allocator<unsigned short> >")), ::Reflex::BaseOffset< ::std::vector<unsigned short>,::std::_Vector_base<unsigned short,std::allocator<unsigned short> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x132( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned short> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned short> >::Generate();
}

//------Dictionary for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------------------
void __std__vector_unsignedsshort__db_datamem(Reflex::Class*);
void __std__vector_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsshort__datamem_bld(&__std__vector_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsshort__funcmem_bld(&__std__vector_unsignedsshort__db_funcmem);
void __std__vector_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned short>"), typeid(::std::vector<unsigned short>), sizeof(::std::vector<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3028, ::Reflex::BaseOffset< ::std::vector<unsigned short>, ::std::_Vector_base<unsigned short,std::allocator<unsigned short> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_311, Reflex::Literal("std::vector<unsigned short>::_Alloc_value_type"))
  .AddTypedef(type_3028, Reflex::Literal("std::vector<unsigned short>::_Base"))
  .AddTypedef(type_3688, Reflex::Literal("std::vector<unsigned short>::_Tp_alloc_type"))
  .AddTypedef(type_11029, Reflex::Literal("std::vector<unsigned short>::_Alloc_traits"))
  .AddTypedef(type_311, Reflex::Literal("std::vector<unsigned short>::value_type"))
  .AddTypedef(type_4409, Reflex::Literal("std::vector<unsigned short>::pointer"))
  .AddTypedef(type_18354, Reflex::Literal("std::vector<unsigned short>::const_pointer"))
  .AddTypedef(type_18356, Reflex::Literal("std::vector<unsigned short>::reference"))
  .AddTypedef(type_18358, Reflex::Literal("std::vector<unsigned short>::const_reference"))
  .AddTypedef(type_10862, Reflex::Literal("std::vector<unsigned short>::iterator"))
  .AddTypedef(type_10863, Reflex::Literal("std::vector<unsigned short>::const_iterator"))
  .AddTypedef(type_3910, Reflex::Literal("std::vector<unsigned short>::const_reverse_iterator"))
  .AddTypedef(type_3911, Reflex::Literal("std::vector<unsigned short>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<unsigned short>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<unsigned short>::difference_type"))
  .AddTypedef(type_3688, Reflex::Literal("std::vector<unsigned short>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18367, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32302), Reflex::Literal("vector"), constructor_18368, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18358, type_32302), Reflex::Literal("vector"), constructor_18369, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32671), Reflex::Literal("vector"), constructor_18370, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18371, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3098, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x131, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x132, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsshort__funcmem_bld);
}

//------Delayed data member builder for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------
void __std__vector_unsignedsshort__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------
void __std__vector_unsignedsshort__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32672, type_32671), Reflex::Literal("operator="), operator_18372, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18358), Reflex::Literal("assign"), method_18373, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862), Reflex::Literal("begin"), method_18374, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10863), Reflex::Literal("begin"), method_18375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862), Reflex::Literal("end"), method_18376, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10863), Reflex::Literal("end"), method_18377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_311), Reflex::Literal("resize"), method_18384, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18387, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18356, type_3405), Reflex::Literal("operator[]"), operator_18388, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18358, type_3405), Reflex::Literal("operator[]"), operator_18389, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18356, type_3405), Reflex::Literal("at"), method_18391, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18358, type_3405), Reflex::Literal("at"), method_18392, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18356), Reflex::Literal("front"), method_18393, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18358), Reflex::Literal("front"), method_18394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18356), Reflex::Literal("back"), method_18395, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18358), Reflex::Literal("back"), method_18396, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4409), Reflex::Literal("data"), method_18397, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18354), Reflex::Literal("data"), method_18398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18358), Reflex::Literal("push_back"), method_18399, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18400, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862, type_10862, type_18358), Reflex::Literal("insert"), method_18401, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10862, type_3405, type_18358), Reflex::Literal("insert"), method_18402, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862, type_10862), Reflex::Literal("erase"), method_18403, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862, type_10862, type_10862), Reflex::Literal("erase"), method_18404, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32672), Reflex::Literal("swap"), method_18405, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18406, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned char,std::allocator<unsigned char> > -------------------------------
static void constructor_18432( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>();
  else ::new(mem) ::std::vector<unsigned char>();
}

static void constructor_18433( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(const ::std::allocator<unsigned char>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char>(*(const ::std::allocator<unsigned char>*)arg[0]);
}

static void constructor_18434( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1]);
  else ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1],
      *(const ::std::allocator<unsigned char>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1],
      *(const ::std::allocator<unsigned char>*)arg[2]);
  }
}

static void constructor_18435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(const ::std::vector<unsigned char>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char>(*(const ::std::vector<unsigned char>*)arg[0]);
}

static void destructor_18436(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned char>*)o)->::std::vector<unsigned char>::~vector)();
}
static  void operator_18437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->operator=)(*(const ::std::vector<unsigned char>*)arg[0]);
  else   (((::std::vector<unsigned char>*)o)->operator=)(*(const ::std::vector<unsigned char>*)arg[0]);
}

static  void method_18438( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned char*)arg[1]);
}

static  void method_18439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->begin)());
  else   (((::std::vector<unsigned char>*)o)->begin)();
}

static  void method_18440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> >)((((const ::std::vector<unsigned char>*)o)->begin)());
  else   (((const ::std::vector<unsigned char>*)o)->begin)();
}

static  void method_18441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->end)());
  else   (((::std::vector<unsigned char>*)o)->end)();
}

static  void method_18442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> >)((((const ::std::vector<unsigned char>*)o)->end)());
  else   (((const ::std::vector<unsigned char>*)o)->end)();
}

static  void method_18447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char>*)o)->size)());
  else   (((const ::std::vector<unsigned char>*)o)->size)();
}

static  void method_18448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char>*)o)->max_size)());
  else   (((const ::std::vector<unsigned char>*)o)->max_size)();
}

static  void method_18449( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned char>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned char>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned char*)arg[1]);
  }
}

static  void method_18450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char>*)o)->capacity)());
  else   (((const ::std::vector<unsigned char>*)o)->capacity)();
}

static  void method_18451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned char>*)o)->empty)());
  else   (((const ::std::vector<unsigned char>*)o)->empty)();
}

static  void method_18452( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->front)();
  else   (((::std::vector<unsigned char>*)o)->front)();
}

static  void method_18459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->front)();
  else   (((const ::std::vector<unsigned char>*)o)->front)();
}

static  void method_18460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->back)();
  else   (((::std::vector<unsigned char>*)o)->back)();
}

static  void method_18461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->back)();
  else   (((const ::std::vector<unsigned char>*)o)->back)();
}

static  void method_18462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned char>*)o)->data)());
  else   (((::std::vector<unsigned char>*)o)->data)();
}

static  void method_18463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned char>*)o)->data)());
  else   (((const ::std::vector<unsigned char>*)o)->data)();
}

static  void method_18464( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->push_back)(*(const unsigned char*)arg[0]);
}

static  void method_18465( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned char>*)o)->pop_back)();
}

static  void method_18466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(const unsigned char*)arg[1]));
  else   (((::std::vector<unsigned char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(const unsigned char*)arg[1]);
}

static  void method_18467( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned char*)arg[2]);
}

static  void method_18468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0]));
  else   (((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0]);
}

static  void method_18469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[1]));
  else   (((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[1]);
}

static  void method_18470( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->swap)(*(::std::vector<unsigned char>*)arg[0]);
}

static  void method_18471( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned char>*)o)->clear)();
}

static void method_newdel_3099( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x134( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned char,std::allocator<unsigned char> >")), ::Reflex::BaseOffset< ::std::vector<unsigned char>,::std::_Vector_base<unsigned char,std::allocator<unsigned char> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned char> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned char> >::Generate();
}

//------Dictionary for class vector<unsigned char,std::allocator<unsigned char> > -------------------------------
void __std__vector_unsignedschar__db_datamem(Reflex::Class*);
void __std__vector_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedschar__datamem_bld(&__std__vector_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedschar__funcmem_bld(&__std__vector_unsignedschar__db_funcmem);
void __std__vector_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned char>"), typeid(::std::vector<unsigned char>), sizeof(::std::vector<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3029, ::Reflex::BaseOffset< ::std::vector<unsigned char>, ::std::_Vector_base<unsigned char,std::allocator<unsigned char> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_291, Reflex::Literal("std::vector<unsigned char>::_Alloc_value_type"))
  .AddTypedef(type_3029, Reflex::Literal("std::vector<unsigned char>::_Base"))
  .AddTypedef(type_3689, Reflex::Literal("std::vector<unsigned char>::_Tp_alloc_type"))
  .AddTypedef(type_11030, Reflex::Literal("std::vector<unsigned char>::_Alloc_traits"))
  .AddTypedef(type_291, Reflex::Literal("std::vector<unsigned char>::value_type"))
  .AddTypedef(type_17438, Reflex::Literal("std::vector<unsigned char>::pointer"))
  .AddTypedef(type_18419, Reflex::Literal("std::vector<unsigned char>::const_pointer"))
  .AddTypedef(type_18421, Reflex::Literal("std::vector<unsigned char>::reference"))
  .AddTypedef(type_18423, Reflex::Literal("std::vector<unsigned char>::const_reference"))
  .AddTypedef(type_10864, Reflex::Literal("std::vector<unsigned char>::iterator"))
  .AddTypedef(type_10865, Reflex::Literal("std::vector<unsigned char>::const_iterator"))
  .AddTypedef(type_3912, Reflex::Literal("std::vector<unsigned char>::const_reverse_iterator"))
  .AddTypedef(type_3913, Reflex::Literal("std::vector<unsigned char>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<unsigned char>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<unsigned char>::difference_type"))
  .AddTypedef(type_3689, Reflex::Literal("std::vector<unsigned char>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18432, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32315), Reflex::Literal("vector"), constructor_18433, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18423, type_32315), Reflex::Literal("vector"), constructor_18434, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32674), Reflex::Literal("vector"), constructor_18435, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18436, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3099, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedschar__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned char,std::allocator<unsigned char> > -------------------
void __std__vector_unsignedschar__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned char,std::allocator<unsigned char> > -------------------
void __std__vector_unsignedschar__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32675, type_32674), Reflex::Literal("operator="), operator_18437, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18423), Reflex::Literal("assign"), method_18438, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864), Reflex::Literal("begin"), method_18439, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10865), Reflex::Literal("begin"), method_18440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864), Reflex::Literal("end"), method_18441, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10865), Reflex::Literal("end"), method_18442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_291), Reflex::Literal("resize"), method_18449, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18452, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18421, type_3405), Reflex::Literal("operator[]"), operator_18453, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18423, type_3405), Reflex::Literal("operator[]"), operator_18454, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18421, type_3405), Reflex::Literal("at"), method_18456, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18423, type_3405), Reflex::Literal("at"), method_18457, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18421), Reflex::Literal("front"), method_18458, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18423), Reflex::Literal("front"), method_18459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18421), Reflex::Literal("back"), method_18460, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18423), Reflex::Literal("back"), method_18461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17438), Reflex::Literal("data"), method_18462, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18419), Reflex::Literal("data"), method_18463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18423), Reflex::Literal("push_back"), method_18464, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18465, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864, type_10864, type_18423), Reflex::Literal("insert"), method_18466, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10864, type_3405, type_18423), Reflex::Literal("insert"), method_18467, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864, type_10864), Reflex::Literal("erase"), method_18468, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864, type_10864, type_10864), Reflex::Literal("erase"), method_18469, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32675), Reflex::Literal("swap"), method_18470, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18471, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long long int,std::allocator<long long int> > -------------------------------
static void constructor_18497( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>();
  else ::new(mem) ::std::vector<long long>();
}

static void constructor_18498( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(const ::std::allocator<long long>*)arg[0]);
  else ::new(mem) ::std::vector<long long>(*(const ::std::allocator<long long>*)arg[0]);
}

static void constructor_18499( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1]);
  else ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1],
      *(const ::std::allocator<long long>*)arg[2]);
  else ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1],
      *(const ::std::allocator<long long>*)arg[2]);
  }
}

static void constructor_18500( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(const ::std::vector<long long>*)arg[0]);
  else ::new(mem) ::std::vector<long long>(*(const ::std::vector<long long>*)arg[0]);
}

static void destructor_18501(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<long long>*)o)->::std::vector<long long>::~vector)();
}
static  void operator_18502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->operator=)(*(const ::std::vector<long long>*)arg[0]);
  else   (((::std::vector<long long>*)o)->operator=)(*(const ::std::vector<long long>*)arg[0]);
}

static  void method_18503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const long long*)arg[1]);
}

static  void method_18504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->begin)());
  else   (((::std::vector<long long>*)o)->begin)();
}

static  void method_18505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> >)((((const ::std::vector<long long>*)o)->begin)());
  else   (((const ::std::vector<long long>*)o)->begin)();
}

static  void method_18506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->end)());
  else   (((::std::vector<long long>*)o)->end)();
}

static  void method_18507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> >)((((const ::std::vector<long long>*)o)->end)());
  else   (((const ::std::vector<long long>*)o)->end)();
}

static  void method_18512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long long>*)o)->size)());
  else   (((const ::std::vector<long long>*)o)->size)();
}

static  void method_18513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long long>*)o)->max_size)());
  else   (((const ::std::vector<long long>*)o)->max_size)();
}

static  void method_18514( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<long long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<long long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(long long*)arg[1]);
  }
}

static  void method_18515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long long>*)o)->capacity)());
  else   (((const ::std::vector<long long>*)o)->capacity)();
}

static  void method_18516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<long long>*)o)->empty)());
  else   (((const ::std::vector<long long>*)o)->empty)();
}

static  void method_18517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->front)();
  else   (((::std::vector<long long>*)o)->front)();
}

static  void method_18524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->front)();
  else   (((const ::std::vector<long long>*)o)->front)();
}

static  void method_18525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->back)();
  else   (((::std::vector<long long>*)o)->back)();
}

static  void method_18526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->back)();
  else   (((const ::std::vector<long long>*)o)->back)();
}

static  void method_18527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<long long>*)o)->data)());
  else   (((::std::vector<long long>*)o)->data)();
}

static  void method_18528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<long long>*)o)->data)());
  else   (((const ::std::vector<long long>*)o)->data)();
}

static  void method_18529( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->push_back)(*(const long long*)arg[0]);
}

static  void method_18530( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long long>*)o)->pop_back)();
}

static  void method_18531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(const long long*)arg[1]));
  else   (((::std::vector<long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(const long long*)arg[1]);
}

static  void method_18532( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const long long*)arg[2]);
}

static  void method_18533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0]));
  else   (((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0]);
}

static  void method_18534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[1]));
  else   (((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[1]);
}

static  void method_18535( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->swap)(*(::std::vector<long long>*)arg[0]);
}

static  void method_18536( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long long>*)o)->clear)();
}

static void method_newdel_3100( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x137( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long long,std::allocator<long long> >")), ::Reflex::BaseOffset< ::std::vector<long long>,::std::_Vector_base<long long,std::allocator<long long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<long long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<long long> >::Generate();
}

//------Dictionary for class vector<long long int,std::allocator<long long int> > -------------------------------
void __std__vector_longslong__db_datamem(Reflex::Class*);
void __std__vector_longslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_longslong__datamem_bld(&__std__vector_longslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_longslong__funcmem_bld(&__std__vector_longslong__db_funcmem);
void __std__vector_longslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<long long>"), typeid(::std::vector<long long>), sizeof(::std::vector<long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3030, ::Reflex::BaseOffset< ::std::vector<long long>, ::std::_Vector_base<long long,std::allocator<long long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2017, Reflex::Literal("std::vector<long long>::_Alloc_value_type"))
  .AddTypedef(type_3030, Reflex::Literal("std::vector<long long>::_Base"))
  .AddTypedef(type_3690, Reflex::Literal("std::vector<long long>::_Tp_alloc_type"))
  .AddTypedef(type_11031, Reflex::Literal("std::vector<long long>::_Alloc_traits"))
  .AddTypedef(type_2017, Reflex::Literal("std::vector<long long>::value_type"))
  .AddTypedef(type_17457, Reflex::Literal("std::vector<long long>::pointer"))
  .AddTypedef(type_18484, Reflex::Literal("std::vector<long long>::const_pointer"))
  .AddTypedef(type_18486, Reflex::Literal("std::vector<long long>::reference"))
  .AddTypedef(type_18488, Reflex::Literal("std::vector<long long>::const_reference"))
  .AddTypedef(type_10866, Reflex::Literal("std::vector<long long>::iterator"))
  .AddTypedef(type_10867, Reflex::Literal("std::vector<long long>::const_iterator"))
  .AddTypedef(type_3914, Reflex::Literal("std::vector<long long>::const_reverse_iterator"))
  .AddTypedef(type_3915, Reflex::Literal("std::vector<long long>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<long long>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<long long>::difference_type"))
  .AddTypedef(type_3690, Reflex::Literal("std::vector<long long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18497, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32328), Reflex::Literal("vector"), constructor_18498, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18488, type_32328), Reflex::Literal("vector"), constructor_18499, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32677), Reflex::Literal("vector"), constructor_18500, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18501, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x137, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_longslong__funcmem_bld);
}

//------Delayed data member builder for class vector<long long int,std::allocator<long long int> > -------------------
void __std__vector_longslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long long int,std::allocator<long long int> > -------------------
void __std__vector_longslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32678, type_32677), Reflex::Literal("operator="), operator_18502, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18488), Reflex::Literal("assign"), method_18503, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866), Reflex::Literal("begin"), method_18504, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10867), Reflex::Literal("begin"), method_18505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866), Reflex::Literal("end"), method_18506, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10867), Reflex::Literal("end"), method_18507, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_2017), Reflex::Literal("resize"), method_18514, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18516, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18517, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18486, type_3405), Reflex::Literal("operator[]"), operator_18518, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18488, type_3405), Reflex::Literal("operator[]"), operator_18519, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18486, type_3405), Reflex::Literal("at"), method_18521, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18488, type_3405), Reflex::Literal("at"), method_18522, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18486), Reflex::Literal("front"), method_18523, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18488), Reflex::Literal("front"), method_18524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18486), Reflex::Literal("back"), method_18525, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18488), Reflex::Literal("back"), method_18526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17457), Reflex::Literal("data"), method_18527, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18484), Reflex::Literal("data"), method_18528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18488), Reflex::Literal("push_back"), method_18529, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18530, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866, type_10866, type_18488), Reflex::Literal("insert"), method_18531, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10866, type_3405, type_18488), Reflex::Literal("insert"), method_18532, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866, type_10866), Reflex::Literal("erase"), method_18533, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866, type_10866, type_10866), Reflex::Literal("erase"), method_18534, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32678), Reflex::Literal("swap"), method_18535, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18536, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long int,std::allocator<long int> > -------------------------------
static void constructor_18562( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>();
  else ::new(mem) ::std::vector<long>();
}

static void constructor_18563( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(const ::std::allocator<long>*)arg[0]);
  else ::new(mem) ::std::vector<long>(*(const ::std::allocator<long>*)arg[0]);
}

static void constructor_18564( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1]);
  else ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1],
      *(const ::std::allocator<long>*)arg[2]);
  else ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1],
      *(const ::std::allocator<long>*)arg[2]);
  }
}

static void constructor_18565( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(const ::std::vector<long>*)arg[0]);
  else ::new(mem) ::std::vector<long>(*(const ::std::vector<long>*)arg[0]);
}

static void destructor_18566(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<long>*)o)->::std::vector<long>::~vector)();
}
static  void operator_18567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->operator=)(*(const ::std::vector<long>*)arg[0]);
  else   (((::std::vector<long>*)o)->operator=)(*(const ::std::vector<long>*)arg[0]);
}

static  void method_18568( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const long*)arg[1]);
}

static  void method_18569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->begin)());
  else   (((::std::vector<long>*)o)->begin)();
}

static  void method_18570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long*,std::vector<long> >)((((const ::std::vector<long>*)o)->begin)());
  else   (((const ::std::vector<long>*)o)->begin)();
}

static  void method_18571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->end)());
  else   (((::std::vector<long>*)o)->end)();
}

static  void method_18572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long*,std::vector<long> >)((((const ::std::vector<long>*)o)->end)());
  else   (((const ::std::vector<long>*)o)->end)();
}

static  void method_18577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long>*)o)->size)());
  else   (((const ::std::vector<long>*)o)->size)();
}

static  void method_18578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long>*)o)->max_size)());
  else   (((const ::std::vector<long>*)o)->max_size)();
}

static  void method_18579( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(long*)arg[1]);
  }
}

static  void method_18580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long>*)o)->capacity)());
  else   (((const ::std::vector<long>*)o)->capacity)();
}

static  void method_18581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<long>*)o)->empty)());
  else   (((const ::std::vector<long>*)o)->empty)();
}

static  void method_18582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->front)();
  else   (((::std::vector<long>*)o)->front)();
}

static  void method_18589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->front)();
  else   (((const ::std::vector<long>*)o)->front)();
}

static  void method_18590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->back)();
  else   (((::std::vector<long>*)o)->back)();
}

static  void method_18591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->back)();
  else   (((const ::std::vector<long>*)o)->back)();
}

static  void method_18592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<long>*)o)->data)());
  else   (((::std::vector<long>*)o)->data)();
}

static  void method_18593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<long>*)o)->data)());
  else   (((const ::std::vector<long>*)o)->data)();
}

static  void method_18594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->push_back)(*(const long*)arg[0]);
}

static  void method_18595( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long>*)o)->pop_back)();
}

static  void method_18596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(const long*)arg[1]));
  else   (((::std::vector<long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(const long*)arg[1]);
}

static  void method_18597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const long*)arg[2]);
}

static  void method_18598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0]));
  else   (((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0]);
}

static  void method_18599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[1]));
  else   (((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[1]);
}

static  void method_18600( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->swap)(*(::std::vector<long>*)arg[0]);
}

static  void method_18601( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long>*)o)->clear)();
}

static void method_newdel_3101( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long,std::allocator<long> >")), ::Reflex::BaseOffset< ::std::vector<long>,::std::_Vector_base<long,std::allocator<long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<long> >::Generate();
}

//------Dictionary for class vector<long int,std::allocator<long int> > -------------------------------
void __std__vector_long__db_datamem(Reflex::Class*);
void __std__vector_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_long__datamem_bld(&__std__vector_long__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_long__funcmem_bld(&__std__vector_long__db_funcmem);
void __std__vector_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<long>"), typeid(::std::vector<long>), sizeof(::std::vector<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3031, ::Reflex::BaseOffset< ::std::vector<long>, ::std::_Vector_base<long,std::allocator<long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_194, Reflex::Literal("std::vector<long>::_Alloc_value_type"))
  .AddTypedef(type_3031, Reflex::Literal("std::vector<long>::_Base"))
  .AddTypedef(type_3691, Reflex::Literal("std::vector<long>::_Tp_alloc_type"))
  .AddTypedef(type_11032, Reflex::Literal("std::vector<long>::_Alloc_traits"))
  .AddTypedef(type_194, Reflex::Literal("std::vector<long>::value_type"))
  .AddTypedef(type_9464, Reflex::Literal("std::vector<long>::pointer"))
  .AddTypedef(type_18549, Reflex::Literal("std::vector<long>::const_pointer"))
  .AddTypedef(type_18551, Reflex::Literal("std::vector<long>::reference"))
  .AddTypedef(type_18553, Reflex::Literal("std::vector<long>::const_reference"))
  .AddTypedef(type_10868, Reflex::Literal("std::vector<long>::iterator"))
  .AddTypedef(type_10869, Reflex::Literal("std::vector<long>::const_iterator"))
  .AddTypedef(type_3916, Reflex::Literal("std::vector<long>::const_reverse_iterator"))
  .AddTypedef(type_3917, Reflex::Literal("std::vector<long>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<long>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<long>::difference_type"))
  .AddTypedef(type_3691, Reflex::Literal("std::vector<long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18562, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32341), Reflex::Literal("vector"), constructor_18563, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18553, type_32341), Reflex::Literal("vector"), constructor_18564, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32679), Reflex::Literal("vector"), constructor_18565, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18566, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_long__funcmem_bld);
}

//------Delayed data member builder for class vector<long int,std::allocator<long int> > -------------------
void __std__vector_long__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long int,std::allocator<long int> > -------------------
void __std__vector_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32680, type_32679), Reflex::Literal("operator="), operator_18567, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18553), Reflex::Literal("assign"), method_18568, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868), Reflex::Literal("begin"), method_18569, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10869), Reflex::Literal("begin"), method_18570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868), Reflex::Literal("end"), method_18571, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10869), Reflex::Literal("end"), method_18572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_194), Reflex::Literal("resize"), method_18579, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18582, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18551, type_3405), Reflex::Literal("operator[]"), operator_18583, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18553, type_3405), Reflex::Literal("operator[]"), operator_18584, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18551, type_3405), Reflex::Literal("at"), method_18586, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18553, type_3405), Reflex::Literal("at"), method_18587, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18551), Reflex::Literal("front"), method_18588, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18553), Reflex::Literal("front"), method_18589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18551), Reflex::Literal("back"), method_18590, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18553), Reflex::Literal("back"), method_18591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9464), Reflex::Literal("data"), method_18592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18549), Reflex::Literal("data"), method_18593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18553), Reflex::Literal("push_back"), method_18594, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18595, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868, type_10868, type_18553), Reflex::Literal("insert"), method_18596, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10868, type_3405, type_18553), Reflex::Literal("insert"), method_18597, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868, type_10868), Reflex::Literal("erase"), method_18598, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868, type_10868, type_10868), Reflex::Literal("erase"), method_18599, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32680), Reflex::Literal("swap"), method_18600, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18601, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<int,std::allocator<int> > -------------------------------
static void constructor_18627( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>();
  else ::new(mem) ::std::vector<int>();
}

static void constructor_18628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(const ::std::allocator<int>*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(const ::std::allocator<int>*)arg[0]);
}

static void constructor_18629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  }
}

static void constructor_18630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(const ::std::vector<int>*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(const ::std::vector<int>*)arg[0]);
}

static void destructor_18631(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<int>*)o)->::std::vector<int>::~vector)();
}
static  void operator_18632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->operator=)(*(const ::std::vector<int>*)arg[0]);
  else   (((::std::vector<int>*)o)->operator=)(*(const ::std::vector<int>*)arg[0]);
}

static  void method_18633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const int*)arg[1]);
}

static  void method_18634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->begin)());
  else   (((::std::vector<int>*)o)->begin)();
}

static  void method_18635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const int*,std::vector<int> >)((((const ::std::vector<int>*)o)->begin)());
  else   (((const ::std::vector<int>*)o)->begin)();
}

static  void method_18636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->end)());
  else   (((::std::vector<int>*)o)->end)();
}

static  void method_18637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const int*,std::vector<int> >)((((const ::std::vector<int>*)o)->end)());
  else   (((const ::std::vector<int>*)o)->end)();
}

static  void method_18642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->size)());
  else   (((const ::std::vector<int>*)o)->size)();
}

static  void method_18643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->max_size)());
  else   (((const ::std::vector<int>*)o)->max_size)();
}

static  void method_18644( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_18645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->capacity)());
  else   (((const ::std::vector<int>*)o)->capacity)();
}

static  void method_18646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<int>*)o)->empty)());
  else   (((const ::std::vector<int>*)o)->empty)();
}

static  void method_18647( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->front)();
  else   (((::std::vector<int>*)o)->front)();
}

static  void method_18654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->front)();
  else   (((const ::std::vector<int>*)o)->front)();
}

static  void method_18655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->back)();
  else   (((::std::vector<int>*)o)->back)();
}

static  void method_18656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->back)();
  else   (((const ::std::vector<int>*)o)->back)();
}

static  void method_18657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<int>*)o)->data)());
  else   (((::std::vector<int>*)o)->data)();
}

static  void method_18658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<int>*)o)->data)());
  else   (((const ::std::vector<int>*)o)->data)();
}

static  void method_18659( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->push_back)(*(const int*)arg[0]);
}

static  void method_18660( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<int>*)o)->pop_back)();
}

static  void method_18661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(const int*)arg[1]));
  else   (((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(const int*)arg[1]);
}

static  void method_18662( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const int*)arg[2]);
}

static  void method_18663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0]));
  else   (((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0]);
}

static  void method_18664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[1]));
  else   (((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[1]);
}

static  void method_18665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->swap)(*(::std::vector<int>*)arg[0]);
}

static  void method_18666( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<int>*)o)->clear)();
}

static void method_newdel_3102( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<int,std::allocator<int> >")), ::Reflex::BaseOffset< ::std::vector<int>,::std::_Vector_base<int,std::allocator<int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x144( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<int> >::Generate();
}

//------Dictionary for class vector<int,std::allocator<int> > -------------------------------
void __std__vector_int__db_datamem(Reflex::Class*);
void __std__vector_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_int__datamem_bld(&__std__vector_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_int__funcmem_bld(&__std__vector_int__db_funcmem);
void __std__vector_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<int>"), typeid(::std::vector<int>), sizeof(::std::vector<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3039, ::Reflex::BaseOffset< ::std::vector<int>, ::std::_Vector_base<int,std::allocator<int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_141, Reflex::Literal("std::vector<int>::_Alloc_value_type"))
  .AddTypedef(type_3039, Reflex::Literal("std::vector<int>::_Base"))
  .AddTypedef(type_3692, Reflex::Literal("std::vector<int>::_Tp_alloc_type"))
  .AddTypedef(type_11040, Reflex::Literal("std::vector<int>::_Alloc_traits"))
  .AddTypedef(type_141, Reflex::Literal("std::vector<int>::value_type"))
  .AddTypedef(type_4140, Reflex::Literal("std::vector<int>::pointer"))
  .AddTypedef(type_18614, Reflex::Literal("std::vector<int>::const_pointer"))
  .AddTypedef(type_18616, Reflex::Literal("std::vector<int>::reference"))
  .AddTypedef(type_18618, Reflex::Literal("std::vector<int>::const_reference"))
  .AddTypedef(type_10884, Reflex::Literal("std::vector<int>::iterator"))
  .AddTypedef(type_10885, Reflex::Literal("std::vector<int>::const_iterator"))
  .AddTypedef(type_3944, Reflex::Literal("std::vector<int>::const_reverse_iterator"))
  .AddTypedef(type_3945, Reflex::Literal("std::vector<int>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<int>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<int>::difference_type"))
  .AddTypedef(type_3692, Reflex::Literal("std::vector<int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18627, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32445), Reflex::Literal("vector"), constructor_18628, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18618, type_32445), Reflex::Literal("vector"), constructor_18629, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19651), Reflex::Literal("vector"), constructor_18630, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18631, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3102, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x144, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_int__funcmem_bld);
}

//------Delayed data member builder for class vector<int,std::allocator<int> > -------------------
void __std__vector_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<int,std::allocator<int> > -------------------
void __std__vector_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19649, type_19651), Reflex::Literal("operator="), operator_18632, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18618), Reflex::Literal("assign"), method_18633, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884), Reflex::Literal("begin"), method_18634, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10885), Reflex::Literal("begin"), method_18635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884), Reflex::Literal("end"), method_18636, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10885), Reflex::Literal("end"), method_18637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_141), Reflex::Literal("resize"), method_18644, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18647, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18616, type_3405), Reflex::Literal("operator[]"), operator_18648, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618, type_3405), Reflex::Literal("operator[]"), operator_18649, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18616, type_3405), Reflex::Literal("at"), method_18651, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618, type_3405), Reflex::Literal("at"), method_18652, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18616), Reflex::Literal("front"), method_18653, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618), Reflex::Literal("front"), method_18654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18616), Reflex::Literal("back"), method_18655, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618), Reflex::Literal("back"), method_18656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4140), Reflex::Literal("data"), method_18657, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18614), Reflex::Literal("data"), method_18658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18618), Reflex::Literal("push_back"), method_18659, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18660, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884, type_10884, type_18618), Reflex::Literal("insert"), method_18661, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10884, type_3405, type_18618), Reflex::Literal("insert"), method_18662, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884, type_10884), Reflex::Literal("erase"), method_18663, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884, type_10884, type_10884), Reflex::Literal("erase"), method_18664, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19649), Reflex::Literal("swap"), method_18665, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18666, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<short int,std::allocator<short int> > -------------------------------
static void constructor_18692( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>();
  else ::new(mem) ::std::vector<short>();
}

static void constructor_18693( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(const ::std::allocator<short>*)arg[0]);
  else ::new(mem) ::std::vector<short>(*(const ::std::allocator<short>*)arg[0]);
}

static void constructor_18694( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1]);
  else ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1],
      *(const ::std::allocator<short>*)arg[2]);
  else ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1],
      *(const ::std::allocator<short>*)arg[2]);
  }
}

static void constructor_18695( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(const ::std::vector<short>*)arg[0]);
  else ::new(mem) ::std::vector<short>(*(const ::std::vector<short>*)arg[0]);
}

static void destructor_18696(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<short>*)o)->::std::vector<short>::~vector)();
}
static  void operator_18697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->operator=)(*(const ::std::vector<short>*)arg[0]);
  else   (((::std::vector<short>*)o)->operator=)(*(const ::std::vector<short>*)arg[0]);
}

static  void method_18698( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const short*)arg[1]);
}

static  void method_18699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->begin)());
  else   (((::std::vector<short>*)o)->begin)();
}

static  void method_18700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const short*,std::vector<short> >)((((const ::std::vector<short>*)o)->begin)());
  else   (((const ::std::vector<short>*)o)->begin)();
}

static  void method_18701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->end)());
  else   (((::std::vector<short>*)o)->end)();
}

static  void method_18702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const short*,std::vector<short> >)((((const ::std::vector<short>*)o)->end)());
  else   (((const ::std::vector<short>*)o)->end)();
}

static  void method_18707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<short>*)o)->size)());
  else   (((const ::std::vector<short>*)o)->size)();
}

static  void method_18708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<short>*)o)->max_size)());
  else   (((const ::std::vector<short>*)o)->max_size)();
}

static  void method_18709( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<short>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<short>*)o)->resize)(*(::std::size_t*)arg[0],
      *(short*)arg[1]);
  }
}

static  void method_18710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<short>*)o)->capacity)());
  else   (((const ::std::vector<short>*)o)->capacity)();
}

static  void method_18711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<short>*)o)->empty)());
  else   (((const ::std::vector<short>*)o)->empty)();
}

static  void method_18712( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->front)();
  else   (((::std::vector<short>*)o)->front)();
}

static  void method_18719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->front)();
  else   (((const ::std::vector<short>*)o)->front)();
}

static  void method_18720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->back)();
  else   (((::std::vector<short>*)o)->back)();
}

static  void method_18721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->back)();
  else   (((const ::std::vector<short>*)o)->back)();
}

static  void method_18722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<short>*)o)->data)());
  else   (((::std::vector<short>*)o)->data)();
}

static  void method_18723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<short>*)o)->data)());
  else   (((const ::std::vector<short>*)o)->data)();
}

static  void method_18724( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->push_back)(*(const short*)arg[0]);
}

static  void method_18725( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<short>*)o)->pop_back)();
}

static  void method_18726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(const short*)arg[1]));
  else   (((::std::vector<short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(const short*)arg[1]);
}

static  void method_18727( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const short*)arg[2]);
}

static  void method_18728( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0]));
  else   (((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0]);
}

static  void method_18729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[1]));
  else   (((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[1]);
}

static  void method_18730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->swap)(*(::std::vector<short>*)arg[0]);
}

static  void method_18731( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<short>*)o)->clear)();
}

static void method_newdel_3103( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x146( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<short,std::allocator<short> >")), ::Reflex::BaseOffset< ::std::vector<short>,::std::_Vector_base<short,std::allocator<short> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x147( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<short> >::Generate();
  else ::Reflex::Proxy< ::std::vector<short> >::Generate();
}

//------Dictionary for class vector<short int,std::allocator<short int> > -------------------------------
void __std__vector_short__db_datamem(Reflex::Class*);
void __std__vector_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_short__datamem_bld(&__std__vector_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_short__funcmem_bld(&__std__vector_short__db_funcmem);
void __std__vector_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<short>"), typeid(::std::vector<short>), sizeof(::std::vector<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3032, ::Reflex::BaseOffset< ::std::vector<short>, ::std::_Vector_base<short,std::allocator<short> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_196, Reflex::Literal("std::vector<short>::_Alloc_value_type"))
  .AddTypedef(type_3032, Reflex::Literal("std::vector<short>::_Base"))
  .AddTypedef(type_3693, Reflex::Literal("std::vector<short>::_Tp_alloc_type"))
  .AddTypedef(type_11033, Reflex::Literal("std::vector<short>::_Alloc_traits"))
  .AddTypedef(type_196, Reflex::Literal("std::vector<short>::value_type"))
  .AddTypedef(type_17494, Reflex::Literal("std::vector<short>::pointer"))
  .AddTypedef(type_18679, Reflex::Literal("std::vector<short>::const_pointer"))
  .AddTypedef(type_18681, Reflex::Literal("std::vector<short>::reference"))
  .AddTypedef(type_18683, Reflex::Literal("std::vector<short>::const_reference"))
  .AddTypedef(type_10870, Reflex::Literal("std::vector<short>::iterator"))
  .AddTypedef(type_10871, Reflex::Literal("std::vector<short>::const_iterator"))
  .AddTypedef(type_3918, Reflex::Literal("std::vector<short>::const_reverse_iterator"))
  .AddTypedef(type_3919, Reflex::Literal("std::vector<short>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<short>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<short>::difference_type"))
  .AddTypedef(type_3693, Reflex::Literal("std::vector<short>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18692, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32354), Reflex::Literal("vector"), constructor_18693, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18683, type_32354), Reflex::Literal("vector"), constructor_18694, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32682), Reflex::Literal("vector"), constructor_18695, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18696, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x146, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_short__funcmem_bld);
}

//------Delayed data member builder for class vector<short int,std::allocator<short int> > -------------------
void __std__vector_short__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<short int,std::allocator<short int> > -------------------
void __std__vector_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32683, type_32682), Reflex::Literal("operator="), operator_18697, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18683), Reflex::Literal("assign"), method_18698, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870), Reflex::Literal("begin"), method_18699, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10871), Reflex::Literal("begin"), method_18700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870), Reflex::Literal("end"), method_18701, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10871), Reflex::Literal("end"), method_18702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_196), Reflex::Literal("resize"), method_18709, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18712, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18681, type_3405), Reflex::Literal("operator[]"), operator_18713, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18683, type_3405), Reflex::Literal("operator[]"), operator_18714, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18681, type_3405), Reflex::Literal("at"), method_18716, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18683, type_3405), Reflex::Literal("at"), method_18717, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18681), Reflex::Literal("front"), method_18718, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18683), Reflex::Literal("front"), method_18719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18681), Reflex::Literal("back"), method_18720, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18683), Reflex::Literal("back"), method_18721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17494), Reflex::Literal("data"), method_18722, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18679), Reflex::Literal("data"), method_18723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18683), Reflex::Literal("push_back"), method_18724, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18725, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870, type_10870, type_18683), Reflex::Literal("insert"), method_18726, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10870, type_3405, type_18683), Reflex::Literal("insert"), method_18727, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870, type_10870), Reflex::Literal("erase"), method_18728, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870, type_10870, type_10870), Reflex::Literal("erase"), method_18729, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32683), Reflex::Literal("swap"), method_18730, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18731, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<char,std::allocator<char> > -------------------------------
static void constructor_18756( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>();
  else ::new(mem) ::std::vector<char>();
}

static void constructor_18757( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::vector<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_18758( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1]);
  else ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_18759( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(const ::std::vector<char>*)arg[0]);
  else ::new(mem) ::std::vector<char>(*(const ::std::vector<char>*)arg[0]);
}

static void destructor_18760(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<char>*)o)->::std::vector<char>::~vector)();
}
static  void operator_18761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->operator=)(*(const ::std::vector<char>*)arg[0]);
  else   (((::std::vector<char>*)o)->operator=)(*(const ::std::vector<char>*)arg[0]);
}

static  void method_18762( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const char*)arg[1]);
}

static  void method_18763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->begin)());
  else   (((::std::vector<char>*)o)->begin)();
}

static  void method_18764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::vector<char> >)((((const ::std::vector<char>*)o)->begin)());
  else   (((const ::std::vector<char>*)o)->begin)();
}

static  void method_18765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->end)());
  else   (((::std::vector<char>*)o)->end)();
}

static  void method_18766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::vector<char> >)((((const ::std::vector<char>*)o)->end)());
  else   (((const ::std::vector<char>*)o)->end)();
}

static  void method_18771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char>*)o)->size)());
  else   (((const ::std::vector<char>*)o)->size)();
}

static  void method_18772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char>*)o)->max_size)());
  else   (((const ::std::vector<char>*)o)->max_size)();
}

static  void method_18773( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<char>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<char>*)o)->resize)(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  }
}

static  void method_18774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char>*)o)->capacity)());
  else   (((const ::std::vector<char>*)o)->capacity)();
}

static  void method_18775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<char>*)o)->empty)());
  else   (((const ::std::vector<char>*)o)->empty)();
}

static  void method_18776( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->front)();
  else   (((::std::vector<char>*)o)->front)();
}

static  void method_18783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->front)();
  else   (((const ::std::vector<char>*)o)->front)();
}

static  void method_18784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->back)();
  else   (((::std::vector<char>*)o)->back)();
}

static  void method_18785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->back)();
  else   (((const ::std::vector<char>*)o)->back)();
}

static  void method_18786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<char>*)o)->data)());
  else   (((::std::vector<char>*)o)->data)();
}

static  void method_18787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<char>*)o)->data)());
  else   (((const ::std::vector<char>*)o)->data)();
}

static  void method_18788( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->push_back)(*(const char*)arg[0]);
}

static  void method_18789( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<char>*)o)->pop_back)();
}

static  void method_18790( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(const char*)arg[1]));
  else   (((::std::vector<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(const char*)arg[1]);
}

static  void method_18791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const char*)arg[2]);
}

static  void method_18792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0]));
  else   (((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0]);
}

static  void method_18793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[1]));
  else   (((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[1]);
}

static  void method_18794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->swap)(*(::std::vector<char>*)arg[0]);
}

static  void method_18795( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<char>*)o)->clear)();
}

static void method_newdel_3104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x149( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<char,std::allocator<char> >")), ::Reflex::BaseOffset< ::std::vector<char>,::std::_Vector_base<char,std::allocator<char> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<char> >::Generate();
  else ::Reflex::Proxy< ::std::vector<char> >::Generate();
}

//------Dictionary for class vector<char,std::allocator<char> > -------------------------------
void __std__vector_char__db_datamem(Reflex::Class*);
void __std__vector_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_char__datamem_bld(&__std__vector_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_char__funcmem_bld(&__std__vector_char__db_funcmem);
void __std__vector_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<char>"), typeid(::std::vector<char>), sizeof(::std::vector<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3033, ::Reflex::BaseOffset< ::std::vector<char>, ::std::_Vector_base<char,std::allocator<char> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1039, Reflex::Literal("std::vector<char>::_Alloc_value_type"))
  .AddTypedef(type_3033, Reflex::Literal("std::vector<char>::_Base"))
  .AddTypedef(type_3694, Reflex::Literal("std::vector<char>::_Tp_alloc_type"))
  .AddTypedef(type_11034, Reflex::Literal("std::vector<char>::_Alloc_traits"))
  .AddTypedef(type_1039, Reflex::Literal("std::vector<char>::value_type"))
  .AddTypedef(type_2786, Reflex::Literal("std::vector<char>::pointer"))
  .AddTypedef(type_4138, Reflex::Literal("std::vector<char>::const_pointer"))
  .AddTypedef(type_18745, Reflex::Literal("std::vector<char>::reference"))
  .AddTypedef(type_18747, Reflex::Literal("std::vector<char>::const_reference"))
  .AddTypedef(type_10872, Reflex::Literal("std::vector<char>::iterator"))
  .AddTypedef(type_10873, Reflex::Literal("std::vector<char>::const_iterator"))
  .AddTypedef(type_3920, Reflex::Literal("std::vector<char>::const_reverse_iterator"))
  .AddTypedef(type_3921, Reflex::Literal("std::vector<char>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<char>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<char>::difference_type"))
  .AddTypedef(type_3694, Reflex::Literal("std::vector<char>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18756, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32367), Reflex::Literal("vector"), constructor_18757, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18747, type_32367), Reflex::Literal("vector"), constructor_18758, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32684), Reflex::Literal("vector"), constructor_18759, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18760, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x149, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_char__funcmem_bld);
}

//------Delayed data member builder for class vector<char,std::allocator<char> > -------------------
void __std__vector_char__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<char,std::allocator<char> > -------------------
void __std__vector_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32685, type_32684), Reflex::Literal("operator="), operator_18761, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18747), Reflex::Literal("assign"), method_18762, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872), Reflex::Literal("begin"), method_18763, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10873), Reflex::Literal("begin"), method_18764, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872), Reflex::Literal("end"), method_18765, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10873), Reflex::Literal("end"), method_18766, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_1039), Reflex::Literal("resize"), method_18773, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18776, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18745, type_3405), Reflex::Literal("operator[]"), operator_18777, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18747, type_3405), Reflex::Literal("operator[]"), operator_18778, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18745, type_3405), Reflex::Literal("at"), method_18780, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18747, type_3405), Reflex::Literal("at"), method_18781, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18745), Reflex::Literal("front"), method_18782, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18747), Reflex::Literal("front"), method_18783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18745), Reflex::Literal("back"), method_18784, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18747), Reflex::Literal("back"), method_18785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2786), Reflex::Literal("data"), method_18786, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4138), Reflex::Literal("data"), method_18787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18747), Reflex::Literal("push_back"), method_18788, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18789, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872, type_10872, type_18747), Reflex::Literal("insert"), method_18790, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10872, type_3405, type_18747), Reflex::Literal("insert"), method_18791, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872, type_10872), Reflex::Literal("erase"), method_18792, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872, type_10872, type_10872), Reflex::Literal("erase"), method_18793, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32685), Reflex::Literal("swap"), method_18794, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18795, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooFitResult*,std::allocator<RooFitResult*> > -------------------------------
static void constructor_18822( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>();
  else ::new(mem) ::std::vector<RooFitResult*>();
}

static void constructor_18823( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(const ::std::allocator<RooFitResult*>*)arg[0]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(const ::std::allocator<RooFitResult*>*)arg[0]);
}

static void constructor_18824( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0],
      *(::RooFitResult* const*)arg[1]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0],
      *(::RooFitResult* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0],
      *(::RooFitResult* const*)arg[1],
      *(const ::std::allocator<RooFitResult*>*)arg[2]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0],
      *(::RooFitResult* const*)arg[1],
      *(const ::std::allocator<RooFitResult*>*)arg[2]);
  }
}

static void constructor_18825( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(const ::std::vector<RooFitResult*>*)arg[0]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(const ::std::vector<RooFitResult*>*)arg[0]);
}

static void destructor_18826(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooFitResult*>*)o)->::std::vector<RooFitResult*>::~vector)();
}
static  void operator_18827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->operator=)(*(const ::std::vector<RooFitResult*>*)arg[0]);
  else   (((::std::vector<RooFitResult*>*)o)->operator=)(*(const ::std::vector<RooFitResult*>*)arg[0]);
}

static  void method_18828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooFitResult* const*)arg[1]);
}

static  void method_18829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->begin)());
  else   (((::std::vector<RooFitResult*>*)o)->begin)();
}

static  void method_18830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult* const*,std::vector<RooFitResult*> >)((((const ::std::vector<RooFitResult*>*)o)->begin)());
  else   (((const ::std::vector<RooFitResult*>*)o)->begin)();
}

static  void method_18831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->end)());
  else   (((::std::vector<RooFitResult*>*)o)->end)();
}

static  void method_18832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult* const*,std::vector<RooFitResult*> >)((((const ::std::vector<RooFitResult*>*)o)->end)());
  else   (((const ::std::vector<RooFitResult*>*)o)->end)();
}

static  void method_18837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooFitResult*>*)o)->size)());
  else   (((const ::std::vector<RooFitResult*>*)o)->size)();
}

static  void method_18838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooFitResult*>*)o)->max_size)());
  else   (((const ::std::vector<RooFitResult*>*)o)->max_size)();
}

static  void method_18839( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooFitResult*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooFitResult*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooFitResult*)arg[1]);
  }
}

static  void method_18840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooFitResult*>*)o)->capacity)());
  else   (((const ::std::vector<RooFitResult*>*)o)->capacity)();
}

static  void method_18841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooFitResult*>*)o)->empty)());
  else   (((const ::std::vector<RooFitResult*>*)o)->empty)();
}

static  void method_18842( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18843( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooFitResult*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooFitResult*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooFitResult*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooFitResult*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18847( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooFitResult*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooFitResult*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->front)();
  else   (((::std::vector<RooFitResult*>*)o)->front)();
}

static  void method_18849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooFitResult*>*)o)->front)();
  else   (((const ::std::vector<RooFitResult*>*)o)->front)();
}

static  void method_18850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->back)();
  else   (((::std::vector<RooFitResult*>*)o)->back)();
}

static  void method_18851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooFitResult*>*)o)->back)();
  else   (((const ::std::vector<RooFitResult*>*)o)->back)();
}

static  void method_18852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooFitResult*>*)o)->data)());
  else   (((::std::vector<RooFitResult*>*)o)->data)();
}

static  void method_18853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooFitResult*>*)o)->data)());
  else   (((const ::std::vector<RooFitResult*>*)o)->data)();
}

static  void method_18854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->push_back)(*(::RooFitResult* const*)arg[0]);
}

static  void method_18855( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooFitResult*>*)o)->pop_back)();
}

static  void method_18856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::RooFitResult* const*)arg[1]));
  else   (((::std::vector<RooFitResult*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::RooFitResult* const*)arg[1]);
}

static  void method_18857( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooFitResult* const*)arg[2]);
}

static  void method_18858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0]));
  else   (((::std::vector<RooFitResult*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0]);
}

static  void method_18859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[1]));
  else   (((::std::vector<RooFitResult*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[1]);
}

static  void method_18860( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->swap)(*(::std::vector<RooFitResult*>*)arg[0]);
}

static  void method_18861( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooFitResult*>*)o)->clear)();
}

static void method_newdel_3105( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> >")), ::Reflex::BaseOffset< ::std::vector<RooFitResult*>,::std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooFitResult*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooFitResult*> >::Generate();
}

//------Dictionary for class vector<RooFitResult*,std::allocator<RooFitResult*> > -------------------------------
void __std__vector_RooFitResultp__db_datamem(Reflex::Class*);
void __std__vector_RooFitResultp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooFitResultp__datamem_bld(&__std__vector_RooFitResultp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooFitResultp__funcmem_bld(&__std__vector_RooFitResultp__db_funcmem);
void __std__vector_RooFitResultp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooFitResult*>"), typeid(::std::vector<RooFitResult*>), sizeof(::std::vector<RooFitResult*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3034, ::Reflex::BaseOffset< ::std::vector<RooFitResult*>, ::std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_18802, Reflex::Literal("std::vector<RooFitResult*>::_Alloc_value_type"))
  .AddTypedef(type_3034, Reflex::Literal("std::vector<RooFitResult*>::_Base"))
  .AddTypedef(type_3695, Reflex::Literal("std::vector<RooFitResult*>::_Tp_alloc_type"))
  .AddTypedef(type_11035, Reflex::Literal("std::vector<RooFitResult*>::_Alloc_traits"))
  .AddTypedef(type_18802, Reflex::Literal("std::vector<RooFitResult*>::value_type"))
  .AddTypedef(type_17531, Reflex::Literal("std::vector<RooFitResult*>::pointer"))
  .AddTypedef(type_18809, Reflex::Literal("std::vector<RooFitResult*>::const_pointer"))
  .AddTypedef(type_18811, Reflex::Literal("std::vector<RooFitResult*>::reference"))
  .AddTypedef(type_18813, Reflex::Literal("std::vector<RooFitResult*>::const_reference"))
  .AddTypedef(type_10874, Reflex::Literal("std::vector<RooFitResult*>::iterator"))
  .AddTypedef(type_10875, Reflex::Literal("std::vector<RooFitResult*>::const_iterator"))
  .AddTypedef(type_3922, Reflex::Literal("std::vector<RooFitResult*>::const_reverse_iterator"))
  .AddTypedef(type_3923, Reflex::Literal("std::vector<RooFitResult*>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<RooFitResult*>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<RooFitResult*>::difference_type"))
  .AddTypedef(type_3695, Reflex::Literal("std::vector<RooFitResult*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18822, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32380), Reflex::Literal("vector"), constructor_18823, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18813, type_32380), Reflex::Literal("vector"), constructor_18824, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32687), Reflex::Literal("vector"), constructor_18825, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18826, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3105, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooFitResultp__funcmem_bld);
}

//------Delayed data member builder for class vector<RooFitResult*,std::allocator<RooFitResult*> > -------------------
void __std__vector_RooFitResultp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooFitResult*,std::allocator<RooFitResult*> > -------------------
void __std__vector_RooFitResultp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32688, type_32687), Reflex::Literal("operator="), operator_18827, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18813), Reflex::Literal("assign"), method_18828, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874), Reflex::Literal("begin"), method_18829, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10875), Reflex::Literal("begin"), method_18830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874), Reflex::Literal("end"), method_18831, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10875), Reflex::Literal("end"), method_18832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18802), Reflex::Literal("resize"), method_18839, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18842, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18811, type_3405), Reflex::Literal("operator[]"), operator_18843, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18813, type_3405), Reflex::Literal("operator[]"), operator_18844, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18811, type_3405), Reflex::Literal("at"), method_18846, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18813, type_3405), Reflex::Literal("at"), method_18847, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18811), Reflex::Literal("front"), method_18848, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18813), Reflex::Literal("front"), method_18849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18811), Reflex::Literal("back"), method_18850, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18813), Reflex::Literal("back"), method_18851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17531), Reflex::Literal("data"), method_18852, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18809), Reflex::Literal("data"), method_18853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18813), Reflex::Literal("push_back"), method_18854, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18855, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874, type_10874, type_18813), Reflex::Literal("insert"), method_18856, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10874, type_3405, type_18813), Reflex::Literal("insert"), method_18857, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874, type_10874), Reflex::Literal("erase"), method_18858, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874, type_10874, type_10874), Reflex::Literal("erase"), method_18859, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32688), Reflex::Literal("swap"), method_18860, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18861, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void constructor_18887( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >();
}

static void constructor_18888( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static void constructor_18889( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[2]);
  }
}

static void constructor_18890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static void destructor_18891(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::~vector)();
}
static  void operator_18892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_18893( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
}

static  void method_18894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)();
}

static  void method_18895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)();
}

static  void method_18896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)();
}

static  void method_18897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)();
}

static  void method_18902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->size)();
}

static  void method_18903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->max_size)();
}

static  void method_18904( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  }
}

static  void method_18905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->capacity)();
}

static  void method_18906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->empty)();
}

static  void method_18907( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18912( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
}

static  void method_18914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
}

static  void method_18915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
}

static  void method_18916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
}

static  void method_18917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)();
}

static  void method_18918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)();
}

static  void method_18919( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static  void method_18920( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->pop_back)();
}

static  void method_18921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
}

static  void method_18922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[2]);
}

static  void method_18923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0]);
}

static  void method_18924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[1]);
}

static  void method_18925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_18926( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->clear)();
}

static void method_newdel_3106( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >,::std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >"), typeid(::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >), sizeof(::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3035, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >, ::std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3489, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Alloc_value_type"))
  .AddTypedef(type_3035, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Base"))
  .AddTypedef(type_3696, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Tp_alloc_type"))
  .AddTypedef(type_11036, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Alloc_traits"))
  .AddTypedef(type_3489, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_17550, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_18874, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_pointer"))
  .AddTypedef(type_18876, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::reference"))
  .AddTypedef(type_18878, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_reference"))
  .AddTypedef(type_10876, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::iterator"))
  .AddTypedef(type_10877, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_iterator"))
  .AddTypedef(type_3924, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_reverse_iterator"))
  .AddTypedef(type_3925, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_3696, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18887, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32393), Reflex::Literal("vector"), constructor_18888, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18878, type_32393), Reflex::Literal("vector"), constructor_18889, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32690), Reflex::Literal("vector"), constructor_18890, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18891, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32691, type_32690), Reflex::Literal("operator="), operator_18892, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18878), Reflex::Literal("assign"), method_18893, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876), Reflex::Literal("begin"), method_18894, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10877), Reflex::Literal("begin"), method_18895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876), Reflex::Literal("end"), method_18896, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10877), Reflex::Literal("end"), method_18897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_3489), Reflex::Literal("resize"), method_18904, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18907, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18876, type_3405), Reflex::Literal("operator[]"), operator_18908, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18878, type_3405), Reflex::Literal("operator[]"), operator_18909, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18876, type_3405), Reflex::Literal("at"), method_18911, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18878, type_3405), Reflex::Literal("at"), method_18912, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18876), Reflex::Literal("front"), method_18913, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18878), Reflex::Literal("front"), method_18914, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18876), Reflex::Literal("back"), method_18915, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18878), Reflex::Literal("back"), method_18916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17550), Reflex::Literal("data"), method_18917, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18874), Reflex::Literal("data"), method_18918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18878), Reflex::Literal("push_back"), method_18919, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18920, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876, type_10876, type_18878), Reflex::Literal("insert"), method_18921, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10876, type_3405, type_18878), Reflex::Literal("insert"), method_18922, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876, type_10876), Reflex::Literal("erase"), method_18923, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876, type_10876, type_10876), Reflex::Literal("erase"), method_18924, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32691), Reflex::Literal("swap"), method_18925, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18926, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > >,std::allocator<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > > > > -------------------------------
static void constructor_18952( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >();
  else ::new(mem) ::std::vector<std::map<void*,double> >();
}

static void constructor_18953( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(const ::std::allocator<std::map<void*,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(const ::std::allocator<std::map<void*,double> >*)arg[0]);
}

static void constructor_18954( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0],
      *(const ::std::map<void*,double>*)arg[1]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0],
      *(const ::std::map<void*,double>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0],
      *(const ::std::map<void*,double>*)arg[1],
      *(const ::std::allocator<std::map<void*,double> >*)arg[2]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0],
      *(const ::std::map<void*,double>*)arg[1],
      *(const ::std::allocator<std::map<void*,double> >*)arg[2]);
  }
}

static void constructor_18955( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(const ::std::vector<std::map<void*,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(const ::std::vector<std::map<void*,double> >*)arg[0]);
}

static void destructor_18956(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::map<void*,double> >*)o)->::std::vector<std::map<void*,double> >::~vector)();
}
static  void operator_18957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->operator=)(*(const ::std::vector<std::map<void*,double> >*)arg[0]);
  else   (((::std::vector<std::map<void*,double> >*)o)->operator=)(*(const ::std::vector<std::map<void*,double> >*)arg[0]);
}

static  void method_18958( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::map<void*,double>*)arg[1]);
}

static  void method_18959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->begin)());
  else   (((::std::vector<std::map<void*,double> >*)o)->begin)();
}

static  void method_18960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((const ::std::vector<std::map<void*,double> >*)o)->begin)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->begin)();
}

static  void method_18961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->end)());
  else   (((::std::vector<std::map<void*,double> >*)o)->end)();
}

static  void method_18962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((const ::std::vector<std::map<void*,double> >*)o)->end)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->end)();
}

static  void method_18967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<void*,double> >*)o)->size)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->size)();
}

static  void method_18968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<void*,double> >*)o)->max_size)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->max_size)();
}

static  void method_18969( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::map<void*,double> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::map<void*,double> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::map<void*,double>*)arg[1]);
  }
}

static  void method_18970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<void*,double> >*)o)->capacity)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->capacity)();
}

static  void method_18971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::map<void*,double> >*)o)->empty)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->empty)();
}

static  void method_18972( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<void*,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<void*,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<void*,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<void*,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<void*,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<void*,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->front)();
  else   (((::std::vector<std::map<void*,double> >*)o)->front)();
}

static  void method_18979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<void*,double> >*)o)->front)();
  else   (((const ::std::vector<std::map<void*,double> >*)o)->front)();
}

static  void method_18980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->back)();
  else   (((::std::vector<std::map<void*,double> >*)o)->back)();
}

static  void method_18981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<void*,double> >*)o)->back)();
  else   (((const ::std::vector<std::map<void*,double> >*)o)->back)();
}

static  void method_18982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::map<void*,double> >*)o)->data)());
  else   (((::std::vector<std::map<void*,double> >*)o)->data)();
}

static  void method_18983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::map<void*,double> >*)o)->data)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->data)();
}

static  void method_18984( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->push_back)(*(const ::std::map<void*,double>*)arg[0]);
}

static  void method_18985( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->pop_back)();
}

static  void method_18986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(const ::std::map<void*,double>*)arg[1]));
  else   (((::std::vector<std::map<void*,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(const ::std::map<void*,double>*)arg[1]);
}

static  void method_18987( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::map<void*,double>*)arg[2]);
}

static  void method_18988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0]));
  else   (((::std::vector<std::map<void*,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0]);
}

static  void method_18989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[1]));
  else   (((::std::vector<std::map<void*,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[1]);
}

static  void method_18990( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->swap)(*(::std::vector<std::map<void*,double> >*)arg[0]);
}

static  void method_18991( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->clear)();
}

static void method_newdel_3107( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > >")), ::Reflex::BaseOffset< ::std::vector<std::map<void*,double> >,::std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::map<void*,double> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::map<void*,double> > >::Generate();
}

//------Dictionary for class vector<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > >,std::allocator<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > > > > -------------------------------
void __std__vector_std__map_voidp_double_s__db_datamem(Reflex::Class*);
void __std__vector_std__map_voidp_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__map_voidp_double_s__datamem_bld(&__std__vector_std__map_voidp_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__map_voidp_double_s__funcmem_bld(&__std__vector_std__map_voidp_double_s__db_funcmem);
void __std__vector_std__map_voidp_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::map<void*,double> >"), typeid(::std::vector<std::map<void*,double> >), sizeof(::std::vector<std::map<void*,double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3036, ::Reflex::BaseOffset< ::std::vector<std::map<void*,double> >, ::std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3353, Reflex::Literal("std::vector<std::map<void*,double> >::_Alloc_value_type"))
  .AddTypedef(type_3036, Reflex::Literal("std::vector<std::map<void*,double> >::_Base"))
  .AddTypedef(type_3697, Reflex::Literal("std::vector<std::map<void*,double> >::_Tp_alloc_type"))
  .AddTypedef(type_11037, Reflex::Literal("std::vector<std::map<void*,double> >::_Alloc_traits"))
  .AddTypedef(type_3353, Reflex::Literal("std::vector<std::map<void*,double> >::value_type"))
  .AddTypedef(type_17569, Reflex::Literal("std::vector<std::map<void*,double> >::pointer"))
  .AddTypedef(type_18939, Reflex::Literal("std::vector<std::map<void*,double> >::const_pointer"))
  .AddTypedef(type_18941, Reflex::Literal("std::vector<std::map<void*,double> >::reference"))
  .AddTypedef(type_18943, Reflex::Literal("std::vector<std::map<void*,double> >::const_reference"))
  .AddTypedef(type_10878, Reflex::Literal("std::vector<std::map<void*,double> >::iterator"))
  .AddTypedef(type_10879, Reflex::Literal("std::vector<std::map<void*,double> >::const_iterator"))
  .AddTypedef(type_3926, Reflex::Literal("std::vector<std::map<void*,double> >::const_reverse_iterator"))
  .AddTypedef(type_3927, Reflex::Literal("std::vector<std::map<void*,double> >::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<std::map<void*,double> >::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<std::map<void*,double> >::difference_type"))
  .AddTypedef(type_3697, Reflex::Literal("std::vector<std::map<void*,double> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18952, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32406), Reflex::Literal("vector"), constructor_18953, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_18943, type_32406), Reflex::Literal("vector"), constructor_18954, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32693), Reflex::Literal("vector"), constructor_18955, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18956, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__map_voidp_double_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > >,std::allocator<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > > > > -------------------
void __std__vector_std__map_voidp_double_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > >,std::allocator<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > > > > -------------------
void __std__vector_std__map_voidp_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32694, type_32693), Reflex::Literal("operator="), operator_18957, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_18943), Reflex::Literal("assign"), method_18958, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878), Reflex::Literal("begin"), method_18959, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10879), Reflex::Literal("begin"), method_18960, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878), Reflex::Literal("end"), method_18961, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10879), Reflex::Literal("end"), method_18962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_18967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_18968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_3353), Reflex::Literal("resize"), method_18969, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_18970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_18972, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18941, type_3405), Reflex::Literal("operator[]"), operator_18973, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18943, type_3405), Reflex::Literal("operator[]"), operator_18974, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18941, type_3405), Reflex::Literal("at"), method_18976, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18943, type_3405), Reflex::Literal("at"), method_18977, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18941), Reflex::Literal("front"), method_18978, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18943), Reflex::Literal("front"), method_18979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18941), Reflex::Literal("back"), method_18980, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18943), Reflex::Literal("back"), method_18981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17569), Reflex::Literal("data"), method_18982, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18939), Reflex::Literal("data"), method_18983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18943), Reflex::Literal("push_back"), method_18984, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18985, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878, type_10878, type_18943), Reflex::Literal("insert"), method_18986, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10878, type_3405, type_18943), Reflex::Literal("insert"), method_18987, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878, type_10878), Reflex::Literal("erase"), method_18988, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878, type_10878, type_10878), Reflex::Literal("erase"), method_18989, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32694), Reflex::Literal("swap"), method_18990, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18991, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------------------
static void constructor_19017( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >();
  else ::new(mem) ::std::vector<std::vector<double> >();
}

static void constructor_19018( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::allocator<std::vector<double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::allocator<std::vector<double> >*)arg[0]);
}

static void constructor_19019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::std::allocator<std::vector<double> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::std::allocator<std::vector<double> >*)arg[2]);
  }
}

static void constructor_19020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::vector<std::vector<double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::vector<std::vector<double> >*)arg[0]);
}

static void destructor_19021(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<double> >*)o)->::std::vector<std::vector<double> >::~vector)();
}
static  void operator_19022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->operator=)(*(const ::std::vector<std::vector<double> >*)arg[0]);
  else   (((::std::vector<std::vector<double> >*)o)->operator=)(*(const ::std::vector<std::vector<double> >*)arg[0]);
}

static  void method_19023( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<double>*)arg[1]);
}

static  void method_19024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->begin)());
  else   (((::std::vector<std::vector<double> >*)o)->begin)();
}

static  void method_19025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > >)((((const ::std::vector<std::vector<double> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<double> >*)o)->begin)();
}

static  void method_19026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->end)());
  else   (((::std::vector<std::vector<double> >*)o)->end)();
}

static  void method_19027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > >)((((const ::std::vector<std::vector<double> >*)o)->end)());
  else   (((const ::std::vector<std::vector<double> >*)o)->end)();
}

static  void method_19032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double> >*)o)->size)());
  else   (((const ::std::vector<std::vector<double> >*)o)->size)();
}

static  void method_19033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<double> >*)o)->max_size)();
}

static  void method_19034( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<double> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<double> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<double>*)arg[1]);
  }
}

static  void method_19035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<double> >*)o)->capacity)();
}

static  void method_19036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<double> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<double> >*)o)->empty)();
}

static  void method_19037( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19041( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19042( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->front)();
  else   (((::std::vector<std::vector<double> >*)o)->front)();
}

static  void method_19044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->front)();
  else   (((const ::std::vector<std::vector<double> >*)o)->front)();
}

static  void method_19045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->back)();
  else   (((::std::vector<std::vector<double> >*)o)->back)();
}

static  void method_19046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->back)();
  else   (((const ::std::vector<std::vector<double> >*)o)->back)();
}

static  void method_19047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<double> >*)o)->data)());
  else   (((::std::vector<std::vector<double> >*)o)->data)();
}

static  void method_19048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<double> >*)o)->data)());
  else   (((const ::std::vector<std::vector<double> >*)o)->data)();
}

static  void method_19049( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->push_back)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_19050( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double> >*)o)->pop_back)();
}

static  void method_19051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(const ::std::vector<double>*)arg[1]));
  else   (((::std::vector<std::vector<double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(const ::std::vector<double>*)arg[1]);
}

static  void method_19052( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<double>*)arg[2]);
}

static  void method_19053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0]));
  else   (((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0]);
}

static  void method_19054( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[1]));
  else   (((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[1]);
}

static  void method_19055( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->swap)(*(::std::vector<std::vector<double> >*)arg[0]);
}

static  void method_19056( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double> >*)o)->clear)();
}

static void method_newdel_3108( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<double> >,::std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<double> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<double> > >::Generate();
}

//------Dictionary for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------------------
void __std__vector_std__vector_double_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_s__datamem_bld(&__std__vector_std__vector_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_s__funcmem_bld(&__std__vector_std__vector_double_s__db_funcmem);
void __std__vector_std__vector_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<double> >"), typeid(::std::vector<std::vector<double> >), sizeof(::std::vector<std::vector<double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3037, ::Reflex::BaseOffset< ::std::vector<std::vector<double> >, ::std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3092, Reflex::Literal("std::vector<std::vector<double> >::_Alloc_value_type"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<std::vector<double> >::_Base"))
  .AddTypedef(type_3699, Reflex::Literal("std::vector<std::vector<double> >::_Tp_alloc_type"))
  .AddTypedef(type_11038, Reflex::Literal("std::vector<std::vector<double> >::_Alloc_traits"))
  .AddTypedef(type_3092, Reflex::Literal("std::vector<std::vector<double> >::value_type"))
  .AddTypedef(type_17588, Reflex::Literal("std::vector<std::vector<double> >::pointer"))
  .AddTypedef(type_19004, Reflex::Literal("std::vector<std::vector<double> >::const_pointer"))
  .AddTypedef(type_19006, Reflex::Literal("std::vector<std::vector<double> >::reference"))
  .AddTypedef(type_19008, Reflex::Literal("std::vector<std::vector<double> >::const_reference"))
  .AddTypedef(type_10880, Reflex::Literal("std::vector<std::vector<double> >::iterator"))
  .AddTypedef(type_10881, Reflex::Literal("std::vector<std::vector<double> >::const_iterator"))
  .AddTypedef(type_3928, Reflex::Literal("std::vector<std::vector<double> >::const_reverse_iterator"))
  .AddTypedef(type_3929, Reflex::Literal("std::vector<std::vector<double> >::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<std::vector<double> >::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<std::vector<double> >::difference_type"))
  .AddTypedef(type_3699, Reflex::Literal("std::vector<std::vector<double> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19017, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32419), Reflex::Literal("vector"), constructor_19018, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19008, type_32419), Reflex::Literal("vector"), constructor_19019, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32696), Reflex::Literal("vector"), constructor_19020, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19021, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3108, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_double_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------
void __std__vector_std__vector_double_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------
void __std__vector_std__vector_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32697, type_32696), Reflex::Literal("operator="), operator_19022, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19008), Reflex::Literal("assign"), method_19023, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880), Reflex::Literal("begin"), method_19024, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10881), Reflex::Literal("begin"), method_19025, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880), Reflex::Literal("end"), method_19026, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10881), Reflex::Literal("end"), method_19027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_3092), Reflex::Literal("resize"), method_19034, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19036, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19037, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19006, type_3405), Reflex::Literal("operator[]"), operator_19038, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19008, type_3405), Reflex::Literal("operator[]"), operator_19039, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19006, type_3405), Reflex::Literal("at"), method_19041, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19008, type_3405), Reflex::Literal("at"), method_19042, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19006), Reflex::Literal("front"), method_19043, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19008), Reflex::Literal("front"), method_19044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19006), Reflex::Literal("back"), method_19045, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19008), Reflex::Literal("back"), method_19046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17588), Reflex::Literal("data"), method_19047, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19004), Reflex::Literal("data"), method_19048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19008), Reflex::Literal("push_back"), method_19049, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19050, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880, type_10880, type_19008), Reflex::Literal("insert"), method_19051, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10880, type_3405, type_19008), Reflex::Literal("insert"), method_19052, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880, type_10880), Reflex::Literal("erase"), method_19053, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880, type_10880, type_10880), Reflex::Literal("erase"), method_19054, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32697), Reflex::Literal("swap"), method_19055, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19056, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<double, std::allocator<double> >*,std::allocator<std::vector<double, std::allocator<double> >*> > -------------------------------
static void constructor_19082( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>();
  else ::new(mem) ::std::vector<std::vector<double>*>();
}

static void constructor_19083( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(const ::std::allocator<std::vector<double>*>*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(const ::std::allocator<std::vector<double>*>*)arg[0]);
}

static void constructor_19084( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0],
      *(::std::vector<double>* const*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0],
      *(::std::vector<double>* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0],
      *(::std::vector<double>* const*)arg[1],
      *(const ::std::allocator<std::vector<double>*>*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0],
      *(::std::vector<double>* const*)arg[1],
      *(const ::std::allocator<std::vector<double>*>*)arg[2]);
  }
}

static void constructor_19085( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(const ::std::vector<std::vector<double>*>*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(const ::std::vector<std::vector<double>*>*)arg[0]);
}

static void destructor_19086(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<double>*>*)o)->::std::vector<std::vector<double>*>::~vector)();
}
static  void operator_19087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->operator=)(*(const ::std::vector<std::vector<double>*>*)arg[0]);
  else   (((::std::vector<std::vector<double>*>*)o)->operator=)(*(const ::std::vector<std::vector<double>*>*)arg[0]);
}

static  void method_19088( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::std::vector<double>* const*)arg[1]);
}

static  void method_19089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->begin)());
  else   (((::std::vector<std::vector<double>*>*)o)->begin)();
}

static  void method_19090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>* const*,std::vector<std::vector<double>*> >)((((const ::std::vector<std::vector<double>*>*)o)->begin)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->begin)();
}

static  void method_19091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->end)());
  else   (((::std::vector<std::vector<double>*>*)o)->end)();
}

static  void method_19092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>* const*,std::vector<std::vector<double>*> >)((((const ::std::vector<std::vector<double>*>*)o)->end)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->end)();
}

static  void method_19097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double>*>*)o)->size)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->size)();
}

static  void method_19098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double>*>*)o)->max_size)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->max_size)();
}

static  void method_19099( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<double>*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<double>*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::std::vector<double>*)arg[1]);
  }
}

static  void method_19100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double>*>*)o)->capacity)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->capacity)();
}

static  void method_19101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<double>*>*)o)->empty)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->empty)();
}

static  void method_19102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double>*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double>*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double>*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->front)();
  else   (((::std::vector<std::vector<double>*>*)o)->front)();
}

static  void method_19109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double>*>*)o)->front)();
  else   (((const ::std::vector<std::vector<double>*>*)o)->front)();
}

static  void method_19110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->back)();
  else   (((::std::vector<std::vector<double>*>*)o)->back)();
}

static  void method_19111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double>*>*)o)->back)();
  else   (((const ::std::vector<std::vector<double>*>*)o)->back)();
}

static  void method_19112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<double>*>*)o)->data)());
  else   (((::std::vector<std::vector<double>*>*)o)->data)();
}

static  void method_19113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<double>*>*)o)->data)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->data)();
}

static  void method_19114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->push_back)(*(::std::vector<double>* const*)arg[0]);
}

static  void method_19115( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->pop_back)();
}

static  void method_19116( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::std::vector<double>* const*)arg[1]));
  else   (((::std::vector<std::vector<double>*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::std::vector<double>* const*)arg[1]);
}

static  void method_19117( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::vector<double>* const*)arg[2]);
}

static  void method_19118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0]));
  else   (((::std::vector<std::vector<double>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0]);
}

static  void method_19119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[1]));
  else   (((::std::vector<std::vector<double>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[1]);
}

static  void method_19120( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->swap)(*(::std::vector<std::vector<double>*>*)arg[0]);
}

static  void method_19121( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->clear)();
}

static void method_newdel_3110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> >")), ::Reflex::BaseOffset< ::std::vector<std::vector<double>*>,::std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<double>*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<double>*> >::Generate();
}

//------Dictionary for class vector<std::vector<double, std::allocator<double> >*,std::allocator<std::vector<double, std::allocator<double> >*> > -------------------------------
void __std__vector_std__vector_double_p__db_datamem(Reflex::Class*);
void __std__vector_std__vector_double_p__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_p__datamem_bld(&__std__vector_std__vector_double_p__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_p__funcmem_bld(&__std__vector_std__vector_double_p__db_funcmem);
void __std__vector_std__vector_double_p__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<double>*>"), typeid(::std::vector<std::vector<double>*>), sizeof(::std::vector<std::vector<double>*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3038, ::Reflex::BaseOffset< ::std::vector<std::vector<double>*>, ::std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_17588, Reflex::Literal("std::vector<std::vector<double>*>::_Alloc_value_type"))
  .AddTypedef(type_3038, Reflex::Literal("std::vector<std::vector<double>*>::_Base"))
  .AddTypedef(type_3717, Reflex::Literal("std::vector<std::vector<double>*>::_Tp_alloc_type"))
  .AddTypedef(type_11039, Reflex::Literal("std::vector<std::vector<double>*>::_Alloc_traits"))
  .AddTypedef(type_17588, Reflex::Literal("std::vector<std::vector<double>*>::value_type"))
  .AddTypedef(type_17607, Reflex::Literal("std::vector<std::vector<double>*>::pointer"))
  .AddTypedef(type_19069, Reflex::Literal("std::vector<std::vector<double>*>::const_pointer"))
  .AddTypedef(type_19071, Reflex::Literal("std::vector<std::vector<double>*>::reference"))
  .AddTypedef(type_19073, Reflex::Literal("std::vector<std::vector<double>*>::const_reference"))
  .AddTypedef(type_10882, Reflex::Literal("std::vector<std::vector<double>*>::iterator"))
  .AddTypedef(type_10883, Reflex::Literal("std::vector<std::vector<double>*>::const_iterator"))
  .AddTypedef(type_3942, Reflex::Literal("std::vector<std::vector<double>*>::const_reverse_iterator"))
  .AddTypedef(type_3943, Reflex::Literal("std::vector<std::vector<double>*>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<std::vector<double>*>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<std::vector<double>*>::difference_type"))
  .AddTypedef(type_3717, Reflex::Literal("std::vector<std::vector<double>*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19082, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32432), Reflex::Literal("vector"), constructor_19083, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19073, type_32432), Reflex::Literal("vector"), constructor_19084, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32699), Reflex::Literal("vector"), constructor_19085, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19086, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_double_p__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<double, std::allocator<double> >*,std::allocator<std::vector<double, std::allocator<double> >*> > -------------------
void __std__vector_std__vector_double_p__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<double, std::allocator<double> >*,std::allocator<std::vector<double, std::allocator<double> >*> > -------------------
void __std__vector_std__vector_double_p__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32700, type_32699), Reflex::Literal("operator="), operator_19087, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19073), Reflex::Literal("assign"), method_19088, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882), Reflex::Literal("begin"), method_19089, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10883), Reflex::Literal("begin"), method_19090, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882), Reflex::Literal("end"), method_19091, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10883), Reflex::Literal("end"), method_19092, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_17588), Reflex::Literal("resize"), method_19099, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19102, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19071, type_3405), Reflex::Literal("operator[]"), operator_19103, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19073, type_3405), Reflex::Literal("operator[]"), operator_19104, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19071, type_3405), Reflex::Literal("at"), method_19106, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19073, type_3405), Reflex::Literal("at"), method_19107, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19071), Reflex::Literal("front"), method_19108, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19073), Reflex::Literal("front"), method_19109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19071), Reflex::Literal("back"), method_19110, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19073), Reflex::Literal("back"), method_19111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17607), Reflex::Literal("data"), method_19112, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19069), Reflex::Literal("data"), method_19113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19073), Reflex::Literal("push_back"), method_19114, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19115, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882, type_10882, type_19073), Reflex::Literal("insert"), method_19116, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10882, type_3405, type_19073), Reflex::Literal("insert"), method_19117, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882, type_10882), Reflex::Literal("erase"), method_19118, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882, type_10882, type_10882), Reflex::Literal("erase"), method_19119, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32700), Reflex::Literal("swap"), method_19120, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19121, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooNormSetCache,std::allocator<RooNormSetCache> > -------------------------------
static void constructor_19147( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>();
  else ::new(mem) ::std::vector<RooNormSetCache>();
}

static void constructor_19148( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(const ::std::allocator<RooNormSetCache>*)arg[0]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(const ::std::allocator<RooNormSetCache>*)arg[0]);
}

static void constructor_19149( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0],
      *(const ::RooNormSetCache*)arg[1]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0],
      *(const ::RooNormSetCache*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0],
      *(const ::RooNormSetCache*)arg[1],
      *(const ::std::allocator<RooNormSetCache>*)arg[2]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0],
      *(const ::RooNormSetCache*)arg[1],
      *(const ::std::allocator<RooNormSetCache>*)arg[2]);
  }
}

static void constructor_19150( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(const ::std::vector<RooNormSetCache>*)arg[0]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(const ::std::vector<RooNormSetCache>*)arg[0]);
}

static void destructor_19151(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooNormSetCache>*)o)->::std::vector<RooNormSetCache>::~vector)();
}
static  void operator_19152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->operator=)(*(const ::std::vector<RooNormSetCache>*)arg[0]);
  else   (((::std::vector<RooNormSetCache>*)o)->operator=)(*(const ::std::vector<RooNormSetCache>*)arg[0]);
}

static  void method_19153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RooNormSetCache*)arg[1]);
}

static  void method_19154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->begin)());
  else   (((::std::vector<RooNormSetCache>*)o)->begin)();
}

static  void method_19155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooNormSetCache*,std::vector<RooNormSetCache> >)((((const ::std::vector<RooNormSetCache>*)o)->begin)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->begin)();
}

static  void method_19156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->end)());
  else   (((::std::vector<RooNormSetCache>*)o)->end)();
}

static  void method_19157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooNormSetCache*,std::vector<RooNormSetCache> >)((((const ::std::vector<RooNormSetCache>*)o)->end)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->end)();
}

static  void method_19162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooNormSetCache>*)o)->size)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->size)();
}

static  void method_19163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooNormSetCache>*)o)->max_size)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->max_size)();
}

static  void method_19164( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooNormSetCache>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooNormSetCache>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RooNormSetCache*)arg[1]);
  }
}

static  void method_19165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooNormSetCache>*)o)->capacity)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->capacity)();
}

static  void method_19166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooNormSetCache>*)o)->empty)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->empty)();
}

static  void method_19167( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooNormSetCache>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooNormSetCache>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooNormSetCache>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooNormSetCache>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19172( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooNormSetCache>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooNormSetCache>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->front)();
  else   (((::std::vector<RooNormSetCache>*)o)->front)();
}

static  void method_19174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooNormSetCache>*)o)->front)();
  else   (((const ::std::vector<RooNormSetCache>*)o)->front)();
}

static  void method_19175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->back)();
  else   (((::std::vector<RooNormSetCache>*)o)->back)();
}

static  void method_19176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooNormSetCache>*)o)->back)();
  else   (((const ::std::vector<RooNormSetCache>*)o)->back)();
}

static  void method_19177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooNormSetCache>*)o)->data)());
  else   (((::std::vector<RooNormSetCache>*)o)->data)();
}

static  void method_19178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooNormSetCache>*)o)->data)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->data)();
}

static  void method_19179( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->push_back)(*(const ::RooNormSetCache*)arg[0]);
}

static  void method_19180( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->pop_back)();
}

static  void method_19181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(const ::RooNormSetCache*)arg[1]));
  else   (((::std::vector<RooNormSetCache>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(const ::RooNormSetCache*)arg[1]);
}

static  void method_19182( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RooNormSetCache*)arg[2]);
}

static  void method_19183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0]));
  else   (((::std::vector<RooNormSetCache>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0]);
}

static  void method_19184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[1]));
  else   (((::std::vector<RooNormSetCache>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[1]);
}

static  void method_19185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->swap)(*(::std::vector<RooNormSetCache>*)arg[0]);
}

static  void method_19186( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->clear)();
}

static void method_newdel_3111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x167( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> >")), ::Reflex::BaseOffset< ::std::vector<RooNormSetCache>,::std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x168( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooNormSetCache> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooNormSetCache> >::Generate();
}

//------Dictionary for class vector<RooNormSetCache,std::allocator<RooNormSetCache> > -------------------------------
void __std__vector_RooNormSetCache__db_datamem(Reflex::Class*);
void __std__vector_RooNormSetCache__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooNormSetCache__datamem_bld(&__std__vector_RooNormSetCache__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooNormSetCache__funcmem_bld(&__std__vector_RooNormSetCache__db_funcmem);
void __std__vector_RooNormSetCache__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooNormSetCache>"), typeid(::std::vector<RooNormSetCache>), sizeof(::std::vector<RooNormSetCache>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3050, ::Reflex::BaseOffset< ::std::vector<RooNormSetCache>, ::std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_795, Reflex::Literal("std::vector<RooNormSetCache>::_Alloc_value_type"))
  .AddTypedef(type_3050, Reflex::Literal("std::vector<RooNormSetCache>::_Base"))
  .AddTypedef(type_3718, Reflex::Literal("std::vector<RooNormSetCache>::_Tp_alloc_type"))
  .AddTypedef(type_11051, Reflex::Literal("std::vector<RooNormSetCache>::_Alloc_traits"))
  .AddTypedef(type_795, Reflex::Literal("std::vector<RooNormSetCache>::value_type"))
  .AddTypedef(type_17832, Reflex::Literal("std::vector<RooNormSetCache>::pointer"))
  .AddTypedef(type_19134, Reflex::Literal("std::vector<RooNormSetCache>::const_pointer"))
  .AddTypedef(type_19136, Reflex::Literal("std::vector<RooNormSetCache>::reference"))
  .AddTypedef(type_19138, Reflex::Literal("std::vector<RooNormSetCache>::const_reference"))
  .AddTypedef(type_10906, Reflex::Literal("std::vector<RooNormSetCache>::iterator"))
  .AddTypedef(type_10907, Reflex::Literal("std::vector<RooNormSetCache>::const_iterator"))
  .AddTypedef(type_3986, Reflex::Literal("std::vector<RooNormSetCache>::const_reverse_iterator"))
  .AddTypedef(type_3987, Reflex::Literal("std::vector<RooNormSetCache>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<RooNormSetCache>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<RooNormSetCache>::difference_type"))
  .AddTypedef(type_3718, Reflex::Literal("std::vector<RooNormSetCache>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19147, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32587), Reflex::Literal("vector"), constructor_19148, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19138, type_32587), Reflex::Literal("vector"), constructor_19149, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32702), Reflex::Literal("vector"), constructor_19150, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19151, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x167, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooNormSetCache__funcmem_bld);
}

//------Delayed data member builder for class vector<RooNormSetCache,std::allocator<RooNormSetCache> > -------------------
void __std__vector_RooNormSetCache__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooNormSetCache,std::allocator<RooNormSetCache> > -------------------
void __std__vector_RooNormSetCache__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32703, type_32702), Reflex::Literal("operator="), operator_19152, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19138), Reflex::Literal("assign"), method_19153, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906), Reflex::Literal("begin"), method_19154, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10907), Reflex::Literal("begin"), method_19155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906), Reflex::Literal("end"), method_19156, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10907), Reflex::Literal("end"), method_19157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_795), Reflex::Literal("resize"), method_19164, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19167, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19136, type_3405), Reflex::Literal("operator[]"), operator_19168, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19138, type_3405), Reflex::Literal("operator[]"), operator_19169, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19136, type_3405), Reflex::Literal("at"), method_19171, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19138, type_3405), Reflex::Literal("at"), method_19172, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19136), Reflex::Literal("front"), method_19173, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19138), Reflex::Literal("front"), method_19174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19136), Reflex::Literal("back"), method_19175, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19138), Reflex::Literal("back"), method_19176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17832), Reflex::Literal("data"), method_19177, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19134), Reflex::Literal("data"), method_19178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19138), Reflex::Literal("push_back"), method_19179, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19180, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906, type_10906, type_19138), Reflex::Literal("insert"), method_19181, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10906, type_3405, type_19138), Reflex::Literal("insert"), method_19182, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906, type_10906), Reflex::Literal("erase"), method_19183, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906, type_10906, type_10906), Reflex::Literal("erase"), method_19184, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32703), Reflex::Literal("swap"), method_19185, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19186, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<double, TString>,std::allocator<std::pair<double, TString> > > -------------------------------
static void constructor_19212( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >();
  else ::new(mem) ::std::vector<std::pair<double,TString> >();
}

static void constructor_19213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(const ::std::allocator<std::pair<double,TString> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(const ::std::allocator<std::pair<double,TString> >*)arg[0]);
}

static void constructor_19214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,TString>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,TString>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,TString>*)arg[1],
      *(const ::std::allocator<std::pair<double,TString> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,TString>*)arg[1],
      *(const ::std::allocator<std::pair<double,TString> >*)arg[2]);
  }
}

static void constructor_19215( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(const ::std::vector<std::pair<double,TString> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(const ::std::vector<std::pair<double,TString> >*)arg[0]);
}

static void destructor_19216(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<double,TString> >*)o)->::std::vector<std::pair<double,TString> >::~vector)();
}
static  void operator_19217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->operator=)(*(const ::std::vector<std::pair<double,TString> >*)arg[0]);
  else   (((::std::vector<std::pair<double,TString> >*)o)->operator=)(*(const ::std::vector<std::pair<double,TString> >*)arg[0]);
}

static  void method_19218( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<double,TString>*)arg[1]);
}

static  void method_19219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->begin)());
  else   (((::std::vector<std::pair<double,TString> >*)o)->begin)();
}

static  void method_19220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((const ::std::vector<std::pair<double,TString> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->begin)();
}

static  void method_19221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->end)());
  else   (((::std::vector<std::pair<double,TString> >*)o)->end)();
}

static  void method_19222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((const ::std::vector<std::pair<double,TString> >*)o)->end)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->end)();
}

static  void method_19227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,TString> >*)o)->size)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->size)();
}

static  void method_19228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,TString> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->max_size)();
}

static  void method_19229( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<double,TString> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<double,TString> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<double,TString>*)arg[1]);
  }
}

static  void method_19230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,TString> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->capacity)();
}

static  void method_19231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<double,TString> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->empty)();
}

static  void method_19232( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<double,TString> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19234( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,TString> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<double,TString> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19237( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,TString> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->front)();
  else   (((::std::vector<std::pair<double,TString> >*)o)->front)();
}

static  void method_19239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,TString> >*)o)->front)();
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->front)();
}

static  void method_19240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->back)();
  else   (((::std::vector<std::pair<double,TString> >*)o)->back)();
}

static  void method_19241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,TString> >*)o)->back)();
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->back)();
}

static  void method_19242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<double,TString> >*)o)->data)());
  else   (((::std::vector<std::pair<double,TString> >*)o)->data)();
}

static  void method_19243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<double,TString> >*)o)->data)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->data)();
}

static  void method_19244( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->push_back)(*(const ::std::pair<double,TString>*)arg[0]);
}

static  void method_19245( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->pop_back)();
}

static  void method_19246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(const ::std::pair<double,TString>*)arg[1]));
  else   (((::std::vector<std::pair<double,TString> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(const ::std::pair<double,TString>*)arg[1]);
}

static  void method_19247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<double,TString>*)arg[2]);
}

static  void method_19248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0]));
  else   (((::std::vector<std::pair<double,TString> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0]);
}

static  void method_19249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[1]));
  else   (((::std::vector<std::pair<double,TString> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[1]);
}

static  void method_19250( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->swap)(*(::std::vector<std::pair<double,TString> >*)arg[0]);
}

static  void method_19251( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->clear)();
}

static void method_newdel_3112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<double,TString> >,::std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x171( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<double,TString> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<double,TString> > >::Generate();
}

//------Dictionary for class vector<std::pair<double, TString>,std::allocator<std::pair<double, TString> > > -------------------------------
void __std__vector_std__pair_double_TString_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_double_TString_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_double_TString_s__datamem_bld(&__std__vector_std__pair_double_TString_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_double_TString_s__funcmem_bld(&__std__vector_std__pair_double_TString_s__db_funcmem);
void __std__vector_std__pair_double_TString_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<double,TString> >"), typeid(::std::vector<std::pair<double,TString> >), sizeof(::std::vector<std::pair<double,TString> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3040, ::Reflex::BaseOffset< ::std::vector<std::pair<double,TString> >, ::std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3517, Reflex::Literal("std::vector<std::pair<double,TString> >::_Alloc_value_type"))
  .AddTypedef(type_3040, Reflex::Literal("std::vector<std::pair<double,TString> >::_Base"))
  .AddTypedef(type_3723, Reflex::Literal("std::vector<std::pair<double,TString> >::_Tp_alloc_type"))
  .AddTypedef(type_11041, Reflex::Literal("std::vector<std::pair<double,TString> >::_Alloc_traits"))
  .AddTypedef(type_3517, Reflex::Literal("std::vector<std::pair<double,TString> >::value_type"))
  .AddTypedef(type_17644, Reflex::Literal("std::vector<std::pair<double,TString> >::pointer"))
  .AddTypedef(type_19199, Reflex::Literal("std::vector<std::pair<double,TString> >::const_pointer"))
  .AddTypedef(type_19201, Reflex::Literal("std::vector<std::pair<double,TString> >::reference"))
  .AddTypedef(type_19203, Reflex::Literal("std::vector<std::pair<double,TString> >::const_reference"))
  .AddTypedef(type_10886, Reflex::Literal("std::vector<std::pair<double,TString> >::iterator"))
  .AddTypedef(type_10887, Reflex::Literal("std::vector<std::pair<double,TString> >::const_iterator"))
  .AddTypedef(type_3948, Reflex::Literal("std::vector<std::pair<double,TString> >::const_reverse_iterator"))
  .AddTypedef(type_3949, Reflex::Literal("std::vector<std::pair<double,TString> >::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<std::pair<double,TString> >::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<std::pair<double,TString> >::difference_type"))
  .AddTypedef(type_3723, Reflex::Literal("std::vector<std::pair<double,TString> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19212, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32458), Reflex::Literal("vector"), constructor_19213, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19203, type_32458), Reflex::Literal("vector"), constructor_19214, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32705), Reflex::Literal("vector"), constructor_19215, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19216, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_double_TString_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<double, TString>,std::allocator<std::pair<double, TString> > > -------------------
void __std__vector_std__pair_double_TString_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<double, TString>,std::allocator<std::pair<double, TString> > > -------------------
void __std__vector_std__pair_double_TString_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32706, type_32705), Reflex::Literal("operator="), operator_19217, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19203), Reflex::Literal("assign"), method_19218, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886), Reflex::Literal("begin"), method_19219, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10887), Reflex::Literal("begin"), method_19220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886), Reflex::Literal("end"), method_19221, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10887), Reflex::Literal("end"), method_19222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_3517), Reflex::Literal("resize"), method_19229, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19232, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19201, type_3405), Reflex::Literal("operator[]"), operator_19233, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19203, type_3405), Reflex::Literal("operator[]"), operator_19234, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19201, type_3405), Reflex::Literal("at"), method_19236, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19203, type_3405), Reflex::Literal("at"), method_19237, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19201), Reflex::Literal("front"), method_19238, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19203), Reflex::Literal("front"), method_19239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19201), Reflex::Literal("back"), method_19240, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19203), Reflex::Literal("back"), method_19241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17644), Reflex::Literal("data"), method_19242, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19199), Reflex::Literal("data"), method_19243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19203), Reflex::Literal("push_back"), method_19244, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19245, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886, type_10886, type_19203), Reflex::Literal("insert"), method_19246, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10886, type_3405, type_19203), Reflex::Literal("insert"), method_19247, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886, type_10886), Reflex::Literal("erase"), method_19248, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886, type_10886, type_10886), Reflex::Literal("erase"), method_19249, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32706), Reflex::Literal("swap"), method_19250, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19251, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<TString,std::allocator<TString> > -------------------------------
static void constructor_19274( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>();
  else ::new(mem) ::std::vector<TString>();
}

static void constructor_19275( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(const ::std::allocator<TString>*)arg[0]);
  else ::new(mem) ::std::vector<TString>(*(const ::std::allocator<TString>*)arg[0]);
}

static void constructor_19276( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0],
      *(const ::TString*)arg[1]);
  else ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0],
      *(const ::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0],
      *(const ::TString*)arg[1],
      *(const ::std::allocator<TString>*)arg[2]);
  else ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0],
      *(const ::TString*)arg[1],
      *(const ::std::allocator<TString>*)arg[2]);
  }
}

static void constructor_19277( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(const ::std::vector<TString>*)arg[0]);
  else ::new(mem) ::std::vector<TString>(*(const ::std::vector<TString>*)arg[0]);
}

static void destructor_19278(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TString>*)o)->::std::vector<TString>::~vector)();
}
static  void operator_19279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->operator=)(*(const ::std::vector<TString>*)arg[0]);
  else   (((::std::vector<TString>*)o)->operator=)(*(const ::std::vector<TString>*)arg[0]);
}

static  void method_19280( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::TString*)arg[1]);
}

static  void method_19281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->begin)());
  else   (((::std::vector<TString>*)o)->begin)();
}

static  void method_19282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TString*,std::vector<TString> >)((((const ::std::vector<TString>*)o)->begin)());
  else   (((const ::std::vector<TString>*)o)->begin)();
}

static  void method_19283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->end)());
  else   (((::std::vector<TString>*)o)->end)();
}

static  void method_19284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TString*,std::vector<TString> >)((((const ::std::vector<TString>*)o)->end)());
  else   (((const ::std::vector<TString>*)o)->end)();
}

static  void method_19289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TString>*)o)->size)());
  else   (((const ::std::vector<TString>*)o)->size)();
}

static  void method_19290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TString>*)o)->max_size)());
  else   (((const ::std::vector<TString>*)o)->max_size)();
}

static  void method_19291( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TString>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TString>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::TString*)arg[1]);
  }
}

static  void method_19292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TString>*)o)->capacity)());
  else   (((const ::std::vector<TString>*)o)->capacity)();
}

static  void method_19293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TString>*)o)->empty)());
  else   (((const ::std::vector<TString>*)o)->empty)();
}

static  void method_19294( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19295( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TString>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19296( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TString>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TString>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19298( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TString>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19299( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TString>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TString>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->front)();
  else   (((::std::vector<TString>*)o)->front)();
}

static  void method_19301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TString>*)o)->front)();
  else   (((const ::std::vector<TString>*)o)->front)();
}

static  void method_19302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->back)();
  else   (((::std::vector<TString>*)o)->back)();
}

static  void method_19303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TString>*)o)->back)();
  else   (((const ::std::vector<TString>*)o)->back)();
}

static  void method_19304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TString>*)o)->data)());
  else   (((::std::vector<TString>*)o)->data)();
}

static  void method_19305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TString>*)o)->data)());
  else   (((const ::std::vector<TString>*)o)->data)();
}

static  void method_19306( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->push_back)(*(const ::TString*)arg[0]);
}

static  void method_19307( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TString>*)o)->pop_back)();
}

static  void method_19308( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(const ::TString*)arg[1]));
  else   (((::std::vector<TString>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(const ::TString*)arg[1]);
}

static  void method_19309( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::TString*)arg[2]);
}

static  void method_19310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0]));
  else   (((::std::vector<TString>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0]);
}

static  void method_19311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[1]));
  else   (((::std::vector<TString>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[1]);
}

static  void method_19312( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->swap)(*(::std::vector<TString>*)arg[0]);
}

static  void method_19313( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TString>*)o)->clear)();
}

static void method_newdel_3114( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x173( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TString,std::allocator<TString> >")), ::Reflex::BaseOffset< ::std::vector<TString>,::std::_Vector_base<TString,std::allocator<TString> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x174( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TString> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TString> >::Generate();
}

//------Dictionary for class vector<TString,std::allocator<TString> > -------------------------------
void __std__vector_TString__db_datamem(Reflex::Class*);
void __std__vector_TString__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TString__datamem_bld(&__std__vector_TString__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TString__funcmem_bld(&__std__vector_TString__db_funcmem);
void __std__vector_TString__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TString>"), typeid(::std::vector<TString>), sizeof(::std::vector<TString>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3044, ::Reflex::BaseOffset< ::std::vector<TString>, ::std::_Vector_base<TString,std::allocator<TString> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2743, Reflex::Literal("std::vector<TString>::_Alloc_value_type"))
  .AddTypedef(type_3044, Reflex::Literal("std::vector<TString>::_Base"))
  .AddTypedef(type_3730, Reflex::Literal("std::vector<TString>::_Tp_alloc_type"))
  .AddTypedef(type_11045, Reflex::Literal("std::vector<TString>::_Alloc_traits"))
  .AddTypedef(type_2743, Reflex::Literal("std::vector<TString>::value_type"))
  .AddTypedef(type_17718, Reflex::Literal("std::vector<TString>::pointer"))
  .AddTypedef(type_9755, Reflex::Literal("std::vector<TString>::const_pointer"))
  .AddTypedef(type_6066, Reflex::Literal("std::vector<TString>::reference"))
  .AddTypedef(type_5554, Reflex::Literal("std::vector<TString>::const_reference"))
  .AddTypedef(type_10894, Reflex::Literal("std::vector<TString>::iterator"))
  .AddTypedef(type_10895, Reflex::Literal("std::vector<TString>::const_iterator"))
  .AddTypedef(type_3960, Reflex::Literal("std::vector<TString>::const_reverse_iterator"))
  .AddTypedef(type_3961, Reflex::Literal("std::vector<TString>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<TString>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<TString>::difference_type"))
  .AddTypedef(type_3730, Reflex::Literal("std::vector<TString>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19274, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32509), Reflex::Literal("vector"), constructor_19275, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_5554, type_32509), Reflex::Literal("vector"), constructor_19276, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32707), Reflex::Literal("vector"), constructor_19277, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19278, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3114, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TString__funcmem_bld);
}

//------Delayed data member builder for class vector<TString,std::allocator<TString> > -------------------
void __std__vector_TString__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TString,std::allocator<TString> > -------------------
void __std__vector_TString__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32708, type_32707), Reflex::Literal("operator="), operator_19279, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_5554), Reflex::Literal("assign"), method_19280, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894), Reflex::Literal("begin"), method_19281, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10895), Reflex::Literal("begin"), method_19282, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894), Reflex::Literal("end"), method_19283, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10895), Reflex::Literal("end"), method_19284, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19289, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19290, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_2743), Reflex::Literal("resize"), method_19291, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19293, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19294, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6066, type_3405), Reflex::Literal("operator[]"), operator_19295, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5554, type_3405), Reflex::Literal("operator[]"), operator_19296, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6066, type_3405), Reflex::Literal("at"), method_19298, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5554, type_3405), Reflex::Literal("at"), method_19299, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6066), Reflex::Literal("front"), method_19300, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5554), Reflex::Literal("front"), method_19301, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6066), Reflex::Literal("back"), method_19302, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5554), Reflex::Literal("back"), method_19303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17718), Reflex::Literal("data"), method_19304, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9755), Reflex::Literal("data"), method_19305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_5554), Reflex::Literal("push_back"), method_19306, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19307, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894, type_10894, type_5554), Reflex::Literal("insert"), method_19308, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10894, type_3405, type_5554), Reflex::Literal("insert"), method_19309, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894, type_10894), Reflex::Literal("erase"), method_19310, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894, type_10894, type_10894), Reflex::Literal("erase"), method_19311, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32708), Reflex::Literal("swap"), method_19312, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19313, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > >,std::allocator<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > > > > -------------------------------
static void constructor_19339( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >();
  else ::new(mem) ::std::vector<std::map<int,int> >();
}

static void constructor_19340( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(const ::std::allocator<std::map<int,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(const ::std::allocator<std::map<int,int> >*)arg[0]);
}

static void constructor_19341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::map<int,int>*)arg[1]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::map<int,int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::map<int,int>*)arg[1],
      *(const ::std::allocator<std::map<int,int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::map<int,int>*)arg[1],
      *(const ::std::allocator<std::map<int,int> >*)arg[2]);
  }
}

static void constructor_19342( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(const ::std::vector<std::map<int,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(const ::std::vector<std::map<int,int> >*)arg[0]);
}

static void destructor_19343(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::map<int,int> >*)o)->::std::vector<std::map<int,int> >::~vector)();
}
static  void operator_19344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->operator=)(*(const ::std::vector<std::map<int,int> >*)arg[0]);
  else   (((::std::vector<std::map<int,int> >*)o)->operator=)(*(const ::std::vector<std::map<int,int> >*)arg[0]);
}

static  void method_19345( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::map<int,int>*)arg[1]);
}

static  void method_19346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->begin)());
  else   (((::std::vector<std::map<int,int> >*)o)->begin)();
}

static  void method_19347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<int,int>*,std::vector<std::map<int,int> > >)((((const ::std::vector<std::map<int,int> >*)o)->begin)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->begin)();
}

static  void method_19348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->end)());
  else   (((::std::vector<std::map<int,int> >*)o)->end)();
}

static  void method_19349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<int,int>*,std::vector<std::map<int,int> > >)((((const ::std::vector<std::map<int,int> >*)o)->end)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->end)();
}

static  void method_19354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<int,int> >*)o)->size)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->size)();
}

static  void method_19355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<int,int> >*)o)->max_size)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->max_size)();
}

static  void method_19356( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::map<int,int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::map<int,int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::map<int,int>*)arg[1]);
  }
}

static  void method_19357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<int,int> >*)o)->capacity)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->capacity)();
}

static  void method_19358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::map<int,int> >*)o)->empty)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->empty)();
}

static  void method_19359( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->front)();
  else   (((::std::vector<std::map<int,int> >*)o)->front)();
}

static  void method_19366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<int,int> >*)o)->front)();
  else   (((const ::std::vector<std::map<int,int> >*)o)->front)();
}

static  void method_19367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->back)();
  else   (((::std::vector<std::map<int,int> >*)o)->back)();
}

static  void method_19368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<int,int> >*)o)->back)();
  else   (((const ::std::vector<std::map<int,int> >*)o)->back)();
}

static  void method_19369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::map<int,int> >*)o)->data)());
  else   (((::std::vector<std::map<int,int> >*)o)->data)();
}

static  void method_19370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::map<int,int> >*)o)->data)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->data)();
}

static  void method_19371( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->push_back)(*(const ::std::map<int,int>*)arg[0]);
}

static  void method_19372( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->pop_back)();
}

static  void method_19373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(const ::std::map<int,int>*)arg[1]));
  else   (((::std::vector<std::map<int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(const ::std::map<int,int>*)arg[1]);
}

static  void method_19374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::map<int,int>*)arg[2]);
}

static  void method_19375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0]));
  else   (((::std::vector<std::map<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0]);
}

static  void method_19376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[1]));
  else   (((::std::vector<std::map<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[1]);
}

static  void method_19377( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->swap)(*(::std::vector<std::map<int,int> >*)arg[0]);
}

static  void method_19378( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->clear)();
}

static void method_newdel_3115( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x176( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > >")), ::Reflex::BaseOffset< ::std::vector<std::map<int,int> >,::std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x177( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::map<int,int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::map<int,int> > >::Generate();
}

//------Dictionary for class vector<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > >,std::allocator<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > > > > -------------------------------
void __std__vector_std__map_int_int_s__db_datamem(Reflex::Class*);
void __std__vector_std__map_int_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__map_int_int_s__datamem_bld(&__std__vector_std__map_int_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__map_int_int_s__funcmem_bld(&__std__vector_std__map_int_int_s__db_funcmem);
void __std__vector_std__map_int_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::map<int,int> >"), typeid(::std::vector<std::map<int,int> >), sizeof(::std::vector<std::map<int,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3045, ::Reflex::BaseOffset< ::std::vector<std::map<int,int> >, ::std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3366, Reflex::Literal("std::vector<std::map<int,int> >::_Alloc_value_type"))
  .AddTypedef(type_3045, Reflex::Literal("std::vector<std::map<int,int> >::_Base"))
  .AddTypedef(type_3731, Reflex::Literal("std::vector<std::map<int,int> >::_Tp_alloc_type"))
  .AddTypedef(type_11046, Reflex::Literal("std::vector<std::map<int,int> >::_Alloc_traits"))
  .AddTypedef(type_3366, Reflex::Literal("std::vector<std::map<int,int> >::value_type"))
  .AddTypedef(type_17737, Reflex::Literal("std::vector<std::map<int,int> >::pointer"))
  .AddTypedef(type_19326, Reflex::Literal("std::vector<std::map<int,int> >::const_pointer"))
  .AddTypedef(type_19328, Reflex::Literal("std::vector<std::map<int,int> >::reference"))
  .AddTypedef(type_19330, Reflex::Literal("std::vector<std::map<int,int> >::const_reference"))
  .AddTypedef(type_10896, Reflex::Literal("std::vector<std::map<int,int> >::iterator"))
  .AddTypedef(type_10897, Reflex::Literal("std::vector<std::map<int,int> >::const_iterator"))
  .AddTypedef(type_3962, Reflex::Literal("std::vector<std::map<int,int> >::const_reverse_iterator"))
  .AddTypedef(type_3963, Reflex::Literal("std::vector<std::map<int,int> >::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<std::map<int,int> >::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<std::map<int,int> >::difference_type"))
  .AddTypedef(type_3731, Reflex::Literal("std::vector<std::map<int,int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19339, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32522), Reflex::Literal("vector"), constructor_19340, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19330, type_32522), Reflex::Literal("vector"), constructor_19341, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32710), Reflex::Literal("vector"), constructor_19342, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19343, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x177, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__map_int_int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > >,std::allocator<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > > > > -------------------
void __std__vector_std__map_int_int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > >,std::allocator<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > > > > -------------------
void __std__vector_std__map_int_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32711, type_32710), Reflex::Literal("operator="), operator_19344, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19330), Reflex::Literal("assign"), method_19345, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896), Reflex::Literal("begin"), method_19346, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10897), Reflex::Literal("begin"), method_19347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896), Reflex::Literal("end"), method_19348, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10897), Reflex::Literal("end"), method_19349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_3366), Reflex::Literal("resize"), method_19356, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19359, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19328, type_3405), Reflex::Literal("operator[]"), operator_19360, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19330, type_3405), Reflex::Literal("operator[]"), operator_19361, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19328, type_3405), Reflex::Literal("at"), method_19363, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19330, type_3405), Reflex::Literal("at"), method_19364, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19328), Reflex::Literal("front"), method_19365, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19330), Reflex::Literal("front"), method_19366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19328), Reflex::Literal("back"), method_19367, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19330), Reflex::Literal("back"), method_19368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17737), Reflex::Literal("data"), method_19369, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19326), Reflex::Literal("data"), method_19370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19330), Reflex::Literal("push_back"), method_19371, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19372, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896, type_10896, type_19330), Reflex::Literal("insert"), method_19373, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10896, type_3405, type_19330), Reflex::Literal("insert"), method_19374, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896, type_10896), Reflex::Literal("erase"), method_19375, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896, type_10896, type_10896), Reflex::Literal("erase"), method_19376, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32711), Reflex::Literal("swap"), method_19377, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19378, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > -------------------------------
static void constructor_19401( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>();
  else ::new(mem) ::std::vector<const RooAbsBinning*>();
}

static void constructor_19402( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(const ::std::allocator<const RooAbsBinning*>*)arg[0]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(const ::std::allocator<const RooAbsBinning*>*)arg[0]);
}

static void constructor_19403( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0],
      *(const ::RooAbsBinning* const*)arg[1]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0],
      *(const ::RooAbsBinning* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0],
      *(const ::RooAbsBinning* const*)arg[1],
      *(const ::std::allocator<const RooAbsBinning*>*)arg[2]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0],
      *(const ::RooAbsBinning* const*)arg[1],
      *(const ::std::allocator<const RooAbsBinning*>*)arg[2]);
  }
}

static void constructor_19404( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(const ::std::vector<const RooAbsBinning*>*)arg[0]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(const ::std::vector<const RooAbsBinning*>*)arg[0]);
}

static void destructor_19405(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<const RooAbsBinning*>*)o)->::std::vector<const RooAbsBinning*>::~vector)();
}
static  void operator_19406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->operator=)(*(const ::std::vector<const RooAbsBinning*>*)arg[0]);
  else   (((::std::vector<const RooAbsBinning*>*)o)->operator=)(*(const ::std::vector<const RooAbsBinning*>*)arg[0]);
}

static  void method_19407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RooAbsBinning* const*)arg[1]);
}

static  void method_19408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->begin)());
  else   (((::std::vector<const RooAbsBinning*>*)o)->begin)();
}

static  void method_19409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning* const*,std::vector<const RooAbsBinning*> >)((((const ::std::vector<const RooAbsBinning*>*)o)->begin)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->begin)();
}

static  void method_19410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->end)());
  else   (((::std::vector<const RooAbsBinning*>*)o)->end)();
}

static  void method_19411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning* const*,std::vector<const RooAbsBinning*> >)((((const ::std::vector<const RooAbsBinning*>*)o)->end)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->end)();
}

static  void method_19416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const RooAbsBinning*>*)o)->size)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->size)();
}

static  void method_19417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const RooAbsBinning*>*)o)->max_size)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->max_size)();
}

static  void method_19418( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<const RooAbsBinning*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<const RooAbsBinning*>*)o)->resize)(*(::std::size_t*)arg[0],
      (const ::RooAbsBinning*)arg[1]);
  }
}

static  void method_19419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const RooAbsBinning*>*)o)->capacity)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->capacity)();
}

static  void method_19420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<const RooAbsBinning*>*)o)->empty)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->empty)();
}

static  void method_19421( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19422( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const RooAbsBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RooAbsBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const RooAbsBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RooAbsBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->front)();
  else   (((::std::vector<const RooAbsBinning*>*)o)->front)();
}

static  void method_19428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RooAbsBinning*>*)o)->front)();
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->front)();
}

static  void method_19429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->back)();
  else   (((::std::vector<const RooAbsBinning*>*)o)->back)();
}

static  void method_19430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RooAbsBinning*>*)o)->back)();
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->back)();
}

static  void method_19431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<const RooAbsBinning*>*)o)->data)());
  else   (((::std::vector<const RooAbsBinning*>*)o)->data)();
}

static  void method_19432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<const RooAbsBinning*>*)o)->data)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->data)();
}

static  void method_19433( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->push_back)(*(const ::RooAbsBinning* const*)arg[0]);
}

static  void method_19434( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->pop_back)();
}

static  void method_19435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(const ::RooAbsBinning* const*)arg[1]));
  else   (((::std::vector<const RooAbsBinning*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(const ::RooAbsBinning* const*)arg[1]);
}

static  void method_19436( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RooAbsBinning* const*)arg[2]);
}

static  void method_19437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0]));
  else   (((::std::vector<const RooAbsBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0]);
}

static  void method_19438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[1]));
  else   (((::std::vector<const RooAbsBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[1]);
}

static  void method_19439( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->swap)(*(::std::vector<const RooAbsBinning*>*)arg[0]);
}

static  void method_19440( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->clear)();
}

static void method_newdel_3116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x179( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> >")), ::Reflex::BaseOffset< ::std::vector<const RooAbsBinning*>,::std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x180( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<const RooAbsBinning*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<const RooAbsBinning*> >::Generate();
}

//------Dictionary for class vector<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > -------------------------------
void __std__vector_constsRooAbsBinningp__db_datamem(Reflex::Class*);
void __std__vector_constsRooAbsBinningp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_constsRooAbsBinningp__datamem_bld(&__std__vector_constsRooAbsBinningp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_constsRooAbsBinningp__funcmem_bld(&__std__vector_constsRooAbsBinningp__db_funcmem);
void __std__vector_constsRooAbsBinningp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<const RooAbsBinning*>"), typeid(::std::vector<const RooAbsBinning*>), sizeof(::std::vector<const RooAbsBinning*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3042, ::Reflex::BaseOffset< ::std::vector<const RooAbsBinning*>, ::std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_16939, Reflex::Literal("std::vector<const RooAbsBinning*>::_Alloc_value_type"))
  .AddTypedef(type_3042, Reflex::Literal("std::vector<const RooAbsBinning*>::_Base"))
  .AddTypedef(type_3714, Reflex::Literal("std::vector<const RooAbsBinning*>::_Tp_alloc_type"))
  .AddTypedef(type_11043, Reflex::Literal("std::vector<const RooAbsBinning*>::_Alloc_traits"))
  .AddTypedef(type_16939, Reflex::Literal("std::vector<const RooAbsBinning*>::value_type"))
  .AddTypedef(type_16945, Reflex::Literal("std::vector<const RooAbsBinning*>::pointer"))
  .AddTypedef(type_16947, Reflex::Literal("std::vector<const RooAbsBinning*>::const_pointer"))
  .AddTypedef(type_16949, Reflex::Literal("std::vector<const RooAbsBinning*>::reference"))
  .AddTypedef(type_16951, Reflex::Literal("std::vector<const RooAbsBinning*>::const_reference"))
  .AddTypedef(type_10890, Reflex::Literal("std::vector<const RooAbsBinning*>::iterator"))
  .AddTypedef(type_10891, Reflex::Literal("std::vector<const RooAbsBinning*>::const_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<const RooAbsBinning*>::const_reverse_iterator"))
  .AddTypedef(type_3955, Reflex::Literal("std::vector<const RooAbsBinning*>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<const RooAbsBinning*>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<const RooAbsBinning*>::difference_type"))
  .AddTypedef(type_3714, Reflex::Literal("std::vector<const RooAbsBinning*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19401, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32195), Reflex::Literal("vector"), constructor_19402, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_16951, type_32195), Reflex::Literal("vector"), constructor_19403, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32712), Reflex::Literal("vector"), constructor_19404, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19405, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x179, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x180, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_constsRooAbsBinningp__funcmem_bld);
}

//------Delayed data member builder for class vector<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > -------------------
void __std__vector_constsRooAbsBinningp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > -------------------
void __std__vector_constsRooAbsBinningp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32713, type_32712), Reflex::Literal("operator="), operator_19406, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_16951), Reflex::Literal("assign"), method_19407, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890), Reflex::Literal("begin"), method_19408, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10891), Reflex::Literal("begin"), method_19409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890), Reflex::Literal("end"), method_19410, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10891), Reflex::Literal("end"), method_19411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19416, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_16939), Reflex::Literal("resize"), method_19418, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19419, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19421, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16949, type_3405), Reflex::Literal("operator[]"), operator_19422, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16951, type_3405), Reflex::Literal("operator[]"), operator_19423, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16949, type_3405), Reflex::Literal("at"), method_19425, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16951, type_3405), Reflex::Literal("at"), method_19426, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16949), Reflex::Literal("front"), method_19427, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16951), Reflex::Literal("front"), method_19428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16949), Reflex::Literal("back"), method_19429, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16951), Reflex::Literal("back"), method_19430, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16945), Reflex::Literal("data"), method_19431, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16947), Reflex::Literal("data"), method_19432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_16951), Reflex::Literal("push_back"), method_19433, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19434, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890, type_10890, type_16951), Reflex::Literal("insert"), method_19435, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10890, type_3405, type_16951), Reflex::Literal("insert"), method_19436, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890, type_10890), Reflex::Literal("erase"), method_19437, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890, type_10890, type_10890), Reflex::Literal("erase"), method_19438, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32713), Reflex::Literal("swap"), method_19439, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19440, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > -------------------------------
static void constructor_19467( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>();
  else ::new(mem) ::std::vector<RooAbsRealLValue*>();
}

static void constructor_19468( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(const ::std::allocator<RooAbsRealLValue*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(const ::std::allocator<RooAbsRealLValue*>*)arg[0]);
}

static void constructor_19469( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsRealLValue* const*)arg[1]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsRealLValue* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsRealLValue* const*)arg[1],
      *(const ::std::allocator<RooAbsRealLValue*>*)arg[2]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsRealLValue* const*)arg[1],
      *(const ::std::allocator<RooAbsRealLValue*>*)arg[2]);
  }
}

static void constructor_19470( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(const ::std::vector<RooAbsRealLValue*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(const ::std::vector<RooAbsRealLValue*>*)arg[0]);
}

static void destructor_19471(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooAbsRealLValue*>*)o)->::std::vector<RooAbsRealLValue*>::~vector)();
}
static  void operator_19472( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->operator=)(*(const ::std::vector<RooAbsRealLValue*>*)arg[0]);
  else   (((::std::vector<RooAbsRealLValue*>*)o)->operator=)(*(const ::std::vector<RooAbsRealLValue*>*)arg[0]);
}

static  void method_19473( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooAbsRealLValue* const*)arg[1]);
}

static  void method_19474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->begin)());
  else   (((::std::vector<RooAbsRealLValue*>*)o)->begin)();
}

static  void method_19475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue* const*,std::vector<RooAbsRealLValue*> >)((((const ::std::vector<RooAbsRealLValue*>*)o)->begin)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->begin)();
}

static  void method_19476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->end)());
  else   (((::std::vector<RooAbsRealLValue*>*)o)->end)();
}

static  void method_19477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue* const*,std::vector<RooAbsRealLValue*> >)((((const ::std::vector<RooAbsRealLValue*>*)o)->end)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->end)();
}

static  void method_19482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsRealLValue*>*)o)->size)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->size)();
}

static  void method_19483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsRealLValue*>*)o)->max_size)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->max_size)();
}

static  void method_19484( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooAbsRealLValue*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooAbsRealLValue*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooAbsRealLValue*)arg[1]);
  }
}

static  void method_19485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsRealLValue*>*)o)->capacity)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->capacity)();
}

static  void method_19486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooAbsRealLValue*>*)o)->empty)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->empty)();
}

static  void method_19487( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsRealLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsRealLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsRealLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19492( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsRealLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->front)();
  else   (((::std::vector<RooAbsRealLValue*>*)o)->front)();
}

static  void method_19494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsRealLValue*>*)o)->front)();
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->front)();
}

static  void method_19495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->back)();
  else   (((::std::vector<RooAbsRealLValue*>*)o)->back)();
}

static  void method_19496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsRealLValue*>*)o)->back)();
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->back)();
}

static  void method_19497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooAbsRealLValue*>*)o)->data)());
  else   (((::std::vector<RooAbsRealLValue*>*)o)->data)();
}

static  void method_19498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooAbsRealLValue*>*)o)->data)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->data)();
}

static  void method_19499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->push_back)(*(::RooAbsRealLValue* const*)arg[0]);
}

static  void method_19500( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->pop_back)();
}

static  void method_19501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::RooAbsRealLValue* const*)arg[1]));
  else   (((::std::vector<RooAbsRealLValue*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::RooAbsRealLValue* const*)arg[1]);
}

static  void method_19502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooAbsRealLValue* const*)arg[2]);
}

static  void method_19503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0]));
  else   (((::std::vector<RooAbsRealLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0]);
}

static  void method_19504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[1]));
  else   (((::std::vector<RooAbsRealLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[1]);
}

static  void method_19505( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->swap)(*(::std::vector<RooAbsRealLValue*>*)arg[0]);
}

static  void method_19506( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->clear)();
}

static void method_newdel_3117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x182( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> >")), ::Reflex::BaseOffset< ::std::vector<RooAbsRealLValue*>,::std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooAbsRealLValue*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooAbsRealLValue*> >::Generate();
}

//------Dictionary for class vector<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > -------------------------------
void __std__vector_RooAbsRealLValuep__db_datamem(Reflex::Class*);
void __std__vector_RooAbsRealLValuep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsRealLValuep__datamem_bld(&__std__vector_RooAbsRealLValuep__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsRealLValuep__funcmem_bld(&__std__vector_RooAbsRealLValuep__db_funcmem);
void __std__vector_RooAbsRealLValuep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooAbsRealLValue*>"), typeid(::std::vector<RooAbsRealLValue*>), sizeof(::std::vector<RooAbsRealLValue*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3043, ::Reflex::BaseOffset< ::std::vector<RooAbsRealLValue*>, ::std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_19447, Reflex::Literal("std::vector<RooAbsRealLValue*>::_Alloc_value_type"))
  .AddTypedef(type_3043, Reflex::Literal("std::vector<RooAbsRealLValue*>::_Base"))
  .AddTypedef(type_3727, Reflex::Literal("std::vector<RooAbsRealLValue*>::_Tp_alloc_type"))
  .AddTypedef(type_11044, Reflex::Literal("std::vector<RooAbsRealLValue*>::_Alloc_traits"))
  .AddTypedef(type_19447, Reflex::Literal("std::vector<RooAbsRealLValue*>::value_type"))
  .AddTypedef(type_17699, Reflex::Literal("std::vector<RooAbsRealLValue*>::pointer"))
  .AddTypedef(type_19454, Reflex::Literal("std::vector<RooAbsRealLValue*>::const_pointer"))
  .AddTypedef(type_19456, Reflex::Literal("std::vector<RooAbsRealLValue*>::reference"))
  .AddTypedef(type_19458, Reflex::Literal("std::vector<RooAbsRealLValue*>::const_reference"))
  .AddTypedef(type_10892, Reflex::Literal("std::vector<RooAbsRealLValue*>::iterator"))
  .AddTypedef(type_10893, Reflex::Literal("std::vector<RooAbsRealLValue*>::const_iterator"))
  .AddTypedef(type_3956, Reflex::Literal("std::vector<RooAbsRealLValue*>::const_reverse_iterator"))
  .AddTypedef(type_3957, Reflex::Literal("std::vector<RooAbsRealLValue*>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<RooAbsRealLValue*>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<RooAbsRealLValue*>::difference_type"))
  .AddTypedef(type_3727, Reflex::Literal("std::vector<RooAbsRealLValue*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19467, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32496), Reflex::Literal("vector"), constructor_19468, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19458, type_32496), Reflex::Literal("vector"), constructor_19469, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32715), Reflex::Literal("vector"), constructor_19470, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19471, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooAbsRealLValuep__funcmem_bld);
}

//------Delayed data member builder for class vector<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > -------------------
void __std__vector_RooAbsRealLValuep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > -------------------
void __std__vector_RooAbsRealLValuep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32716, type_32715), Reflex::Literal("operator="), operator_19472, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19458), Reflex::Literal("assign"), method_19473, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892), Reflex::Literal("begin"), method_19474, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10893), Reflex::Literal("begin"), method_19475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892), Reflex::Literal("end"), method_19476, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10893), Reflex::Literal("end"), method_19477, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19447), Reflex::Literal("resize"), method_19484, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19485, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19487, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456, type_3405), Reflex::Literal("operator[]"), operator_19488, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19458, type_3405), Reflex::Literal("operator[]"), operator_19489, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456, type_3405), Reflex::Literal("at"), method_19491, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19458, type_3405), Reflex::Literal("at"), method_19492, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("front"), method_19493, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19458), Reflex::Literal("front"), method_19494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19456), Reflex::Literal("back"), method_19495, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19458), Reflex::Literal("back"), method_19496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17699), Reflex::Literal("data"), method_19497, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19454), Reflex::Literal("data"), method_19498, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19458), Reflex::Literal("push_back"), method_19499, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19500, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892, type_10892, type_19458), Reflex::Literal("insert"), method_19501, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10892, type_3405, type_19458), Reflex::Literal("insert"), method_19502, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892, type_10892), Reflex::Literal("erase"), method_19503, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892, type_10892, type_10892), Reflex::Literal("erase"), method_19504, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32716), Reflex::Literal("swap"), method_19505, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19506, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<bool,std::allocator<bool> > -------------------------------
static  void method_19526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<bool>)((((const ::std::vector<bool>*)o)->get_allocator)());
  else   (((const ::std::vector<bool>*)o)->get_allocator)();
}

static void constructor_19527( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>();
  else ::new(mem) ::std::vector<bool>();
}

static void constructor_19528( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(const ::std::allocator<bool>*)arg[0]);
  else ::new(mem) ::std::vector<bool>(*(const ::std::allocator<bool>*)arg[0]);
}

static void constructor_19529( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1]);
  else ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::allocator<bool>*)arg[2]);
  else ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::allocator<bool>*)arg[2]);
  }
}

static void constructor_19530( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(const ::std::vector<bool>*)arg[0]);
  else ::new(mem) ::std::vector<bool>(*(const ::std::vector<bool>*)arg[0]);
}

static void destructor_19531(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<bool>*)o)->::std::vector<bool>::~vector)();
}
static  void operator_19532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<bool>*)o)->operator=)(*(const ::std::vector<bool>*)arg[0]);
  else   (((::std::vector<bool>*)o)->operator=)(*(const ::std::vector<bool>*)arg[0]);
}

static  void method_19533( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const bool*)arg[1]);
}

static  void method_19534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->begin)());
  else   (((::std::vector<bool>*)o)->begin)();
}

static  void method_19535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_const_iterator)((((const ::std::vector<bool>*)o)->begin)());
  else   (((const ::std::vector<bool>*)o)->begin)();
}

static  void method_19536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->end)());
  else   (((::std::vector<bool>*)o)->end)();
}

static  void method_19537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_const_iterator)((((const ::std::vector<bool>*)o)->end)());
  else   (((const ::std::vector<bool>*)o)->end)();
}

static  void method_19542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<bool>*)o)->size)());
  else   (((const ::std::vector<bool>*)o)->size)();
}

static  void method_19543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<bool>*)o)->max_size)());
  else   (((const ::std::vector<bool>*)o)->max_size)();
}

static  void method_19544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<bool>*)o)->capacity)());
  else   (((const ::std::vector<bool>*)o)->capacity)();
}

static  void method_19545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->empty)());
  else   (((const ::std::vector<bool>*)o)->empty)();
}

static  void operator_19546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19551( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_19552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->front)());
  else   (((::std::vector<bool>*)o)->front)();
}

static  void method_19553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->front)());
  else   (((const ::std::vector<bool>*)o)->front)();
}

static  void method_19554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->back)());
  else   (((::std::vector<bool>*)o)->back)();
}

static  void method_19555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->back)());
  else   (((const ::std::vector<bool>*)o)->back)();
}

static  void method_19556( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->data)();
}

static  void method_19557( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->push_back)(*(bool*)arg[0]);
}

static  void method_19558( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->swap)(*(::std::vector<bool>*)arg[0]);
}

static  void method_19559( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->swap)(*(::std::_Bit_reference*)arg[0],
    *(::std::_Bit_reference*)arg[1]);
}

static  void method_19560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0]));
    else     (((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0],
      *(const bool*)arg[1]));
    else     (((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_19561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0],
    *(::std::size_t*)arg[1],
    *(const bool*)arg[2]);
}

static  void method_19562( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->pop_back)();
}

static  void method_19563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0]));
  else   (((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0]);
}

static  void method_19564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0],
    *(::std::_Bit_iterator*)arg[1]));
  else   (((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0],
    *(::std::_Bit_iterator*)arg[1]);
}

static  void method_19565( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<bool>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<bool>*)o)->resize)(*(::std::size_t*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_19566( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->flip)();
}

static  void method_19567( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->clear)();
}

static void method_newdel_3118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x185( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Bvector_base<std::allocator<bool> >")), ::Reflex::BaseOffset< ::std::vector<bool>,::std::_Bvector_base<std::allocator<bool> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x186( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<bool> >::Generate();
  else ::Reflex::Proxy< ::std::vector<bool> >::Generate();
}

//------Dictionary for class vector<bool,std::allocator<bool> > -------------------------------
void __std__vector_bool__db_datamem(Reflex::Class*);
void __std__vector_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_bool__datamem_bld(&__std__vector_bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_bool__funcmem_bld(&__std__vector_bool__db_funcmem);
void __std__vector_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<bool>"), typeid(::std::vector<bool>), sizeof(::std::vector<bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3256, ::Reflex::BaseOffset< ::std::vector<bool>, ::std::_Bvector_base<std::allocator<bool> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3256, Reflex::Literal("std::vector<bool>::_Base"))
  .AddTypedef(type_667, Reflex::Literal("std::vector<bool>::value_type"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<bool>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<bool>::difference_type"))
  .AddTypedef(type_3224, Reflex::Literal("std::vector<bool>::reference"))
  .AddTypedef(type_667, Reflex::Literal("std::vector<bool>::const_reference"))
  .AddTypedef(type_17951, Reflex::Literal("std::vector<bool>::pointer"))
  .AddTypedef(type_17941, Reflex::Literal("std::vector<bool>::const_pointer"))
  .AddTypedef(type_3225, Reflex::Literal("std::vector<bool>::iterator"))
  .AddTypedef(type_4022, Reflex::Literal("std::vector<bool>::const_iterator"))
  .AddTypedef(type_4000, Reflex::Literal("std::vector<bool>::const_reverse_iterator"))
  .AddTypedef(type_4001, Reflex::Literal("std::vector<bool>::reverse_iterator"))
  .AddTypedef(type_3729, Reflex::Literal("std::vector<bool>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19527, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32717), Reflex::Literal("vector"), constructor_19528, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_26071, type_32717), Reflex::Literal("vector"), constructor_19529, 0, "__n;__value=bool();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32718), Reflex::Literal("vector"), constructor_19530, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19531, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x185, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_bool__funcmem_bld);
}

//------Delayed data member builder for class vector<bool,std::allocator<bool> > -------------------
void __std__vector_bool__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<bool,std::allocator<bool> > -------------------
void __std__vector_bool__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3729), Reflex::Literal("get_allocator"), method_19526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32719, type_32718), Reflex::Literal("operator="), operator_19532, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_26071), Reflex::Literal("assign"), method_19533, 0, "__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3225), Reflex::Literal("begin"), method_19534, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4022), Reflex::Literal("begin"), method_19535, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3225), Reflex::Literal("end"), method_19536, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4022), Reflex::Literal("end"), method_19537, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19544, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3224, type_3405), Reflex::Literal("operator[]"), operator_19546, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667, type_3405), Reflex::Literal("operator[]"), operator_19547, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3224, type_3405), Reflex::Literal("at"), method_19549, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667, type_3405), Reflex::Literal("at"), method_19550, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19551, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3224), Reflex::Literal("front"), method_19552, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("front"), method_19553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3224), Reflex::Literal("back"), method_19554, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("back"), method_19555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("data"), method_19556, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_667), Reflex::Literal("push_back"), method_19557, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32719), Reflex::Literal("swap"), method_19558, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3224, type_3224), Reflex::Literal("swap"), method_19559, 0, "__x;__y", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3225, type_3225, type_26071), Reflex::Literal("insert"), method_19560, 0, "__position;__x=bool()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3225, type_3405, type_26071), Reflex::Literal("insert"), method_19561, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19562, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3225, type_3225), Reflex::Literal("erase"), method_19563, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3225, type_3225, type_3225), Reflex::Literal("erase"), method_19564, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_667), Reflex::Literal("resize"), method_19565, 0, "__new_size;__x=bool()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("flip"), method_19566, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19567, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooArgSet*,std::allocator<RooArgSet*> > -------------------------------
static void constructor_19595( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>();
  else ::new(mem) ::std::vector<RooArgSet*>();
}

static void constructor_19596( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(const ::std::allocator<RooArgSet*>*)arg[0]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(const ::std::allocator<RooArgSet*>*)arg[0]);
}

static void constructor_19597( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0],
      *(::RooArgSet* const*)arg[1]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0],
      *(::RooArgSet* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0],
      *(::RooArgSet* const*)arg[1],
      *(const ::std::allocator<RooArgSet*>*)arg[2]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0],
      *(::RooArgSet* const*)arg[1],
      *(const ::std::allocator<RooArgSet*>*)arg[2]);
  }
}

static void constructor_19598( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(const ::std::vector<RooArgSet*>*)arg[0]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(const ::std::vector<RooArgSet*>*)arg[0]);
}

static void destructor_19599(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooArgSet*>*)o)->::std::vector<RooArgSet*>::~vector)();
}
static  void operator_19600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->operator=)(*(const ::std::vector<RooArgSet*>*)arg[0]);
  else   (((::std::vector<RooArgSet*>*)o)->operator=)(*(const ::std::vector<RooArgSet*>*)arg[0]);
}

static  void method_19601( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooArgSet* const*)arg[1]);
}

static  void method_19602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->begin)());
  else   (((::std::vector<RooArgSet*>*)o)->begin)();
}

static  void method_19603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet* const*,std::vector<RooArgSet*> >)((((const ::std::vector<RooArgSet*>*)o)->begin)());
  else   (((const ::std::vector<RooArgSet*>*)o)->begin)();
}

static  void method_19604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->end)());
  else   (((::std::vector<RooArgSet*>*)o)->end)();
}

static  void method_19605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet* const*,std::vector<RooArgSet*> >)((((const ::std::vector<RooArgSet*>*)o)->end)());
  else   (((const ::std::vector<RooArgSet*>*)o)->end)();
}

static  void method_19610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooArgSet*>*)o)->size)());
  else   (((const ::std::vector<RooArgSet*>*)o)->size)();
}

static  void method_19611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooArgSet*>*)o)->max_size)());
  else   (((const ::std::vector<RooArgSet*>*)o)->max_size)();
}

static  void method_19612( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooArgSet*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooArgSet*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooArgSet*)arg[1]);
  }
}

static  void method_19613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooArgSet*>*)o)->capacity)());
  else   (((const ::std::vector<RooArgSet*>*)o)->capacity)();
}

static  void method_19614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooArgSet*>*)o)->empty)());
  else   (((const ::std::vector<RooArgSet*>*)o)->empty)();
}

static  void method_19615( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooArgSet*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooArgSet*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooArgSet*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooArgSet*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooArgSet*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooArgSet*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->front)();
  else   (((::std::vector<RooArgSet*>*)o)->front)();
}

static  void method_19622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooArgSet*>*)o)->front)();
  else   (((const ::std::vector<RooArgSet*>*)o)->front)();
}

static  void method_19623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->back)();
  else   (((::std::vector<RooArgSet*>*)o)->back)();
}

static  void method_19624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooArgSet*>*)o)->back)();
  else   (((const ::std::vector<RooArgSet*>*)o)->back)();
}

static  void method_19625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooArgSet*>*)o)->data)());
  else   (((::std::vector<RooArgSet*>*)o)->data)();
}

static  void method_19626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooArgSet*>*)o)->data)());
  else   (((const ::std::vector<RooArgSet*>*)o)->data)();
}

static  void method_19627( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->push_back)(*(::RooArgSet* const*)arg[0]);
}

static  void method_19628( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooArgSet*>*)o)->pop_back)();
}

static  void method_19629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::RooArgSet* const*)arg[1]));
  else   (((::std::vector<RooArgSet*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::RooArgSet* const*)arg[1]);
}

static  void method_19630( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooArgSet* const*)arg[2]);
}

static  void method_19631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0]));
  else   (((::std::vector<RooArgSet*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0]);
}

static  void method_19632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[1]));
  else   (((::std::vector<RooArgSet*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[1]);
}

static  void method_19633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->swap)(*(::std::vector<RooArgSet*>*)arg[0]);
}

static  void method_19634( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooArgSet*>*)o)->clear)();
}

static void method_newdel_3119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> >")), ::Reflex::BaseOffset< ::std::vector<RooArgSet*>,::std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x189( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooArgSet*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooArgSet*> >::Generate();
}

//------Dictionary for class vector<RooArgSet*,std::allocator<RooArgSet*> > -------------------------------
void __std__vector_RooArgSetp__db_datamem(Reflex::Class*);
void __std__vector_RooArgSetp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooArgSetp__datamem_bld(&__std__vector_RooArgSetp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooArgSetp__funcmem_bld(&__std__vector_RooArgSetp__db_funcmem);
void __std__vector_RooArgSetp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooArgSet*>"), typeid(::std::vector<RooArgSet*>), sizeof(::std::vector<RooArgSet*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3046, ::Reflex::BaseOffset< ::std::vector<RooArgSet*>, ::std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2835, Reflex::Literal("std::vector<RooArgSet*>::_Alloc_value_type"))
  .AddTypedef(type_3046, Reflex::Literal("std::vector<RooArgSet*>::_Base"))
  .AddTypedef(type_3735, Reflex::Literal("std::vector<RooArgSet*>::_Tp_alloc_type"))
  .AddTypedef(type_11047, Reflex::Literal("std::vector<RooArgSet*>::_Alloc_traits"))
  .AddTypedef(type_2835, Reflex::Literal("std::vector<RooArgSet*>::value_type"))
  .AddTypedef(type_17756, Reflex::Literal("std::vector<RooArgSet*>::pointer"))
  .AddTypedef(type_19582, Reflex::Literal("std::vector<RooArgSet*>::const_pointer"))
  .AddTypedef(type_19584, Reflex::Literal("std::vector<RooArgSet*>::reference"))
  .AddTypedef(type_19586, Reflex::Literal("std::vector<RooArgSet*>::const_reference"))
  .AddTypedef(type_10898, Reflex::Literal("std::vector<RooArgSet*>::iterator"))
  .AddTypedef(type_10899, Reflex::Literal("std::vector<RooArgSet*>::const_iterator"))
  .AddTypedef(type_3964, Reflex::Literal("std::vector<RooArgSet*>::const_reverse_iterator"))
  .AddTypedef(type_3965, Reflex::Literal("std::vector<RooArgSet*>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<RooArgSet*>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<RooArgSet*>::difference_type"))
  .AddTypedef(type_3735, Reflex::Literal("std::vector<RooArgSet*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19595, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32535), Reflex::Literal("vector"), constructor_19596, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19586, type_32535), Reflex::Literal("vector"), constructor_19597, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32721), Reflex::Literal("vector"), constructor_19598, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19599, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x189, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooArgSetp__funcmem_bld);
}

//------Delayed data member builder for class vector<RooArgSet*,std::allocator<RooArgSet*> > -------------------
void __std__vector_RooArgSetp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooArgSet*,std::allocator<RooArgSet*> > -------------------
void __std__vector_RooArgSetp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32722, type_32721), Reflex::Literal("operator="), operator_19600, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19586), Reflex::Literal("assign"), method_19601, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898), Reflex::Literal("begin"), method_19602, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10899), Reflex::Literal("begin"), method_19603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898), Reflex::Literal("end"), method_19604, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10899), Reflex::Literal("end"), method_19605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_2835), Reflex::Literal("resize"), method_19612, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19615, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19584, type_3405), Reflex::Literal("operator[]"), operator_19616, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19586, type_3405), Reflex::Literal("operator[]"), operator_19617, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19584, type_3405), Reflex::Literal("at"), method_19619, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19586, type_3405), Reflex::Literal("at"), method_19620, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19584), Reflex::Literal("front"), method_19621, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19586), Reflex::Literal("front"), method_19622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19584), Reflex::Literal("back"), method_19623, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19586), Reflex::Literal("back"), method_19624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17756), Reflex::Literal("data"), method_19625, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19582), Reflex::Literal("data"), method_19626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19586), Reflex::Literal("push_back"), method_19627, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19628, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898, type_10898, type_19586), Reflex::Literal("insert"), method_19629, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10898, type_3405, type_19586), Reflex::Literal("insert"), method_19630, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898, type_10898), Reflex::Literal("erase"), method_19631, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898, type_10898, type_10898), Reflex::Literal("erase"), method_19632, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32722), Reflex::Literal("swap"), method_19633, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19634, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------------------
static void constructor_19660( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >();
  else ::new(mem) ::std::vector<std::vector<int> >();
}

static void constructor_19661( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::allocator<std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::allocator<std::vector<int> >*)arg[0]);
}

static void constructor_19662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1],
      *(const ::std::allocator<std::vector<int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1],
      *(const ::std::allocator<std::vector<int> >*)arg[2]);
  }
}

static void constructor_19663( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::vector<std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::vector<std::vector<int> >*)arg[0]);
}

static void destructor_19664(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<int> >*)o)->::std::vector<std::vector<int> >::~vector)();
}
static  void operator_19665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->operator=)(*(const ::std::vector<std::vector<int> >*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->operator=)(*(const ::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_19666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<int>*)arg[1]);
}

static  void method_19667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->begin)());
  else   (((::std::vector<std::vector<int> >*)o)->begin)();
}

static  void method_19668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >)((((const ::std::vector<std::vector<int> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<int> >*)o)->begin)();
}

static  void method_19669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->end)());
  else   (((::std::vector<std::vector<int> >*)o)->end)();
}

static  void method_19670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >)((((const ::std::vector<std::vector<int> >*)o)->end)());
  else   (((const ::std::vector<std::vector<int> >*)o)->end)();
}

static  void method_19675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->size)());
  else   (((const ::std::vector<std::vector<int> >*)o)->size)();
}

static  void method_19676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<int> >*)o)->max_size)();
}

static  void method_19677( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<int>*)arg[1]);
  }
}

static  void method_19678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<int> >*)o)->capacity)();
}

static  void method_19679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<int> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<int> >*)o)->empty)();
}

static  void method_19680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->front)();
  else   (((::std::vector<std::vector<int> >*)o)->front)();
}

static  void method_19687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->front)();
  else   (((const ::std::vector<std::vector<int> >*)o)->front)();
}

static  void method_19688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->back)();
  else   (((::std::vector<std::vector<int> >*)o)->back)();
}

static  void method_19689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->back)();
  else   (((const ::std::vector<std::vector<int> >*)o)->back)();
}

static  void method_19690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<int> >*)o)->data)());
  else   (((::std::vector<std::vector<int> >*)o)->data)();
}

static  void method_19691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<int> >*)o)->data)());
  else   (((const ::std::vector<std::vector<int> >*)o)->data)();
}

static  void method_19692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->push_back)(*(const ::std::vector<int>*)arg[0]);
}

static  void method_19693( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<int> >*)o)->pop_back)();
}

static  void method_19694( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(const ::std::vector<int>*)arg[1]));
  else   (((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(const ::std::vector<int>*)arg[1]);
}

static  void method_19695( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<int>*)arg[2]);
}

static  void method_19696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0]));
  else   (((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0]);
}

static  void method_19697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[1]));
  else   (((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[1]);
}

static  void method_19698( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->swap)(*(::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_19699( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<int> >*)o)->clear)();
}

static void method_newdel_3120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x191( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<int> >,::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x192( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<int> > >::Generate();
}

//------Dictionary for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------------------
void __std__vector_std__vector_int_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_int_s__datamem_bld(&__std__vector_std__vector_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_int_s__funcmem_bld(&__std__vector_std__vector_int_s__db_funcmem);
void __std__vector_std__vector_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<int> >"), typeid(::std::vector<std::vector<int> >), sizeof(::std::vector<std::vector<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3047, ::Reflex::BaseOffset< ::std::vector<std::vector<int> >, ::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3102, Reflex::Literal("std::vector<std::vector<int> >::_Alloc_value_type"))
  .AddTypedef(type_3047, Reflex::Literal("std::vector<std::vector<int> >::_Base"))
  .AddTypedef(type_3736, Reflex::Literal("std::vector<std::vector<int> >::_Tp_alloc_type"))
  .AddTypedef(type_11048, Reflex::Literal("std::vector<std::vector<int> >::_Alloc_traits"))
  .AddTypedef(type_3102, Reflex::Literal("std::vector<std::vector<int> >::value_type"))
  .AddTypedef(type_17775, Reflex::Literal("std::vector<std::vector<int> >::pointer"))
  .AddTypedef(type_19647, Reflex::Literal("std::vector<std::vector<int> >::const_pointer"))
  .AddTypedef(type_19649, Reflex::Literal("std::vector<std::vector<int> >::reference"))
  .AddTypedef(type_19651, Reflex::Literal("std::vector<std::vector<int> >::const_reference"))
  .AddTypedef(type_10900, Reflex::Literal("std::vector<std::vector<int> >::iterator"))
  .AddTypedef(type_10901, Reflex::Literal("std::vector<std::vector<int> >::const_iterator"))
  .AddTypedef(type_3966, Reflex::Literal("std::vector<std::vector<int> >::const_reverse_iterator"))
  .AddTypedef(type_3967, Reflex::Literal("std::vector<std::vector<int> >::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<std::vector<int> >::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<std::vector<int> >::difference_type"))
  .AddTypedef(type_3736, Reflex::Literal("std::vector<std::vector<int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19660, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32548), Reflex::Literal("vector"), constructor_19661, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19651, type_32548), Reflex::Literal("vector"), constructor_19662, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32724), Reflex::Literal("vector"), constructor_19663, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19664, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x191, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x192, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------
void __std__vector_std__vector_int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------
void __std__vector_std__vector_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32725, type_32724), Reflex::Literal("operator="), operator_19665, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19651), Reflex::Literal("assign"), method_19666, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900), Reflex::Literal("begin"), method_19667, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10901), Reflex::Literal("begin"), method_19668, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900), Reflex::Literal("end"), method_19669, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10901), Reflex::Literal("end"), method_19670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_3102), Reflex::Literal("resize"), method_19677, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19680, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19649, type_3405), Reflex::Literal("operator[]"), operator_19681, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19651, type_3405), Reflex::Literal("operator[]"), operator_19682, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19649, type_3405), Reflex::Literal("at"), method_19684, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19651, type_3405), Reflex::Literal("at"), method_19685, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19649), Reflex::Literal("front"), method_19686, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19651), Reflex::Literal("front"), method_19687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19649), Reflex::Literal("back"), method_19688, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19651), Reflex::Literal("back"), method_19689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17775), Reflex::Literal("data"), method_19690, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19647), Reflex::Literal("data"), method_19691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19651), Reflex::Literal("push_back"), method_19692, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19693, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900, type_10900, type_19651), Reflex::Literal("insert"), method_19694, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10900, type_3405, type_19651), Reflex::Literal("insert"), method_19695, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900, type_10900), Reflex::Literal("erase"), method_19696, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900, type_10900, type_10900), Reflex::Literal("erase"), method_19697, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32725), Reflex::Literal("swap"), method_19698, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19699, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
static void constructor_19725( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >();
}

static void constructor_19726( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static void constructor_19727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[2]);
  }
}

static void constructor_19728( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static void destructor_19729(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->::std::vector<std::pair<std::basic_string<char>,int> >::~vector)();
}
static  void operator_19730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static  void method_19731( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
}

static  void method_19732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)();
}

static  void method_19733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)();
}

static  void method_19734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)();
}

static  void method_19735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)();
}

static  void method_19740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->size)();
}

static  void method_19741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->max_size)();
}

static  void method_19742( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,int>*)arg[1]);
  }
}

static  void method_19743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->capacity)();
}

static  void method_19744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->empty)();
}

static  void method_19745( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
}

static  void method_19752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
}

static  void method_19753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
}

static  void method_19754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
}

static  void method_19755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)();
}

static  void method_19756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)();
}

static  void method_19757( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
}

static  void method_19758( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->pop_back)();
}

static  void method_19759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
}

static  void method_19760( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[2]);
}

static  void method_19761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0]);
}

static  void method_19762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[1]);
}

static  void method_19763( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static  void method_19764( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->clear)();
}

static void method_newdel_3121( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x194( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,int> >,::std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x195( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,int> > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__int_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__int_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__int_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__int_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >"), typeid(::std::vector<std::pair<std::basic_string<char>,int> >), sizeof(::std::vector<std::pair<std::basic_string<char>,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3052, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,int> >, ::std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3555, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Alloc_value_type"))
  .AddTypedef(type_3052, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Base"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Tp_alloc_type"))
  .AddTypedef(type_11053, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Alloc_traits"))
  .AddTypedef(type_3555, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::value_type"))
  .AddTypedef(type_17870, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::pointer"))
  .AddTypedef(type_19712, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_pointer"))
  .AddTypedef(type_19714, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::reference"))
  .AddTypedef(type_19716, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_reference"))
  .AddTypedef(type_10910, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::iterator"))
  .AddTypedef(type_10911, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_iterator"))
  .AddTypedef(type_4004, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_reverse_iterator"))
  .AddTypedef(type_4005, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::difference_type"))
  .AddTypedef(type_3753, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19725, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32613), Reflex::Literal("vector"), constructor_19726, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19716, type_32613), Reflex::Literal("vector"), constructor_19727, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32727), Reflex::Literal("vector"), constructor_19728, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19729, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3121, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x194, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x195, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__vector_std__pair_std__basic_string_char__int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__vector_std__pair_std__basic_string_char__int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31252, type_32727), Reflex::Literal("operator="), operator_19730, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19716), Reflex::Literal("assign"), method_19731, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10910), Reflex::Literal("begin"), method_19732, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10911), Reflex::Literal("begin"), method_19733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10910), Reflex::Literal("end"), method_19734, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10911), Reflex::Literal("end"), method_19735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_3555), Reflex::Literal("resize"), method_19742, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19745, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19714, type_3405), Reflex::Literal("operator[]"), operator_19746, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19716, type_3405), Reflex::Literal("operator[]"), operator_19747, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19714, type_3405), Reflex::Literal("at"), method_19749, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19716, type_3405), Reflex::Literal("at"), method_19750, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19714), Reflex::Literal("front"), method_19751, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19716), Reflex::Literal("front"), method_19752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19714), Reflex::Literal("back"), method_19753, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19716), Reflex::Literal("back"), method_19754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17870), Reflex::Literal("data"), method_19755, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19712), Reflex::Literal("data"), method_19756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19716), Reflex::Literal("push_back"), method_19757, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19758, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10910, type_10910, type_19716), Reflex::Literal("insert"), method_19759, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10910, type_3405, type_19716), Reflex::Literal("insert"), method_19760, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10910, type_10910), Reflex::Literal("erase"), method_19761, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10910, type_10910, type_10910), Reflex::Literal("erase"), method_19762, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_31252), Reflex::Literal("swap"), method_19763, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19764, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooAbsArg*,std::allocator<RooAbsArg*> > -------------------------------
static void constructor_19791( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>();
  else ::new(mem) ::std::vector<RooAbsArg*>();
}

static void constructor_19792( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(const ::std::allocator<RooAbsArg*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(const ::std::allocator<RooAbsArg*>*)arg[0]);
}

static void constructor_19793( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0],
      *(::RooAbsArg* const*)arg[1]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0],
      *(::RooAbsArg* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0],
      *(::RooAbsArg* const*)arg[1],
      *(const ::std::allocator<RooAbsArg*>*)arg[2]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0],
      *(::RooAbsArg* const*)arg[1],
      *(const ::std::allocator<RooAbsArg*>*)arg[2]);
  }
}

static void constructor_19794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(const ::std::vector<RooAbsArg*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(const ::std::vector<RooAbsArg*>*)arg[0]);
}

static void destructor_19795(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooAbsArg*>*)o)->::std::vector<RooAbsArg*>::~vector)();
}
static  void operator_19796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->operator=)(*(const ::std::vector<RooAbsArg*>*)arg[0]);
  else   (((::std::vector<RooAbsArg*>*)o)->operator=)(*(const ::std::vector<RooAbsArg*>*)arg[0]);
}

static  void method_19797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooAbsArg* const*)arg[1]);
}

static  void method_19798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->begin)());
  else   (((::std::vector<RooAbsArg*>*)o)->begin)();
}

static  void method_19799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg* const*,std::vector<RooAbsArg*> >)((((const ::std::vector<RooAbsArg*>*)o)->begin)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->begin)();
}

static  void method_19800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->end)());
  else   (((::std::vector<RooAbsArg*>*)o)->end)();
}

static  void method_19801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg* const*,std::vector<RooAbsArg*> >)((((const ::std::vector<RooAbsArg*>*)o)->end)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->end)();
}

static  void method_19806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsArg*>*)o)->size)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->size)();
}

static  void method_19807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsArg*>*)o)->max_size)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->max_size)();
}

static  void method_19808( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooAbsArg*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooAbsArg*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooAbsArg*)arg[1]);
  }
}

static  void method_19809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsArg*>*)o)->capacity)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->capacity)();
}

static  void method_19810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooAbsArg*>*)o)->empty)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->empty)();
}

static  void method_19811( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsArg*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsArg*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsArg*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsArg*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19816( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsArg*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsArg*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->front)();
  else   (((::std::vector<RooAbsArg*>*)o)->front)();
}

static  void method_19818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsArg*>*)o)->front)();
  else   (((const ::std::vector<RooAbsArg*>*)o)->front)();
}

static  void method_19819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->back)();
  else   (((::std::vector<RooAbsArg*>*)o)->back)();
}

static  void method_19820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsArg*>*)o)->back)();
  else   (((const ::std::vector<RooAbsArg*>*)o)->back)();
}

static  void method_19821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooAbsArg*>*)o)->data)());
  else   (((::std::vector<RooAbsArg*>*)o)->data)();
}

static  void method_19822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooAbsArg*>*)o)->data)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->data)();
}

static  void method_19823( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->push_back)(*(::RooAbsArg* const*)arg[0]);
}

static  void method_19824( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->pop_back)();
}

static  void method_19825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::RooAbsArg* const*)arg[1]));
  else   (((::std::vector<RooAbsArg*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::RooAbsArg* const*)arg[1]);
}

static  void method_19826( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooAbsArg* const*)arg[2]);
}

static  void method_19827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0]));
  else   (((::std::vector<RooAbsArg*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0]);
}

static  void method_19828( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[1]));
  else   (((::std::vector<RooAbsArg*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[1]);
}

static  void method_19829( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->swap)(*(::std::vector<RooAbsArg*>*)arg[0]);
}

static  void method_19830( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->clear)();
}

static void method_newdel_3122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x197( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> >")), ::Reflex::BaseOffset< ::std::vector<RooAbsArg*>,::std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x198( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooAbsArg*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooAbsArg*> >::Generate();
}

//------Dictionary for class vector<RooAbsArg*,std::allocator<RooAbsArg*> > -------------------------------
void __std__vector_RooAbsArgp__db_datamem(Reflex::Class*);
void __std__vector_RooAbsArgp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsArgp__datamem_bld(&__std__vector_RooAbsArgp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsArgp__funcmem_bld(&__std__vector_RooAbsArgp__db_funcmem);
void __std__vector_RooAbsArgp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooAbsArg*>"), typeid(::std::vector<RooAbsArg*>), sizeof(::std::vector<RooAbsArg*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3048, ::Reflex::BaseOffset< ::std::vector<RooAbsArg*>, ::std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_19771, Reflex::Literal("std::vector<RooAbsArg*>::_Alloc_value_type"))
  .AddTypedef(type_3048, Reflex::Literal("std::vector<RooAbsArg*>::_Base"))
  .AddTypedef(type_3754, Reflex::Literal("std::vector<RooAbsArg*>::_Tp_alloc_type"))
  .AddTypedef(type_11049, Reflex::Literal("std::vector<RooAbsArg*>::_Alloc_traits"))
  .AddTypedef(type_19771, Reflex::Literal("std::vector<RooAbsArg*>::value_type"))
  .AddTypedef(type_17794, Reflex::Literal("std::vector<RooAbsArg*>::pointer"))
  .AddTypedef(type_19778, Reflex::Literal("std::vector<RooAbsArg*>::const_pointer"))
  .AddTypedef(type_19780, Reflex::Literal("std::vector<RooAbsArg*>::reference"))
  .AddTypedef(type_19782, Reflex::Literal("std::vector<RooAbsArg*>::const_reference"))
  .AddTypedef(type_10902, Reflex::Literal("std::vector<RooAbsArg*>::iterator"))
  .AddTypedef(type_10903, Reflex::Literal("std::vector<RooAbsArg*>::const_iterator"))
  .AddTypedef(type_3982, Reflex::Literal("std::vector<RooAbsArg*>::const_reverse_iterator"))
  .AddTypedef(type_3983, Reflex::Literal("std::vector<RooAbsArg*>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<RooAbsArg*>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<RooAbsArg*>::difference_type"))
  .AddTypedef(type_3754, Reflex::Literal("std::vector<RooAbsArg*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19791, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32561), Reflex::Literal("vector"), constructor_19792, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19782, type_32561), Reflex::Literal("vector"), constructor_19793, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32729), Reflex::Literal("vector"), constructor_19794, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19795, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x198, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooAbsArgp__funcmem_bld);
}

//------Delayed data member builder for class vector<RooAbsArg*,std::allocator<RooAbsArg*> > -------------------
void __std__vector_RooAbsArgp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooAbsArg*,std::allocator<RooAbsArg*> > -------------------
void __std__vector_RooAbsArgp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32730, type_32729), Reflex::Literal("operator="), operator_19796, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19782), Reflex::Literal("assign"), method_19797, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902), Reflex::Literal("begin"), method_19798, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10903), Reflex::Literal("begin"), method_19799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902), Reflex::Literal("end"), method_19800, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10903), Reflex::Literal("end"), method_19801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19771), Reflex::Literal("resize"), method_19808, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19811, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780, type_3405), Reflex::Literal("operator[]"), operator_19812, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19782, type_3405), Reflex::Literal("operator[]"), operator_19813, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780, type_3405), Reflex::Literal("at"), method_19815, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19782, type_3405), Reflex::Literal("at"), method_19816, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780), Reflex::Literal("front"), method_19817, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19782), Reflex::Literal("front"), method_19818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19780), Reflex::Literal("back"), method_19819, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19782), Reflex::Literal("back"), method_19820, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17794), Reflex::Literal("data"), method_19821, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19778), Reflex::Literal("data"), method_19822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19782), Reflex::Literal("push_back"), method_19823, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19824, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902, type_10902, type_19782), Reflex::Literal("insert"), method_19825, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10902, type_3405, type_19782), Reflex::Literal("insert"), method_19826, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902, type_10902), Reflex::Literal("erase"), method_19827, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902, type_10902, type_10902), Reflex::Literal("erase"), method_19828, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32730), Reflex::Literal("swap"), method_19829, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19830, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > -------------------------------
static void constructor_19857( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>();
  else ::new(mem) ::std::vector<RooAbsCacheElement*>();
}

static void constructor_19858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(const ::std::allocator<RooAbsCacheElement*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(const ::std::allocator<RooAbsCacheElement*>*)arg[0]);
}

static void constructor_19859( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0],
      *(::RooAbsCacheElement* const*)arg[1]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0],
      *(::RooAbsCacheElement* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0],
      *(::RooAbsCacheElement* const*)arg[1],
      *(const ::std::allocator<RooAbsCacheElement*>*)arg[2]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0],
      *(::RooAbsCacheElement* const*)arg[1],
      *(const ::std::allocator<RooAbsCacheElement*>*)arg[2]);
  }
}

static void constructor_19860( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(const ::std::vector<RooAbsCacheElement*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(const ::std::vector<RooAbsCacheElement*>*)arg[0]);
}

static void destructor_19861(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooAbsCacheElement*>*)o)->::std::vector<RooAbsCacheElement*>::~vector)();
}
static  void operator_19862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->operator=)(*(const ::std::vector<RooAbsCacheElement*>*)arg[0]);
  else   (((::std::vector<RooAbsCacheElement*>*)o)->operator=)(*(const ::std::vector<RooAbsCacheElement*>*)arg[0]);
}

static  void method_19863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooAbsCacheElement* const*)arg[1]);
}

static  void method_19864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->begin)());
  else   (((::std::vector<RooAbsCacheElement*>*)o)->begin)();
}

static  void method_19865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement* const*,std::vector<RooAbsCacheElement*> >)((((const ::std::vector<RooAbsCacheElement*>*)o)->begin)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->begin)();
}

static  void method_19866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->end)());
  else   (((::std::vector<RooAbsCacheElement*>*)o)->end)();
}

static  void method_19867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement* const*,std::vector<RooAbsCacheElement*> >)((((const ::std::vector<RooAbsCacheElement*>*)o)->end)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->end)();
}

static  void method_19872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsCacheElement*>*)o)->size)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->size)();
}

static  void method_19873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsCacheElement*>*)o)->max_size)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->max_size)();
}

static  void method_19874( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooAbsCacheElement*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooAbsCacheElement*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooAbsCacheElement*)arg[1]);
  }
}

static  void method_19875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsCacheElement*>*)o)->capacity)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->capacity)();
}

static  void method_19876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooAbsCacheElement*>*)o)->empty)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->empty)();
}

static  void method_19877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsCacheElement*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsCacheElement*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsCacheElement*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsCacheElement*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->front)();
  else   (((::std::vector<RooAbsCacheElement*>*)o)->front)();
}

static  void method_19884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsCacheElement*>*)o)->front)();
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->front)();
}

static  void method_19885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->back)();
  else   (((::std::vector<RooAbsCacheElement*>*)o)->back)();
}

static  void method_19886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsCacheElement*>*)o)->back)();
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->back)();
}

static  void method_19887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooAbsCacheElement*>*)o)->data)());
  else   (((::std::vector<RooAbsCacheElement*>*)o)->data)();
}

static  void method_19888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooAbsCacheElement*>*)o)->data)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->data)();
}

static  void method_19889( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->push_back)(*(::RooAbsCacheElement* const*)arg[0]);
}

static  void method_19890( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->pop_back)();
}

static  void method_19891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::RooAbsCacheElement* const*)arg[1]));
  else   (((::std::vector<RooAbsCacheElement*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::RooAbsCacheElement* const*)arg[1]);
}

static  void method_19892( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooAbsCacheElement* const*)arg[2]);
}

static  void method_19893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0]));
  else   (((::std::vector<RooAbsCacheElement*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0]);
}

static  void method_19894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[1]));
  else   (((::std::vector<RooAbsCacheElement*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[1]);
}

static  void method_19895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->swap)(*(::std::vector<RooAbsCacheElement*>*)arg[0]);
}

static  void method_19896( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->clear)();
}

static void method_newdel_3123( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x200( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> >")), ::Reflex::BaseOffset< ::std::vector<RooAbsCacheElement*>,::std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x201( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooAbsCacheElement*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooAbsCacheElement*> >::Generate();
}

//------Dictionary for class vector<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > -------------------------------
void __std__vector_RooAbsCacheElementp__db_datamem(Reflex::Class*);
void __std__vector_RooAbsCacheElementp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsCacheElementp__datamem_bld(&__std__vector_RooAbsCacheElementp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsCacheElementp__funcmem_bld(&__std__vector_RooAbsCacheElementp__db_funcmem);
void __std__vector_RooAbsCacheElementp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooAbsCacheElement*>"), typeid(::std::vector<RooAbsCacheElement*>), sizeof(::std::vector<RooAbsCacheElement*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3049, ::Reflex::BaseOffset< ::std::vector<RooAbsCacheElement*>, ::std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_19837, Reflex::Literal("std::vector<RooAbsCacheElement*>::_Alloc_value_type"))
  .AddTypedef(type_3049, Reflex::Literal("std::vector<RooAbsCacheElement*>::_Base"))
  .AddTypedef(type_3755, Reflex::Literal("std::vector<RooAbsCacheElement*>::_Tp_alloc_type"))
  .AddTypedef(type_11050, Reflex::Literal("std::vector<RooAbsCacheElement*>::_Alloc_traits"))
  .AddTypedef(type_19837, Reflex::Literal("std::vector<RooAbsCacheElement*>::value_type"))
  .AddTypedef(type_17813, Reflex::Literal("std::vector<RooAbsCacheElement*>::pointer"))
  .AddTypedef(type_19844, Reflex::Literal("std::vector<RooAbsCacheElement*>::const_pointer"))
  .AddTypedef(type_19846, Reflex::Literal("std::vector<RooAbsCacheElement*>::reference"))
  .AddTypedef(type_19848, Reflex::Literal("std::vector<RooAbsCacheElement*>::const_reference"))
  .AddTypedef(type_10904, Reflex::Literal("std::vector<RooAbsCacheElement*>::iterator"))
  .AddTypedef(type_10905, Reflex::Literal("std::vector<RooAbsCacheElement*>::const_iterator"))
  .AddTypedef(type_3984, Reflex::Literal("std::vector<RooAbsCacheElement*>::const_reverse_iterator"))
  .AddTypedef(type_3985, Reflex::Literal("std::vector<RooAbsCacheElement*>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<RooAbsCacheElement*>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<RooAbsCacheElement*>::difference_type"))
  .AddTypedef(type_3755, Reflex::Literal("std::vector<RooAbsCacheElement*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19857, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32574), Reflex::Literal("vector"), constructor_19858, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19848, type_32574), Reflex::Literal("vector"), constructor_19859, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32732), Reflex::Literal("vector"), constructor_19860, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19861, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x201, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooAbsCacheElementp__funcmem_bld);
}

//------Delayed data member builder for class vector<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > -------------------
void __std__vector_RooAbsCacheElementp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > -------------------
void __std__vector_RooAbsCacheElementp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32733, type_32732), Reflex::Literal("operator="), operator_19862, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19848), Reflex::Literal("assign"), method_19863, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904), Reflex::Literal("begin"), method_19864, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10905), Reflex::Literal("begin"), method_19865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904), Reflex::Literal("end"), method_19866, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10905), Reflex::Literal("end"), method_19867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19837), Reflex::Literal("resize"), method_19874, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19877, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19846, type_3405), Reflex::Literal("operator[]"), operator_19878, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19848, type_3405), Reflex::Literal("operator[]"), operator_19879, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19846, type_3405), Reflex::Literal("at"), method_19881, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19848, type_3405), Reflex::Literal("at"), method_19882, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19846), Reflex::Literal("front"), method_19883, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19848), Reflex::Literal("front"), method_19884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19846), Reflex::Literal("back"), method_19885, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19848), Reflex::Literal("back"), method_19886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17813), Reflex::Literal("data"), method_19887, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19844), Reflex::Literal("data"), method_19888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19848), Reflex::Literal("push_back"), method_19889, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19890, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904, type_10904, type_19848), Reflex::Literal("insert"), method_19891, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10904, type_3405, type_19848), Reflex::Literal("insert"), method_19892, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904, type_10904), Reflex::Literal("erase"), method_19893, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904, type_10904, type_10904), Reflex::Literal("erase"), method_19894, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32733), Reflex::Literal("swap"), method_19895, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19896, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > -------------------------------
static void constructor_19922( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>();
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>();
}

static void constructor_19923( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(const ::std::allocator<RooMsgService::StreamConfig>*)arg[0]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(const ::std::allocator<RooMsgService::StreamConfig>*)arg[0]);
}

static void constructor_19924( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0],
      *(const ::RooMsgService::StreamConfig*)arg[1]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0],
      *(const ::RooMsgService::StreamConfig*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0],
      *(const ::RooMsgService::StreamConfig*)arg[1],
      *(const ::std::allocator<RooMsgService::StreamConfig>*)arg[2]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0],
      *(const ::RooMsgService::StreamConfig*)arg[1],
      *(const ::std::allocator<RooMsgService::StreamConfig>*)arg[2]);
  }
}

static void constructor_19925( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(const ::std::vector<RooMsgService::StreamConfig>*)arg[0]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(const ::std::vector<RooMsgService::StreamConfig>*)arg[0]);
}

static void destructor_19926(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooMsgService::StreamConfig>*)o)->::std::vector<RooMsgService::StreamConfig>::~vector)();
}
static  void operator_19927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->operator=)(*(const ::std::vector<RooMsgService::StreamConfig>*)arg[0]);
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->operator=)(*(const ::std::vector<RooMsgService::StreamConfig>*)arg[0]);
}

static  void method_19928( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RooMsgService::StreamConfig*)arg[1]);
}

static  void method_19929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->begin)());
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->begin)();
}

static  void method_19930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->begin)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->begin)();
}

static  void method_19931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->end)());
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->end)();
}

static  void method_19932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->end)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->end)();
}

static  void method_19937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->size)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->size)();
}

static  void method_19938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->max_size)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->max_size)();
}

static  void method_19939( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooMsgService::StreamConfig>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooMsgService::StreamConfig>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RooMsgService::StreamConfig*)arg[1]);
  }
}

static  void method_19940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->capacity)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->capacity)();
}

static  void method_19941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->empty)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->empty)();
}

static  void method_19942( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooMsgService::StreamConfig>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooMsgService::StreamConfig>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->front)();
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->front)();
}

static  void method_19949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooMsgService::StreamConfig>*)o)->front)();
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->front)();
}

static  void method_19950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->back)();
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->back)();
}

static  void method_19951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooMsgService::StreamConfig>*)o)->back)();
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->back)();
}

static  void method_19952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooMsgService::StreamConfig>*)o)->data)());
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->data)();
}

static  void method_19953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooMsgService::StreamConfig>*)o)->data)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->data)();
}

static  void method_19954( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->push_back)(*(const ::RooMsgService::StreamConfig*)arg[0]);
}

static  void method_19955( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->pop_back)();
}

static  void method_19956( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(const ::RooMsgService::StreamConfig*)arg[1]));
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(const ::RooMsgService::StreamConfig*)arg[1]);
}

static  void method_19957( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RooMsgService::StreamConfig*)arg[2]);
}

static  void method_19958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0]));
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0]);
}

static  void method_19959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[1]));
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[1]);
}

static  void method_19960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->swap)(*(::std::vector<RooMsgService::StreamConfig>*)arg[0]);
}

static  void method_19961( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->clear)();
}

static void method_newdel_3124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> >")), ::Reflex::BaseOffset< ::std::vector<RooMsgService::StreamConfig>,::std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x204( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooMsgService::StreamConfig> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooMsgService::StreamConfig> >::Generate();
}

//------Dictionary for class vector<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > -------------------------------
void __std__vector_RooMsgService__StreamConfig__db_datamem(Reflex::Class*);
void __std__vector_RooMsgService__StreamConfig__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooMsgService__StreamConfig__datamem_bld(&__std__vector_RooMsgService__StreamConfig__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooMsgService__StreamConfig__funcmem_bld(&__std__vector_RooMsgService__StreamConfig__db_funcmem);
void __std__vector_RooMsgService__StreamConfig__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooMsgService::StreamConfig>"), typeid(::std::vector<RooMsgService::StreamConfig>), sizeof(::std::vector<RooMsgService::StreamConfig>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3051, ::Reflex::BaseOffset< ::std::vector<RooMsgService::StreamConfig>, ::std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4328, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::_Alloc_value_type"))
  .AddTypedef(type_3051, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::_Base"))
  .AddTypedef(type_3760, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::_Tp_alloc_type"))
  .AddTypedef(type_11052, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::_Alloc_traits"))
  .AddTypedef(type_4328, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::value_type"))
  .AddTypedef(type_17851, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::pointer"))
  .AddTypedef(type_19909, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::const_pointer"))
  .AddTypedef(type_19911, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::reference"))
  .AddTypedef(type_19913, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::const_reference"))
  .AddTypedef(type_10908, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::iterator"))
  .AddTypedef(type_10909, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::const_iterator"))
  .AddTypedef(type_3992, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::const_reverse_iterator"))
  .AddTypedef(type_3993, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::difference_type"))
  .AddTypedef(type_3760, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19922, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32600), Reflex::Literal("vector"), constructor_19923, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19913, type_32600), Reflex::Literal("vector"), constructor_19924, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20756), Reflex::Literal("vector"), constructor_19925, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19926, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x204, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooMsgService__StreamConfig__funcmem_bld);
}

//------Delayed data member builder for class vector<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > -------------------
void __std__vector_RooMsgService__StreamConfig__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > -------------------
void __std__vector_RooMsgService__StreamConfig__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20754, type_20756), Reflex::Literal("operator="), operator_19927, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19913), Reflex::Literal("assign"), method_19928, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10908), Reflex::Literal("begin"), method_19929, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10909), Reflex::Literal("begin"), method_19930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10908), Reflex::Literal("end"), method_19931, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10909), Reflex::Literal("end"), method_19932, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_19937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_19938, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_4328), Reflex::Literal("resize"), method_19939, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_19940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19941, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_19942, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19911, type_3405), Reflex::Literal("operator[]"), operator_19943, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19913, type_3405), Reflex::Literal("operator[]"), operator_19944, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19911, type_3405), Reflex::Literal("at"), method_19946, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19913, type_3405), Reflex::Literal("at"), method_19947, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19911), Reflex::Literal("front"), method_19948, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19913), Reflex::Literal("front"), method_19949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19911), Reflex::Literal("back"), method_19950, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19913), Reflex::Literal("back"), method_19951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17851), Reflex::Literal("data"), method_19952, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19909), Reflex::Literal("data"), method_19953, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19913), Reflex::Literal("push_back"), method_19954, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19955, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10908, type_10908, type_19913), Reflex::Literal("insert"), method_19956, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10908, type_3405, type_19913), Reflex::Literal("insert"), method_19957, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10908, type_10908), Reflex::Literal("erase"), method_19958, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10908, type_10908, type_10908), Reflex::Literal("erase"), method_19959, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_20754), Reflex::Literal("swap"), method_19960, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19961, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<TVirtualArray*,std::allocator<TVirtualArray*> > -------------------------------
static void constructor_19988( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>();
  else ::new(mem) ::std::vector<TVirtualArray*>();
}

static void constructor_19989( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(const ::std::allocator<TVirtualArray*>*)arg[0]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(const ::std::allocator<TVirtualArray*>*)arg[0]);
}

static void constructor_19990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0],
      *(::TVirtualArray* const*)arg[1]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0],
      *(::TVirtualArray* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0],
      *(::TVirtualArray* const*)arg[1],
      *(const ::std::allocator<TVirtualArray*>*)arg[2]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0],
      *(::TVirtualArray* const*)arg[1],
      *(const ::std::allocator<TVirtualArray*>*)arg[2]);
  }
}

static void constructor_19991( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(const ::std::vector<TVirtualArray*>*)arg[0]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(const ::std::vector<TVirtualArray*>*)arg[0]);
}

static void destructor_19992(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TVirtualArray*>*)o)->::std::vector<TVirtualArray*>::~vector)();
}
static  void operator_19993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->operator=)(*(const ::std::vector<TVirtualArray*>*)arg[0]);
  else   (((::std::vector<TVirtualArray*>*)o)->operator=)(*(const ::std::vector<TVirtualArray*>*)arg[0]);
}

static  void method_19994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::TVirtualArray* const*)arg[1]);
}

static  void method_19995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->begin)());
  else   (((::std::vector<TVirtualArray*>*)o)->begin)();
}

static  void method_19996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray* const*,std::vector<TVirtualArray*> >)((((const ::std::vector<TVirtualArray*>*)o)->begin)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->begin)();
}

static  void method_19997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->end)());
  else   (((::std::vector<TVirtualArray*>*)o)->end)();
}

static  void method_19998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray* const*,std::vector<TVirtualArray*> >)((((const ::std::vector<TVirtualArray*>*)o)->end)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->end)();
}

static  void method_20003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TVirtualArray*>*)o)->size)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->size)();
}

static  void method_20004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TVirtualArray*>*)o)->max_size)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->max_size)();
}

static  void method_20005( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TVirtualArray*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TVirtualArray*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::TVirtualArray*)arg[1]);
  }
}

static  void method_20006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TVirtualArray*>*)o)->capacity)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->capacity)();
}

static  void method_20007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TVirtualArray*>*)o)->empty)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->empty)();
}

static  void method_20008( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TVirtualArray*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TVirtualArray*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TVirtualArray*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20012( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TVirtualArray*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20013( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TVirtualArray*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TVirtualArray*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->front)();
  else   (((::std::vector<TVirtualArray*>*)o)->front)();
}

static  void method_20015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TVirtualArray*>*)o)->front)();
  else   (((const ::std::vector<TVirtualArray*>*)o)->front)();
}

static  void method_20016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->back)();
  else   (((::std::vector<TVirtualArray*>*)o)->back)();
}

static  void method_20017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TVirtualArray*>*)o)->back)();
  else   (((const ::std::vector<TVirtualArray*>*)o)->back)();
}

static  void method_20018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TVirtualArray*>*)o)->data)());
  else   (((::std::vector<TVirtualArray*>*)o)->data)();
}

static  void method_20019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TVirtualArray*>*)o)->data)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->data)();
}

static  void method_20020( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->push_back)(*(::TVirtualArray* const*)arg[0]);
}

static  void method_20021( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->pop_back)();
}

static  void method_20022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::TVirtualArray* const*)arg[1]));
  else   (((::std::vector<TVirtualArray*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::TVirtualArray* const*)arg[1]);
}

static  void method_20023( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::TVirtualArray* const*)arg[2]);
}

static  void method_20024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0]));
  else   (((::std::vector<TVirtualArray*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0]);
}

static  void method_20025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[1]));
  else   (((::std::vector<TVirtualArray*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[1]);
}

static  void method_20026( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->swap)(*(::std::vector<TVirtualArray*>*)arg[0]);
}

static  void method_20027( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->clear)();
}

static void method_newdel_3126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x206( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> >")), ::Reflex::BaseOffset< ::std::vector<TVirtualArray*>,::std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x207( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TVirtualArray*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TVirtualArray*> >::Generate();
}

//------Dictionary for class vector<TVirtualArray*,std::allocator<TVirtualArray*> > -------------------------------
void __std__vector_TVirtualArrayp__db_datamem(Reflex::Class*);
void __std__vector_TVirtualArrayp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TVirtualArrayp__datamem_bld(&__std__vector_TVirtualArrayp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TVirtualArrayp__funcmem_bld(&__std__vector_TVirtualArrayp__db_funcmem);
void __std__vector_TVirtualArrayp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TVirtualArray*>"), typeid(::std::vector<TVirtualArray*>), sizeof(::std::vector<TVirtualArray*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3053, ::Reflex::BaseOffset< ::std::vector<TVirtualArray*>, ::std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_19968, Reflex::Literal("std::vector<TVirtualArray*>::_Alloc_value_type"))
  .AddTypedef(type_3053, Reflex::Literal("std::vector<TVirtualArray*>::_Base"))
  .AddTypedef(type_3780, Reflex::Literal("std::vector<TVirtualArray*>::_Tp_alloc_type"))
  .AddTypedef(type_11054, Reflex::Literal("std::vector<TVirtualArray*>::_Alloc_traits"))
  .AddTypedef(type_19968, Reflex::Literal("std::vector<TVirtualArray*>::value_type"))
  .AddTypedef(type_17889, Reflex::Literal("std::vector<TVirtualArray*>::pointer"))
  .AddTypedef(type_19975, Reflex::Literal("std::vector<TVirtualArray*>::const_pointer"))
  .AddTypedef(type_19977, Reflex::Literal("std::vector<TVirtualArray*>::reference"))
  .AddTypedef(type_19979, Reflex::Literal("std::vector<TVirtualArray*>::const_reference"))
  .AddTypedef(type_10912, Reflex::Literal("std::vector<TVirtualArray*>::iterator"))
  .AddTypedef(type_10913, Reflex::Literal("std::vector<TVirtualArray*>::const_iterator"))
  .AddTypedef(type_4012, Reflex::Literal("std::vector<TVirtualArray*>::const_reverse_iterator"))
  .AddTypedef(type_4013, Reflex::Literal("std::vector<TVirtualArray*>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<TVirtualArray*>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<TVirtualArray*>::difference_type"))
  .AddTypedef(type_3780, Reflex::Literal("std::vector<TVirtualArray*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19988, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32626), Reflex::Literal("vector"), constructor_19989, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_19979, type_32626), Reflex::Literal("vector"), constructor_19990, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32736), Reflex::Literal("vector"), constructor_19991, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19992, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x206, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x207, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TVirtualArrayp__funcmem_bld);
}

//------Delayed data member builder for class vector<TVirtualArray*,std::allocator<TVirtualArray*> > -------------------
void __std__vector_TVirtualArrayp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TVirtualArray*,std::allocator<TVirtualArray*> > -------------------
void __std__vector_TVirtualArrayp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32737, type_32736), Reflex::Literal("operator="), operator_19993, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19979), Reflex::Literal("assign"), method_19994, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10912), Reflex::Literal("begin"), method_19995, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10913), Reflex::Literal("begin"), method_19996, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10912), Reflex::Literal("end"), method_19997, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10913), Reflex::Literal("end"), method_19998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_20003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_20004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_19968), Reflex::Literal("resize"), method_20005, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_20006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_20007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_20008, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19977, type_3405), Reflex::Literal("operator[]"), operator_20009, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19979, type_3405), Reflex::Literal("operator[]"), operator_20010, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19977, type_3405), Reflex::Literal("at"), method_20012, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19979, type_3405), Reflex::Literal("at"), method_20013, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19977), Reflex::Literal("front"), method_20014, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19979), Reflex::Literal("front"), method_20015, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19977), Reflex::Literal("back"), method_20016, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19979), Reflex::Literal("back"), method_20017, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17889), Reflex::Literal("data"), method_20018, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19975), Reflex::Literal("data"), method_20019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19979), Reflex::Literal("push_back"), method_20020, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_20021, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10912, type_10912, type_19979), Reflex::Literal("insert"), method_20022, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10912, type_3405, type_19979), Reflex::Literal("insert"), method_20023, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10912, type_10912), Reflex::Literal("erase"), method_20024, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10912, type_10912, type_10912), Reflex::Literal("erase"), method_20025, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32737), Reflex::Literal("swap"), method_20026, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_20027, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > -------------------------------
static void constructor_20053( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>();
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>();
}

static void constructor_20054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(const ::std::allocator<ROOT::TSchemaHelper>*)arg[0]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(const ::std::allocator<ROOT::TSchemaHelper>*)arg[0]);
}

static void constructor_20055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0],
      *(const ::ROOT::TSchemaHelper*)arg[1]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0],
      *(const ::ROOT::TSchemaHelper*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0],
      *(const ::ROOT::TSchemaHelper*)arg[1],
      *(const ::std::allocator<ROOT::TSchemaHelper>*)arg[2]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0],
      *(const ::ROOT::TSchemaHelper*)arg[1],
      *(const ::std::allocator<ROOT::TSchemaHelper>*)arg[2]);
  }
}

static void constructor_20056( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(const ::std::vector<ROOT::TSchemaHelper>*)arg[0]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(const ::std::vector<ROOT::TSchemaHelper>*)arg[0]);
}

static void destructor_20057(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<ROOT::TSchemaHelper>*)o)->::std::vector<ROOT::TSchemaHelper>::~vector)();
}
static  void operator_20058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->operator=)(*(const ::std::vector<ROOT::TSchemaHelper>*)arg[0]);
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->operator=)(*(const ::std::vector<ROOT::TSchemaHelper>*)arg[0]);
}

static  void method_20059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::ROOT::TSchemaHelper*)arg[1]);
}

static  void method_20060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->begin)());
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->begin)();
}

static  void method_20061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->begin)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->begin)();
}

static  void method_20062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->end)());
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->end)();
}

static  void method_20063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->end)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->end)();
}

static  void method_20068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->size)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->size)();
}

static  void method_20069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->max_size)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->max_size)();
}

static  void method_20070( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<ROOT::TSchemaHelper>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<ROOT::TSchemaHelper>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::ROOT::TSchemaHelper*)arg[1]);
  }
}

static  void method_20071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->capacity)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->capacity)();
}

static  void method_20072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->empty)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->empty)();
}

static  void method_20073( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ROOT::TSchemaHelper>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ROOT::TSchemaHelper>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->front)();
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->front)();
}

static  void method_20080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ROOT::TSchemaHelper>*)o)->front)();
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->front)();
}

static  void method_20081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->back)();
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->back)();
}

static  void method_20082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ROOT::TSchemaHelper>*)o)->back)();
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->back)();
}

static  void method_20083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<ROOT::TSchemaHelper>*)o)->data)());
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->data)();
}

static  void method_20084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<ROOT::TSchemaHelper>*)o)->data)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->data)();
}

static  void method_20085( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->push_back)(*(const ::ROOT::TSchemaHelper*)arg[0]);
}

static  void method_20086( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->pop_back)();
}

static  void method_20087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(const ::ROOT::TSchemaHelper*)arg[1]));
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(const ::ROOT::TSchemaHelper*)arg[1]);
}

static  void method_20088( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::ROOT::TSchemaHelper*)arg[2]);
}

static  void method_20089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0]));
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0]);
}

static  void method_20090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[1]));
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[1]);
}

static  void method_20091( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->swap)(*(::std::vector<ROOT::TSchemaHelper>*)arg[0]);
}

static  void method_20092( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->clear)();
}

static void method_newdel_3127( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x209( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> >")), ::Reflex::BaseOffset< ::std::vector<ROOT::TSchemaHelper>,::std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x210( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<ROOT::TSchemaHelper> >::Generate();
  else ::Reflex::Proxy< ::std::vector<ROOT::TSchemaHelper> >::Generate();
}

//------Dictionary for class vector<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > -------------------------------
void __std__vector_ROOT__TSchemaHelper__db_datamem(Reflex::Class*);
void __std__vector_ROOT__TSchemaHelper__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_ROOT__TSchemaHelper__datamem_bld(&__std__vector_ROOT__TSchemaHelper__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_ROOT__TSchemaHelper__funcmem_bld(&__std__vector_ROOT__TSchemaHelper__db_funcmem);
void __std__vector_ROOT__TSchemaHelper__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<ROOT::TSchemaHelper>"), typeid(::std::vector<ROOT::TSchemaHelper>), sizeof(::std::vector<ROOT::TSchemaHelper>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3054, ::Reflex::BaseOffset< ::std::vector<ROOT::TSchemaHelper>, ::std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13472, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::_Alloc_value_type"))
  .AddTypedef(type_3054, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::_Base"))
  .AddTypedef(type_3781, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::_Tp_alloc_type"))
  .AddTypedef(type_11055, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::_Alloc_traits"))
  .AddTypedef(type_13472, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::value_type"))
  .AddTypedef(type_17908, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::pointer"))
  .AddTypedef(type_20040, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::const_pointer"))
  .AddTypedef(type_20042, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::reference"))
  .AddTypedef(type_20044, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::const_reference"))
  .AddTypedef(type_10914, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::iterator"))
  .AddTypedef(type_10915, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::const_iterator"))
  .AddTypedef(type_4014, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::const_reverse_iterator"))
  .AddTypedef(type_4015, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::reverse_iterator"))
  .AddTypedef(type_3405, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::size_type"))
  .AddTypedef(type_3258, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::difference_type"))
  .AddTypedef(type_3781, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20053, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32639), Reflex::Literal("vector"), constructor_20054, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3405, type_20044, type_32639), Reflex::Literal("vector"), constructor_20055, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32739), Reflex::Literal("vector"), constructor_20056, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20057, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3127, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x210, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_ROOT__TSchemaHelper__funcmem_bld);
}

//------Delayed data member builder for class vector<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > -------------------
void __std__vector_ROOT__TSchemaHelper__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > -------------------
void __std__vector_ROOT__TSchemaHelper__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32740, type_32739), Reflex::Literal("operator="), operator_20058, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_20044), Reflex::Literal("assign"), method_20059, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10914), Reflex::Literal("begin"), method_20060, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10915), Reflex::Literal("begin"), method_20061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10914), Reflex::Literal("end"), method_20062, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10915), Reflex::Literal("end"), method_20063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("size"), method_20068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("max_size"), method_20069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405, type_13472), Reflex::Literal("resize"), method_20070, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3405), Reflex::Literal("capacity"), method_20071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_20072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3405), Reflex::Literal("reserve"), method_20073, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20042, type_3405), Reflex::Literal("operator[]"), operator_20074, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20044, type_3405), Reflex::Literal("operator[]"), operator_20075, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20042, type_3405), Reflex::Literal("at"), method_20077, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20044, type_3405), Reflex::Literal("at"), method_20078, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20042), Reflex::Literal("front"), method_20079, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20044), Reflex::Literal("front"), method_20080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20042), Reflex::Literal("back"), method_20081, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20044), Reflex::Literal("back"), method_20082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17908), Reflex::Literal("data"), method_20083, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20040), Reflex::Literal("data"), method_20084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_20044), Reflex::Literal("push_back"), method_20085, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_20086, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10914, type_10914, type_20044), Reflex::Literal("insert"), method_20087, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10914, type_3405, type_20044), Reflex::Literal("insert"), method_20088, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10914, type_10914), Reflex::Literal("erase"), method_20089, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10914, type_10914, type_10914), Reflex::Literal("erase"), method_20090, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32740), Reflex::Literal("swap"), method_20091, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_20092, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooAbsData*> -------------------------------
static void destructor_22954(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,RooAbsData*>*)o)->::std::pair<std::basic_string<char>,RooAbsData*>::~pair)();
}
static  void operator_22955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,RooAbsData*>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,RooAbsData*>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,RooAbsData*>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,RooAbsData*>*)arg[0]);
}

static void constructor_22956( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>(*(const ::std::pair<std::basic_string<char>,RooAbsData*>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>(*(const ::std::pair<std::basic_string<char>,RooAbsData*>*)arg[0]);
}

static void constructor_22957( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>();
  else ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>();
}

static void constructor_22958( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>(*(const ::std::basic_string<char>*)arg[0],
      *(::RooAbsData* const*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>(*(const ::std::basic_string<char>*)arg[0],
      *(::RooAbsData* const*)arg[1]);
}

static void method_newdel_3488( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooAbsData*> -------------------------------
void __std__pair_std__basic_string_char__RooAbsDatap__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__RooAbsDatap__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__RooAbsDatap__datamem_bld(&__std__pair_std__basic_string_char__RooAbsDatap__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__RooAbsDatap__funcmem_bld(&__std__pair_std__basic_string_char__RooAbsDatap__db_funcmem);
void __std__pair_std__basic_string_char__RooAbsDatap__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,RooAbsData*>"), typeid(::std::pair<std::basic_string<char>,RooAbsData*>), sizeof(::std::pair<std::basic_string<char>,RooAbsData*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_3149, Reflex::Literal("std::pair<std::basic_string<char>,RooAbsData*>::first_type"))
  .AddTypedef(type_22409, Reflex::Literal("std::pair<std::basic_string<char>,RooAbsData*>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_22954, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33171, type_33172), Reflex::Literal("operator="), operator_22955, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33172), Reflex::Literal("pair"), constructor_22956, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_22957, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17092, type_33109), Reflex::Literal("pair"), constructor_22958, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3488, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__RooAbsDatap__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooAbsData*> -------------------
void __std__pair_std__basic_string_char__RooAbsDatap__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3149, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__RooAbsDatap_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_22409, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__RooAbsDatap_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooAbsData*> -------------------
void __std__pair_std__basic_string_char__RooAbsDatap__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BoundaryConditions -------------------------------
static void destructor_28329(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineKnot::BoundaryConditions*)o)->::RooCubicSplineKnot::BoundaryConditions::~BoundaryConditions)();
}
static  void operator_28330( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::BoundaryConditions*)o)->operator=)(*(const ::RooCubicSplineKnot::BoundaryConditions*)arg[0]);
  else   (((::RooCubicSplineKnot::BoundaryConditions*)o)->operator=)(*(const ::RooCubicSplineKnot::BoundaryConditions*)arg[0]);
}

static void constructor_28331( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(const ::RooCubicSplineKnot::BoundaryConditions*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(const ::RooCubicSplineKnot::BoundaryConditions*)arg[0]);
}

static void constructor_28332( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions();
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
}

static void constructor_x212( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions();
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions();
}

static void method_newdel_7158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BoundaryConditions -------------------------------
void __RooCubicSplineKnot__BoundaryConditions_db_datamem(Reflex::Class*);
void __RooCubicSplineKnot__BoundaryConditions_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__BoundaryConditions_datamem_bld(&__RooCubicSplineKnot__BoundaryConditions_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__BoundaryConditions_funcmem_bld(&__RooCubicSplineKnot__BoundaryConditions_db_funcmem);
void __RooCubicSplineKnot__BoundaryConditions_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineKnot::BoundaryConditions"), typeid(::RooCubicSplineKnot::BoundaryConditions), sizeof(::RooCubicSplineKnot::BoundaryConditions), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BoundaryConditions"), destructor_28329, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33861, type_33862), Reflex::Literal("operator="), operator_28330, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33862), Reflex::Literal("BoundaryConditions"), constructor_28331, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_667, type_667, type_694, type_694), Reflex::Literal("BoundaryConditions"), constructor_28332, 0, "leftSecondDerivative=true;rightSecondDerivative=true;valueLeft=0;valueRight=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BoundaryConditions"), constructor_x212, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineKnot__BoundaryConditions_datamem_bld);
}

//------Delayed data member builder for class BoundaryConditions -------------------
void __RooCubicSplineKnot__BoundaryConditions_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_33860, Reflex::Literal("secondDerivative"), OffsetOf(__shadow__::__RooCubicSplineKnot__BoundaryConditions, secondDerivative), ::Reflex::PUBLIC)
  .AddDataMember(type_33775, Reflex::Literal("value"), OffsetOf(__shadow__::__RooCubicSplineKnot__BoundaryConditions, value), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BoundaryConditions -------------------
void __RooCubicSplineKnot__BoundaryConditions_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class S_edge -------------------------------
static void destructor_28354(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineKnot::S_edge*)o)->::RooCubicSplineKnot::S_edge::~S_edge)();
}
static  void operator_28355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_edge*)o)->operator=)(*(const ::RooCubicSplineKnot::S_edge*)arg[0]);
  else   (((::RooCubicSplineKnot::S_edge*)o)->operator=)(*(const ::RooCubicSplineKnot::S_edge*)arg[0]);
}

static void constructor_28356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_edge(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot::S_edge(*(double*)arg[0],
      *(double*)arg[1]);
}

static void constructor_28357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_edge(*(const ::RooCubicSplineKnot::S_edge*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot::S_edge(*(const ::RooCubicSplineKnot::S_edge*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_edge(*(const ::RooCubicSplineKnot::S_edge*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot::S_edge(*(const ::RooCubicSplineKnot::S_edge*)arg[0],
      *(double*)arg[1]);
  }
}

static  void operator_28358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot::S_edge*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::RooCubicSplineKnot::S_edge*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]);
}

//------Dictionary for class S_edge -------------------------------
void __RooCubicSplineKnot__S_edge_db_datamem(Reflex::Class*);
void __RooCubicSplineKnot__S_edge_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__S_edge_datamem_bld(&__RooCubicSplineKnot__S_edge_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__S_edge_funcmem_bld(&__RooCubicSplineKnot__S_edge_db_funcmem);
void __RooCubicSplineKnot__S_edge_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineKnot::S_edge"), typeid(::RooCubicSplineKnot::S_edge), sizeof(::RooCubicSplineKnot::S_edge), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~S_edge"), destructor_28354, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33863, type_33864), Reflex::Literal("operator="), operator_28355, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_694, type_694), Reflex::Literal("S_edge"), constructor_28356, 0, "a;b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33864, type_694), Reflex::Literal("S_edge"), constructor_28357, 0, "other;offset=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineKnot__S_edge_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCubicSplineKnot__S_edge_funcmem_bld);
}

//------Delayed data member builder for class S_edge -------------------
void __RooCubicSplineKnot__S_edge_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_694, Reflex::Literal("alpha"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_edge, alpha), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("beta"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_edge, beta), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class S_edge -------------------
void __RooCubicSplineKnot__S_edge_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_141, type_141), Reflex::Literal("operator()"), operator_28358, 0, "j;k", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
static void function_5387( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 29 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainSignal(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(double*)arg[15],
      *(double*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::TString*)arg[22],
      *(::TString*)arg[23],
      *(::TString*)arg[24],
      *(::TString*)arg[25],
      *(::Bool_t*)arg[26],
      *(::Bool_t*)arg[27],
      (::RooWorkspace*)arg[28]);
    else MassFitUtils::ObtainSignal(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(double*)arg[15],
      *(double*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::TString*)arg[22],
      *(::TString*)arg[23],
      *(::TString*)arg[24],
      *(::TString*)arg[25],
      *(::Bool_t*)arg[26],
      *(::Bool_t*)arg[27],
      (::RooWorkspace*)arg[28]);
  }
  else if ( arg.size() == 30 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainSignal(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(double*)arg[15],
      *(double*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::TString*)arg[22],
      *(::TString*)arg[23],
      *(::TString*)arg[24],
      *(::TString*)arg[25],
      *(::Bool_t*)arg[26],
      *(::Bool_t*)arg[27],
      (::RooWorkspace*)arg[28],
      *(bool*)arg[29]);
    else MassFitUtils::ObtainSignal(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(double*)arg[15],
      *(double*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::TString*)arg[22],
      *(::TString*)arg[23],
      *(::TString*)arg[24],
      *(::TString*)arg[25],
      *(::Bool_t*)arg[26],
      *(::Bool_t*)arg[27],
      (::RooWorkspace*)arg[28],
      *(bool*)arg[29]);
  }
}
static void function_5388( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainLbLcPi(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(::TString*)arg[9],
    *(::TString*)arg[10],
    *(::TString*)arg[11],
    (::RooWorkspace*)arg[12],
    *(bool*)arg[13]);
  else MassFitUtils::ObtainLbLcPi(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(::TString*)arg[9],
    *(::TString*)arg[10],
    *(::TString*)arg[11],
    (::RooWorkspace*)arg[12],
    *(bool*)arg[13]);
}
static void function_5389( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 15 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14]);
    else MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14]);
  }
  else if ( arg.size() == 16 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14],
      *(bool*)arg[15]);
    else MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14],
      *(bool*)arg[15]);
  }
  else if ( arg.size() == 17 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14],
      *(bool*)arg[15],
      *(bool*)arg[16]);
    else MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14],
      *(bool*)arg[15],
      *(bool*)arg[16]);
  }
}
static void function_5390( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainBDPi(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(::TString*)arg[11],
    *(::TString*)arg[12],
    *(::TString*)arg[13],
    *(::Bool_t*)arg[14],
    *(::TString*)arg[15]);
  else MassFitUtils::ObtainBDPi(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(::TString*)arg[11],
    *(::TString*)arg[12],
    *(::TString*)arg[13],
    *(::Bool_t*)arg[14],
    *(::TString*)arg[15]);
}
static void function_5391( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 24 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainData(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::Bool_t*)arg[22],
      (::RooWorkspace*)arg[23]);
    else MassFitUtils::ObtainData(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::Bool_t*)arg[22],
      (::RooWorkspace*)arg[23]);
  }
  else if ( arg.size() == 25 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainData(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::Bool_t*)arg[22],
      (::RooWorkspace*)arg[23],
      *(bool*)arg[24]);
    else MassFitUtils::ObtainData(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::Bool_t*)arg[22],
      (::RooWorkspace*)arg[23],
      *(bool*)arg[24]);
  }
}
static void function_5392( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 21 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainMissForBsDsK(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20]);
    else MassFitUtils::ObtainMissForBsDsK(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20]);
  }
  else if ( arg.size() == 22 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainMissForBsDsK(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
    else MassFitUtils::ObtainMissForBsDsK(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
  }
}
static void function_5393( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 21 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainMissForBsDsPi(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20]);
    else MassFitUtils::ObtainMissForBsDsPi(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20]);
  }
  else if ( arg.size() == 22 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainMissForBsDsPi(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
    else MassFitUtils::ObtainMissForBsDsPi(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
  }
}
static void function_5394( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)MassFitUtils::CreatePdfSpecBackground(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    (::RooWorkspace*)arg[10],
    *(::Bool_t*)arg[11],
    *(bool*)arg[12]);
  else MassFitUtils::CreatePdfSpecBackground(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    (::RooWorkspace*)arg[10],
    *(::Bool_t*)arg[11],
    *(bool*)arg[12]);
}
static void function_5395( void*, void*, const std::vector<void*>& arg, void*)
{
  MassFitUtils::ExpectedYield(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(::TString*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(::TString*)arg[15],
    *(::TString*)arg[16],
    *(::TString*)arg[17],
    *(::TString*)arg[18]);
}
static void function_5396( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 21 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainSpecBack(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      (::RooWorkspace*)arg[18],
      *(::Bool_t*)arg[19],
      *(::Bool_t*)arg[20]);
    else MassFitUtils::ObtainSpecBack(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      (::RooWorkspace*)arg[18],
      *(::Bool_t*)arg[19],
      *(::Bool_t*)arg[20]);
  }
  else if ( arg.size() == 22 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainSpecBack(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      (::RooWorkspace*)arg[18],
      *(::Bool_t*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
    else MassFitUtils::ObtainSpecBack(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      (::RooWorkspace*)arg[18],
      *(::Bool_t*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
  }
}
static void function_6759( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3],
      *(double*)arg[4]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3],
      *(double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
  }
}
static void function_6760( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(bool*)arg[9]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(bool*)arg[9]);
  }
}
static void function_6761( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 8 ) {
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(bool*)arg[8]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(bool*)arg[8]);
  }
}
static void function_6762( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(double*)arg[5]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6]);
  }
}
static void function_7997( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::build_Bs2DsK_BKG_MDFitter(*(::RooAbsReal*)arg[0],
    *(::RooAbsReal*)arg[1],
    (::RooWorkspace*)arg[2],
    (::RooAddPdf*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    *(::RooRealVar*)arg[10],
    *(::RooRealVar*)arg[11],
    *(::RooRealVar*)arg[12],
    *(::RooRealVar*)arg[13],
    *(::RooRealVar*)arg[14],
    *(::RooRealVar*)arg[15],
    (::RooAbsPdf*)arg[16],
    *(::RooRealVar*)arg[17],
    *(::RooRealVar*)arg[18],
    *(::RooRealVar*)arg[19],
    *(::TString*)arg[20],
    *(::RooRealVar*)arg[21],
    *(bool*)arg[22]);
  else Bs2Dsh2011TDAnaModels::build_Bs2DsK_BKG_MDFitter(*(::RooAbsReal*)arg[0],
    *(::RooAbsReal*)arg[1],
    (::RooWorkspace*)arg[2],
    (::RooAddPdf*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    *(::RooRealVar*)arg[10],
    *(::RooRealVar*)arg[11],
    *(::RooRealVar*)arg[12],
    *(::RooRealVar*)arg[13],
    *(::RooRealVar*)arg[14],
    *(::RooRealVar*)arg[15],
    (::RooAbsPdf*)arg[16],
    *(::RooRealVar*)arg[17],
    *(::RooRealVar*)arg[18],
    *(::RooRealVar*)arg[19],
    *(::TString*)arg[20],
    *(::RooRealVar*)arg[21],
    *(bool*)arg[22]);
}
static void function_7998( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      *(bool*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_7999( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBdDsX(*(::RooAbsReal*)arg[0],
      *(::RooFormulaVar*)arg[1],
      *(::RooFormulaVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooFormulaVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10]);
    else Bs2Dsh2011TDAnaModels::buildBdDsX(*(::RooAbsReal*)arg[0],
      *(::RooFormulaVar*)arg[1],
      *(::RooFormulaVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooFormulaVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBdDsX(*(::RooAbsReal*)arg[0],
      *(::RooFormulaVar*)arg[1],
      *(::RooFormulaVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooFormulaVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10],
      *(bool*)arg[11]);
    else Bs2Dsh2011TDAnaModels::buildBdDsX(*(::RooAbsReal*)arg[0],
      *(::RooFormulaVar*)arg[1],
      *(::RooFormulaVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooFormulaVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10],
      *(bool*)arg[11]);
  }
}
static void function_8000( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 19 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBsDsK_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      (::RooAddPdf*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(bool*)arg[18]);
    else Bs2Dsh2011TDAnaModels::buildBsDsK_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      (::RooAddPdf*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(bool*)arg[18]);
  }
  else if ( arg.size() == 20 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBsDsK_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      (::RooAddPdf*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(bool*)arg[18],
      *(bool*)arg[19]);
    else Bs2Dsh2011TDAnaModels::buildBsDsK_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      (::RooAddPdf*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(bool*)arg[18],
      *(bool*)arg[19]);
  }
}
static void function_8001( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      (::RooAbsPdf*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      (::RooAbsPdf*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      (::RooAbsPdf*)arg[5],
      *(bool*)arg[6]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      (::RooAbsPdf*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_8002( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_8003( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBPDF_sim(*(::RooAbsReal*)arg[0],
    *(::RooRealVar*)arg[1],
    *(::RooRealVar*)arg[2],
    *(::RooRealVar*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    (const char*)arg[10],
    (const char*)arg[11],
    *(bool*)arg[12]);
  else Bs2Dsh2011TDAnaModels::buildDoubleCBPDF_sim(*(::RooAbsReal*)arg[0],
    *(::RooRealVar*)arg[1],
    *(::RooRealVar*)arg[2],
    *(::RooRealVar*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    (const char*)arg[10],
    (const char*)arg[11],
    *(bool*)arg[12]);
}
static void function_8004( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooFormulaVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8]);
    else Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooFormulaVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooFormulaVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8],
      *(bool*)arg[9]);
    else Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooFormulaVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8],
      *(bool*)arg[9]);
  }
}
static void function_8005( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8]);
    else Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8],
      *(bool*)arg[9]);
    else Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8],
      *(bool*)arg[9]);
  }
}
static void function_8006( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_8007( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)(Bs2Dsh2011TDAnaModels::CheckPDF((::RooAbsPdf*)arg[0]));
    else Bs2Dsh2011TDAnaModels::CheckPDF((::RooAbsPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)(Bs2Dsh2011TDAnaModels::CheckPDF((::RooAbsPdf*)arg[0],
      *(bool*)arg[1]));
    else Bs2Dsh2011TDAnaModels::CheckPDF((::RooAbsPdf*)arg[0],
      *(bool*)arg[1]);
  }
}
static void function_8008( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 20 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBsDsPi_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      (::RooAbsPdf*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::RooRealVar*)arg[16],
      *(::TString*)arg[17],
      *(::RooRealVar*)arg[18],
      *(bool*)arg[19]);
    else Bs2Dsh2011TDAnaModels::buildBsDsPi_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      (::RooAbsPdf*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::RooRealVar*)arg[16],
      *(::TString*)arg[17],
      *(::RooRealVar*)arg[18],
      *(bool*)arg[19]);
  }
  else if ( arg.size() == 21 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBsDsPi_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      (::RooAbsPdf*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::RooRealVar*)arg[16],
      *(::TString*)arg[17],
      *(::RooRealVar*)arg[18],
      *(bool*)arg[19],
      *(bool*)arg[20]);
    else Bs2Dsh2011TDAnaModels::buildBsDsPi_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      (::RooAbsPdf*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::RooRealVar*)arg[16],
      *(::TString*)arg[17],
      *(::RooRealVar*)arg[18],
      *(bool*)arg[19],
      *(bool*)arg[20]);
  }
}
static void function_8009( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3]);
    else Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_8010( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainComboBs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::TString*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainComboBs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::TString*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainComboBs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainComboBs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_8011( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::build_Bs2DsPi_BKG_MDFitter(*(::RooAbsReal*)arg[0],
    *(::RooAbsReal*)arg[1],
    (::RooWorkspace*)arg[2],
    *(::RooRealVar*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    (::RooAbsPdf*)arg[10],
    *(::RooRealVar*)arg[11],
    *(::RooRealVar*)arg[12],
    *(::RooRealVar*)arg[13],
    *(::RooRealVar*)arg[14],
    (::RooAbsPdf*)arg[15],
    *(::RooRealVar*)arg[16],
    *(::RooRealVar*)arg[17],
    *(::RooRealVar*)arg[18],
    *(::RooRealVar*)arg[19],
    *(::RooRealVar*)arg[20],
    *(::RooRealVar*)arg[21],
    *(::TString*)arg[22],
    *(::RooRealVar*)arg[23],
    *(bool*)arg[24]);
  else Bs2Dsh2011TDAnaModels::build_Bs2DsPi_BKG_MDFitter(*(::RooAbsReal*)arg[0],
    *(::RooAbsReal*)arg[1],
    (::RooWorkspace*)arg[2],
    *(::RooRealVar*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    (::RooAbsPdf*)arg[10],
    *(::RooRealVar*)arg[11],
    *(::RooRealVar*)arg[12],
    *(::RooRealVar*)arg[13],
    *(::RooRealVar*)arg[14],
    (::RooAbsPdf*)arg[15],
    *(::RooRealVar*)arg[16],
    *(::RooRealVar*)arg[17],
    *(::RooRealVar*)arg[18],
    *(::RooRealVar*)arg[19],
    *(::RooRealVar*)arg[20],
    *(::RooRealVar*)arg[21],
    *(::TString*)arg[22],
    *(::RooRealVar*)arg[23],
    *(bool*)arg[24]);
}
static void function_8012( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)(Bs2Dsh2011TDAnaModels::CheckVar((::RooRealVar*)arg[0]));
    else Bs2Dsh2011TDAnaModels::CheckVar((::RooRealVar*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)(Bs2Dsh2011TDAnaModels::CheckVar((::RooRealVar*)arg[0],
      *(bool*)arg[1]));
    else Bs2Dsh2011TDAnaModels::CheckVar((::RooRealVar*)arg[0],
      *(bool*)arg[1]);
  }
}
static void function_8013( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_8014( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainMassShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2],
      *(::RooRealVar*)arg[3]);
    else Bs2Dsh2011TDAnaModels::ObtainMassShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2],
      *(::RooRealVar*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainMassShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainMassShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_8015( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 12 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooRealVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
    else Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooRealVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooRealVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
    else Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooRealVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_8016( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 12 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
    else Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
    else Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_8017( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainComboDs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      (::RooAbsPdf*)arg[3],
      *(::TString*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainComboDs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      (::RooAbsPdf*)arg[3],
      *(::TString*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainComboDs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      (::RooAbsPdf*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainComboDs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      (::RooAbsPdf*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_8018( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_9466( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsKK((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsKK((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9467( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsKP((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsKP((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9468( void*, void*, const std::vector<void*>& arg, void*)
{
  WeightingUtils::PlotWeightingSample(*(::TString*)arg[0],
    (::RooDataSet*)arg[1],
    (::RooDataSet*)arg[2],
    (::RooRealVar*)arg[3],
    (::RooRealVar*)arg[4],
    (::RooRealVar*)arg[5],
    (::RooRealVar*)arg[6],
    *(::Int_t*)arg[7],
    *(::Int_t*)arg[8],
    *(::Int_t*)arg[9],
    *(::Int_t*)arg[10],
    *(::TString*)arg[11],
    *(::TString*)arg[12],
    *(::TString*)arg[13],
    *(::TString*)arg[14],
    *(::TString*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
}
static void function_9469( void*, void*, const std::vector<void*>& arg, void*)
{
  WeightingUtils::PlotWeightingSample(*(::TString*)arg[0],
    (::RooDataSet*)arg[1],
    (::RooDataSet*)arg[2],
    (::RooRealVar*)arg[3],
    (::RooRealVar*)arg[4],
    (::RooRealVar*)arg[5],
    *(::Int_t*)arg[6],
    *(::Int_t*)arg[7],
    *(::Int_t*)arg[8],
    *(::TString*)arg[9],
    *(::TString*)arg[10],
    *(::TString*)arg[11],
    *(::TString*)arg[12],
    *(::TString*)arg[13],
    (::RooWorkspace*)arg[14],
    *(bool*)arg[15]);
}
static void function_9470( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(WeightingUtils::CheckWeightLabel(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else WeightingUtils::CheckWeightLabel(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_9471( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::Get2DHist((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    (::RooRealVar*)arg[2],
    *(::Int_t*)arg[3],
    *(::Int_t*)arg[4],
    *(::TString*)arg[5],
    *(bool*)arg[6]);
  else WeightingUtils::Get2DHist((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    (::RooRealVar*)arg[2],
    *(::Int_t*)arg[3],
    *(::Int_t*)arg[4],
    *(::TString*)arg[5],
    *(bool*)arg[6]);
}
static void function_9472( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainHistRatio(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::Int_t*)arg[4],
    *(::Int_t*)arg[5],
    *(::Int_t*)arg[6],
    *(::TString*)arg[7],
    *(::TString*)arg[8],
    *(::TString*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(double*)arg[15],
    *(::TString*)arg[16],
    (::RooWorkspace*)arg[17],
    *(bool*)arg[18]);
  else WeightingUtils::ObtainHistRatio(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::Int_t*)arg[4],
    *(::Int_t*)arg[5],
    *(::Int_t*)arg[6],
    *(::TString*)arg[7],
    *(::TString*)arg[8],
    *(::TString*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(double*)arg[15],
    *(::TString*)arg[16],
    (::RooWorkspace*)arg[17],
    *(bool*)arg[18]);
}
static void function_9473( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainHistRatio(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::Int_t*)arg[4],
    *(::Int_t*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(::TString*)arg[12],
    (::RooWorkspace*)arg[13],
    *(bool*)arg[14]);
  else WeightingUtils::ObtainHistRatio(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::Int_t*)arg[4],
    *(::Int_t*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(::TString*)arg[12],
    (::RooWorkspace*)arg[13],
    *(bool*)arg[14]);
}
static void function_9474( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(::Int_t*)arg[14],
    *(::Int_t*)arg[15],
    *(::Int_t*)arg[16],
    *(::TString*)arg[17],
    (::RooWorkspace*)arg[18],
    *(bool*)arg[19]);
  else WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(::Int_t*)arg[14],
    *(::Int_t*)arg[15],
    *(::Int_t*)arg[16],
    *(::TString*)arg[17],
    (::RooWorkspace*)arg[18],
    *(bool*)arg[19]);
}
static void function_9475( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(::Int_t*)arg[11],
    *(::Int_t*)arg[12],
    *(::TString*)arg[13],
    (::RooWorkspace*)arg[14],
    *(bool*)arg[15]);
  else WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(::Int_t*)arg[11],
    *(::Int_t*)arg[12],
    *(::TString*)arg[13],
    (::RooWorkspace*)arg[14],
    *(bool*)arg[15]);
}
static void function_9476( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::GetDataCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    (::RooRealVar*)arg[4],
    *(bool*)arg[5]);
  else WeightingUtils::GetDataCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    (::RooRealVar*)arg[4],
    *(bool*)arg[5]);
}
static void function_9477( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::GetDataCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    *(bool*)arg[4]);
  else WeightingUtils::GetDataCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    *(bool*)arg[4]);
}
static void function_9478( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsPiK((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsPiK((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9479( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsPiPi((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsPiPi((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9480( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(WeightingUtils::CheckTreeLabel(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(bool*)arg[2]));
  else WeightingUtils::CheckTreeLabel(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(bool*)arg[2]);
}
static void function_9481( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(WeightingUtils::CheckTreeLabel(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else WeightingUtils::CheckTreeLabel(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_9482( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsKPi((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsKPi((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9483( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainPIDShapeFromCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(double*)arg[15],
    *(::Int_t*)arg[16],
    *(::Int_t*)arg[17],
    *(::Int_t*)arg[18],
    *(::TString*)arg[19],
    (::RooWorkspace*)arg[20],
    *(bool*)arg[21]);
  else WeightingUtils::ObtainPIDShapeFromCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(double*)arg[15],
    *(::Int_t*)arg[16],
    *(::Int_t*)arg[17],
    *(::Int_t*)arg[18],
    *(::TString*)arg[19],
    (::RooWorkspace*)arg[20],
    *(bool*)arg[21]);
}
static void function_9484( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainPIDShapeFromCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(::Int_t*)arg[13],
    *(::Int_t*)arg[14],
    *(::TString*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
  else WeightingUtils::ObtainPIDShapeFromCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(::Int_t*)arg[13],
    *(::Int_t*)arg[14],
    *(::TString*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
}
static void function_9485( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::Get3DHist((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    (::TH3F*)arg[4],
    *(bool*)arg[5]);
  else WeightingUtils::Get3DHist((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    (::TH3F*)arg[4],
    *(bool*)arg[5]);
}
static void function_9486( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainHistRatioOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::Int_t*)arg[2],
    *(::Int_t*)arg[3],
    *(::Int_t*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(::TString*)arg[14],
    (::RooWorkspace*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
  else WeightingUtils::ObtainHistRatioOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::Int_t*)arg[2],
    *(::Int_t*)arg[3],
    *(::Int_t*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(::TString*)arg[14],
    (::RooWorkspace*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
}
static void function_9487( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainHistRatioOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::Int_t*)arg[2],
    *(::Int_t*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(::TString*)arg[10],
    (::RooWorkspace*)arg[11],
    (::RooWorkspace*)arg[12],
    *(bool*)arg[13]);
  else WeightingUtils::ObtainHistRatioOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::Int_t*)arg[2],
    *(::Int_t*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(::TString*)arg[10],
    (::RooWorkspace*)arg[11],
    (::RooWorkspace*)arg[12],
    *(bool*)arg[13]);
}
static void function_9987( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 10 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9]);
    else GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10]);
    else GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
    else GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
    else GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_9988( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10]);
    else GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11]);
    else GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11],
      (const char*)arg[12]);
    else GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11],
      (const char*)arg[12]);
  }
  else if ( arg.size() == 14 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11],
      (const char*)arg[12],
      *(bool*)arg[13]);
    else GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11],
      (const char*)arg[12],
      *(bool*)arg[13]);
  }
}
static void function_9989( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 10 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9]);
    else GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10]);
    else GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
    else GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
    else GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_9990( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4]);
    else GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5]);
    else GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5],
      (const char*)arg[6]);
    else GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5],
      (const char*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5],
      (const char*)arg[6],
      *(bool*)arg[7]);
    else GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5],
      (const char*)arg[6],
      *(bool*)arg[7]);
  }
}
static void function_9991( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3]);
    else GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4]);
    else GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
    else GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
    else GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_9992( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3]);
    else GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4]);
    else GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
    else GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
    else GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_9993( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8]);
    else GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9]);
    else GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9],
      (const char*)arg[10]);
    else GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9],
      (const char*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9],
      (const char*)arg[10],
      *(bool*)arg[11]);
    else GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9],
      (const char*)arg[10],
      *(bool*)arg[11]);
  }
}
static void function_9994( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_9995( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 12 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12]);
  }
  else if ( arg.size() == 14 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13]);
  }
  else if ( arg.size() == 15 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13],
      *(bool*)arg[14]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13],
      *(bool*)arg[14]);
  }
}
static void function_9996( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 12 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12]);
  }
  else if ( arg.size() == 14 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13]);
  }
  else if ( arg.size() == 15 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13],
      *(bool*)arg[14]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13],
      *(bool*)arg[14]);
  }
}
static void function_9997( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
    else GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3]);
    else GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4]);
    else GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4],
      *(bool*)arg[5]);
    else GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_12536( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 8 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2DshModels::buildBsBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7]);
    else Bs2DshModels::buildBsBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2DshModels::buildBsBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(bool*)arg[8]);
    else Bs2DshModels::buildBsBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(bool*)arg[8]);
  }
}
static void function_13934( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 7 ) {
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6]);
    else Bd2DhModels::buildBdBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(bool*)arg[7]);
    else Bd2DhModels::buildBdBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(bool*)arg[7]);
  }
}
static void function_13935( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 10 ) {
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundNoTagEPDFInTime(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9]);
    else Bd2DhModels::buildBdBackgroundNoTagEPDFInTime(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundNoTagEPDFInTime(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(bool*)arg[10]);
    else Bd2DhModels::buildBdBackgroundNoTagEPDFInTime(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(bool*)arg[10]);
  }
}
static void function_13936( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 6 ) {
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(const long*)arg[2],
      *(const long*)arg[3],
      *(const long*)arg[4],
      *(const long*)arg[5]);
    else Bd2DhModels::buildBdBackgroundPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(const long*)arg[2],
      *(const long*)arg[3],
      *(const long*)arg[4],
      *(const long*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(const long*)arg[2],
      *(const long*)arg[3],
      *(const long*)arg[4],
      *(const long*)arg[5],
      *(bool*)arg[6]);
    else Bd2DhModels::buildBdBackgroundPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(const long*)arg[2],
      *(const long*)arg[3],
      *(const long*)arg[4],
      *(const long*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_14386( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadPIDHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
    else GeneralUtils::ReadPIDHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadPIDHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
    else GeneralUtils::ReadPIDHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14387( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreateHistPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3]);
    else GeneralUtils::CreateHistPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreateHistPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3],
      *(bool*)arg[4]);
    else GeneralUtils::CreateHistPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14388( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::GetLabel(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::GetLabel(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14389( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (TString)(GeneralUtils::ReadOneMode(*(::TString*)arg[0]));
    else GeneralUtils::ReadOneMode(*(::TString*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (TString)(GeneralUtils::ReadOneMode(*(::TString*)arg[0],
      *(bool*)arg[1]));
    else GeneralUtils::ReadOneMode(*(::TString*)arg[0],
      *(bool*)arg[1]);
  }
}
static void function_14390( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    GeneralUtils::SaveDataSet((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    GeneralUtils::SaveDataSet((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14391( void*, void*, const std::vector<void*>& arg, void*)
{
  GeneralUtils::Save2DComparison((::TH2F*)arg[0],
    *(::TString*)arg[1],
    (::TH2F*)arg[2],
    *(::TString*)arg[3],
    (::TH2F*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6]);
}
static void function_14392( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::AddHist((::TH1F*)arg[0],
      *(::Double_t*)arg[1],
      (::TH1F*)arg[2],
      *(::Double_t*)arg[3]);
    else GeneralUtils::AddHist((::TH1F*)arg[0],
      *(::Double_t*)arg[1],
      (::TH1F*)arg[2],
      *(::Double_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::AddHist((::TH1F*)arg[0],
      *(::Double_t*)arg[1],
      (::TH1F*)arg[2],
      *(::Double_t*)arg[3],
      *(bool*)arg[4]);
    else GeneralUtils::AddHist((::TH1F*)arg[0],
      *(::Double_t*)arg[1],
      (::TH1F*)arg[2],
      *(::Double_t*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14393( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    GeneralUtils::SaveTemplateHist((::RooDataHist*)arg[0],
      (::RooHistPdf*)arg[1],
      (::RooRealVar*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    GeneralUtils::SaveTemplateHist((::RooDataHist*)arg[0],
      (::RooHistPdf*)arg[1],
      (::RooRealVar*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_14394( void*, void*, const std::vector<void*>& arg, void*)
{
  GeneralUtils::Save2DHist((::TH2F*)arg[0],
    *(::TString*)arg[1]);
}
static void function_14395( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    GeneralUtils::ReadOneName(*(::TString*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1],
      *(::TString*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    GeneralUtils::ReadOneName(*(::TString*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1],
      *(::TString*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14396( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::Read3DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
    else GeneralUtils::Read3DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::Read3DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
    else GeneralUtils::Read3DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14397( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreateBinnedPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3]);
    else GeneralUtils::CreateBinnedPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreateBinnedPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3],
      *(bool*)arg[4]);
    else GeneralUtils::CreateBinnedPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14398( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadTreeData(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(int*)arg[1]);
    else GeneralUtils::ReadTreeData(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadTreeData(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::ReadTreeData(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14399( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetObservable((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetObservable((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetObservable((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetObservable((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14400( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    GeneralUtils::SaveWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    GeneralUtils::SaveWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14401( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::LoadWorkspace(*(::TString*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::LoadWorkspace(*(::TString*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::LoadWorkspace(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::LoadWorkspace(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14402( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    GeneralUtils::SaveTemplate((::RooDataSet*)arg[0],
      (::RooKeysPdf*)arg[1],
      (::RooRealVar*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    GeneralUtils::SaveTemplate((::RooDataSet*)arg[0],
      (::RooKeysPdf*)arg[1],
      (::RooRealVar*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_14403( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetRooArgSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetRooArgSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetRooArgSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetRooArgSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14404( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadTreeMC((const char*)arg[0],
      (const char*)arg[1]);
    else GeneralUtils::ReadTreeMC((const char*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadTreeMC((const char*)arg[0],
      (const char*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::ReadTreeMC((const char*)arg[0],
      (const char*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14405( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreatePDFMC((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::Bool_t*)arg[4]);
    else GeneralUtils::CreatePDFMC((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreatePDFMC((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::Bool_t*)arg[4],
      *(bool*)arg[5]);
    else GeneralUtils::CreatePDFMC((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::Bool_t*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_14406( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetCategory((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetCategory((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetCategory((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetCategory((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14407( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckDMode(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckDMode(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14408( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckDMode(*(::std::string*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckDMode(*(::std::string*)arg[0],
    *(bool*)arg[1]);
}
static void function_14409( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::Read2DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
    else GeneralUtils::Read2DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::Read2DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
    else GeneralUtils::Read2DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14410( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckBDTGBin(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckBDTGBin(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14411( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetDataHist((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetDataHist((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetDataHist((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetDataHist((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14412( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckPolarity(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckPolarity(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14413( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckPolarity(*(::std::string*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckPolarity(*(::std::string*)arg[0],
    *(bool*)arg[1]);
}
static void function_14414( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetDataSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetDataSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetDataSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetDataSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14415( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckKKPiMode(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckKKPiMode(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14416( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckKKPiMode(*(::std::string*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckKKPiMode(*(::std::string*)arg[0],
    *(bool*)arg[1]);
}
static void function_14417( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    GeneralUtils::ReadMode(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    GeneralUtils::ReadMode(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    GeneralUtils::ReadMode(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14418( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::TreeCut((::TTree*)arg[0],
      *(::TCut*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3]);
    else GeneralUtils::TreeCut((::TTree*)arg[0],
      *(::TCut*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::TreeCut((::TTree*)arg[0],
      *(::TCut*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(bool*)arg[4]);
    else GeneralUtils::TreeCut((::TTree*)arg[0],
      *(::TCut*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14419( void*, void*, const std::vector<void*>& arg, void*)
{
  GeneralUtils::Save3DHist((::TH3F*)arg[0],
    *(::TString*)arg[1]);
}
static void function_14420( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    GeneralUtils::saveDataTemplateToFile((::RooAbsData*)arg[0],
      (::RooAbsPdf*)arg[1],
      (::RooRealVar*)arg[2],
      (const char*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    GeneralUtils::saveDataTemplateToFile((::RooAbsData*)arg[0],
      (::RooAbsPdf*)arg[1],
      (::RooRealVar*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    GeneralUtils::saveDataTemplateToFile((::RooAbsData*)arg[0],
      (::RooAbsPdf*)arg[1],
      (::RooRealVar*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    GeneralUtils::saveDataTemplateToFile((::RooAbsData*)arg[0],
      (::RooAbsPdf*)arg[1],
      (::RooRealVar*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_15178( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::CopyDataForToys((::TTree*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10]);
    else SFitUtils::CopyDataForToys((::TTree*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::CopyDataForToys((::TTree*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10],
      *(bool*)arg[11]);
    else SFitUtils::CopyDataForToys((::TTree*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10],
      *(bool*)arg[11]);
  }
}
static void function_15179( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights2(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10]);
    else SFitUtils::ReadDataFromSWeights2(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights2(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11]);
    else SFitUtils::ReadDataFromSWeights2(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11]);
  }
}
static void function_15180( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10]);
    else SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11]);
    else SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11],
      *(bool*)arg[12]);
    else SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_15181( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 17 ) {
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadLbLcPiFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(::TString*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      (::RooWorkspace*)arg[16]);
    else SFitUtils::ReadLbLcPiFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(::TString*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      (::RooWorkspace*)arg[16]);
  }
  else if ( arg.size() == 18 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadLbLcPiFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(::TString*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      (::RooWorkspace*)arg[16],
      *(bool*)arg[17]);
    else SFitUtils::ReadLbLcPiFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(::TString*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      (::RooWorkspace*)arg[16],
      *(bool*)arg[17]);
  }
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TagEfficiencyWeight_dict(); 
      __RooBinned1DQuinticBase_RooAbsReal__dict(); 
      __DecRateCoeff_dict(); 
      __IfThreeWayPdf_dict(); 
      __Inverse_dict(); 
      __RooEffConvGenContext_dict(); 
      __BdPTAcceptance_dict(); 
      __RooBinned2DBicubicBase_RooAbsPdf__dict(); 
      __RooBinned2DBicubicBase_RooAbsReal__dict(); 
      __IfThreeWayCatPdf_dict(); 
      __NonOscTaggingPdf_dict(); 
      __DTAcceptanceLHCbNote2007041_dict(); 
      __RooEffResModel_dict(); 
      __RooAbsEffResModel_dict(); 
      __IfThreeWayCat_dict(); 
      __RooCubicSplineKnot_dict(); 
      __RooBinnedPdf_dict(); 
      __MistagDistribution_dict(); 
      __SquaredSum_dict(); 
      __RooGenSmearIntegrandBinding_dict(); 
      __RooGaussEfficiencyModel_dict(); 
      __RooGeneralisedSmearingBase_RooAbsPdf__dict(); 
      __RooBinned1DQuinticBase_RooAbsPdf__dict(); 
      __RooEffHistProd_dict(); 
      __RooAbsGaussModelEfficiency_dict(); 
      __RooGeneralisedSmearingBase_RooAbsReal__dict(); 
      __TagEfficiencyWeightNoCat_dict(); 
      __FinalStateChargePdf_dict(); 
      __TaggingCat_dict(); 
      __RangeAcceptance_dict(); 
      __PowLawAcceptance_dict(); 
      __MistagCalibration_dict(); 
      __SharedArrayImp_double__dict(); 
      __SharedArrayImp_float__dict(); 
      __SharedArrayImp_unsignedslongslong__dict(); 
      __SharedArrayImp_unsignedslong__dict(); 
      __SharedArrayImp_unsignedsint__dict(); 
      __SharedArrayImp_unsignedsshort__dict(); 
      __SharedArrayImp_unsignedschar__dict(); 
      __SharedArrayImp_longslong__dict(); 
      __SharedArrayImp_long__dict(); 
      __SharedArrayImp_int__dict(); 
      __SharedArrayImp_short__dict(); 
      __SharedArrayImp_char__dict(); 
      __Dilution_dict(); 
      __FitMeTool_dict(); 
      __RooCubicSplineFun_dict(); 
      __CPObservable_dict(); 
      __RooComplementCoef_dict(); 
      __SharedArray_double__dict(); 
      __SharedArray_float__dict(); 
      __SharedArray_unsignedslongslong__dict(); 
      __SharedArray_unsignedslong__dict(); 
      __SharedArray_unsignedsint__dict(); 
      __SharedArray_unsignedsshort__dict(); 
      __SharedArray_unsignedschar__dict(); 
      __SharedArray_longslong__dict(); 
      __SharedArray_long__dict(); 
      __SharedArray_int__dict(); 
      __SharedArray_short__dict(); 
      __SharedArray_char__dict(); 
      __IfThreeWay_dict(); 
      __RooCruijff_dict(); 
      __CombBkgPTPdf_dict(); 
      __RooBinnedFun_dict(); 
      __std__vector_double__dict(); 
      __RooCubicSplineKnot__S_jk_dict(); 
      __std__vector_RooCubicSplineKnot__S_jk__dict(); 
      __std__vector_float__dict(); 
      __std__vector_unsignedslongslong__dict(); 
      __std__vector_unsignedslong__dict(); 
      __std__vector_unsignedsint__dict(); 
      __std__vector_unsignedsshort__dict(); 
      __std__vector_unsignedschar__dict(); 
      __std__vector_longslong__dict(); 
      __std__vector_long__dict(); 
      __std__vector_int__dict(); 
      __std__vector_short__dict(); 
      __std__vector_char__dict(); 
      __std__vector_RooFitResultp__dict(); 
      __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__dict(); 
      __std__vector_std__map_voidp_double_s__dict(); 
      __std__vector_std__vector_double_s__dict(); 
      __std__vector_std__vector_double_p__dict(); 
      __std__vector_RooNormSetCache__dict(); 
      __std__vector_std__pair_double_TString_s__dict(); 
      __std__vector_TString__dict(); 
      __std__vector_std__map_int_int_s__dict(); 
      __std__vector_constsRooAbsBinningp__dict(); 
      __std__vector_RooAbsRealLValuep__dict(); 
      __std__vector_bool__dict(); 
      __std__vector_RooArgSetp__dict(); 
      __std__vector_std__vector_int_s__dict(); 
      __std__vector_std__pair_std__basic_string_char__int_s__dict(); 
      __std__vector_RooAbsArgp__dict(); 
      __std__vector_RooAbsCacheElementp__dict(); 
      __std__vector_RooMsgService__StreamConfig__dict(); 
      __std__vector_TVirtualArrayp__dict(); 
      __std__vector_ROOT__TSchemaHelper__dict(); 
      __std__pair_std__basic_string_char__RooAbsDatap__dict(); 
      __RooCubicSplineKnot__BoundaryConditions_dict(); 
      __RooCubicSplineKnot__S_edge_dict(); 
      ::Reflex::Type t0 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_668, type_668, type_27832, type_667);      ::Reflex::FunctionBuilder(t0, Reflex::Literal("MassFitUtils::ObtainSignal"), function_5387, 0, Reflex::Literal("filesDir;sig;PIDcut2;Pcut_down2;Pcut_up2;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;time_down;time_up;PT_down;PT_up;nTr_down;nTr_up;mVar;mDVar;tVar;terrVar;tagVar;tagOmegaVar;idVar;mProbVar;mode;reweight;veto;work;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t1 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t1, Reflex::Literal("MassFitUtils::ObtainLbLcPi"), function_5388, 0, Reflex::Literal("filesDir;sig;PIDcut;Pcut_down;Pcut_up;PT_down;PT_up;nTr_down;nTr_up;mVar;mDVar;mode;workspace;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t2 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_141, type_141, type_141, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_27832, type_28007, type_667, type_667);      ::Reflex::FunctionBuilder(t2, Reflex::Literal("MassFitUtils::getSpecBkg4kfactor"), function_5389, 0, Reflex::Literal("filesDir;sig;sigtree;PIDcut;PIDmisscut;pPIDcut;Pcut_down;Pcut_up;BDTGCut;Dmass_down;Dmass_up;mVar;hypo;workspace;ffile;mass_win=true;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t3 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_6066, type_668, type_6066);      ::Reflex::FunctionBuilder(t3, Reflex::Literal("MassFitUtils::ObtainBDPi"), function_5390, 0, Reflex::Literal("filesDir;sigBs;PIDcut;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Bmass_down;Bmass_up;Dmass_down;Dmass_up;mVar;mProbVar;mode;MC;hypo"), ::Reflex::PUBLIC);
      ::Reflex::Type t4 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_668, type_27832, type_667);      ::Reflex::FunctionBuilder(t4, Reflex::Literal("MassFitUtils::ObtainData"), function_5391, 0, Reflex::Literal("fileDir;sig;PIDcut;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;time_down;time_up;mVar;mDVar;tVar;terrVar;tagVar;tagOmegaVar;idVar;mProbVar;mode;tagtool;workspace;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t5 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_6066, type_6066, type_27832, type_668, type_667);      ::Reflex::FunctionBuilder(t5, Reflex::Literal("MassFitUtils::ObtainMissForBsDsK"), function_5392, 0, Reflex::Literal("filesDir;sig;PIDmisscut;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;PT_down;PT_up;nTr_down;nTr_up;mVar;mDVar;mProbVar;mode;workspace;mistag;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t6 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_6066, type_6066, type_27832, type_668, type_667);      ::Reflex::FunctionBuilder(t6, Reflex::Literal("MassFitUtils::ObtainMissForBsDsPi"), function_5393, 0, Reflex::Literal("filesDir;sig;namehypo;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;PT_down;PT_up;nTr_down;nTr_up;mVar;mDVar;mProbVar;mode;workspace;mistag;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t7 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_694, type_694, type_694, type_694, type_27832, type_668, type_667);      ::Reflex::FunctionBuilder(t7, Reflex::Literal("MassFitUtils::CreatePdfSpecBackground"), function_5394, 0, Reflex::Literal("filesDirMU;sigMU;filesDirMD;sigMD;mVar;mDVar;Bmass_down;Bmass_up;Dmass_down;Dmass_up;workspace;mistag;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t8 = ::Reflex::FunctionTypeBuilder(type_1511, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_6066, type_6066);      ::Reflex::FunctionBuilder(t8, Reflex::Literal("MassFitUtils::ExpectedYield"), function_5395, 0, Reflex::Literal("filesDir;sigBs;sigBd;sigPID_lab4;PIDcut_lab4;sigPID_lab51;PIDcut_lab51;sigPID_lab52;PIDcut_lab52;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;mVar;mProbVar;mode;mode2"), ::Reflex::PUBLIC);
      ::Reflex::Type t9 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_141, type_141, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_6066, type_6066, type_27832, type_668, type_668, type_667);      ::Reflex::FunctionBuilder(t9, Reflex::Literal("MassFitUtils::ObtainSpecBack"), function_5396, 0, Reflex::Literal("filesDir;sig;sigtree;PIDcut;PIDmisscut;pPIDcut;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;mVar;mDVar;mProbVar;hypo;workspace;save;mistag;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t10 = ::Reflex::FunctionTypeBuilder(type_27809, type_4138, type_27803, type_4138, type_667, type_694, type_694);      ::Reflex::FunctionBuilder(t10, Reflex::Literal("PTResModels::getPTResolutionModel"), function_6759, 0, Reflex::Literal("modelName;time;prefix=\"Sig\";debug=false;scalingfactor=1.0e+0;biasonmean=0.0"), ::Reflex::PUBLIC);
      ::Reflex::Type t11 = ::Reflex::FunctionTypeBuilder(type_27809, type_27803, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_667);      ::Reflex::FunctionBuilder(t11, Reflex::Literal("PTResModels::tripleGausResolutionModel"), function_6760, 0, Reflex::Literal("time;scalingfactor;biasonmean;sigma1;sigma2;sigma3;frac1;frac2;frac3;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t12 = ::Reflex::FunctionTypeBuilder(type_27809, type_27803, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_667);      ::Reflex::FunctionBuilder(t12, Reflex::Literal("PTResModels::tripleGausResolutionModel"), function_6761, 0, Reflex::Literal("time;scalingfactor;biasonmean;sigma1;sigma2;sigma3;frac1;frac2;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t13 = ::Reflex::FunctionTypeBuilder(type_27809, type_27803, type_667, type_667, type_667, type_667, type_694, type_694);      ::Reflex::FunctionBuilder(t13, Reflex::Literal("PTResModels::tripleGausResolutionModel"), function_6762, 0, Reflex::Literal("time;fixparameters=true;fixfractions=true;extended=true;debug=false;scalingfactor=1.0e+0;biasonmean=0.0"), ::Reflex::PUBLIC);
      ::Reflex::Type t14 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27793, type_27832, type_28430, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_28050, type_27803, type_27803, type_27803, type_6066, type_27803, type_667);      ::Reflex::FunctionBuilder(t14, Reflex::Literal("Bs2Dsh2011TDAnaModels::build_Bs2DsK_BKG_MDFitter"), function_7997, 0, Reflex::Literal("mass;massDs;work;pdf_Bd2DsK;nCombBkgEvts;nBsLb2DsDsstPPiRhoEvts;nBs2DsDssKKstEvts;nBd2DKEvts;nLb2LcKEvts;g1_f1;g2_f1;g2_f2;g3_f1;g4_f1;g4_f2;g5_f1;pdf_SignalDs;cBVar;cDVar;fracDsComb;samplemode;lumRatio;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t15 = ::Reflex::FunctionTypeBuilder(type_28431, type_27832, type_6066, type_6066, type_27803, type_28050, type_667);      ::Reflex::FunctionBuilder(t15, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter"), function_7998, 0, Reflex::Literal("work;mode;pol;lumRatio;pdf_Ds=0l;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t16 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_28255, type_28255, type_694, type_694, type_28255, type_694, type_694, type_694, type_6066, type_6066, type_667);      ::Reflex::FunctionBuilder(t16, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildBdDsX"), function_7999, 0, Reflex::Literal("obs;meanVar;sigma1Var;alpha1;n1;sigma2Var;alpha2;n2;frac;samplemode;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t17 = ::Reflex::FunctionTypeBuilder(type_28050, type_27803, type_27832, type_28430, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_6066, type_6066, type_667, type_667);      ::Reflex::FunctionBuilder(t17, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildBsDsK_sim"), function_8000, 0, Reflex::Literal("mass;work;pdf;nCombBkgEvts;nBs2DsDsstPiRhoEvts;nBs2DsDssKKstEvts;nLb2DsDsstpEvts;nBd2DKEvts;nLb2LcKEvts;g1_f1;g1_f2;g1_f3;g2_f1;g2_f2;g2_f3;g3_f1;sample;mode;toys;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t18 = ::Reflex::FunctionTypeBuilder(type_28431, type_27832, type_6066, type_6066, type_27803, type_28050, type_28050, type_667);      ::Reflex::FunctionBuilder(t18, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter"), function_8001, 0, Reflex::Literal("work;mode;pol;lumRatio;pdf_Time;pdf_Ds=0l;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t19 = ::Reflex::FunctionTypeBuilder(type_28432, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t19, Reflex::Literal("Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace"), function_8002, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t20 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t20, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleCBPDF_sim"), function_8003, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;nEvents;prefix;bName;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t21 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27803, type_27803, type_27803, type_27803, type_28255, type_4138, type_4138, type_667, type_667);      ::Reflex::FunctionBuilder(t21, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim"), function_8004, 0, Reflex::Literal("obs;mean;sigma1;sigma2;frac;nEvents;prefix;bName;extendend;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t22 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27803, type_27803, type_27803, type_27803, type_27803, type_4138, type_4138, type_667, type_667);      ::Reflex::FunctionBuilder(t22, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim"), function_8005, 0, Reflex::Literal("obs;mean;sigma1;sigma2;frac;nEvents;prefix;bName;extendend;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t23 = ::Reflex::FunctionTypeBuilder(type_28433, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t23, Reflex::Literal("Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace"), function_8006, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t24 = ::Reflex::FunctionTypeBuilder(type_667, type_28050, type_667);      ::Reflex::FunctionBuilder(t24, Reflex::Literal("Bs2Dsh2011TDAnaModels::CheckPDF"), function_8007, 0, Reflex::Literal("pdf;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t25 = ::Reflex::FunctionTypeBuilder(type_28050, type_27803, type_27832, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_28050, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_6066, type_27803, type_667, type_667);      ::Reflex::FunctionBuilder(t25, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildBsDsPi_sim"), function_8008, 0, Reflex::Literal("mass;work;nCombBkgEvts;nBd2DPiEvts;nBs2DsDsstPiRhoEvts;g1_f1;g1_f2;nLb2LcPiEvts;nBdDsPi;pdf_BdDsPi;nBdDsstPi;nBd2DsRhoEvts;nBd2DstPiEvts;nBs2DsKEvts;cB1Var;cB2Var;fracComb;samplemode;lumRatio;toys;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t26 = ::Reflex::FunctionTypeBuilder(type_28050, type_27832, type_6066, type_6066, type_27803, type_667, type_667);      ::Reflex::FunctionBuilder(t26, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainPIDKShape"), function_8009, 0, Reflex::Literal("work;mode;pol;lumRatio;DsMode=false;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t27 = ::Reflex::FunctionTypeBuilder(type_28430, type_27793, type_27803, type_27803, type_27803, type_6066, type_667);      ::Reflex::FunctionBuilder(t27, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainComboBs"), function_8010, 0, Reflex::Literal("mass;cBVar;cBVar2;frac;Mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t28 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27793, type_27832, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_28050, type_27803, type_27803, type_27803, type_27803, type_28050, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_6066, type_27803, type_667);      ::Reflex::FunctionBuilder(t28, Reflex::Literal("Bs2Dsh2011TDAnaModels::build_Bs2DsPi_BKG_MDFitter"), function_8011, 0, Reflex::Literal("mass;massDs;work;nCombBkgEvts;nBd2DPiEvts;nBs2DsDsstPiRhoEvts;g1_f1;g1_f2;nLb2LcPiEvts;nBdDsPi;pdf_BdDsPi;nBdDsstPi;nBd2DRhoEvts;nBd2DstPiEvts;nBs2DsKEvts;pdf_SignalDs;cBVar;cB2Var;fracBsComb;cDVar;fracDsComb;fracPIDComb;samplemode;lumRatio;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t29 = ::Reflex::FunctionTypeBuilder(type_667, type_22942, type_667);      ::Reflex::FunctionBuilder(t29, Reflex::Literal("Bs2Dsh2011TDAnaModels::CheckVar"), function_8012, 0, Reflex::Literal("var;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t30 = ::Reflex::FunctionTypeBuilder(type_28050, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t30, Reflex::Literal("Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace"), function_8013, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t31 = ::Reflex::FunctionTypeBuilder(type_28050, type_27832, type_6066, type_667, type_27803, type_667);      ::Reflex::FunctionBuilder(t31, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainMassShape"), function_8014, 0, Reflex::Literal("work;mode;dsMass;lumRatio;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t32 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27803, type_27803, type_694, type_694, type_27803, type_694, type_694, type_694, type_27803, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t32, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix"), function_8015, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;nEvents;prefix;bName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t33 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t33, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim"), function_8016, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;nEvents;prefix;bName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t34 = ::Reflex::FunctionTypeBuilder(type_28430, type_27793, type_27803, type_27803, type_28050, type_6066, type_667);      ::Reflex::FunctionBuilder(t34, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainComboDs"), function_8017, 0, Reflex::Literal("massDs;cDVar;fracDsComb;pdf_SignalDs;Mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t35 = ::Reflex::FunctionTypeBuilder(type_28430, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t35, Reflex::Literal("Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace"), function_8018, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t36 = ::Reflex::FunctionTypeBuilder(type_28050, type_28052, type_22942, type_6066, type_667);      ::Reflex::FunctionBuilder(t36, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsKK"), function_9466, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t37 = ::Reflex::FunctionTypeBuilder(type_28050, type_28052, type_22942, type_6066, type_667);      ::Reflex::FunctionBuilder(t37, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsKP"), function_9467, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t38 = ::Reflex::FunctionTypeBuilder(type_1511, type_6066, type_28052, type_28052, type_22942, type_22942, type_22942, type_22942, type_1309, type_1309, type_1309, type_1309, type_6066, type_6066, type_6066, type_6066, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t38, Reflex::Literal("WeightingUtils::PlotWeightingSample"), function_9468, 0, Reflex::Literal("nm;dataCalib;dataCalibRW;Var1;Var2;Var3;PID;bin1;bin2;bin3;binPIDK;label1;label2;label3;dir;ext;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t39 = ::Reflex::FunctionTypeBuilder(type_1511, type_6066, type_28052, type_28052, type_22942, type_22942, type_22942, type_1309, type_1309, type_1309, type_6066, type_6066, type_6066, type_6066, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t39, Reflex::Literal("WeightingUtils::PlotWeightingSample"), function_9469, 0, Reflex::Literal("nm;dataCalib;dataCalibRW;Var1;Var2;PID;bin1;bin2;bin3;label1;label2;label3;dir;ext;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t40 = ::Reflex::FunctionTypeBuilder(type_2743, type_6066, type_667);      ::Reflex::FunctionBuilder(t40, Reflex::Literal("WeightingUtils::CheckWeightLabel"), function_9470, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t41 = ::Reflex::FunctionTypeBuilder(type_28610, type_28052, type_22942, type_22942, type_1309, type_1309, type_6066, type_667);      ::Reflex::FunctionBuilder(t41, Reflex::Literal("WeightingUtils::Get2DHist"), function_9471, 0, Reflex::Literal("data;Var1;Var2;bin1;bin2;histName1;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t42 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_6066, type_1309, type_1309, type_1309, type_6066, type_6066, type_6066, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t42, Reflex::Literal("WeightingUtils::ObtainHistRatio"), function_9472, 0, Reflex::Literal("filesDir;sig;fileCalibUp;workCalibUp;bin1;bin2;bin3;nameVar1;nameVar2;nameVar3;Var1_down;Var1_up;Var2_down;Var2_up;Var3_down;Var3_up;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t43 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_6066, type_1309, type_1309, type_6066, type_6066, type_694, type_694, type_694, type_694, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t43, Reflex::Literal("WeightingUtils::ObtainHistRatio"), function_9473, 0, Reflex::Literal("filesDir;sig;fileCalibUp;workCalibUp;bin1;bin2;nameVar1;nameVar2;Var1_down;Var1_up;Var2_down;Var2_up;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t44 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_1309, type_1309, type_1309, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t44, Reflex::Literal("WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample"), function_9474, 0, Reflex::Literal("fileCalib;workCalib;namePID;nameVar1;nameVar2;nameVar3;PID_down;PID_up;Var1_down;Var1_up;Var2_down;Var2_up;Var3_down;Var3_up;bin1;bin2;bin3;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t45 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_6066, type_6066, type_694, type_694, type_694, type_694, type_694, type_694, type_1309, type_1309, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t45, Reflex::Literal("WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample"), function_9475, 0, Reflex::Literal("fileCalib;workCalib;namePID;nameVar1;nameVar2;PID_down;PID_up;Var1_down;Var1_up;Var2_down;Var2_up;bin1;bin2;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t46 = ::Reflex::FunctionTypeBuilder(type_28052, type_6066, type_6066, type_22942, type_22942, type_22942, type_667);      ::Reflex::FunctionBuilder(t46, Reflex::Literal("WeightingUtils::GetDataCalibSample"), function_9476, 0, Reflex::Literal("fileName;workName;Var1;Var2;Var3;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t47 = ::Reflex::FunctionTypeBuilder(type_28052, type_6066, type_6066, type_22942, type_22942, type_667);      ::Reflex::FunctionBuilder(t47, Reflex::Literal("WeightingUtils::GetDataCalibSample"), function_9477, 0, Reflex::Literal("fileName;workName;Var1;Var2;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t48 = ::Reflex::FunctionTypeBuilder(type_28050, type_28052, type_22942, type_6066, type_667);      ::Reflex::FunctionBuilder(t48, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsPiK"), function_9478, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t49 = ::Reflex::FunctionTypeBuilder(type_28050, type_28052, type_22942, type_6066, type_667);      ::Reflex::FunctionBuilder(t49, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsPiPi"), function_9479, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t50 = ::Reflex::FunctionTypeBuilder(type_2743, type_6066, type_6066, type_667);      ::Reflex::FunctionBuilder(t50, Reflex::Literal("WeightingUtils::CheckTreeLabel"), function_9480, 0, Reflex::Literal("fileCalib;check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t51 = ::Reflex::FunctionTypeBuilder(type_2743, type_6066, type_667);      ::Reflex::FunctionBuilder(t51, Reflex::Literal("WeightingUtils::CheckTreeLabel"), function_9481, 0, Reflex::Literal("fileCalib;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t52 = ::Reflex::FunctionTypeBuilder(type_28050, type_28052, type_22942, type_6066, type_667);      ::Reflex::FunctionBuilder(t52, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsKPi"), function_9482, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t53 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_1309, type_1309, type_1309, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t53, Reflex::Literal("WeightingUtils::ObtainPIDShapeFromCalibSample"), function_9483, 0, Reflex::Literal("filesDir;sig;fileCalibUp;workCalibUp;PIDVar1;nameVar1;nameVar2;nameVar3;PID_down;PID_up;Var1_down;Var1_up;Var2_down;Var2_up;Var3_down;Var3_up;bin1;bin2;bin3;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t54 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_2743, type_694, type_694, type_694, type_694, type_694, type_694, type_1309, type_1309, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t54, Reflex::Literal("WeightingUtils::ObtainPIDShapeFromCalibSample"), function_9484, 0, Reflex::Literal("filesDir;sig;fileCalibUp;workCalibUp;PIDVar1;nameVar1;nameVar2;PID_down;PID_up;Var1_down;Var1_up;Var2_down;Var2_up;bin1;bin2;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t55 = ::Reflex::FunctionTypeBuilder(type_28611, type_28052, type_22942, type_22942, type_22942, type_28611, type_667);      ::Reflex::FunctionBuilder(t55, Reflex::Literal("WeightingUtils::Get3DHist"), function_9485, 0, Reflex::Literal("data;Var1;Var2;Var3;hist;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t56 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_1309, type_1309, type_1309, type_6066, type_6066, type_6066, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_27832, type_27832, type_667);      ::Reflex::FunctionBuilder(t56, Reflex::Literal("WeightingUtils::ObtainHistRatioOneSample"), function_9486, 0, Reflex::Literal("fileCalib;workCalib;bin1;bin2;bin3;nameVar1;nameVar2;nameVar3;Var1_down;Var1_up;Var2_down;Var2_up;Var3_down;Var3_up;type;work;workL;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t57 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_1309, type_1309, type_6066, type_6066, type_694, type_694, type_694, type_694, type_6066, type_27832, type_27832, type_667);      ::Reflex::FunctionBuilder(t57, Reflex::Literal("WeightingUtils::ObtainHistRatioOneSample"), function_9487, 0, Reflex::Literal("fileCalib;workCalib;bin1;bin2;nameVar1;nameVar2;Var1_down;Var1_up;Var2_down;Var2_up;type;work;workL;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t58 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27809, type_28158, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t58, Reflex::Literal("GeneralModels::buildRooBDecayPDF"), function_9987, 0, Reflex::Literal("time;Gamma;deltaGamma;deltaM;cosh;sinh;cos;sin;resModel;acceptance;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t59 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27809, type_28158, type_27793, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t59, Reflex::Literal("GeneralModels::buildRooBDecayEPDF"), function_9988, 0, Reflex::Literal("time;Gamma;deltaGamma;deltaM;cosh;sinh;cos;sin;resModel;acceptance;nEvents;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t60 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_27803, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t60, Reflex::Literal("GeneralModels::buildDoubleCBEPDF"), function_9989, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;nEvents;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t61 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27803, type_27809, type_28158, type_27803, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t61, Reflex::Literal("GeneralModels::buildRooDecayEPDF"), function_9990, 0, Reflex::Literal("time;Gamma;resModel;acceptance;nEvents;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t62 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27803, type_27809, type_28158, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t62, Reflex::Literal("GeneralModels::buildRooDecayPDF"), function_9991, 0, Reflex::Literal("time;Gamma;resModel;acceptance;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t63 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_694, type_694, type_27803, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t63, Reflex::Literal("GeneralModels::buildGaussianEPDF"), function_9992, 0, Reflex::Literal("obs;mean;sigma;nEvents;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t64 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t64, Reflex::Literal("GeneralModels::buildDoubleCBPDF"), function_9993, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t65 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_28682, type_13039, type_694, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t65, Reflex::Literal("GeneralModels::buildKeysPDF"), function_9994, 0, Reflex::Literal("obs;dataset;mirror=MirrorBoth;rho=1.0e+0;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t66 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_28158, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_28050, type_27809, type_28158, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t66, Reflex::Literal("GeneralModels::buildRooBDecayPDFWithPEDTE"), function_9995, 0, Reflex::Literal("time;timeerr;Gamma;deltaGamma;deltaM;cosh;sinh;cos;sin;timeerrPdf;resModel;acceptance;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t67 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_27793, type_28050, type_27809, type_28158, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t67, Reflex::Literal("GeneralModels::buildRooBDecayPDFWithPEDTE"), function_9996, 0, Reflex::Literal("time;timeerr;Gamma;deltaGamma;deltaM;cosh;sinh;cos;sin;timeerrPdf;resModel;acceptance;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t68 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_694, type_694, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t68, Reflex::Literal("GeneralModels::buildGaussianPDF"), function_9997, 0, Reflex::Literal("obs;mean;sigma;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t69 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_28388, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_667);      ::Reflex::FunctionBuilder(t69, Reflex::Literal("Bs2DshModels::buildBsBackgroundEPDFInMass"), function_12536, 0, Reflex::Literal("m_obs_mass;filesDir;nCombBkgEvts;nBd2DPiEvts;nBs2DsRhoEvts;nBs2DsstPiEvts;nBs2DsXEvts;nLb2LcPiEvts;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t70 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_28388, type_27803, type_27803, type_27803, type_27803, type_27803, type_667);      ::Reflex::FunctionBuilder(t70, Reflex::Literal("Bd2DhModels::buildBdBackgroundEPDFInMass"), function_13934, 0, Reflex::Literal("m_obs_mass;filesDir;nCombBkgEvts;nBd2DKEvts;nBd2DRhoEvts;nBd2DstPiEvts;nBd2DXEvts;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t71 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27803, type_27809, type_28158, type_667);      ::Reflex::FunctionBuilder(t71, Reflex::Literal("Bd2DhModels::buildBdBackgroundNoTagEPDFInTime"), function_13935, 0, Reflex::Literal("time;Gamma;nCombBkgEvts;CombBkgPTPdf_a;CombBkgPTPdf_f;CombBkgPTPdf_alpha;CombBkgPTPdf_beta;nBd2DKEvts;resModel;acceptance;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t72 = ::Reflex::FunctionTypeBuilder(type_28050, type_27793, type_28388, type_194c, type_194c, type_194c, type_194c, type_667);      ::Reflex::FunctionBuilder(t72, Reflex::Literal("Bd2DhModels::buildBdBackgroundPDFInMass"), function_13936, 0, Reflex::Literal("m_obs_mass;filesDir;fracCombBkgEvts;fracBd2DKEvts;fracBd2DstPiEvts;fracBd2DXEvts;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t73 = ::Reflex::FunctionTypeBuilder(type_28641, type_31923, type_6066, type_141, type_667);      ::Reflex::FunctionBuilder(t73, Reflex::Literal("GeneralUtils::ReadPIDHist"), function_14386, 0, Reflex::Literal("FilePID;nameHist;sample;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t74 = ::Reflex::FunctionTypeBuilder(type_28433, type_28052, type_22942, type_6066, type_1309, type_667);      ::Reflex::FunctionBuilder(t74, Reflex::Literal("GeneralUtils::CreateHistPDF"), function_14387, 0, Reflex::Literal("dataSet;obs;name;bin;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t75 = ::Reflex::FunctionTypeBuilder(type_2743, type_6066, type_667);      ::Reflex::FunctionBuilder(t75, Reflex::Literal("GeneralUtils::GetLabel"), function_14388, 0, Reflex::Literal("mode;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t76 = ::Reflex::FunctionTypeBuilder(type_2743, type_2743, type_667);      ::Reflex::FunctionBuilder(t76, Reflex::Literal("GeneralUtils::ReadOneMode"), function_14389, 0, Reflex::Literal("path;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t77 = ::Reflex::FunctionTypeBuilder(type_1511, type_28052, type_22942, type_6066, type_6066, type_667);      ::Reflex::FunctionBuilder(t77, Reflex::Literal("GeneralUtils::SaveDataSet"), function_14390, 0, Reflex::Literal("dataSet;mass;sample;mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t78 = ::Reflex::FunctionTypeBuilder(type_1511, type_28610, type_6066, type_28610, type_6066, type_28610, type_6066, type_6066);      ::Reflex::FunctionBuilder(t78, Reflex::Literal("GeneralUtils::Save2DComparison"), function_14391, 0, Reflex::Literal("hist1;l1;hist2;l2;hist3;l3;ext"), ::Reflex::PUBLIC);
      ::Reflex::Type t79 = ::Reflex::FunctionTypeBuilder(type_28641, type_28641, type_2317, type_28641, type_2317, type_667);      ::Reflex::FunctionBuilder(t79, Reflex::Literal("GeneralUtils::AddHist"), function_14392, 0, Reflex::Literal("hist1;w1;hist2;w2;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t80 = ::Reflex::FunctionTypeBuilder(type_1511, type_27950, type_28433, type_22942, type_6066, type_6066, type_667);      ::Reflex::FunctionBuilder(t80, Reflex::Literal("GeneralUtils::SaveTemplateHist"), function_14393, 0, Reflex::Literal("dataSet;pdf;mass;sample;mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t81 = ::Reflex::FunctionTypeBuilder(type_1511, type_28610, type_6066);      ::Reflex::FunctionBuilder(t81, Reflex::Literal("GeneralUtils::Save2DHist"), function_14394, 0, Reflex::Literal("hist;ext"), ::Reflex::PUBLIC);
      ::Reflex::Type t82 = ::Reflex::FunctionTypeBuilder(type_1511, type_6066, type_31923, type_6066, type_667);      ::Reflex::FunctionBuilder(t82, Reflex::Literal("GeneralUtils::ReadOneName"), function_14395, 0, Reflex::Literal("filesDir;FileName;sig;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t83 = ::Reflex::FunctionTypeBuilder(type_28611, type_31923, type_6066, type_141, type_667);      ::Reflex::FunctionBuilder(t83, Reflex::Literal("GeneralUtils::Read3DHist"), function_14396, 0, Reflex::Literal("FilePID;nameHist;sample;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t84 = ::Reflex::FunctionTypeBuilder(type_28050, type_28052, type_22942, type_6066, type_1309, type_667);      ::Reflex::FunctionBuilder(t84, Reflex::Literal("GeneralUtils::CreateBinnedPDF"), function_14397, 0, Reflex::Literal("dataSet;obs;name;bin;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t85 = ::Reflex::FunctionTypeBuilder(type_8027, type_31923, type_141, type_667);      ::Reflex::FunctionBuilder(t85, Reflex::Literal("GeneralUtils::ReadTreeData"), function_14398, 0, Reflex::Literal("FileName;sample;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t86 = ::Reflex::FunctionTypeBuilder(type_22942, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t86, Reflex::Literal("GeneralUtils::GetObservable"), function_14399, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t87 = ::Reflex::FunctionTypeBuilder(type_1511, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t87, Reflex::Literal("GeneralUtils::SaveWorkspace"), function_14400, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t88 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_667);      ::Reflex::FunctionBuilder(t88, Reflex::Literal("GeneralUtils::LoadWorkspace"), function_14401, 0, Reflex::Literal("fileName;workName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t89 = ::Reflex::FunctionTypeBuilder(type_1511, type_28052, type_28432, type_22942, type_6066, type_6066, type_667);      ::Reflex::FunctionBuilder(t89, Reflex::Literal("GeneralUtils::SaveTemplate"), function_14402, 0, Reflex::Literal("dataSet;pdf;mass;sample;mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t90 = ::Reflex::FunctionTypeBuilder(type_2835, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t90, Reflex::Literal("GeneralUtils::GetRooArgSet"), function_14403, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t91 = ::Reflex::FunctionTypeBuilder(type_8027, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t91, Reflex::Literal("GeneralUtils::ReadTreeMC"), function_14404, 0, Reflex::Literal("fileName;treeName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t92 = ::Reflex::FunctionTypeBuilder(type_28432, type_28052, type_22942, type_6066, type_6066, type_668, type_667);      ::Reflex::FunctionBuilder(t92, Reflex::Literal("GeneralUtils::CreatePDFMC"), function_14405, 0, Reflex::Literal("dataSetMC;massMC;sample;mode;mistag;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t93 = ::Reflex::FunctionTypeBuilder(type_28058, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t93, Reflex::Literal("GeneralUtils::GetCategory"), function_14406, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t94 = ::Reflex::FunctionTypeBuilder(type_2743, type_6066, type_667);      ::Reflex::FunctionBuilder(t94, Reflex::Literal("GeneralUtils::CheckDMode"), function_14407, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t95 = ::Reflex::FunctionTypeBuilder(type_2743, type_31924, type_667);      ::Reflex::FunctionBuilder(t95, Reflex::Literal("GeneralUtils::CheckDMode"), function_14408, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t96 = ::Reflex::FunctionTypeBuilder(type_28610, type_31923, type_6066, type_141, type_667);      ::Reflex::FunctionBuilder(t96, Reflex::Literal("GeneralUtils::Read2DHist"), function_14409, 0, Reflex::Literal("FilePID;nameHist;sample;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t97 = ::Reflex::FunctionTypeBuilder(type_2743, type_6066, type_667);      ::Reflex::FunctionBuilder(t97, Reflex::Literal("GeneralUtils::CheckBDTGBin"), function_14410, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t98 = ::Reflex::FunctionTypeBuilder(type_27950, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t98, Reflex::Literal("GeneralUtils::GetDataHist"), function_14411, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t99 = ::Reflex::FunctionTypeBuilder(type_2743, type_6066, type_667);      ::Reflex::FunctionBuilder(t99, Reflex::Literal("GeneralUtils::CheckPolarity"), function_14412, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t100 = ::Reflex::FunctionTypeBuilder(type_2743, type_31924, type_667);      ::Reflex::FunctionBuilder(t100, Reflex::Literal("GeneralUtils::CheckPolarity"), function_14413, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t101 = ::Reflex::FunctionTypeBuilder(type_28052, type_27832, type_6066, type_667);      ::Reflex::FunctionBuilder(t101, Reflex::Literal("GeneralUtils::GetDataSet"), function_14414, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t102 = ::Reflex::FunctionTypeBuilder(type_2743, type_6066, type_667);      ::Reflex::FunctionBuilder(t102, Reflex::Literal("GeneralUtils::CheckKKPiMode"), function_14415, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t103 = ::Reflex::FunctionTypeBuilder(type_2743, type_31924, type_667);      ::Reflex::FunctionBuilder(t103, Reflex::Literal("GeneralUtils::CheckKKPiMode"), function_14416, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t104 = ::Reflex::FunctionTypeBuilder(type_1511, type_31923, type_31923, type_667, type_667);      ::Reflex::FunctionBuilder(t104, Reflex::Literal("GeneralUtils::ReadMode"), function_14417, 0, Reflex::Literal("MCFileName;mode;iskfactor=false;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t105 = ::Reflex::FunctionTypeBuilder(type_8027, type_8027, type_28685, type_6066, type_6066, type_667);      ::Reflex::FunctionBuilder(t105, Reflex::Literal("GeneralUtils::TreeCut"), function_14418, 0, Reflex::Literal("tree;cut;sample;mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t106 = ::Reflex::FunctionTypeBuilder(type_1511, type_28611, type_6066);      ::Reflex::FunctionBuilder(t106, Reflex::Literal("GeneralUtils::Save3DHist"), function_14419, 0, Reflex::Literal("hist;ext"), ::Reflex::PUBLIC);
      ::Reflex::Type t107 = ::Reflex::FunctionTypeBuilder(type_1511, type_22409, type_28050, type_22942, type_4138, type_4138, type_4138, type_667);      ::Reflex::FunctionBuilder(t107, Reflex::Literal("GeneralUtils::saveDataTemplateToFile"), function_14420, 0, Reflex::Literal("data;pdf;observable;mode;extension=\"pdf\";suffix=0l;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t108 = ::Reflex::FunctionTypeBuilder(type_28052, type_8027, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_667);      ::Reflex::FunctionBuilder(t108, Reflex::Literal("SFitUtils::CopyDataForToys"), function_15178, 0, Reflex::Literal("tree;mVar;mDVar;PIDKVar;tVar;terrVar;tagVar;tagOmegaVar;idVar;trueIDVar;dataName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t109 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_694, type_694, type_6066, type_6066, type_6066, type_6066, type_6066, type_667, type_667);      ::Reflex::FunctionBuilder(t109, Reflex::Literal("SFitUtils::ReadDataFromSWeights2"), function_15179, 0, Reflex::Literal("part;pathFile;treeName;time_down;time_up;tVar;terrVar;tagName;tagOmegaVar;idVar;weighted;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t110 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_6066, type_694, type_694, type_6066, type_6066, type_6066, type_6066, type_6066, type_667, type_667, type_667);      ::Reflex::FunctionBuilder(t110, Reflex::Literal("SFitUtils::ReadDataFromSWeights"), function_15180, 0, Reflex::Literal("part;pathFile;treeName;time_down;time_up;tVar;terrVar;tagName;tagOmegaVar;idVar;weighted;debug=false;applykfactor=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t111 = ::Reflex::FunctionTypeBuilder(type_27832, type_6066, type_6066, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6066, type_6066, type_6066, type_6066, type_6066, type_6066, type_27832, type_667);      ::Reflex::FunctionBuilder(t111, Reflex::Literal("SFitUtils::ReadLbLcPiFromSWeights"), function_15181, 0, Reflex::Literal("pathFile;treeName;P_down;P_up;PT_down;PT_up;nTr_down;nTr_up;PID_down;PID_up;mVar;mDVar;pVar;ptVar;nTrVar;pidVar;workspace;debug=false"), ::Reflex::PUBLIC);
    }
    ~Dictionaries() {
      type_12.Unload(); // class TagEfficiencyWeight 
      type_130.Unload(); // class RooBinned1DQuinticBase<RooAbsReal> 
      type_259.Unload(); // class DecRateCoeff 
      type_266.Unload(); // class IfThreeWayPdf 
      type_286.Unload(); // class Inverse 
      type_324.Unload(); // class RooEffConvGenContext 
      type_327.Unload(); // class BdPTAcceptance 
      type_449.Unload(); // class RooBinned2DBicubicBase<RooAbsPdf> 
      type_450.Unload(); // class RooBinned2DBicubicBase<RooAbsReal> 
      type_485.Unload(); // class IfThreeWayCatPdf 
      type_515.Unload(); // class NonOscTaggingPdf 
      type_577.Unload(); // class DTAcceptanceLHCbNote2007041 
      type_664.Unload(); // class RooEffResModel 
      type_670.Unload(); // class RooAbsEffResModel 
      type_723.Unload(); // class IfThreeWayCat 
      type_855.Unload(); // class RooCubicSplineKnot 
      type_995.Unload(); // class RooBinnedPdf 
      type_1073.Unload(); // class MistagDistribution 
      type_1305.Unload(); // class SquaredSum 
      type_1382.Unload(); // class RooGenSmearIntegrandBinding 
      type_1438.Unload(); // class RooGaussEfficiencyModel 
      type_1473.Unload(); // class RooGeneralisedSmearingBase<RooAbsPdf> 
      type_1576.Unload(); // class RooBinned1DQuinticBase<RooAbsPdf> 
      type_1630.Unload(); // class RooEffHistProd 
      type_1672.Unload(); // class RooAbsGaussModelEfficiency 
      type_1675.Unload(); // class RooGeneralisedSmearingBase<RooAbsReal> 
      type_1679.Unload(); // class TagEfficiencyWeightNoCat 
      type_1744.Unload(); // class FinalStateChargePdf 
      type_1831.Unload(); // class TaggingCat 
      type_1880.Unload(); // class RangeAcceptance 
      type_1909.Unload(); // class PowLawAcceptance 
      type_1927.Unload(); // class MistagCalibration 
      type_1939.Unload(); // class SharedArrayImp<double> 
      type_1940.Unload(); // class SharedArrayImp<float> 
      type_1941.Unload(); // class SharedArrayImp<unsigned long long> 
      type_1942.Unload(); // class SharedArrayImp<unsigned long> 
      type_1943.Unload(); // class SharedArrayImp<unsigned int> 
      type_1944.Unload(); // class SharedArrayImp<unsigned short> 
      type_1945.Unload(); // class SharedArrayImp<unsigned char> 
      type_1946.Unload(); // class SharedArrayImp<long long> 
      type_1947.Unload(); // class SharedArrayImp<long> 
      type_1948.Unload(); // class SharedArrayImp<int> 
      type_1949.Unload(); // class SharedArrayImp<short> 
      type_1950.Unload(); // class SharedArrayImp<char> 
      type_2072.Unload(); // class Dilution 
      type_2078.Unload(); // class FitMeTool 
      type_2117.Unload(); // class RooCubicSplineFun 
      type_2165.Unload(); // class CPObservable 
      type_2200.Unload(); // class RooComplementCoef 
      type_2203.Unload(); // class SharedArray<double> 
      type_2204.Unload(); // class SharedArray<float> 
      type_2205.Unload(); // class SharedArray<unsigned long long> 
      type_2206.Unload(); // class SharedArray<unsigned long> 
      type_2207.Unload(); // class SharedArray<unsigned int> 
      type_2208.Unload(); // class SharedArray<unsigned short> 
      type_2209.Unload(); // class SharedArray<unsigned char> 
      type_2210.Unload(); // class SharedArray<long long> 
      type_2211.Unload(); // class SharedArray<long> 
      type_2212.Unload(); // class SharedArray<int> 
      type_2213.Unload(); // class SharedArray<short> 
      type_2214.Unload(); // class SharedArray<char> 
      type_2231.Unload(); // class IfThreeWay 
      type_2502.Unload(); // class RooCruijff 
      type_2590.Unload(); // class CombBkgPTPdf 
      type_2744.Unload(); // class RooBinnedFun 
      type_3092.Unload(); // class std::vector<double> 
      type_7159.Unload(); // class RooCubicSplineKnot::S_jk 
      type_3093.Unload(); // class std::vector<RooCubicSplineKnot::S_jk> 
      type_3094.Unload(); // class std::vector<float> 
      type_3095.Unload(); // class std::vector<unsigned long long> 
      type_3096.Unload(); // class std::vector<unsigned long> 
      type_3097.Unload(); // class std::vector<unsigned int> 
      type_3098.Unload(); // class std::vector<unsigned short> 
      type_3099.Unload(); // class std::vector<unsigned char> 
      type_3100.Unload(); // class std::vector<long long> 
      type_3101.Unload(); // class std::vector<long> 
      type_3102.Unload(); // class std::vector<int> 
      type_3103.Unload(); // class std::vector<short> 
      type_3104.Unload(); // class std::vector<char> 
      type_3105.Unload(); // class std::vector<RooFitResult*> 
      type_3106.Unload(); // class std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > 
      type_3107.Unload(); // class std::vector<std::map<void*,double> > 
      type_3108.Unload(); // class std::vector<std::vector<double> > 
      type_3110.Unload(); // class std::vector<std::vector<double>*> 
      type_3111.Unload(); // class std::vector<RooNormSetCache> 
      type_3112.Unload(); // class std::vector<std::pair<double,TString> > 
      type_3114.Unload(); // class std::vector<TString> 
      type_3115.Unload(); // class std::vector<std::map<int,int> > 
      type_3116.Unload(); // class std::vector<const RooAbsBinning*> 
      type_3117.Unload(); // class std::vector<RooAbsRealLValue*> 
      type_3118.Unload(); // class std::vector<bool> 
      type_3119.Unload(); // class std::vector<RooArgSet*> 
      type_3120.Unload(); // class std::vector<std::vector<int> > 
      type_3121.Unload(); // class std::vector<std::pair<std::basic_string<char>,int> > 
      type_3122.Unload(); // class std::vector<RooAbsArg*> 
      type_3123.Unload(); // class std::vector<RooAbsCacheElement*> 
      type_3124.Unload(); // class std::vector<RooMsgService::StreamConfig> 
      type_3126.Unload(); // class std::vector<TVirtualArray*> 
      type_3127.Unload(); // class std::vector<ROOT::TSchemaHelper> 
      type_3488.Unload(); // class std::pair<std::basic_string<char>,RooAbsData*> 
      type_7158.Unload(); // class RooCubicSplineKnot::BoundaryConditions 
      type_7160.Unload(); // class RooCubicSplineKnot::S_edge 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
