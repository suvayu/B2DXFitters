// Generated at Mon Sep 23 17:17:29 2013. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/usr/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/usr/bin/c++"
  GCCXML_CXXFLAGS="-g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security "
  GCCXML_EXECUTABLE="/usr/bin/gccxml_cc1plus"
  GCCXML_CPP="/usr/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__OPTIMIZE__='1' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.7.2"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SSP__='1' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='7' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/usr/share/gccxml-0.9/GCC/4.7" -isystem"/opt/intel/composer_xe_2011_sp1.6.233/mkl/include" -isystem"/opt/intel/composer_xe_2011_sp1.6.233/tbb/include" -isystem"/usr/include/c++/4.7" -isystem"/usr/include/c++/4.7/x86_64-linux-gnu" -isystem"/usr/include/c++/4.7/backward" -isystem"/usr/lib/gcc/x86_64-linux-gnu/4.7/include" -isystem"/usr/local/include" -isystem"/usr/lib/gcc/x86_64-linux-gnu/4.7/include-fixed" -isystem"/usr/include/x86_64-linux-gnu" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/usr/share/gccxml-0.9"

Compiler info:
c++ (Debian 4.7.2-5) 4.7.2
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "B2DXFittersDict.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("MassFitUtils") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("PTResModels") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("Bs2Dsh2011TDAnaModels") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("WeightingUtils") );
  ::Reflex::NamespaceBuilder nsb5( Reflex::Literal("GeneralModels") );
  ::Reflex::NamespaceBuilder nsb6( Reflex::Literal("Bs2DshModels") );
  ::Reflex::NamespaceBuilder nsb7( Reflex::Literal("Bd2DhModels") );
  ::Reflex::NamespaceBuilder nsb8( Reflex::Literal("GeneralUtils") );
  ::Reflex::NamespaceBuilder nsb9( Reflex::Literal("SFitUtils") );
  ::Reflex::Type type_141 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_667 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_2823 = ::Reflex::TypeBuilder(Reflex::Literal("TH1"));
  ::Reflex::Type type_2841 = ::Reflex::TypeBuilder(Reflex::Literal("TH2"));
  ::Reflex::Type type_194 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_252 = ::Reflex::TypeBuilder(Reflex::Literal("TH2F"));
  ::Reflex::Type type_265 = ::Reflex::TypeBuilder(Reflex::Literal("TH3F"));
  ::Reflex::Type type_245 = ::Reflex::TypeBuilder(Reflex::Literal("TH1F"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1039 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_196 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_1511 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_102 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_844 = ::Reflex::TypeBuilder(Reflex::Literal("TFile"));
  ::Reflex::Type type_1573 = ::Reflex::TypeBuilder(Reflex::Literal("TCut"));
  ::Reflex::Type type_694 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_2976 = ::Reflex::TypeBuilder(Reflex::Literal("TTree"));
  ::Reflex::Type type_2058 = ::Reflex::TypeBuilder(Reflex::Literal("TClass"));
  ::Reflex::Type type_286 = ::Reflex::TypeBuilder(Reflex::Literal("Inverse"));
  ::Reflex::Type type_1819 = ::Reflex::TypeBuilder(Reflex::Literal("TGraph"));
  ::Reflex::Type type_1129 = ::Reflex::TypeBuilder(Reflex::Literal("TObject"));
  ::Reflex::Type type_2929 = ::Reflex::TypeBuilder(Reflex::Literal("TBuffer"));
  ::Reflex::Type type_2743 = ::Reflex::TypeBuilder(Reflex::Literal("TString"));
  ::Reflex::Type type_2072 = ::Reflex::TypeBuilder(Reflex::Literal("Dilution"));
  ::Reflex::Type type_1126 = ::Reflex::TypeBuilder(Reflex::Literal("RooArgSet"));
  ::Reflex::Type type_2033 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf"));
  ::Reflex::Type type_1962 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg"));
  ::Reflex::Type type_2579 = ::Reflex::TypeBuilder(Reflex::Literal("TObjArray"));
  ::Reflex::Type type_2017 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_2078 = ::Reflex::TypeBuilder(Reflex::Literal("FitMeTool"));
  ::Reflex::Type type_2007 = ::Reflex::TypeBuilder(Reflex::Literal("RooCmdArg"));
  ::Reflex::Type type_2819 = ::Reflex::TypeBuilder(Reflex::Literal("RooAddPdf"));
  ::Reflex::Type type_781 = ::Reflex::TypeBuilder(Reflex::Literal("RooProdPdf"));
  ::Reflex::Type type_236 = ::Reflex::TypeBuilder(Reflex::Literal("RooHistPdf"));
  ::Reflex::Type type_2525 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal"));
  ::Reflex::Type type_1874 = ::Reflex::TypeBuilder(Reflex::Literal("RooUniform"));
  ::Reflex::Type type_2021 = ::Reflex::TypeBuilder(Reflex::Literal("RooDataSet"));
  ::Reflex::Type type_878 = ::Reflex::TypeBuilder(Reflex::Literal("RooSetProxy"));
  ::Reflex::Type type_1620 = ::Reflex::TypeBuilder(Reflex::Literal("RooArgList"));
  ::Reflex::Type type_1305 = ::Reflex::TypeBuilder(Reflex::Literal("SquaredSum"));
  ::Reflex::Type type_2683 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsFunc"));
  ::Reflex::Type type_1113 = ::Reflex::TypeBuilder(Reflex::Literal("RooRealVar"));
  ::Reflex::Type type_1831 = ::Reflex::TypeBuilder(Reflex::Literal("TaggingCat"));
  ::Reflex::Type type_2494 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsData"));
  ::Reflex::Type type_2231 = ::Reflex::TypeBuilder(Reflex::Literal("IfThreeWay"));
  ::Reflex::Type type_2502 = ::Reflex::TypeBuilder(Reflex::Literal("RooCruijff"));
  ::Reflex::Type type_2099 = ::Reflex::TypeBuilder(Reflex::Literal("RooKeysPdf"));
  ::Reflex::Type type_211 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_259 = ::Reflex::TypeBuilder(Reflex::Literal("DecRateCoeff"));
  ::Reflex::Type type_646 = ::Reflex::TypeBuilder(Reflex::Literal("RooListProxy"));
  ::Reflex::Type type_995 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinnedPdf"));
  ::Reflex::Type type_1656 = ::Reflex::TypeBuilder(Reflex::Literal("RooCategory"));
  ::Reflex::Type type_800 = ::Reflex::TypeBuilder(Reflex::Literal("TGraphErrors"));
  ::Reflex::Type type_188 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsLValue"));
  ::Reflex::Type type_906 = ::Reflex::TypeBuilder(Reflex::Literal("RooStringVar"));
  ::Reflex::Type type_2134 = ::Reflex::TypeBuilder(Reflex::Literal("RooDataHist"));
  ::Reflex::Type type_1249 = ::Reflex::TypeBuilder(Reflex::Literal("RooRealProxy"));
  ::Reflex::Type type_48 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsCategory"));
  ::Reflex::Type type_266 = ::Reflex::TypeBuilder(Reflex::Literal("IfThreeWayPdf"));
  ::Reflex::Type type_723 = ::Reflex::TypeBuilder(Reflex::Literal("IfThreeWayCat"));
  ::Reflex::Type type_167 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_291 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_2041 = ::Reflex::TypeBuilder(Reflex::Literal("RooFitResult"));
  ::Reflex::Type type_1147 = ::Reflex::TypeBuilder(Reflex::Literal("RooWorkspace"));
  ::Reflex::Type type_2165 = ::Reflex::TypeBuilder(Reflex::Literal("CPObservable"));
  ::Reflex::Type type_2590 = ::Reflex::TypeBuilder(Reflex::Literal("CombBkgPTPdf"));
  ::Reflex::Type type_2744 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinnedFun"));
  ::Reflex::Type type_641 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsBinning"));
  ::Reflex::Type type_532 = ::Reflex::TypeBuilder(Reflex::Literal("TVirtualArray"));
  ::Reflex::Type type_2191 = ::Reflex::TypeBuilder(Reflex::Literal("RooFFTConvPdf"));
  ::Reflex::Type type_2826 = ::Reflex::TypeBuilder(Reflex::Literal("RooNumConvPdf"));
  ::Reflex::Type type_327 = ::Reflex::TypeBuilder(Reflex::Literal("BdPTAcceptance"));
  ::Reflex::Type type_664 = ::Reflex::TypeBuilder(Reflex::Literal("RooEffResModel"));
  ::Reflex::Type type_311 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_1554 = ::Reflex::TypeBuilder(Reflex::Literal("RooFormulaVar"));
  ::Reflex::Type type_1630 = ::Reflex::TypeBuilder(Reflex::Literal("RooEffHistProd"));
  ::Reflex::Type type_795 = ::Reflex::TypeBuilder(Reflex::Literal("RooNormSetCache"));
  ::Reflex::Type type_434 = ::Reflex::TypeBuilder(Reflex::Literal("TMemberInspector"));
  ::Reflex::Type type_485 = ::Reflex::TypeBuilder(Reflex::Literal("IfThreeWayCatPdf"));
  ::Reflex::Type type_515 = ::Reflex::TypeBuilder(Reflex::Literal("NonOscTaggingPdf"));
  ::Reflex::Type type_952 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGenContext"));
  ::Reflex::Type type_145 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_2970 = ::Reflex::TypeBuilder(Reflex::Literal("RooNumIntConfig"));
  ::Reflex::Type type_1880 = ::Reflex::TypeBuilder(Reflex::Literal("RangeAcceptance"));
  ::Reflex::Type type_1173 = ::Reflex::TypeBuilder(Reflex::Literal("RooCategoryProxy"));
  ::Reflex::Type type_1420 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsRealLValue"));
  ::Reflex::Type type_755 = ::Reflex::TypeBuilder(Reflex::Literal("RooConvGenContext"));
  ::Reflex::Type type_2172 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsAnaConvPdf"));
  ::Reflex::Type type_39 = ::Reflex::TypeBuilder(Reflex::Literal("RooResolutionModel"));
  ::Reflex::Type type_670 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsEffResModel"));
  ::Reflex::Type type_2144 = ::Reflex::TypeBuilder(Reflex::Literal("TVectorT<double>"));
  ::Reflex::Type type_2751 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsIntegrator"));
  ::Reflex::Type type_1909 = ::Reflex::TypeBuilder(Reflex::Literal("PowLawAcceptance"));
  ::Reflex::Type type_3099 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_2278 = ::Reflex::TypeBuilder(Reflex::Literal("RooUnblindOffset"));
  ::Reflex::Type type_2212 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<int>"));
  ::Reflex::Type type_12 = ::Reflex::TypeBuilder(Reflex::Literal("TagEfficiencyWeight"));
  ::Reflex::Type type_2993 = ::Reflex::TypeBuilder(Reflex::Literal("std::list<double>"));
  ::Reflex::Type type_855 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineKnot"));
  ::Reflex::Type type_3116 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<bool>"));
  ::Reflex::Type type_1927 = ::Reflex::TypeBuilder(Reflex::Literal("MistagCalibration"));
  ::Reflex::Type type_820 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long long"));
  ::Reflex::Type type_3098 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long>"));
  ::Reflex::Type type_3101 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<char>"));
  ::Reflex::Type type_2117 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineFun"));
  ::Reflex::Type type_2200 = ::Reflex::TypeBuilder(Reflex::Literal("RooComplementCoef"));
  ::Reflex::Type type_2211 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<long>"));
  ::Reflex::Type type_2214 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<char>"));
  ::Reflex::Type type_3365 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,int>"));
  ::Reflex::Type type_2216 = ::Reflex::TypeBuilder(Reflex::Literal("RooObjCacheManager"));
  ::Reflex::Type type_1073 = ::Reflex::TypeBuilder(Reflex::Literal("MistagDistribution"));
  ::Reflex::Type type_3091 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_3100 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<short>"));
  ::Reflex::Type type_2204 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<float>"));
  ::Reflex::Type type_2213 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<short>"));
  ::Reflex::Type type_3223 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_iterator"));
  ::Reflex::Type type_2677 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsCacheElement"));
  ::Reflex::Type type_2203 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<double>"));
  ::Reflex::Type type_324 = ::Reflex::TypeBuilder(Reflex::Literal("RooEffConvGenContext"));
  ::Reflex::Type type_3089 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_1744 = ::Reflex::TypeBuilder(Reflex::Literal("FinalStateChargePdf"));
  ::Reflex::Type type_1948 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<int>"));
  ::Reflex::Type type_3687 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<int>"));
  ::Reflex::Type type_3222 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_reference"));
  ::Reflex::Type type_3113 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TString>"));
  ::Reflex::Type type_3635 = ::Reflex::TypeBuilder(Reflex::Literal("std::complex<double>"));
  ::Reflex::Type type_1947 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<long>"));
  ::Reflex::Type type_1950 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<char>"));
  ::Reflex::Type type_3686 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<long>"));
  ::Reflex::Type type_3689 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char>"));
  ::Reflex::Type type_3723 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<bool>"));
  ::Reflex::Type type_13467 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::TSchemaHelper"));
  ::Reflex::Type type_1940 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<float>"));
  ::Reflex::Type type_1949 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<short>"));
  ::Reflex::Type type_3679 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<float>"));
  ::Reflex::Type type_3688 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<short>"));
  ::Reflex::Type type_1939 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<double>"));
  ::Reflex::Type type_3097 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long long>"));
  ::Reflex::Type type_2210 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<long long>"));
  ::Reflex::Type type_3676 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<double>"));
  ::Reflex::Type type_3351 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<void*,double>"));
  ::Reflex::Type type_5196 = ::Reflex::EnumTypeBuilder(Reflex::Literal("DecRateCoeff::Flags"));
  ::Reflex::Type type_1438 = ::Reflex::TypeBuilder(Reflex::Literal("RooGaussEfficiencyModel"));
  ::Reflex::Type type_3147 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_3724 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TString>"));
  ::Reflex::Type type_3117 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooArgSet*>"));
  ::Reflex::Type type_3120 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooAbsArg*>"));
  ::Reflex::Type type_13032 = ::Reflex::EnumTypeBuilder(Reflex::Literal("RooKeysPdf::Mirror"));
  ::Reflex::Type type_3112 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooAbsReal*>"));
  ::Reflex::Type type_7149 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineKnot::S_jk"));
  ::Reflex::Type type_1679 = ::Reflex::TypeBuilder(Reflex::Literal("TagEfficiencyWeightNoCat"));
  ::Reflex::Type type_13484 = ::Reflex::EnumTypeBuilder(Reflex::Literal("CPObservable::which"));
  ::Reflex::Type type_4012 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_const_iterator"));
  ::Reflex::Type type_3094 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_1946 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<long long>"));
  ::Reflex::Type type_2207 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned int>"));
  ::Reflex::Type type_3685 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<long long>"));
  ::Reflex::Type type_3516 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<double,TString>"));
  ::Reflex::Type type_577 = ::Reflex::TypeBuilder(Reflex::Literal("DTAcceptanceLHCbNote2007041"));
  ::Reflex::Type type_7150 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineKnot::S_edge"));
  ::Reflex::Type type_1672 = ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGaussModelEfficiency"));
  ::Reflex::Type type_12434 = ::Reflex::EnumTypeBuilder(Reflex::Literal("RooAbsPdf::ExtendMode"));
  ::Reflex::Type type_3093 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3096 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned char>"));
  ::Reflex::Type type_2206 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned long>"));
  ::Reflex::Type type_2209 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned char>"));
  ::Reflex::Type type_13800 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<int>::RWProxy"));
  ::Reflex::Type type_3102 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooFitResult*>"));
  ::Reflex::Type type_3108 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooAbsLValue*>"));
  ::Reflex::Type type_3729 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooArgSet*>"));
  ::Reflex::Type type_3748 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooAbsArg*>"));
  ::Reflex::Type type_1382 = ::Reflex::TypeBuilder(Reflex::Literal("RooGenSmearIntegrandBinding"));
  ::Reflex::Type type_3095 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_2208 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned short>"));
  ::Reflex::Type type_13775 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<long>::RWProxy"));
  ::Reflex::Type type_13850 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<char>::RWProxy"));
  ::Reflex::Type type_4318 = ::Reflex::TypeBuilder(Reflex::Literal("RooMsgService::StreamConfig"));
  ::Reflex::Type type_3124 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TVirtualArray*>"));
  ::Reflex::Type type_1943 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned int>"));
  ::Reflex::Type type_13600 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<float>::RWProxy"));
  ::Reflex::Type type_13825 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<short>::RWProxy"));
  ::Reflex::Type type_3682 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned int>"));
  ::Reflex::Type type_3110 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooNormSetCache>"));
  ::Reflex::Type type_1942 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned long>"));
  ::Reflex::Type type_1945 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned char>"));
  ::Reflex::Type type_13575 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<double>::RWProxy"));
  ::Reflex::Type type_3681 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned long>"));
  ::Reflex::Type type_3684 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned char>"));
  ::Reflex::Type type_3690 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooFitResult*>"));
  ::Reflex::Type type_3709 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooAbsLValue*>"));
  ::Reflex::Type type_1944 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned short>"));
  ::Reflex::Type type_3683 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned short>"));
  ::Reflex::Type type_3115 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooAbsRealLValue*>"));
  ::Reflex::Type type_3118 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<int> >"));
  ::Reflex::Type type_3774 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TVirtualArray*>"));
  ::Reflex::Type type_3114 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::map<int,int> >"));
  ::Reflex::Type type_3092 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long long>"));
  ::Reflex::Type type_2205 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned long long>"));
  ::Reflex::Type type_3711 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooNormSetCache>"));
  ::Reflex::Type type_3350 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,RooArgSet>"));
  ::Reflex::Type type_449 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinned2DBicubicBase<RooAbsPdf>"));
  ::Reflex::Type type_13750 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<long long>::RWProxy"));
  ::Reflex::Type type_3121 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooAbsCacheElement*>"));
  ::Reflex::Type type_3125 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<ROOT::TSchemaHelper>"));
  ::Reflex::Type type_130 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinned1DQuinticBase<RooAbsReal>"));
  ::Reflex::Type type_450 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinned2DBicubicBase<RooAbsReal>"));
  ::Reflex::Type type_3105 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<double> >"));
  ::Reflex::Type type_1576 = ::Reflex::TypeBuilder(Reflex::Literal("RooBinned1DQuinticBase<RooAbsPdf>"));
  ::Reflex::Type type_3107 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const RooAbsBinning*>"));
  ::Reflex::Type type_3109 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<double>*>"));
  ::Reflex::Type type_3721 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooAbsRealLValue*>"));
  ::Reflex::Type type_3730 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<int> >"));
  ::Reflex::Type type_1941 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArrayImp<unsigned long long>"));
  ::Reflex::Type type_3680 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned long long>"));
  ::Reflex::Type type_3725 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::map<int,int> >"));
  ::Reflex::Type type_13675 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned int>::RWProxy"));
  ::Reflex::Type type_3749 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooAbsCacheElement*>"));
  ::Reflex::Type type_3775 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<ROOT::TSchemaHelper>"));
  ::Reflex::Type type_3104 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::map<void*,double> >"));
  ::Reflex::Type type_13650 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned long>::RWProxy"));
  ::Reflex::Type type_13725 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned char>::RWProxy"));
  ::Reflex::Type type_3694 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<double> >"));
  ::Reflex::Type type_3708 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<const RooAbsBinning*>"));
  ::Reflex::Type type_3710 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<double>*>"));
  ::Reflex::Type type_3090 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>"));
  ::Reflex::Type type_1473 = ::Reflex::TypeBuilder(Reflex::Literal("RooGeneralisedSmearingBase<RooAbsPdf>"));
  ::Reflex::Type type_3106 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_13700 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned short>::RWProxy"));
  ::Reflex::Type type_7148 = ::Reflex::TypeBuilder(Reflex::Literal("RooCubicSplineKnot::BoundaryConditions"));
  ::Reflex::Type type_1675 = ::Reflex::TypeBuilder(Reflex::Literal("RooGeneralisedSmearingBase<RooAbsReal>"));
  ::Reflex::Type type_3554 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,int>"));
  ::Reflex::Type type_3483 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<DecRateCoeff::CacheElem*,int>"));
  ::Reflex::Type type_3111 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<double,TString> >"));
  ::Reflex::Type type_3692 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::map<void*,double> >"));
  ::Reflex::Type type_3677 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooCubicSplineKnot::S_jk>"));
  ::Reflex::Type type_3122 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<RooMsgService::StreamConfig>"));
  ::Reflex::Type type_13625 = ::Reflex::TypeBuilder(Reflex::Literal("SharedArray<unsigned long long>::RWProxy"));
  ::Reflex::Type type_3254 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bvector_base<std::allocator<bool> >"));
  ::Reflex::Type type_3991 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Bit_iterator>"));
  ::Reflex::Type type_3717 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<double,TString> >"));
  ::Reflex::Type type_3484 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<NonOscTaggingPdf::CacheElem*,int>"));
  ::Reflex::Type type_3036 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<int,std::allocator<int> >"));
  ::Reflex::Type type_3754 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<RooMsgService::StreamConfig>"));
  ::Reflex::Type type_3363 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,RooArgSet*>"));
  ::Reflex::Type type_3027 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long,std::allocator<long> >"));
  ::Reflex::Type type_3029 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<char,std::allocator<char> >"));
  ::Reflex::Type type_3485 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,RooAbsData*>"));
  ::Reflex::Type type_3020 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<float,std::allocator<float> >"));
  ::Reflex::Type type_3028 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<short,std::allocator<short> >"));
  ::Reflex::Type type_3990 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Bit_const_iterator>"));
  ::Reflex::Type type_2955 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_ostream<char,std::char_traits<char> >"));
  ::Reflex::Type type_11031 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<int> >"));
  ::Reflex::Type type_3038 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<double,std::allocator<double> >"));
  ::Reflex::Type type_11022 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<long> >"));
  ::Reflex::Type type_11024 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<char> >"));
  ::Reflex::Type type_11015 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<float> >"));
  ::Reflex::Type type_11023 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<short> >"));
  ::Reflex::Type type_11033 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<double> >"));
  ::Reflex::Type type_3041 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TString,std::allocator<TString> >"));
  ::Reflex::Type type_11036 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<TString> >"));
  ::Reflex::Type type_3119 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >"));
  ::Reflex::Type type_10876 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<int*,std::vector<int> >"));
  ::Reflex::Type type_11021 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<long long> >"));
  ::Reflex::Type type_3026 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long long,std::allocator<long long> >"));
  ::Reflex::Type type_10858 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<long*,std::vector<long> >"));
  ::Reflex::Type type_10862 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::vector<char> >"));
  ::Reflex::Type type_11038 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooArgSet*> >"));
  ::Reflex::Type type_3747 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,int> >"));
  ::Reflex::Type type_11040 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooAbsArg*> >"));
  ::Reflex::Type type_10844 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<float*,std::vector<float> >"));
  ::Reflex::Type type_11018 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned int> >"));
  ::Reflex::Type type_10860 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<short*,std::vector<short> >"));
  ::Reflex::Type type_3043 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> >"));
  ::Reflex::Type type_3045 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> >"));
  ::Reflex::Type type_3358 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<int,RooArgSet> >"));
  ::Reflex::Type type_11017 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned long> >"));
  ::Reflex::Type type_11020 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned char> >"));
  ::Reflex::Type type_11025 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooFitResult*> >"));
  ::Reflex::Type type_11029 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooAbsLValue*> >"));
  ::Reflex::Type type_10880 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<double*,std::vector<double> >"));
  ::Reflex::Type type_11019 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned short> >"));
  ::Reflex::Type type_10877 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const int*,std::vector<int> >"));
  ::Reflex::Type type_3486 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_11045 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<TVirtualArray*> >"));
  ::Reflex::Type type_3356 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<int,RooAbsReal*> >"));
  ::Reflex::Type type_11042 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooNormSetCache> >"));
  ::Reflex::Type type_3023 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >"));
  ::Reflex::Type type_10859 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const long*,std::vector<long> >"));
  ::Reflex::Type type_10863 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::vector<char> >"));
  ::Reflex::Type type_10886 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >"));
  ::Reflex::Type type_11035 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooAbsRealLValue*> >"));
  ::Reflex::Type type_11039 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::vector<int> > >"));
  ::Reflex::Type type_10845 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const float*,std::vector<float> >"));
  ::Reflex::Type type_11016 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned long long> >"));
  ::Reflex::Type type_3022 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long,std::allocator<unsigned long> >"));
  ::Reflex::Type type_3025 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned char,std::allocator<unsigned char> >"));
  ::Reflex::Type type_10861 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const short*,std::vector<short> >"));
  ::Reflex::Type type_3030 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> >"));
  ::Reflex::Type type_3034 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsLValue*,std::allocator<RooAbsLValue*> >"));
  ::Reflex::Type type_11037 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::map<int,int> > >"));
  ::Reflex::Type type_11041 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooAbsCacheElement*> >"));
  ::Reflex::Type type_11046 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<ROOT::TSchemaHelper> >"));
  ::Reflex::Type type_10881 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const double*,std::vector<double> >"));
  ::Reflex::Type type_3024 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned short,std::allocator<unsigned short> >"));
  ::Reflex::Type type_10856 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >"));
  ::Reflex::Type type_11028 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::vector<double> > >"));
  ::Reflex::Type type_11034 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<const RooAbsBinning*> >"));
  ::Reflex::Type type_11030 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::vector<double>*> >"));
  ::Reflex::Type type_3050 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> >"));
  ::Reflex::Type type_3352 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> >"));
  ::Reflex::Type type_3047 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> >"));
  ::Reflex::Type type_10887 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const TString*,std::vector<TString> >"));
  ::Reflex::Type type_10890 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >"));
  ::Reflex::Type type_10894 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >"));
  ::Reflex::Type type_11027 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::map<void*,double> > >"));
  ::Reflex::Type type_11014 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooCubicSplineKnot::S_jk> >"));
  ::Reflex::Type type_3044 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > >"));
  ::Reflex::Type type_10850 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_10857 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> >"));
  ::Reflex::Type type_11032 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<double,TString> > >"));
  ::Reflex::Type type_3040 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> >"));
  ::Reflex::Type type_3042 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > >"));
  ::Reflex::Type type_11043 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<RooMsgService::StreamConfig> >"));
  ::Reflex::Type type_3021 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long long,std::allocator<unsigned long long> >"));
  ::Reflex::Type type_10848 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >"));
  ::Reflex::Type type_10854 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >"));
  ::Reflex::Type type_10864 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >"));
  ::Reflex::Type type_3103 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_10872 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >"));
  ::Reflex::Type type_10891 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooArgSet* const*,std::vector<RooArgSet*> >"));
  ::Reflex::Type type_10895 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsArg* const*,std::vector<RooAbsArg*> >"));
  ::Reflex::Type type_10852 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >"));
  ::Reflex::Type type_3046 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> >"));
  ::Reflex::Type type_10904 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >"));
  ::Reflex::Type type_3051 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> >"));
  ::Reflex::Type type_3935 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<int*,std::vector<int> > >"));
  ::Reflex::Type type_3691 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_3033 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > >"));
  ::Reflex::Type type_3354 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> >"));
  ::Reflex::Type type_10851 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_3039 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> >"));
  ::Reflex::Type type_3035 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> >"));
  ::Reflex::Type type_10898 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >"));
  ::Reflex::Type type_3909 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<long*,std::vector<long> > >"));
  ::Reflex::Type type_3913 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::vector<char> > >"));
  ::Reflex::Type type_10849 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >"));
  ::Reflex::Type type_10855 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> >"));
  ::Reflex::Type type_10865 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooFitResult* const*,std::vector<RooFitResult*> >"));
  ::Reflex::Type type_10873 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsLValue* const*,std::vector<RooAbsLValue*> >"));
  ::Reflex::Type type_3895 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<float*,std::vector<float> > >"));
  ::Reflex::Type type_3911 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<short*,std::vector<short> > >"));
  ::Reflex::Type type_10892 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >"));
  ::Reflex::Type type_10853 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >"));
  ::Reflex::Type type_10884 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >"));
  ::Reflex::Type type_10905 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TVirtualArray* const*,std::vector<TVirtualArray*> >"));
  ::Reflex::Type type_3941 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<double*,std::vector<double> > >"));
  ::Reflex::Type type_3934 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const int*,std::vector<int> > >"));
  ::Reflex::Type type_3032 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > >"));
  ::Reflex::Type type_10888 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >"));
  ::Reflex::Type type_10846 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >"));
  ::Reflex::Type type_10899 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooNormSetCache*,std::vector<RooNormSetCache> >"));
  ::Reflex::Type type_3908 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const long*,std::vector<long> > >"));
  ::Reflex::Type type_3912 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::vector<char> > >"));
  ::Reflex::Type type_3951 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TString*,std::vector<TString> > >"));
  ::Reflex::Type type_11044 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_3019 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> >"));
  ::Reflex::Type type_10896 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >"));
  ::Reflex::Type type_10906 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >"));
  ::Reflex::Type type_3894 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const float*,std::vector<float> > >"));
  ::Reflex::Type type_3910 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const short*,std::vector<short> > >"));
  ::Reflex::Type type_10870 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >"));
  ::Reflex::Type type_10893 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >"));
  ::Reflex::Type type_10882 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >"));
  ::Reflex::Type type_10874 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >"));
  ::Reflex::Type type_10885 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsRealLValue* const*,std::vector<RooAbsRealLValue*> >"));
  ::Reflex::Type type_3940 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const double*,std::vector<double> > >"));
  ::Reflex::Type type_3907 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<long long*,std::vector<long long> > >"));
  ::Reflex::Type type_3037 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > >"));
  ::Reflex::Type type_10889 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::map<int,int>*,std::vector<std::map<int,int> > >"));
  ::Reflex::Type type_10847 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> >"));
  ::Reflex::Type type_3950 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const TString*,std::vector<TString> > >"));
  ::Reflex::Type type_3955 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> > >"));
  ::Reflex::Type type_3973 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> > >"));
  ::Reflex::Type type_10897 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooAbsCacheElement* const*,std::vector<RooAbsCacheElement*> >"));
  ::Reflex::Type type_3048 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> >"));
  ::Reflex::Type type_10907 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >"));
  ::Reflex::Type type_10868 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >"));
  ::Reflex::Type type_10871 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > >"));
  ::Reflex::Type type_10883 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooAbsBinning* const*,std::vector<const RooAbsBinning*> >"));
  ::Reflex::Type type_10875 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<double>* const*,std::vector<std::vector<double>*> >"));
  ::Reflex::Type type_3901 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_3906 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> > >"));
  ::Reflex::Type type_10842 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >"));
  ::Reflex::Type type_3899 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> > >"));
  ::Reflex::Type type_3905 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> > >"));
  ::Reflex::Type type_3915 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> > >"));
  ::Reflex::Type type_3931 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> > >"));
  ::Reflex::Type type_3954 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooArgSet* const*,std::vector<RooArgSet*> > >"));
  ::Reflex::Type type_3972 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsArg* const*,std::vector<RooAbsArg*> > >"));
  ::Reflex::Type type_3903 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> > >"));
  ::Reflex::Type type_10869 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::map<void*,double>*,std::vector<std::map<void*,double> > >"));
  ::Reflex::Type type_10878 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >"));
  ::Reflex::Type type_4003 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> > >"));
  ::Reflex::Type type_3900 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_3977 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> > >"));
  ::Reflex::Type type_10843 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >"));
  ::Reflex::Type type_10900 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >"));
  ::Reflex::Type type_3898 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> > >"));
  ::Reflex::Type type_3904 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> > >"));
  ::Reflex::Type type_3914 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooFitResult* const*,std::vector<RooFitResult*> > >"));
  ::Reflex::Type type_3930 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsLValue* const*,std::vector<RooAbsLValue*> > >"));
  ::Reflex::Type type_3957 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_3902 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> > >"));
  ::Reflex::Type type_10879 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<double,TString>*,std::vector<std::pair<double,TString> > >"));
  ::Reflex::Type type_3947 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> > >"));
  ::Reflex::Type type_4002 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TVirtualArray* const*,std::vector<TVirtualArray*> > >"));
  ::Reflex::Type type_11026 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_3953 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > > >"));
  ::Reflex::Type type_3897 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> > >"));
  ::Reflex::Type type_3976 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooNormSetCache*,std::vector<RooNormSetCache> > >"));
  ::Reflex::Type type_10901 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >"));
  ::Reflex::Type type_3975 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> > >"));
  ::Reflex::Type type_4005 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> > >"));
  ::Reflex::Type type_3929 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > > >"));
  ::Reflex::Type type_3956 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_3945 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> > >"));
  ::Reflex::Type type_3933 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> > >"));
  ::Reflex::Type type_3946 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsRealLValue* const*,std::vector<RooAbsRealLValue*> > >"));
  ::Reflex::Type type_3952 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::map<int,int>*,std::vector<std::map<int,int> > > >"));
  ::Reflex::Type type_3896 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> > >"));
  ::Reflex::Type type_3049 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_3974 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooAbsCacheElement* const*,std::vector<RooAbsCacheElement*> > >"));
  ::Reflex::Type type_4004 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> > >"));
  ::Reflex::Type type_3919 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > > >"));
  ::Reflex::Type type_3928 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > > >"));
  ::Reflex::Type type_3944 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooAbsBinning* const*,std::vector<const RooAbsBinning*> > >"));
  ::Reflex::Type type_3932 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<double>* const*,std::vector<std::vector<double>*> > >"));
  ::Reflex::Type type_3893 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> > >"));
  ::Reflex::Type type_3918 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::map<void*,double>*,std::vector<std::map<void*,double> > > >"));
  ::Reflex::Type type_3939 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > > >"));
  ::Reflex::Type type_3892 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> > >"));
  ::Reflex::Type type_10902 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_3983 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> > >"));
  ::Reflex::Type type_3938 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<double,TString>*,std::vector<std::pair<double,TString> > > >"));
  ::Reflex::Type type_10903 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_3982 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> > >"));
  ::Reflex::Type type_3995 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > > >"));
  ::Reflex::Type type_3994 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > > >"));
  ::Reflex::Type type_3031 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_10866 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_10867 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_3917 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_3916 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_27657 = ::Reflex::ReferenceBuilder(type_12);
  ::Reflex::Type type_12c = ::Reflex::ConstBuilder(type_12);
  ::Reflex::Type type_27658 = ::Reflex::ReferenceBuilder(type_12c);
  ::Reflex::Type type_1039c = ::Reflex::ConstBuilder(type_1039);
  ::Reflex::Type type_4128 = ::Reflex::PointerBuilder(type_1039c);
  ::Reflex::Type type_27659 = ::Reflex::ReferenceBuilder(type_48);
  ::Reflex::Type type_27660 = ::Reflex::ReferenceBuilder(type_2525);
  ::Reflex::Type type_25463 = ::Reflex::PointerBuilder(type_1129);
  ::Reflex::Type type_8018 = ::Reflex::PointerBuilder(type_2058);
  ::Reflex::Type type_2654 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Version_t"), type_196);
  ::Reflex::Type type_27661 = ::Reflex::ReferenceBuilder(type_434);
  ::Reflex::Type type_6045 = ::Reflex::ReferenceBuilder(type_2929);
  ::Reflex::Type type_2823c = ::Reflex::ConstBuilder(type_2823);
  ::Reflex::Type type_27745 = ::Reflex::ReferenceBuilder(type_2823c);
  ::Reflex::Type type_130c = ::Reflex::ConstBuilder(type_130);
  ::Reflex::Type type_27746 = ::Reflex::ReferenceBuilder(type_130c);
  ::Reflex::Type type_27747 = ::Reflex::ReferenceBuilder(type_130);
  ::Reflex::Type type_27748 = ::Reflex::PointerBuilder(type_130);
  ::Reflex::Type type_2317 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Double_t"), type_694);
  ::Reflex::Type type_1309 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_141);
  ::Reflex::Type type_27678 = ::Reflex::ReferenceBuilder(type_1126);
  ::Reflex::Type type_668 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Bool_t"), type_667);
  ::Reflex::Type type_1126c = ::Reflex::ConstBuilder(type_1126);
  ::Reflex::Type type_27673 = ::Reflex::ReferenceBuilder(type_1126c);
  ::Reflex::Type type_27749 = ::Reflex::PointerBuilder(type_2993);
  ::Reflex::Type type_27750 = ::Reflex::ReferenceBuilder(type_1420);
  ::Reflex::Type type_27675 = ::Reflex::PointerBuilder(type_1126c);
  ::Reflex::Type type_2834 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("UInt_t"), type_211);
  ::Reflex::Type type_27860 = ::Reflex::ReferenceBuilder(type_259);
  ::Reflex::Type type_259c = ::Reflex::ConstBuilder(type_259);
  ::Reflex::Type type_27861 = ::Reflex::ReferenceBuilder(type_259c);
  ::Reflex::Type type_27862 = ::Reflex::ReferenceBuilder(type_2033);
  ::Reflex::Type type_1962c = ::Reflex::ConstBuilder(type_1962);
  ::Reflex::Type type_9885 = ::Reflex::ReferenceBuilder(type_1962c);
  ::Reflex::Type type_27867 = ::Reflex::ReferenceBuilder(type_266);
  ::Reflex::Type type_266c = ::Reflex::ConstBuilder(type_266);
  ::Reflex::Type type_27868 = ::Reflex::ReferenceBuilder(type_266c);
  ::Reflex::Type type_27872 = ::Reflex::ReferenceBuilder(type_286);
  ::Reflex::Type type_286c = ::Reflex::ConstBuilder(type_286);
  ::Reflex::Type type_27873 = ::Reflex::ReferenceBuilder(type_286c);
  ::Reflex::Type type_27887 = ::Reflex::ReferenceBuilder(type_324);
  ::Reflex::Type type_324c = ::Reflex::ConstBuilder(type_324);
  ::Reflex::Type type_27888 = ::Reflex::ReferenceBuilder(type_324c);
  ::Reflex::Type type_2191c = ::Reflex::ConstBuilder(type_2191);
  ::Reflex::Type type_27889 = ::Reflex::ReferenceBuilder(type_2191c);
  ::Reflex::Type type_2021c = ::Reflex::ConstBuilder(type_2021);
  ::Reflex::Type type_27674 = ::Reflex::PointerBuilder(type_2021c);
  ::Reflex::Type type_2826c = ::Reflex::ConstBuilder(type_2826);
  ::Reflex::Type type_27890 = ::Reflex::ReferenceBuilder(type_2826c);
  ::Reflex::Type type_2172c = ::Reflex::ConstBuilder(type_2172);
  ::Reflex::Type type_27672 = ::Reflex::ReferenceBuilder(type_2172c);
  ::Reflex::Type type_27892 = ::Reflex::ReferenceBuilder(type_327);
  ::Reflex::Type type_327c = ::Reflex::ConstBuilder(type_327);
  ::Reflex::Type type_27893 = ::Reflex::ReferenceBuilder(type_327c);
  ::Reflex::Type type_2841c = ::Reflex::ConstBuilder(type_2841);
  ::Reflex::Type type_27948 = ::Reflex::ReferenceBuilder(type_2841c);
  ::Reflex::Type type_449c = ::Reflex::ConstBuilder(type_449);
  ::Reflex::Type type_27949 = ::Reflex::ReferenceBuilder(type_449c);
  ::Reflex::Type type_27950 = ::Reflex::ReferenceBuilder(type_449);
  ::Reflex::Type type_27951 = ::Reflex::PointerBuilder(type_449);
  ::Reflex::Type type_450c = ::Reflex::ConstBuilder(type_450);
  ::Reflex::Type type_27957 = ::Reflex::ReferenceBuilder(type_450c);
  ::Reflex::Type type_27958 = ::Reflex::ReferenceBuilder(type_450);
  ::Reflex::Type type_27959 = ::Reflex::PointerBuilder(type_450);
  ::Reflex::Type type_27972 = ::Reflex::ReferenceBuilder(type_485);
  ::Reflex::Type type_485c = ::Reflex::ConstBuilder(type_485);
  ::Reflex::Type type_27973 = ::Reflex::ReferenceBuilder(type_485c);
  ::Reflex::Type type_28000 = ::Reflex::ReferenceBuilder(type_515);
  ::Reflex::Type type_515c = ::Reflex::ConstBuilder(type_515);
  ::Reflex::Type type_28001 = ::Reflex::ReferenceBuilder(type_515c);
  ::Reflex::Type type_28010 = ::Reflex::ReferenceBuilder(type_577);
  ::Reflex::Type type_577c = ::Reflex::ConstBuilder(type_577);
  ::Reflex::Type type_28011 = ::Reflex::ReferenceBuilder(type_577c);
  ::Reflex::Type type_28061 = ::Reflex::ReferenceBuilder(type_664);
  ::Reflex::Type type_664c = ::Reflex::ConstBuilder(type_664);
  ::Reflex::Type type_28062 = ::Reflex::ReferenceBuilder(type_664c);
  ::Reflex::Type type_27668 = ::Reflex::ReferenceBuilder(type_39);
  ::Reflex::Type type_28063 = ::Reflex::PointerBuilder(type_664);
  ::Reflex::Type type_27671 = ::Reflex::PointerBuilder(type_952);
  ::Reflex::Type type_28025 = ::Reflex::PointerBuilder(type_2525);
  ::Reflex::Type type_2835 = ::Reflex::PointerBuilder(type_1126);
  ::Reflex::Type type_28065 = ::Reflex::ReferenceBuilder(type_670);
  ::Reflex::Type type_670c = ::Reflex::ConstBuilder(type_670);
  ::Reflex::Type type_28066 = ::Reflex::ReferenceBuilder(type_670c);
  ::Reflex::Type type_2525c = ::Reflex::ConstBuilder(type_2525);
  ::Reflex::Type type_27891 = ::Reflex::PointerBuilder(type_2525c);
  ::Reflex::Type type_28078 = ::Reflex::ReferenceBuilder(type_723);
  ::Reflex::Type type_723c = ::Reflex::ConstBuilder(type_723);
  ::Reflex::Type type_28079 = ::Reflex::ReferenceBuilder(type_723c);
  ::Reflex::Type type_28226 = ::Reflex::ReferenceBuilder(type_855);
  ::Reflex::Type type_855c = ::Reflex::ConstBuilder(type_855);
  ::Reflex::Type type_28227 = ::Reflex::ReferenceBuilder(type_855c);
  ::Reflex::Type type_694c = ::Reflex::ConstBuilder(type_694);
  ::Reflex::Type type_17837 = ::Reflex::PointerBuilder(type_694c);
  ::Reflex::Type type_3089c = ::Reflex::ConstBuilder(type_3089);
  ::Reflex::Type type_18881 = ::Reflex::ReferenceBuilder(type_3089c);
  ::Reflex::Type type_1620c = ::Reflex::ConstBuilder(type_1620);
  ::Reflex::Type type_27821 = ::Reflex::ReferenceBuilder(type_1620c);
  ::Reflex::Type type_18879 = ::Reflex::ReferenceBuilder(type_3089);
  ::Reflex::Type type_28133 = ::Reflex::PointerBuilder(type_2823c);
  ::Reflex::Type type_2145 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TVectorD"), type_2144);
  ::Reflex::Type type_28228 = ::Reflex::ReferenceBuilder(type_2145);
  ::Reflex::Type type_146 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_145);
  ::Reflex::Type type_28229 = ::Reflex::ReferenceBuilder(type_146);
  ::Reflex::Type type_28292 = ::Reflex::ReferenceBuilder(type_995);
  ::Reflex::Type type_995c = ::Reflex::ConstBuilder(type_995);
  ::Reflex::Type type_28293 = ::Reflex::ReferenceBuilder(type_995c);
  ::Reflex::Type type_2579c = ::Reflex::ConstBuilder(type_2579);
  ::Reflex::Type type_28294 = ::Reflex::ReferenceBuilder(type_2579c);
  ::Reflex::Type type_6054 = ::Reflex::ReferenceBuilder(type_1962);
  ::Reflex::Type type_2013 = ::Reflex::PointerBuilder(type_1620);
  ::Reflex::Type type_28309 = ::Reflex::ReferenceBuilder(type_1073);
  ::Reflex::Type type_1073c = ::Reflex::ConstBuilder(type_1073);
  ::Reflex::Type type_28310 = ::Reflex::ReferenceBuilder(type_1073c);
  ::Reflex::Type type_28429 = ::Reflex::ReferenceBuilder(type_1305);
  ::Reflex::Type type_1305c = ::Reflex::ConstBuilder(type_1305);
  ::Reflex::Type type_28430 = ::Reflex::ReferenceBuilder(type_1305c);
  ::Reflex::Type type_19390 = ::Reflex::PointerBuilder(type_1420);
  ::Reflex::Type type_28479 = ::Reflex::ReferenceBuilder(type_1382);
  ::Reflex::Type type_1382c = ::Reflex::ConstBuilder(type_1382);
  ::Reflex::Type type_28480 = ::Reflex::ReferenceBuilder(type_1382c);
  ::Reflex::Type type_27751 = ::Reflex::ReferenceBuilder(type_2525c);
  ::Reflex::Type type_2317c = ::Reflex::ConstBuilder(type_2317);
  ::Reflex::Type type_27725 = ::Reflex::PointerBuilder(type_2317c);
  ::Reflex::Type type_28514 = ::Reflex::ReferenceBuilder(type_1438);
  ::Reflex::Type type_1438c = ::Reflex::ConstBuilder(type_1438);
  ::Reflex::Type type_28515 = ::Reflex::ReferenceBuilder(type_1438c);
  ::Reflex::Type type_27670 = ::Reflex::ReferenceBuilder(type_1113);
  ::Reflex::Type type_28516 = ::Reflex::ReferenceBuilder(type_1672);
  ::Reflex::Type type_28523 = ::Reflex::PointerBuilder(type_2751);
  ::Reflex::Type type_28524 = ::Reflex::PointerBuilder(type_1382);
  ::Reflex::Type type_2786 = ::Reflex::PointerBuilder(type_1039);
  ::Reflex::Type type_22885 = ::Reflex::PointerBuilder(type_1113);
  ::Reflex::Type type_1473c = ::Reflex::ConstBuilder(type_1473);
  ::Reflex::Type type_28525 = ::Reflex::ReferenceBuilder(type_1473c);
  ::Reflex::Type type_28526 = ::Reflex::ReferenceBuilder(type_1473);
  ::Reflex::Type type_28527 = ::Reflex::ReferenceBuilder(type_2970);
  ::Reflex::Type type_2970c = ::Reflex::ConstBuilder(type_2970);
  ::Reflex::Type type_28528 = ::Reflex::ReferenceBuilder(type_2970c);
  ::Reflex::Type type_1576c = ::Reflex::ConstBuilder(type_1576);
  ::Reflex::Type type_28558 = ::Reflex::ReferenceBuilder(type_1576c);
  ::Reflex::Type type_28559 = ::Reflex::ReferenceBuilder(type_1576);
  ::Reflex::Type type_28560 = ::Reflex::PointerBuilder(type_1576);
  ::Reflex::Type type_28595 = ::Reflex::ReferenceBuilder(type_1630);
  ::Reflex::Type type_1630c = ::Reflex::ConstBuilder(type_1630);
  ::Reflex::Type type_28596 = ::Reflex::ReferenceBuilder(type_1630c);
  ::Reflex::Type type_27917 = ::Reflex::PointerBuilder(type_2033);
  ::Reflex::Type type_1672c = ::Reflex::ConstBuilder(type_1672);
  ::Reflex::Type type_28608 = ::Reflex::ReferenceBuilder(type_1672c);
  ::Reflex::Type type_3635c = ::Reflex::ConstBuilder(type_3635);
  ::Reflex::Type type_22775 = ::Reflex::ReferenceBuilder(type_3635c);
  ::Reflex::Type type_1675c = ::Reflex::ConstBuilder(type_1675);
  ::Reflex::Type type_28609 = ::Reflex::ReferenceBuilder(type_1675c);
  ::Reflex::Type type_28610 = ::Reflex::ReferenceBuilder(type_1675);
  ::Reflex::Type type_28611 = ::Reflex::ReferenceBuilder(type_1679);
  ::Reflex::Type type_1679c = ::Reflex::ConstBuilder(type_1679);
  ::Reflex::Type type_28612 = ::Reflex::ReferenceBuilder(type_1679c);
  ::Reflex::Type type_30948 = ::Reflex::ReferenceBuilder(type_1744);
  ::Reflex::Type type_1744c = ::Reflex::ConstBuilder(type_1744);
  ::Reflex::Type type_30949 = ::Reflex::ReferenceBuilder(type_1744c);
  ::Reflex::Type type_30982 = ::Reflex::ReferenceBuilder(type_1831);
  ::Reflex::Type type_1831c = ::Reflex::ConstBuilder(type_1831);
  ::Reflex::Type type_30983 = ::Reflex::ReferenceBuilder(type_1831c);
  ::Reflex::Type type_28509 = ::Reflex::ReferenceBuilder(type_1620);
  ::Reflex::Type type_30990 = ::Reflex::ReferenceBuilder(type_1880);
  ::Reflex::Type type_1880c = ::Reflex::ConstBuilder(type_1880);
  ::Reflex::Type type_30991 = ::Reflex::ReferenceBuilder(type_1880c);
  ::Reflex::Type type_1909c = ::Reflex::ConstBuilder(type_1909);
  ::Reflex::Type type_30996 = ::Reflex::ReferenceBuilder(type_1909c);
  ::Reflex::Type type_30997 = ::Reflex::ReferenceBuilder(type_1909);
  ::Reflex::Type type_30998 = ::Reflex::ReferenceBuilder(type_1927);
  ::Reflex::Type type_1927c = ::Reflex::ConstBuilder(type_1927);
  ::Reflex::Type type_30999 = ::Reflex::ReferenceBuilder(type_1927c);
  ::Reflex::Type type_31002 = ::Reflex::ReferenceBuilder(type_1939);
  ::Reflex::Type type_1939c = ::Reflex::ConstBuilder(type_1939);
  ::Reflex::Type type_31003 = ::Reflex::ReferenceBuilder(type_1939c);
  ::Reflex::Type type_31004 = ::Reflex::PointerBuilder(type_1939);
  ::Reflex::Type type_17841 = ::Reflex::ReferenceBuilder(type_694c);
  ::Reflex::Type type_17839 = ::Reflex::ReferenceBuilder(type_694);
  ::Reflex::Type type_31005 = ::Reflex::ReferenceBuilder(type_1940);
  ::Reflex::Type type_1940c = ::Reflex::ConstBuilder(type_1940);
  ::Reflex::Type type_31006 = ::Reflex::ReferenceBuilder(type_1940c);
  ::Reflex::Type type_31007 = ::Reflex::PointerBuilder(type_1940);
  ::Reflex::Type type_102c = ::Reflex::ConstBuilder(type_102);
  ::Reflex::Type type_17971 = ::Reflex::ReferenceBuilder(type_102c);
  ::Reflex::Type type_17969 = ::Reflex::ReferenceBuilder(type_102);
  ::Reflex::Type type_31008 = ::Reflex::ReferenceBuilder(type_1941);
  ::Reflex::Type type_1941c = ::Reflex::ConstBuilder(type_1941);
  ::Reflex::Type type_31009 = ::Reflex::ReferenceBuilder(type_1941c);
  ::Reflex::Type type_31010 = ::Reflex::PointerBuilder(type_1941);
  ::Reflex::Type type_820c = ::Reflex::ConstBuilder(type_820);
  ::Reflex::Type type_18036 = ::Reflex::ReferenceBuilder(type_820c);
  ::Reflex::Type type_18034 = ::Reflex::ReferenceBuilder(type_820);
  ::Reflex::Type type_31011 = ::Reflex::ReferenceBuilder(type_1942);
  ::Reflex::Type type_1942c = ::Reflex::ConstBuilder(type_1942);
  ::Reflex::Type type_31012 = ::Reflex::ReferenceBuilder(type_1942c);
  ::Reflex::Type type_31013 = ::Reflex::PointerBuilder(type_1942);
  ::Reflex::Type type_167c = ::Reflex::ConstBuilder(type_167);
  ::Reflex::Type type_18101 = ::Reflex::ReferenceBuilder(type_167c);
  ::Reflex::Type type_18099 = ::Reflex::ReferenceBuilder(type_167);
  ::Reflex::Type type_31014 = ::Reflex::ReferenceBuilder(type_1943);
  ::Reflex::Type type_1943c = ::Reflex::ConstBuilder(type_1943);
  ::Reflex::Type type_31015 = ::Reflex::ReferenceBuilder(type_1943c);
  ::Reflex::Type type_31016 = ::Reflex::PointerBuilder(type_1943);
  ::Reflex::Type type_211c = ::Reflex::ConstBuilder(type_211);
  ::Reflex::Type type_18166 = ::Reflex::ReferenceBuilder(type_211c);
  ::Reflex::Type type_18164 = ::Reflex::ReferenceBuilder(type_211);
  ::Reflex::Type type_31017 = ::Reflex::ReferenceBuilder(type_1944);
  ::Reflex::Type type_1944c = ::Reflex::ConstBuilder(type_1944);
  ::Reflex::Type type_31018 = ::Reflex::ReferenceBuilder(type_1944c);
  ::Reflex::Type type_31019 = ::Reflex::PointerBuilder(type_1944);
  ::Reflex::Type type_311c = ::Reflex::ConstBuilder(type_311);
  ::Reflex::Type type_18231 = ::Reflex::ReferenceBuilder(type_311c);
  ::Reflex::Type type_18229 = ::Reflex::ReferenceBuilder(type_311);
  ::Reflex::Type type_31020 = ::Reflex::ReferenceBuilder(type_1945);
  ::Reflex::Type type_1945c = ::Reflex::ConstBuilder(type_1945);
  ::Reflex::Type type_31021 = ::Reflex::ReferenceBuilder(type_1945c);
  ::Reflex::Type type_31022 = ::Reflex::PointerBuilder(type_1945);
  ::Reflex::Type type_291c = ::Reflex::ConstBuilder(type_291);
  ::Reflex::Type type_18296 = ::Reflex::ReferenceBuilder(type_291c);
  ::Reflex::Type type_18294 = ::Reflex::ReferenceBuilder(type_291);
  ::Reflex::Type type_31023 = ::Reflex::ReferenceBuilder(type_1946);
  ::Reflex::Type type_1946c = ::Reflex::ConstBuilder(type_1946);
  ::Reflex::Type type_31024 = ::Reflex::ReferenceBuilder(type_1946c);
  ::Reflex::Type type_31025 = ::Reflex::PointerBuilder(type_1946);
  ::Reflex::Type type_2017c = ::Reflex::ConstBuilder(type_2017);
  ::Reflex::Type type_18361 = ::Reflex::ReferenceBuilder(type_2017c);
  ::Reflex::Type type_18359 = ::Reflex::ReferenceBuilder(type_2017);
  ::Reflex::Type type_31026 = ::Reflex::ReferenceBuilder(type_1947);
  ::Reflex::Type type_1947c = ::Reflex::ConstBuilder(type_1947);
  ::Reflex::Type type_31027 = ::Reflex::ReferenceBuilder(type_1947c);
  ::Reflex::Type type_31028 = ::Reflex::PointerBuilder(type_1947);
  ::Reflex::Type type_194c = ::Reflex::ConstBuilder(type_194);
  ::Reflex::Type type_18426 = ::Reflex::ReferenceBuilder(type_194c);
  ::Reflex::Type type_18424 = ::Reflex::ReferenceBuilder(type_194);
  ::Reflex::Type type_31029 = ::Reflex::ReferenceBuilder(type_1948);
  ::Reflex::Type type_1948c = ::Reflex::ConstBuilder(type_1948);
  ::Reflex::Type type_31030 = ::Reflex::ReferenceBuilder(type_1948c);
  ::Reflex::Type type_31031 = ::Reflex::PointerBuilder(type_1948);
  ::Reflex::Type type_141c = ::Reflex::ConstBuilder(type_141);
  ::Reflex::Type type_18491 = ::Reflex::ReferenceBuilder(type_141c);
  ::Reflex::Type type_18489 = ::Reflex::ReferenceBuilder(type_141);
  ::Reflex::Type type_31032 = ::Reflex::ReferenceBuilder(type_1949);
  ::Reflex::Type type_1949c = ::Reflex::ConstBuilder(type_1949);
  ::Reflex::Type type_31033 = ::Reflex::ReferenceBuilder(type_1949c);
  ::Reflex::Type type_31034 = ::Reflex::PointerBuilder(type_1949);
  ::Reflex::Type type_196c = ::Reflex::ConstBuilder(type_196);
  ::Reflex::Type type_18556 = ::Reflex::ReferenceBuilder(type_196c);
  ::Reflex::Type type_18554 = ::Reflex::ReferenceBuilder(type_196);
  ::Reflex::Type type_31035 = ::Reflex::ReferenceBuilder(type_1950);
  ::Reflex::Type type_1950c = ::Reflex::ConstBuilder(type_1950);
  ::Reflex::Type type_31036 = ::Reflex::ReferenceBuilder(type_1950c);
  ::Reflex::Type type_31037 = ::Reflex::PointerBuilder(type_1950);
  ::Reflex::Type type_18620 = ::Reflex::ReferenceBuilder(type_1039c);
  ::Reflex::Type type_18618 = ::Reflex::ReferenceBuilder(type_1039);
  ::Reflex::Type type_31138 = ::Reflex::ReferenceBuilder(type_2072);
  ::Reflex::Type type_2072c = ::Reflex::ConstBuilder(type_2072);
  ::Reflex::Type type_31139 = ::Reflex::ReferenceBuilder(type_2072c);
  ::Reflex::Type type_22352 = ::Reflex::PointerBuilder(type_2494);
  ::Reflex::Type type_18675 = ::Reflex::PointerBuilder(type_2041);
  ::Reflex::Type type_28187 = ::Reflex::PointerBuilder(type_844);
  ::Reflex::Type type_27699 = ::Reflex::PointerBuilder(type_1147);
  ::Reflex::Type type_31140 = ::Reflex::ReferenceBuilder(type_2078);
  ::Reflex::Type type_2078c = ::Reflex::ConstBuilder(type_2078);
  ::Reflex::Type type_31141 = ::Reflex::ReferenceBuilder(type_2078c);
  ::Reflex::Type type_2007c = ::Reflex::ConstBuilder(type_2007);
  ::Reflex::Type type_27721 = ::Reflex::ReferenceBuilder(type_2007c);
  ::Reflex::Type type_31142 = ::Reflex::PointerBuilder(type_2278);
  ::Reflex::Type type_28605 = ::Reflex::ReferenceBuilder(type_1656);
  ::Reflex::Type type_3157 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_3147);
  ::Reflex::Type type_3157c = ::Reflex::ConstBuilder(type_3157);
  ::Reflex::Type type_27919 = ::Reflex::PointerBuilder(type_2021);
  ::Reflex::Type type_6056 = ::Reflex::ReferenceBuilder(type_2743);
  ::Reflex::Type type_31153 = ::Reflex::ReferenceBuilder(type_2117);
  ::Reflex::Type type_2117c = ::Reflex::ConstBuilder(type_2117);
  ::Reflex::Type type_31154 = ::Reflex::ReferenceBuilder(type_2117c);
  ::Reflex::Type type_1819c = ::Reflex::ConstBuilder(type_1819);
  ::Reflex::Type type_30976 = ::Reflex::PointerBuilder(type_1819c);
  ::Reflex::Type type_800c = ::Reflex::ConstBuilder(type_800);
  ::Reflex::Type type_31155 = ::Reflex::PointerBuilder(type_800c);
  ::Reflex::Type type_2165c = ::Reflex::ConstBuilder(type_2165);
  ::Reflex::Type type_31283 = ::Reflex::ReferenceBuilder(type_2165c);
  ::Reflex::Type type_31284 = ::Reflex::ReferenceBuilder(type_2165);
  ::Reflex::Type type_31286 = ::Reflex::ReferenceBuilder(type_2200);
  ::Reflex::Type type_2200c = ::Reflex::ConstBuilder(type_2200);
  ::Reflex::Type type_31287 = ::Reflex::ReferenceBuilder(type_2200c);
  ::Reflex::Type type_2956 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ostream"), type_2955);
  ::Reflex::Type type_9883 = ::Reflex::ReferenceBuilder(type_2956);
  ::Reflex::Type type_2203c = ::Reflex::ConstBuilder(type_2203);
  ::Reflex::Type type_31320 = ::Reflex::ReferenceBuilder(type_2203c);
  ::Reflex::Type type_31321 = ::Reflex::PointerBuilder(type_2203);
  ::Reflex::Type type_31322 = ::Reflex::ReferenceBuilder(type_2203);
  ::Reflex::Type type_13575c = ::Reflex::ConstBuilder(type_13575);
  ::Reflex::Type type_2204c = ::Reflex::ConstBuilder(type_2204);
  ::Reflex::Type type_31356 = ::Reflex::ReferenceBuilder(type_2204c);
  ::Reflex::Type type_31357 = ::Reflex::PointerBuilder(type_2204);
  ::Reflex::Type type_31358 = ::Reflex::ReferenceBuilder(type_2204);
  ::Reflex::Type type_13600c = ::Reflex::ConstBuilder(type_13600);
  ::Reflex::Type type_2205c = ::Reflex::ConstBuilder(type_2205);
  ::Reflex::Type type_31392 = ::Reflex::ReferenceBuilder(type_2205c);
  ::Reflex::Type type_31393 = ::Reflex::PointerBuilder(type_2205);
  ::Reflex::Type type_31394 = ::Reflex::ReferenceBuilder(type_2205);
  ::Reflex::Type type_13625c = ::Reflex::ConstBuilder(type_13625);
  ::Reflex::Type type_2206c = ::Reflex::ConstBuilder(type_2206);
  ::Reflex::Type type_31428 = ::Reflex::ReferenceBuilder(type_2206c);
  ::Reflex::Type type_31429 = ::Reflex::PointerBuilder(type_2206);
  ::Reflex::Type type_31430 = ::Reflex::ReferenceBuilder(type_2206);
  ::Reflex::Type type_13650c = ::Reflex::ConstBuilder(type_13650);
  ::Reflex::Type type_2207c = ::Reflex::ConstBuilder(type_2207);
  ::Reflex::Type type_31464 = ::Reflex::ReferenceBuilder(type_2207c);
  ::Reflex::Type type_31465 = ::Reflex::PointerBuilder(type_2207);
  ::Reflex::Type type_31466 = ::Reflex::ReferenceBuilder(type_2207);
  ::Reflex::Type type_13675c = ::Reflex::ConstBuilder(type_13675);
  ::Reflex::Type type_2208c = ::Reflex::ConstBuilder(type_2208);
  ::Reflex::Type type_31500 = ::Reflex::ReferenceBuilder(type_2208c);
  ::Reflex::Type type_31501 = ::Reflex::PointerBuilder(type_2208);
  ::Reflex::Type type_31502 = ::Reflex::ReferenceBuilder(type_2208);
  ::Reflex::Type type_13700c = ::Reflex::ConstBuilder(type_13700);
  ::Reflex::Type type_2209c = ::Reflex::ConstBuilder(type_2209);
  ::Reflex::Type type_31536 = ::Reflex::ReferenceBuilder(type_2209c);
  ::Reflex::Type type_31537 = ::Reflex::PointerBuilder(type_2209);
  ::Reflex::Type type_31538 = ::Reflex::ReferenceBuilder(type_2209);
  ::Reflex::Type type_13725c = ::Reflex::ConstBuilder(type_13725);
  ::Reflex::Type type_2210c = ::Reflex::ConstBuilder(type_2210);
  ::Reflex::Type type_31572 = ::Reflex::ReferenceBuilder(type_2210c);
  ::Reflex::Type type_31573 = ::Reflex::PointerBuilder(type_2210);
  ::Reflex::Type type_31574 = ::Reflex::ReferenceBuilder(type_2210);
  ::Reflex::Type type_13750c = ::Reflex::ConstBuilder(type_13750);
  ::Reflex::Type type_2211c = ::Reflex::ConstBuilder(type_2211);
  ::Reflex::Type type_31608 = ::Reflex::ReferenceBuilder(type_2211c);
  ::Reflex::Type type_31609 = ::Reflex::PointerBuilder(type_2211);
  ::Reflex::Type type_31610 = ::Reflex::ReferenceBuilder(type_2211);
  ::Reflex::Type type_13775c = ::Reflex::ConstBuilder(type_13775);
  ::Reflex::Type type_2212c = ::Reflex::ConstBuilder(type_2212);
  ::Reflex::Type type_31644 = ::Reflex::ReferenceBuilder(type_2212c);
  ::Reflex::Type type_31645 = ::Reflex::PointerBuilder(type_2212);
  ::Reflex::Type type_31646 = ::Reflex::ReferenceBuilder(type_2212);
  ::Reflex::Type type_13800c = ::Reflex::ConstBuilder(type_13800);
  ::Reflex::Type type_2213c = ::Reflex::ConstBuilder(type_2213);
  ::Reflex::Type type_31680 = ::Reflex::ReferenceBuilder(type_2213c);
  ::Reflex::Type type_31681 = ::Reflex::PointerBuilder(type_2213);
  ::Reflex::Type type_31682 = ::Reflex::ReferenceBuilder(type_2213);
  ::Reflex::Type type_13825c = ::Reflex::ConstBuilder(type_13825);
  ::Reflex::Type type_2214c = ::Reflex::ConstBuilder(type_2214);
  ::Reflex::Type type_31716 = ::Reflex::ReferenceBuilder(type_2214c);
  ::Reflex::Type type_31717 = ::Reflex::PointerBuilder(type_2214);
  ::Reflex::Type type_31718 = ::Reflex::ReferenceBuilder(type_2214);
  ::Reflex::Type type_13850c = ::Reflex::ConstBuilder(type_13850);
  ::Reflex::Type type_31723 = ::Reflex::ReferenceBuilder(type_2231);
  ::Reflex::Type type_2231c = ::Reflex::ConstBuilder(type_2231);
  ::Reflex::Type type_31724 = ::Reflex::ReferenceBuilder(type_2231c);
  ::Reflex::Type type_31775 = ::Reflex::ReferenceBuilder(type_2502);
  ::Reflex::Type type_2502c = ::Reflex::ConstBuilder(type_2502);
  ::Reflex::Type type_31776 = ::Reflex::ReferenceBuilder(type_2502c);
  ::Reflex::Type type_31840 = ::Reflex::ReferenceBuilder(type_2590);
  ::Reflex::Type type_2590c = ::Reflex::ConstBuilder(type_2590);
  ::Reflex::Type type_31841 = ::Reflex::ReferenceBuilder(type_2590c);
  ::Reflex::Type type_31914 = ::Reflex::ReferenceBuilder(type_2744);
  ::Reflex::Type type_2744c = ::Reflex::ConstBuilder(type_2744);
  ::Reflex::Type type_31915 = ::Reflex::ReferenceBuilder(type_2744c);
  ::Reflex::Type type_31916 = ::Reflex::PointerBuilder(type_2744);
  ::Reflex::Type type_6336 = ::Reflex::PointerBuilder(type_694);
  ::Reflex::Type type_3404 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_167);
  ::Reflex::Type type_3256 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_194);
  ::Reflex::Type type_3676c = ::Reflex::ConstBuilder(type_3676);
  ::Reflex::Type type_32329 = ::Reflex::ReferenceBuilder(type_3676c);
  ::Reflex::Type type_17904 = ::Reflex::ReferenceBuilder(type_7149);
  ::Reflex::Type type_7149c = ::Reflex::ConstBuilder(type_7149);
  ::Reflex::Type type_17906 = ::Reflex::ReferenceBuilder(type_7149c);
  ::Reflex::Type type_17180 = ::Reflex::PointerBuilder(type_7149);
  ::Reflex::Type type_17902 = ::Reflex::PointerBuilder(type_7149c);
  ::Reflex::Type type_3677c = ::Reflex::ConstBuilder(type_3677);
  ::Reflex::Type type_32082 = ::Reflex::ReferenceBuilder(type_3677c);
  ::Reflex::Type type_3090c = ::Reflex::ConstBuilder(type_3090);
  ::Reflex::Type type_32515 = ::Reflex::ReferenceBuilder(type_3090c);
  ::Reflex::Type type_32516 = ::Reflex::ReferenceBuilder(type_3090);
  ::Reflex::Type type_6044 = ::Reflex::PointerBuilder(type_102);
  ::Reflex::Type type_17967 = ::Reflex::PointerBuilder(type_102c);
  ::Reflex::Type type_3679c = ::Reflex::ConstBuilder(type_3679);
  ::Reflex::Type type_32095 = ::Reflex::ReferenceBuilder(type_3679c);
  ::Reflex::Type type_3091c = ::Reflex::ConstBuilder(type_3091);
  ::Reflex::Type type_32518 = ::Reflex::ReferenceBuilder(type_3091c);
  ::Reflex::Type type_32519 = ::Reflex::ReferenceBuilder(type_3091);
  ::Reflex::Type type_17217 = ::Reflex::PointerBuilder(type_820);
  ::Reflex::Type type_18032 = ::Reflex::PointerBuilder(type_820c);
  ::Reflex::Type type_3680c = ::Reflex::ConstBuilder(type_3680);
  ::Reflex::Type type_32108 = ::Reflex::ReferenceBuilder(type_3680c);
  ::Reflex::Type type_3092c = ::Reflex::ConstBuilder(type_3092);
  ::Reflex::Type type_32521 = ::Reflex::ReferenceBuilder(type_3092c);
  ::Reflex::Type type_32522 = ::Reflex::ReferenceBuilder(type_3092);
  ::Reflex::Type type_17236 = ::Reflex::PointerBuilder(type_167);
  ::Reflex::Type type_18097 = ::Reflex::PointerBuilder(type_167c);
  ::Reflex::Type type_3681c = ::Reflex::ConstBuilder(type_3681);
  ::Reflex::Type type_32121 = ::Reflex::ReferenceBuilder(type_3681c);
  ::Reflex::Type type_3093c = ::Reflex::ConstBuilder(type_3093);
  ::Reflex::Type type_32524 = ::Reflex::ReferenceBuilder(type_3093c);
  ::Reflex::Type type_32525 = ::Reflex::ReferenceBuilder(type_3093);
  ::Reflex::Type type_13933 = ::Reflex::PointerBuilder(type_211);
  ::Reflex::Type type_18162 = ::Reflex::PointerBuilder(type_211c);
  ::Reflex::Type type_3682c = ::Reflex::ConstBuilder(type_3682);
  ::Reflex::Type type_32134 = ::Reflex::ReferenceBuilder(type_3682c);
  ::Reflex::Type type_3094c = ::Reflex::ConstBuilder(type_3094);
  ::Reflex::Type type_32527 = ::Reflex::ReferenceBuilder(type_3094c);
  ::Reflex::Type type_32528 = ::Reflex::ReferenceBuilder(type_3094);
  ::Reflex::Type type_4399 = ::Reflex::PointerBuilder(type_311);
  ::Reflex::Type type_18227 = ::Reflex::PointerBuilder(type_311c);
  ::Reflex::Type type_3683c = ::Reflex::ConstBuilder(type_3683);
  ::Reflex::Type type_32147 = ::Reflex::ReferenceBuilder(type_3683c);
  ::Reflex::Type type_3095c = ::Reflex::ConstBuilder(type_3095);
  ::Reflex::Type type_32530 = ::Reflex::ReferenceBuilder(type_3095c);
  ::Reflex::Type type_32531 = ::Reflex::ReferenceBuilder(type_3095);
  ::Reflex::Type type_17291 = ::Reflex::PointerBuilder(type_291);
  ::Reflex::Type type_18292 = ::Reflex::PointerBuilder(type_291c);
  ::Reflex::Type type_3684c = ::Reflex::ConstBuilder(type_3684);
  ::Reflex::Type type_32160 = ::Reflex::ReferenceBuilder(type_3684c);
  ::Reflex::Type type_3096c = ::Reflex::ConstBuilder(type_3096);
  ::Reflex::Type type_32533 = ::Reflex::ReferenceBuilder(type_3096c);
  ::Reflex::Type type_32534 = ::Reflex::ReferenceBuilder(type_3096);
  ::Reflex::Type type_17310 = ::Reflex::PointerBuilder(type_2017);
  ::Reflex::Type type_18357 = ::Reflex::PointerBuilder(type_2017c);
  ::Reflex::Type type_3685c = ::Reflex::ConstBuilder(type_3685);
  ::Reflex::Type type_32173 = ::Reflex::ReferenceBuilder(type_3685c);
  ::Reflex::Type type_3097c = ::Reflex::ConstBuilder(type_3097);
  ::Reflex::Type type_32536 = ::Reflex::ReferenceBuilder(type_3097c);
  ::Reflex::Type type_32537 = ::Reflex::ReferenceBuilder(type_3097);
  ::Reflex::Type type_9454 = ::Reflex::PointerBuilder(type_194);
  ::Reflex::Type type_18422 = ::Reflex::PointerBuilder(type_194c);
  ::Reflex::Type type_3686c = ::Reflex::ConstBuilder(type_3686);
  ::Reflex::Type type_32186 = ::Reflex::ReferenceBuilder(type_3686c);
  ::Reflex::Type type_3098c = ::Reflex::ConstBuilder(type_3098);
  ::Reflex::Type type_32538 = ::Reflex::ReferenceBuilder(type_3098c);
  ::Reflex::Type type_32539 = ::Reflex::ReferenceBuilder(type_3098);
  ::Reflex::Type type_4130 = ::Reflex::PointerBuilder(type_141);
  ::Reflex::Type type_18487 = ::Reflex::PointerBuilder(type_141c);
  ::Reflex::Type type_3687c = ::Reflex::ConstBuilder(type_3687);
  ::Reflex::Type type_32303 = ::Reflex::ReferenceBuilder(type_3687c);
  ::Reflex::Type type_3099c = ::Reflex::ConstBuilder(type_3099);
  ::Reflex::Type type_19594 = ::Reflex::ReferenceBuilder(type_3099c);
  ::Reflex::Type type_19592 = ::Reflex::ReferenceBuilder(type_3099);
  ::Reflex::Type type_17347 = ::Reflex::PointerBuilder(type_196);
  ::Reflex::Type type_18552 = ::Reflex::PointerBuilder(type_196c);
  ::Reflex::Type type_3688c = ::Reflex::ConstBuilder(type_3688);
  ::Reflex::Type type_32199 = ::Reflex::ReferenceBuilder(type_3688c);
  ::Reflex::Type type_3100c = ::Reflex::ConstBuilder(type_3100);
  ::Reflex::Type type_32541 = ::Reflex::ReferenceBuilder(type_3100c);
  ::Reflex::Type type_32542 = ::Reflex::ReferenceBuilder(type_3100);
  ::Reflex::Type type_3689c = ::Reflex::ConstBuilder(type_3689);
  ::Reflex::Type type_32212 = ::Reflex::ReferenceBuilder(type_3689c);
  ::Reflex::Type type_3101c = ::Reflex::ConstBuilder(type_3101);
  ::Reflex::Type type_32543 = ::Reflex::ReferenceBuilder(type_3101c);
  ::Reflex::Type type_32544 = ::Reflex::ReferenceBuilder(type_3101);
  ::Reflex::Type type_17384 = ::Reflex::PointerBuilder(type_18675);
  ::Reflex::Type type_18675c = ::Reflex::ConstBuilder(type_18675);
  ::Reflex::Type type_18682 = ::Reflex::PointerBuilder(type_18675c);
  ::Reflex::Type type_18684 = ::Reflex::ReferenceBuilder(type_18675);
  ::Reflex::Type type_18686 = ::Reflex::ReferenceBuilder(type_18675c);
  ::Reflex::Type type_3690c = ::Reflex::ConstBuilder(type_3690);
  ::Reflex::Type type_32225 = ::Reflex::ReferenceBuilder(type_3690c);
  ::Reflex::Type type_3102c = ::Reflex::ConstBuilder(type_3102);
  ::Reflex::Type type_32546 = ::Reflex::ReferenceBuilder(type_3102c);
  ::Reflex::Type type_32547 = ::Reflex::ReferenceBuilder(type_3102);
  ::Reflex::Type type_17403 = ::Reflex::PointerBuilder(type_3486);
  ::Reflex::Type type_3486c = ::Reflex::ConstBuilder(type_3486);
  ::Reflex::Type type_18747 = ::Reflex::PointerBuilder(type_3486c);
  ::Reflex::Type type_18749 = ::Reflex::ReferenceBuilder(type_3486);
  ::Reflex::Type type_18751 = ::Reflex::ReferenceBuilder(type_3486c);
  ::Reflex::Type type_3691c = ::Reflex::ConstBuilder(type_3691);
  ::Reflex::Type type_32238 = ::Reflex::ReferenceBuilder(type_3691c);
  ::Reflex::Type type_3103c = ::Reflex::ConstBuilder(type_3103);
  ::Reflex::Type type_32549 = ::Reflex::ReferenceBuilder(type_3103c);
  ::Reflex::Type type_32550 = ::Reflex::ReferenceBuilder(type_3103);
  ::Reflex::Type type_17422 = ::Reflex::PointerBuilder(type_3351);
  ::Reflex::Type type_3351c = ::Reflex::ConstBuilder(type_3351);
  ::Reflex::Type type_18812 = ::Reflex::PointerBuilder(type_3351c);
  ::Reflex::Type type_18814 = ::Reflex::ReferenceBuilder(type_3351);
  ::Reflex::Type type_18816 = ::Reflex::ReferenceBuilder(type_3351c);
  ::Reflex::Type type_3692c = ::Reflex::ConstBuilder(type_3692);
  ::Reflex::Type type_32251 = ::Reflex::ReferenceBuilder(type_3692c);
  ::Reflex::Type type_3104c = ::Reflex::ConstBuilder(type_3104);
  ::Reflex::Type type_32552 = ::Reflex::ReferenceBuilder(type_3104c);
  ::Reflex::Type type_32553 = ::Reflex::ReferenceBuilder(type_3104);
  ::Reflex::Type type_17441 = ::Reflex::PointerBuilder(type_3089);
  ::Reflex::Type type_18877 = ::Reflex::PointerBuilder(type_3089c);
  ::Reflex::Type type_3694c = ::Reflex::ConstBuilder(type_3694);
  ::Reflex::Type type_32264 = ::Reflex::ReferenceBuilder(type_3694c);
  ::Reflex::Type type_3105c = ::Reflex::ConstBuilder(type_3105);
  ::Reflex::Type type_32555 = ::Reflex::ReferenceBuilder(type_3105c);
  ::Reflex::Type type_32556 = ::Reflex::ReferenceBuilder(type_3105);
  ::Reflex::Type type_641c = ::Reflex::ConstBuilder(type_641);
  ::Reflex::Type type_18936 = ::Reflex::PointerBuilder(type_641c);
  ::Reflex::Type type_17553 = ::Reflex::PointerBuilder(type_18936);
  ::Reflex::Type type_18936c = ::Reflex::ConstBuilder(type_18936);
  ::Reflex::Type type_18943 = ::Reflex::PointerBuilder(type_18936c);
  ::Reflex::Type type_18945 = ::Reflex::ReferenceBuilder(type_18936);
  ::Reflex::Type type_18947 = ::Reflex::ReferenceBuilder(type_18936c);
  ::Reflex::Type type_3708c = ::Reflex::ConstBuilder(type_3708);
  ::Reflex::Type type_32342 = ::Reflex::ReferenceBuilder(type_3708c);
  ::Reflex::Type type_3107c = ::Reflex::ConstBuilder(type_3107);
  ::Reflex::Type type_32559 = ::Reflex::ReferenceBuilder(type_3107c);
  ::Reflex::Type type_32560 = ::Reflex::ReferenceBuilder(type_3107);
  ::Reflex::Type type_19002 = ::Reflex::PointerBuilder(type_188);
  ::Reflex::Type type_17460 = ::Reflex::PointerBuilder(type_19002);
  ::Reflex::Type type_19002c = ::Reflex::ConstBuilder(type_19002);
  ::Reflex::Type type_19009 = ::Reflex::PointerBuilder(type_19002c);
  ::Reflex::Type type_19011 = ::Reflex::ReferenceBuilder(type_19002);
  ::Reflex::Type type_19013 = ::Reflex::ReferenceBuilder(type_19002c);
  ::Reflex::Type type_3709c = ::Reflex::ConstBuilder(type_3709);
  ::Reflex::Type type_32277 = ::Reflex::ReferenceBuilder(type_3709c);
  ::Reflex::Type type_3108c = ::Reflex::ConstBuilder(type_3108);
  ::Reflex::Type type_32562 = ::Reflex::ReferenceBuilder(type_3108c);
  ::Reflex::Type type_32563 = ::Reflex::ReferenceBuilder(type_3108);
  ::Reflex::Type type_17479 = ::Reflex::PointerBuilder(type_17441);
  ::Reflex::Type type_17441c = ::Reflex::ConstBuilder(type_17441);
  ::Reflex::Type type_19074 = ::Reflex::PointerBuilder(type_17441c);
  ::Reflex::Type type_19076 = ::Reflex::ReferenceBuilder(type_17441);
  ::Reflex::Type type_19078 = ::Reflex::ReferenceBuilder(type_17441c);
  ::Reflex::Type type_3710c = ::Reflex::ConstBuilder(type_3710);
  ::Reflex::Type type_32290 = ::Reflex::ReferenceBuilder(type_3710c);
  ::Reflex::Type type_3109c = ::Reflex::ConstBuilder(type_3109);
  ::Reflex::Type type_32565 = ::Reflex::ReferenceBuilder(type_3109c);
  ::Reflex::Type type_32566 = ::Reflex::ReferenceBuilder(type_3109);
  ::Reflex::Type type_17705 = ::Reflex::PointerBuilder(type_795);
  ::Reflex::Type type_795c = ::Reflex::ConstBuilder(type_795);
  ::Reflex::Type type_19139 = ::Reflex::PointerBuilder(type_795c);
  ::Reflex::Type type_19141 = ::Reflex::ReferenceBuilder(type_795);
  ::Reflex::Type type_19143 = ::Reflex::ReferenceBuilder(type_795c);
  ::Reflex::Type type_3711c = ::Reflex::ConstBuilder(type_3711);
  ::Reflex::Type type_32446 = ::Reflex::ReferenceBuilder(type_3711c);
  ::Reflex::Type type_3110c = ::Reflex::ConstBuilder(type_3110);
  ::Reflex::Type type_32568 = ::Reflex::ReferenceBuilder(type_3110c);
  ::Reflex::Type type_32569 = ::Reflex::ReferenceBuilder(type_3110);
  ::Reflex::Type type_17516 = ::Reflex::PointerBuilder(type_3516);
  ::Reflex::Type type_3516c = ::Reflex::ConstBuilder(type_3516);
  ::Reflex::Type type_19204 = ::Reflex::PointerBuilder(type_3516c);
  ::Reflex::Type type_19206 = ::Reflex::ReferenceBuilder(type_3516);
  ::Reflex::Type type_19208 = ::Reflex::ReferenceBuilder(type_3516c);
  ::Reflex::Type type_3717c = ::Reflex::ConstBuilder(type_3717);
  ::Reflex::Type type_32316 = ::Reflex::ReferenceBuilder(type_3717c);
  ::Reflex::Type type_3111c = ::Reflex::ConstBuilder(type_3111);
  ::Reflex::Type type_32571 = ::Reflex::ReferenceBuilder(type_3111c);
  ::Reflex::Type type_32572 = ::Reflex::ReferenceBuilder(type_3111);
  ::Reflex::Type type_17591 = ::Reflex::PointerBuilder(type_2743);
  ::Reflex::Type type_2743c = ::Reflex::ConstBuilder(type_2743);
  ::Reflex::Type type_9745 = ::Reflex::PointerBuilder(type_2743c);
  ::Reflex::Type type_5544 = ::Reflex::ReferenceBuilder(type_2743c);
  ::Reflex::Type type_3724c = ::Reflex::ConstBuilder(type_3724);
  ::Reflex::Type type_32368 = ::Reflex::ReferenceBuilder(type_3724c);
  ::Reflex::Type type_3113c = ::Reflex::ConstBuilder(type_3113);
  ::Reflex::Type type_32573 = ::Reflex::ReferenceBuilder(type_3113c);
  ::Reflex::Type type_32574 = ::Reflex::ReferenceBuilder(type_3113);
  ::Reflex::Type type_17610 = ::Reflex::PointerBuilder(type_3365);
  ::Reflex::Type type_3365c = ::Reflex::ConstBuilder(type_3365);
  ::Reflex::Type type_19331 = ::Reflex::PointerBuilder(type_3365c);
  ::Reflex::Type type_19333 = ::Reflex::ReferenceBuilder(type_3365);
  ::Reflex::Type type_19335 = ::Reflex::ReferenceBuilder(type_3365c);
  ::Reflex::Type type_3725c = ::Reflex::ConstBuilder(type_3725);
  ::Reflex::Type type_32381 = ::Reflex::ReferenceBuilder(type_3725c);
  ::Reflex::Type type_3114c = ::Reflex::ConstBuilder(type_3114);
  ::Reflex::Type type_32576 = ::Reflex::ReferenceBuilder(type_3114c);
  ::Reflex::Type type_32577 = ::Reflex::ReferenceBuilder(type_3114);
  ::Reflex::Type type_17572 = ::Reflex::PointerBuilder(type_19390);
  ::Reflex::Type type_19390c = ::Reflex::ConstBuilder(type_19390);
  ::Reflex::Type type_19397 = ::Reflex::PointerBuilder(type_19390c);
  ::Reflex::Type type_19399 = ::Reflex::ReferenceBuilder(type_19390);
  ::Reflex::Type type_19401 = ::Reflex::ReferenceBuilder(type_19390c);
  ::Reflex::Type type_3721c = ::Reflex::ConstBuilder(type_3721);
  ::Reflex::Type type_32355 = ::Reflex::ReferenceBuilder(type_3721c);
  ::Reflex::Type type_3115c = ::Reflex::ConstBuilder(type_3115);
  ::Reflex::Type type_32579 = ::Reflex::ReferenceBuilder(type_3115c);
  ::Reflex::Type type_32580 = ::Reflex::ReferenceBuilder(type_3115);
  ::Reflex::Type type_17824 = ::Reflex::PointerBuilder(type_3222);
  ::Reflex::Type type_667c = ::Reflex::ConstBuilder(type_667);
  ::Reflex::Type type_17814 = ::Reflex::PointerBuilder(type_667c);
  ::Reflex::Type type_3723c = ::Reflex::ConstBuilder(type_3723);
  ::Reflex::Type type_32581 = ::Reflex::ReferenceBuilder(type_3723c);
  ::Reflex::Type type_25948 = ::Reflex::ReferenceBuilder(type_667c);
  ::Reflex::Type type_3116c = ::Reflex::ConstBuilder(type_3116);
  ::Reflex::Type type_32582 = ::Reflex::ReferenceBuilder(type_3116c);
  ::Reflex::Type type_32583 = ::Reflex::ReferenceBuilder(type_3116);
  ::Reflex::Type type_17629 = ::Reflex::PointerBuilder(type_2835);
  ::Reflex::Type type_2835c = ::Reflex::ConstBuilder(type_2835);
  ::Reflex::Type type_19525 = ::Reflex::PointerBuilder(type_2835c);
  ::Reflex::Type type_19527 = ::Reflex::ReferenceBuilder(type_2835);
  ::Reflex::Type type_19529 = ::Reflex::ReferenceBuilder(type_2835c);
  ::Reflex::Type type_3729c = ::Reflex::ConstBuilder(type_3729);
  ::Reflex::Type type_32394 = ::Reflex::ReferenceBuilder(type_3729c);
  ::Reflex::Type type_3117c = ::Reflex::ConstBuilder(type_3117);
  ::Reflex::Type type_32585 = ::Reflex::ReferenceBuilder(type_3117c);
  ::Reflex::Type type_32586 = ::Reflex::ReferenceBuilder(type_3117);
  ::Reflex::Type type_17648 = ::Reflex::PointerBuilder(type_3099);
  ::Reflex::Type type_19590 = ::Reflex::PointerBuilder(type_3099c);
  ::Reflex::Type type_3730c = ::Reflex::ConstBuilder(type_3730);
  ::Reflex::Type type_32407 = ::Reflex::ReferenceBuilder(type_3730c);
  ::Reflex::Type type_3118c = ::Reflex::ConstBuilder(type_3118);
  ::Reflex::Type type_32588 = ::Reflex::ReferenceBuilder(type_3118c);
  ::Reflex::Type type_32589 = ::Reflex::ReferenceBuilder(type_3118);
  ::Reflex::Type type_17743 = ::Reflex::PointerBuilder(type_3554);
  ::Reflex::Type type_3554c = ::Reflex::ConstBuilder(type_3554);
  ::Reflex::Type type_19655 = ::Reflex::PointerBuilder(type_3554c);
  ::Reflex::Type type_19657 = ::Reflex::ReferenceBuilder(type_3554);
  ::Reflex::Type type_19659 = ::Reflex::ReferenceBuilder(type_3554c);
  ::Reflex::Type type_3747c = ::Reflex::ConstBuilder(type_3747);
  ::Reflex::Type type_32472 = ::Reflex::ReferenceBuilder(type_3747c);
  ::Reflex::Type type_3119c = ::Reflex::ConstBuilder(type_3119);
  ::Reflex::Type type_32591 = ::Reflex::ReferenceBuilder(type_3119c);
  ::Reflex::Type type_31105 = ::Reflex::ReferenceBuilder(type_3119);
  ::Reflex::Type type_19714 = ::Reflex::PointerBuilder(type_1962);
  ::Reflex::Type type_17667 = ::Reflex::PointerBuilder(type_19714);
  ::Reflex::Type type_19714c = ::Reflex::ConstBuilder(type_19714);
  ::Reflex::Type type_19721 = ::Reflex::PointerBuilder(type_19714c);
  ::Reflex::Type type_19723 = ::Reflex::ReferenceBuilder(type_19714);
  ::Reflex::Type type_19725 = ::Reflex::ReferenceBuilder(type_19714c);
  ::Reflex::Type type_3748c = ::Reflex::ConstBuilder(type_3748);
  ::Reflex::Type type_32420 = ::Reflex::ReferenceBuilder(type_3748c);
  ::Reflex::Type type_3120c = ::Reflex::ConstBuilder(type_3120);
  ::Reflex::Type type_32593 = ::Reflex::ReferenceBuilder(type_3120c);
  ::Reflex::Type type_32594 = ::Reflex::ReferenceBuilder(type_3120);
  ::Reflex::Type type_19780 = ::Reflex::PointerBuilder(type_2677);
  ::Reflex::Type type_17686 = ::Reflex::PointerBuilder(type_19780);
  ::Reflex::Type type_19780c = ::Reflex::ConstBuilder(type_19780);
  ::Reflex::Type type_19787 = ::Reflex::PointerBuilder(type_19780c);
  ::Reflex::Type type_19789 = ::Reflex::ReferenceBuilder(type_19780);
  ::Reflex::Type type_19791 = ::Reflex::ReferenceBuilder(type_19780c);
  ::Reflex::Type type_3749c = ::Reflex::ConstBuilder(type_3749);
  ::Reflex::Type type_32433 = ::Reflex::ReferenceBuilder(type_3749c);
  ::Reflex::Type type_3121c = ::Reflex::ConstBuilder(type_3121);
  ::Reflex::Type type_32596 = ::Reflex::ReferenceBuilder(type_3121c);
  ::Reflex::Type type_32597 = ::Reflex::ReferenceBuilder(type_3121);
  ::Reflex::Type type_17724 = ::Reflex::PointerBuilder(type_4318);
  ::Reflex::Type type_4318c = ::Reflex::ConstBuilder(type_4318);
  ::Reflex::Type type_19852 = ::Reflex::PointerBuilder(type_4318c);
  ::Reflex::Type type_19854 = ::Reflex::ReferenceBuilder(type_4318);
  ::Reflex::Type type_19856 = ::Reflex::ReferenceBuilder(type_4318c);
  ::Reflex::Type type_3754c = ::Reflex::ConstBuilder(type_3754);
  ::Reflex::Type type_32459 = ::Reflex::ReferenceBuilder(type_3754c);
  ::Reflex::Type type_3122c = ::Reflex::ConstBuilder(type_3122);
  ::Reflex::Type type_20699 = ::Reflex::ReferenceBuilder(type_3122c);
  ::Reflex::Type type_20697 = ::Reflex::ReferenceBuilder(type_3122);
  ::Reflex::Type type_19911 = ::Reflex::PointerBuilder(type_532);
  ::Reflex::Type type_17762 = ::Reflex::PointerBuilder(type_19911);
  ::Reflex::Type type_19911c = ::Reflex::ConstBuilder(type_19911);
  ::Reflex::Type type_19918 = ::Reflex::PointerBuilder(type_19911c);
  ::Reflex::Type type_19920 = ::Reflex::ReferenceBuilder(type_19911);
  ::Reflex::Type type_19922 = ::Reflex::ReferenceBuilder(type_19911c);
  ::Reflex::Type type_3774c = ::Reflex::ConstBuilder(type_3774);
  ::Reflex::Type type_32485 = ::Reflex::ReferenceBuilder(type_3774c);
  ::Reflex::Type type_3124c = ::Reflex::ConstBuilder(type_3124);
  ::Reflex::Type type_32600 = ::Reflex::ReferenceBuilder(type_3124c);
  ::Reflex::Type type_32601 = ::Reflex::ReferenceBuilder(type_3124);
  ::Reflex::Type type_17781 = ::Reflex::PointerBuilder(type_13467);
  ::Reflex::Type type_13467c = ::Reflex::ConstBuilder(type_13467);
  ::Reflex::Type type_19983 = ::Reflex::PointerBuilder(type_13467c);
  ::Reflex::Type type_19985 = ::Reflex::ReferenceBuilder(type_13467);
  ::Reflex::Type type_19987 = ::Reflex::ReferenceBuilder(type_13467c);
  ::Reflex::Type type_3775c = ::Reflex::ConstBuilder(type_3775);
  ::Reflex::Type type_32498 = ::Reflex::ReferenceBuilder(type_3775c);
  ::Reflex::Type type_3125c = ::Reflex::ConstBuilder(type_3125);
  ::Reflex::Type type_32603 = ::Reflex::ReferenceBuilder(type_3125c);
  ::Reflex::Type type_32604 = ::Reflex::ReferenceBuilder(type_3125);
  ::Reflex::Type type_33035 = ::Reflex::ReferenceBuilder(type_3485);
  ::Reflex::Type type_3485c = ::Reflex::ConstBuilder(type_3485);
  ::Reflex::Type type_33036 = ::Reflex::ReferenceBuilder(type_3485c);
  ::Reflex::Type type_3147c = ::Reflex::ConstBuilder(type_3147);
  ::Reflex::Type type_16945 = ::Reflex::ReferenceBuilder(type_3147c);
  ::Reflex::Type type_22352c = ::Reflex::ConstBuilder(type_22352);
  ::Reflex::Type type_32973 = ::Reflex::ReferenceBuilder(type_22352c);
  ::Reflex::Type type_33697 = ::Reflex::ArrayBuilder(type_667, 2);
  ::Reflex::Type type_33612 = ::Reflex::ArrayBuilder(type_694, 2);
  ::Reflex::Type type_33698 = ::Reflex::ReferenceBuilder(type_7148);
  ::Reflex::Type type_7148c = ::Reflex::ConstBuilder(type_7148);
  ::Reflex::Type type_33699 = ::Reflex::ReferenceBuilder(type_7148c);
  ::Reflex::Type type_33700 = ::Reflex::ReferenceBuilder(type_7150);
  ::Reflex::Type type_7150c = ::Reflex::ConstBuilder(type_7150);
  ::Reflex::Type type_33701 = ::Reflex::ReferenceBuilder(type_7150c);
  ::Reflex::Type type_27874 = ::Reflex::ReferenceBuilder(type_844);
  ::Reflex::Type type_27676 = ::Reflex::PointerBuilder(type_39);
  ::Reflex::Type type_28297 = ::Reflex::PointerBuilder(type_2819);
  ::Reflex::Type type_28298 = ::Reflex::PointerBuilder(type_781);
  ::Reflex::Type type_28122 = ::Reflex::ReferenceBuilder(type_1554);
  ::Reflex::Type type_28299 = ::Reflex::PointerBuilder(type_2099);
  ::Reflex::Type type_28300 = ::Reflex::PointerBuilder(type_236);
  ::Reflex::Type type_28477 = ::Reflex::PointerBuilder(type_252);
  ::Reflex::Type type_28478 = ::Reflex::PointerBuilder(type_265);
  ::Reflex::Type type_28549 = ::Reflex::ReferenceBuilder(type_2021);
  ::Reflex::Type type_28255 = ::Reflex::ReferenceBuilder(type_906);
  ::Reflex::Type type_28508 = ::Reflex::PointerBuilder(type_245);
  ::Reflex::Type type_31777 = ::Reflex::ReferenceBuilder(type_3106);
  ::Reflex::Type type_27817 = ::Reflex::PointerBuilder(type_2134);
  ::Reflex::Type type_8017 = ::Reflex::PointerBuilder(type_2976);
  ::Reflex::Type type_27925 = ::Reflex::PointerBuilder(type_1656);
  ::Reflex::Type type_31778 = ::Reflex::ReferenceBuilder(type_3157);
  ::Reflex::Type type_28552 = ::Reflex::ReferenceBuilder(type_1573);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TagEfficiencyWeight
#undef __TagEfficiencyWeight
#endif
class __TagEfficiencyWeight : public ::RooAbsReal {
  public:
  __TagEfficiencyWeight();
  virtual ~__TagEfficiencyWeight() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooCategoryProxy tag;
  ::RooRealProxy eff;
};
#ifdef __RooBinned1DQuinticBase_RooAbsReal_
#undef __RooBinned1DQuinticBase_RooAbsReal_
#endif
class __RooBinned1DQuinticBase_RooAbsReal_ : public ::RooAbsReal {
  public:
  __RooBinned1DQuinticBase_RooAbsReal_();
  virtual ~__RooBinned1DQuinticBase_RooAbsReal_() throw();
#ifdef __RooBinned1DQuinticBase_RooAbsReal_____148
#undef __RooBinned1DQuinticBase_RooAbsReal_____148
#endif
  enum __RooBinned1DQuinticBase_RooAbsReal_____148 {};
#ifdef __RooBinned1DQuinticBase_RooAbsReal___BinSizeException
#undef __RooBinned1DQuinticBase_RooAbsReal___BinSizeException
#endif
  class __RooBinned1DQuinticBase_RooAbsReal___BinSizeException :   public ::std::exception   {
    public:
    __RooBinned1DQuinticBase_RooAbsReal___BinSizeException();
    virtual ~__RooBinned1DQuinticBase_RooAbsReal___BinSizeException() throw();
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Bool_t isBinnedDistribution(RooArgSet const&) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::std::list<double>* binBoundaries(RooAbsRealLValue&, double, double) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooBinned1DQuinticBase<RooAbsReal>* clone(char const*) const throw();
  virtual ::std::list<double>* plotSamplingHint(RooAbsRealLValue&, double, double) const throw();
  ::RooRealProxy x;
  int nBinsX;
  double binSizeX;
  double xmin;
  double xmax;
  bool isIntegral;
  ::SharedArray<double> coeffs;
};
#ifdef __DecRateCoeff
#undef __DecRateCoeff
#endif
class __DecRateCoeff : public ::RooAbsReal {
  public:
  __DecRateCoeff();
  virtual ~__DecRateCoeff() throw();
#ifdef __DecRateCoeff__CacheElem
#undef __DecRateCoeff__CacheElem
#endif
  class __DecRateCoeff__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __DecRateCoeff__CacheElem();
    virtual ~__DecRateCoeff__CacheElem() throw();
#ifdef __DecRateCoeff__CacheElem__Flags
#undef __DecRateCoeff__CacheElem__Flags
#endif
    enum __DecRateCoeff__CacheElem__Flags {};
    void* m_etaintpdftagged;
    void* m_etaintprodpdfmistagtaggedplus;
    void* m_etaintprodpdfmistagtaggedminus;
    void* m_etaintpdfuntagged;
    ::RooArgSet m_nset;
    void* m_rangeName;
    int& m_parent;
    ::std::string m_workRangeName[2];
    ::std::pair<RooRealVar*,RooRealVar*> m_workRange[2];
    ::std::vector<double> m_etabins;
    double m_prodcachedval[2];
    __DecRateCoeff__CacheElem__Flags m_flags;
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegralWN(int, RooArgSet const*, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::Double_t getValV(RooArgSet const*) const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual ::Int_t getAnalyticalIntegralWN(RooArgSet&, RooArgSet&, RooArgSet const*, char const*) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooCategoryProxy m_qf;
  ::RooCategoryProxy m_qt;
  ::RooRealProxy m_Cf;
  ::RooRealProxy m_Cfbar;
  ::RooRealProxy m_etaobs;
  ::RooRealProxy m_etapdf;
  ::RooUniform m_etapdfutinstance;
  ::RooRealProxy m_etapdfut;
  ::RooRealProxy m_tageff;
  ::RooRealProxy m_eta;
  ::RooRealProxy m_etabar;
  ::RooRealProxy m_aprod;
  ::RooRealProxy m_adet;
  ::RooRealProxy m_atageff;
  ::RooObjCacheManager m_cacheMgr;
  ::std::map<unsigned int,RooArgSet> m_nsets;
  void* m_nset;
  ::UInt_t m_nsethash;
  ::DecRateCoeff::Flags m_flags;
};
#ifdef __IfThreeWayPdf
#undef __IfThreeWayPdf
#endif
class __IfThreeWayPdf : public ::RooAbsPdf {
  public:
  __IfThreeWayPdf();
  virtual ~__IfThreeWayPdf() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy cond;
  ::RooRealProxy pos;
  ::RooRealProxy zero;
  ::RooRealProxy neg;
};
#ifdef __Inverse
#undef __Inverse
#endif
class __Inverse : public ::RooAbsReal {
  public:
  __Inverse();
  virtual ~__Inverse() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy val;
};
#ifdef __RooEffConvGenContext
#undef __RooEffConvGenContext
#endif
class __RooEffConvGenContext : public ::RooConvGenContext {
  public:
  __RooEffConvGenContext();
  virtual ~__RooEffConvGenContext() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual void generateEvent(RooArgSet&, int) throw();
  virtual ::TClass* IsA() const throw();
  virtual void attach(RooArgSet const&) throw();
  virtual void Streamer(TBuffer&) throw();
  double _maxEff;
};
#ifdef __BdPTAcceptance
#undef __BdPTAcceptance
#endif
class __BdPTAcceptance : public ::RooAbsReal {
  public:
  __BdPTAcceptance();
  virtual ~__BdPTAcceptance() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy t;
  ::RooRealProxy beta;
  ::RooRealProxy slope;
  ::RooRealProxy offset;
};
#ifdef __RooBinned2DBicubicBase_RooAbsPdf_
#undef __RooBinned2DBicubicBase_RooAbsPdf_
#endif
class __RooBinned2DBicubicBase_RooAbsPdf_ : public ::RooAbsPdf {
  public:
  __RooBinned2DBicubicBase_RooAbsPdf_();
  virtual ~__RooBinned2DBicubicBase_RooAbsPdf_() throw();
#ifdef __RooBinned2DBicubicBase_RooAbsPdf_____147
#undef __RooBinned2DBicubicBase_RooAbsPdf_____147
#endif
  enum __RooBinned2DBicubicBase_RooAbsPdf_____147 {};
#ifdef __RooBinned2DBicubicBase_RooAbsPdf___BinSizeException
#undef __RooBinned2DBicubicBase_RooAbsPdf___BinSizeException
#endif
  class __RooBinned2DBicubicBase_RooAbsPdf___BinSizeException :   public ::std::exception   {
    public:
    __RooBinned2DBicubicBase_RooAbsPdf___BinSizeException();
    virtual ~__RooBinned2DBicubicBase_RooAbsPdf___BinSizeException() throw();
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooBinned2DBicubicBase<RooAbsPdf>* clone(char const*) const throw();
  ::RooRealProxy x;
  ::RooRealProxy y;
  int nBinsX;
  int nBinsY;
  double binSizeX;
  double binSizeY;
  double xmin;
  double xmax;
  double ymin;
  double ymax;
  ::SharedArray<double> coeffs;
};
#ifdef __RooBinned2DBicubicBase_RooAbsReal_
#undef __RooBinned2DBicubicBase_RooAbsReal_
#endif
class __RooBinned2DBicubicBase_RooAbsReal_ : public ::RooAbsReal {
  public:
  __RooBinned2DBicubicBase_RooAbsReal_();
  virtual ~__RooBinned2DBicubicBase_RooAbsReal_() throw();
#ifdef __RooBinned2DBicubicBase_RooAbsReal_____147
#undef __RooBinned2DBicubicBase_RooAbsReal_____147
#endif
  enum __RooBinned2DBicubicBase_RooAbsReal_____147 {};
#ifdef __RooBinned2DBicubicBase_RooAbsReal___BinSizeException
#undef __RooBinned2DBicubicBase_RooAbsReal___BinSizeException
#endif
  class __RooBinned2DBicubicBase_RooAbsReal___BinSizeException :   public ::std::exception   {
    public:
    __RooBinned2DBicubicBase_RooAbsReal___BinSizeException();
    virtual ~__RooBinned2DBicubicBase_RooAbsReal___BinSizeException() throw();
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooBinned2DBicubicBase<RooAbsReal>* clone(char const*) const throw();
  ::RooRealProxy x;
  ::RooRealProxy y;
  int nBinsX;
  int nBinsY;
  double binSizeX;
  double binSizeY;
  double xmin;
  double xmax;
  double ymin;
  double ymax;
  ::SharedArray<double> coeffs;
};
#ifdef __IfThreeWayCatPdf
#undef __IfThreeWayCatPdf
#endif
class __IfThreeWayCatPdf : public ::RooAbsPdf {
  public:
  __IfThreeWayCatPdf();
  virtual ~__IfThreeWayCatPdf() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooCategoryProxy cond;
  ::RooRealProxy pos;
  ::RooRealProxy zero;
  ::RooRealProxy neg;
};
#ifdef __NonOscTaggingPdf
#undef __NonOscTaggingPdf
#endif
class __NonOscTaggingPdf : public ::RooAbsPdf {
  public:
  __NonOscTaggingPdf();
  virtual ~__NonOscTaggingPdf() throw();
#ifdef __NonOscTaggingPdf__CacheElem
#undef __NonOscTaggingPdf__CacheElem
#endif
  class __NonOscTaggingPdf__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __NonOscTaggingPdf__CacheElem();
    virtual ~__NonOscTaggingPdf__CacheElem() throw();
#ifdef __NonOscTaggingPdf__CacheElem__Flags
#undef __NonOscTaggingPdf__CacheElem__Flags
#endif
    enum __NonOscTaggingPdf__CacheElem__Flags {};
    int& m_parent;
    void* m_etapdfint;
    void* m_etapdfintut;
    ::RooArgSet m_nset;
    void* m_rangeName;
    __NonOscTaggingPdf__CacheElem__Flags m_flags;
  };
  virtual ::Bool_t selfNormalized() const throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegralWN(int, RooArgSet const*, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual ::Int_t getAnalyticalIntegralWN(RooArgSet&, RooArgSet&, RooArgSet const*, char const*) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooCategoryProxy m_qf;
  ::RooCategoryProxy m_qt;
  ::RooRealProxy m_etaobs;
  ::RooRealProxy m_etapdf;
  ::RooUniform m_etapdfutinstance;
  ::RooRealProxy m_etapdfut;
  ::RooRealProxy m_epsilon;
  ::RooRealProxy m_adet;
  ::RooRealProxy m_atageff_f;
  ::RooRealProxy m_atageff_t;
  ::RooObjCacheManager m_cacheMgr;
};
#ifdef __DTAcceptanceLHCbNote2007041
#undef __DTAcceptanceLHCbNote2007041
#endif
class __DTAcceptanceLHCbNote2007041 : public ::RooAbsReal {
  public:
  __DTAcceptanceLHCbNote2007041();
  virtual ~__DTAcceptanceLHCbNote2007041() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy t;
  ::RooRealProxy s_low;
  ::RooRealProxy s_high;
  ::RooRealProxy n;
  ::RooRealProxy limit;
};
#ifdef __RooEffResModel
#undef __RooEffResModel
#endif
class __RooEffResModel : public ::RooResolutionModel, public ::RooAbsEffResModel {
  public:
  __RooEffResModel();
  virtual ~__RooEffResModel() throw();
#ifdef __RooEffResModel__CacheElem
#undef __RooEffResModel__CacheElem
#endif
  class __RooEffResModel__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __RooEffResModel__CacheElem();
    virtual ~__RooEffResModel__CacheElem() throw();
    ::std::vector<double> _bounds;
    void* _x;
    void* _eff;
    void* _xmin;
    void* _xmax;
    void* _int;
    ::Double_t _val;
  };
  virtual ::Int_t getGenerator(RooArgSet const&, RooArgSet&, bool) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::RooArgSet* observables() const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::std::vector<RooAbsReal*> efficiencies() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::RooAbsReal* efficiency() const throw();
  virtual ::RooResolutionModel& model() const throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual void initGenerator(int) throw();
  virtual ::Int_t basisCode(char const*) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooEffResModel* clone(char const*) const throw();
  virtual void generateEvent(int) throw();
  virtual ::RooAbsGenContext* modelGenContext(RooAbsAnaConvPdf const&, RooArgSet const&, RooDataSet const*, RooArgSet const*, bool) const throw();
  virtual ::RooEffResModel* convolution(RooFormulaVar*, RooAbsArg*) const throw();
  ::RooSetProxy _observables;
  ::RooRealProxy _model;
  ::RooRealProxy _eff;
  ::RooObjCacheManager _cacheMgr;
};
#ifdef __RooAbsEffResModel
#undef __RooAbsEffResModel
#endif
class __RooAbsEffResModel {
  public:
  __RooAbsEffResModel();
  virtual ~__RooAbsEffResModel() throw();
};
#ifdef __IfThreeWayCat
#undef __IfThreeWayCat
#endif
class __IfThreeWayCat : public ::RooAbsReal {
  public:
  __IfThreeWayCat();
  virtual ~__IfThreeWayCat() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooCategoryProxy cond;
  ::RooRealProxy pos;
  ::RooRealProxy zero;
  ::RooRealProxy neg;
};
#ifdef __RooCubicSplineKnot
#undef __RooCubicSplineKnot
#endif
class __RooCubicSplineKnot {
  public:
  __RooCubicSplineKnot();
  virtual ~__RooCubicSplineKnot() throw();
  ::std::vector<double> _u;
  ::std::vector<double> _PQRS;
  ::std::vector<double> _IABCD;
  ::std::vector<RooCubicSplineKnot::S_jk> _S_jk;
};
#ifdef __RooBinnedPdf
#undef __RooBinnedPdf
#endif
class __RooBinnedPdf : public ::RooAbsPdf {
  public:
  __RooBinnedPdf();
  virtual ~__RooBinnedPdf() throw();
#ifdef __RooBinnedPdf__CacheElem
#undef __RooBinnedPdf__CacheElem
#endif
  class __RooBinnedPdf__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __RooBinnedPdf__CacheElem();
    virtual ~__RooBinnedPdf__CacheElem() throw();
    int& _parent;
    void* _function;
    ::std::vector<RooAbsRealLValue*> _baseVarsList;
    ::std::vector<const RooAbsBinning*> _binningList;
    ::std::map<RooAbsRealLValue*,RooAbsRealLValue*> _baseVarsMapping;
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::std::list<double>* binBoundaries(RooAbsRealLValue&, double, double) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::Double_t getValV(RooArgSet const*) const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t maxVal(int) const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::std::list<double>* plotSamplingHint(RooAbsRealLValue&, double, double) const throw();
  ::RooListProxy _baseCatsList;
  ::RooListProxy _baseVarsList;
  ::TObjArray _coefLists;
  ::RooRealProxy _function;
  ::std::vector<std::map<int,int> > _indexPositions;
  ::std::vector<TString> _binningNames;
  ::std::vector<bool> _calcCoefZeros;
  ::Int_t _numCats;
  ::Bool_t _continuousBase;
  ::Bool_t _forceUnitIntegral;
  ::Bool_t _binIntegralCoefs;
  ::Bool_t _ignoreFirstBin;
  ::RooObjCacheManager m_cacheMgr;
  void* m_nset;
  ::UInt_t m_nsethash;
  ::std::map<unsigned int,RooArgSet> m_nsets;
};
#ifdef __MistagDistribution
#undef __MistagDistribution
#endif
class __MistagDistribution : public ::RooAbsPdf {
  public:
  __MistagDistribution();
  virtual ~__MistagDistribution() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy w;
  ::RooRealProxy w0;
  ::RooRealProxy wa;
  ::RooRealProxy f;
  double lastw0;
  double lastwa;
  double lastf;
  double lastwc;
};
#ifdef __SquaredSum
#undef __SquaredSum
#endif
class __SquaredSum : public ::RooAbsReal {
  public:
  __SquaredSum();
  virtual ~__SquaredSum() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy C;
  ::RooRealProxy D;
  ::RooRealProxy S;
};
#ifdef __RooGenSmearIntegrandBinding
#undef __RooGenSmearIntegrandBinding
#endif
class __RooGenSmearIntegrandBinding : public ::RooAbsFunc {
  public:
  __RooGenSmearIntegrandBinding();
  virtual ~__RooGenSmearIntegrandBinding() throw();
  void* _func;
  void* _model;
  void* _var;
  void* _nset;
  ::Bool_t _xvecValid;
  ::Bool_t _clipInvalid;
};
#ifdef __RooGaussEfficiencyModel
#undef __RooGaussEfficiencyModel
#endif
class __RooGaussEfficiencyModel : public ::RooResolutionModel, public ::RooAbsEffResModel {
  public:
  __RooGaussEfficiencyModel();
  virtual ~__RooGaussEfficiencyModel() throw();
  virtual ::Int_t getGenerator(RooArgSet const&, RooArgSet&, bool) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::RooArgSet* observables() const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual const ::RooAbsReal* efficiency() const throw();
  virtual ::Int_t basisCode(char const*) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual void generateEvent(int) throw();
  virtual ::Bool_t isDirectGenSafe(RooAbsArg const&) const throw();
  virtual ::RooAbsGenContext* modelGenContext(RooAbsAnaConvPdf const&, RooArgSet const&, RooDataSet const*, RooArgSet const*, bool) const throw();
  ::Bool_t _flatSFInt;
  ::RooRealProxy eff;
  ::RooRealProxy mean;
  ::RooRealProxy sigma;
  ::RooRealProxy msf;
  ::RooRealProxy ssf;
};
#ifdef __RooGeneralisedSmearingBase_RooAbsPdf_
#undef __RooGeneralisedSmearingBase_RooAbsPdf_
#endif
class __RooGeneralisedSmearingBase_RooAbsPdf_ : public ::RooAbsPdf {
  public:
  __RooGeneralisedSmearingBase_RooAbsPdf_();
  virtual ~__RooGeneralisedSmearingBase_RooAbsPdf_() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t getMax(int) const throw();
  virtual void printCompactTreeHook(std::ostream&, char const*) throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::Bool_t redirectServersHook(RooAbsCollection const&, bool, bool, bool) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::Bool_t _init;
  ::RooNumIntConfig _convIntConfig;
  void* _integrator;
  void* _integrand;
  ::RooRealProxy _origVar;
  ::RooRealProxy _origPdf;
  ::RooRealProxy _origModel;
  void* _cloneVar;
  void* _clonePdf;
  void* _cloneModel;
  ::std::map<std::basic_string<char>,std::map<int,RooArgSet> > _integvarset;
  ::std::map<std::basic_string<char>,std::map<int,RooAbsReal*> > _integralset;
  ::std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> > _integrandset;
  ::std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> > _integratorset;
  void* _binning;
  ::RooRealProxy _binnedvar;
  void* _binnedvarClone;
  ::RooArgSet _binnedcats;
  ::std::vector<std::vector<double> > _binnedcache;
  ::std::vector<std::map<void*,double> > _binnedcacheLastVal;
  bool _preferBinnedIntegrals;
  ::Bool_t _useWindow;
  ::Double_t _windowScale;
  ::RooListProxy _windowParam;
};
#ifdef __RooBinned1DQuinticBase_RooAbsPdf_
#undef __RooBinned1DQuinticBase_RooAbsPdf_
#endif
class __RooBinned1DQuinticBase_RooAbsPdf_ : public ::RooAbsPdf {
  public:
  __RooBinned1DQuinticBase_RooAbsPdf_();
  virtual ~__RooBinned1DQuinticBase_RooAbsPdf_() throw();
#ifdef __RooBinned1DQuinticBase_RooAbsPdf_____148
#undef __RooBinned1DQuinticBase_RooAbsPdf_____148
#endif
  enum __RooBinned1DQuinticBase_RooAbsPdf_____148 {};
#ifdef __RooBinned1DQuinticBase_RooAbsPdf___BinSizeException
#undef __RooBinned1DQuinticBase_RooAbsPdf___BinSizeException
#endif
  class __RooBinned1DQuinticBase_RooAbsPdf___BinSizeException :   public ::std::exception   {
    public:
    __RooBinned1DQuinticBase_RooAbsPdf___BinSizeException();
    virtual ~__RooBinned1DQuinticBase_RooAbsPdf___BinSizeException() throw();
  };
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Bool_t isBinnedDistribution(RooArgSet const&) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::std::list<double>* binBoundaries(RooAbsRealLValue&, double, double) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::RooBinned1DQuinticBase<RooAbsPdf>* clone(char const*) const throw();
  virtual ::std::list<double>* plotSamplingHint(RooAbsRealLValue&, double, double) const throw();
  ::RooRealProxy x;
  int nBinsX;
  double binSizeX;
  double xmin;
  double xmax;
  bool isIntegral;
  ::SharedArray<double> coeffs;
};
#ifdef __RooEffHistProd
#undef __RooEffHistProd
#endif
class __RooEffHistProd : public ::RooAbsPdf {
  public:
  __RooEffHistProd();
  virtual ~__RooEffHistProd() throw();
#ifdef __RooEffHistProd__CacheElem
#undef __RooEffHistProd__CacheElem
#endif
  class __RooEffHistProd__CacheElem :   public ::RooAbsCacheElement   {
    public:
    __RooEffHistProd__CacheElem();
    virtual ~__RooEffHistProd__CacheElem() throw();
    ::RooArgSet _intObs;
    void* _clone;
    void* _I;
    bool _trivial;
  };
  virtual ::Int_t getGenerator(RooArgSet const&, RooArgSet&, bool) const throw();
  virtual ::RooAbsGenContext* genContext(RooArgSet const&, RooDataSet const*, RooArgSet const*, bool) const throw();
  virtual ::Double_t expectedEvents(RooArgSet const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::RooAbsPdf::ExtendMode extendMode() const throw();
  virtual ::Double_t getValV(RooArgSet const*) const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual void initGenerator(int) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual void generateEvent(int) throw();
  virtual void selectNormalization(RooArgSet const*, bool) throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  ::std::vector<double> _binboundaries;
  ::RooRealProxy _pdf;
  ::RooRealProxy _eff;
  ::RooSetProxy _observables;
  ::RooArgSet _pdfGenVars;
  ::Int_t _pdfGenCode;
  ::Double_t _maxEff;
  ::std::vector<std::pair<double,TString> > _levels;
  ::std::map<std::basic_string<char>,RooArgSet*> _pdfObs;
  void* _pdfNormSet;
  void* _fixedNormSet;
  ::RooObjCacheManager _cacheMgr;
};
#ifdef __RooAbsGaussModelEfficiency
#undef __RooAbsGaussModelEfficiency
#endif
class __RooAbsGaussModelEfficiency : public ::RooAbsReal {
  public:
  __RooAbsGaussModelEfficiency();
  virtual ~__RooAbsGaussModelEfficiency() throw();
  virtual ::std::complex<double> productAnalyticalIntegral(double, double, double, double, std::complex<double> const&) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
};
#ifdef __RooGeneralisedSmearingBase_RooAbsReal_
#undef __RooGeneralisedSmearingBase_RooAbsReal_
#endif
class __RooGeneralisedSmearingBase_RooAbsReal_ : public ::RooAbsReal {
  public:
  __RooGeneralisedSmearingBase_RooAbsReal_();
  virtual ~__RooGeneralisedSmearingBase_RooAbsReal_() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t getMax(int) const throw();
  virtual void printCompactTreeHook(std::ostream&, char const*) throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual ::Bool_t redirectServersHook(RooAbsCollection const&, bool, bool, bool) throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::Bool_t forceAnalyticalInt(RooAbsArg const&) const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::Bool_t _init;
  ::RooNumIntConfig _convIntConfig;
  void* _integrator;
  void* _integrand;
  ::RooRealProxy _origVar;
  ::RooRealProxy _origPdf;
  ::RooRealProxy _origModel;
  void* _cloneVar;
  void* _clonePdf;
  void* _cloneModel;
  ::std::map<std::basic_string<char>,std::map<int,RooArgSet> > _integvarset;
  ::std::map<std::basic_string<char>,std::map<int,RooAbsReal*> > _integralset;
  ::std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> > _integrandset;
  ::std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> > _integratorset;
  void* _binning;
  ::RooRealProxy _binnedvar;
  void* _binnedvarClone;
  ::RooArgSet _binnedcats;
  ::std::vector<std::vector<double> > _binnedcache;
  ::std::vector<std::map<void*,double> > _binnedcacheLastVal;
  bool _preferBinnedIntegrals;
  ::Bool_t _useWindow;
  ::Double_t _windowScale;
  ::RooListProxy _windowParam;
};
#ifdef __TagEfficiencyWeightNoCat
#undef __TagEfficiencyWeightNoCat
#endif
class __TagEfficiencyWeightNoCat : public ::RooAbsReal {
  public:
  __TagEfficiencyWeightNoCat();
  virtual ~__TagEfficiencyWeightNoCat() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy tag;
  ::RooRealProxy eff;
};
#ifdef __FinalStateChargePdf
#undef __FinalStateChargePdf
#endif
class __FinalStateChargePdf : public ::RooAbsPdf {
  public:
  __FinalStateChargePdf();
  virtual ~__FinalStateChargePdf() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooCategoryProxy m_qf;
  ::RooRealProxy m_asymm;
};
#ifdef __TaggingCat
#undef __TaggingCat
#endif
class __TaggingCat : public ::RooAbsReal {
  public:
  __TaggingCat();
  virtual ~__TaggingCat() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooCategoryProxy qt;
  ::RooCategoryProxy cat;
  ::RooListProxy catlist;
  ::RooRealProxy untaggedVal;
};
#ifdef __RangeAcceptance
#undef __RangeAcceptance
#endif
class __RangeAcceptance : public ::RooAbsReal {
  public:
  __RangeAcceptance();
  virtual ~__RangeAcceptance() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy x;
  double xmin;
  double xmax;
};
#ifdef __PowLawAcceptance
#undef __PowLawAcceptance
#endif
class __PowLawAcceptance : public ::RooAbsReal {
  public:
  __PowLawAcceptance();
  virtual ~__PowLawAcceptance() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy _turnon;
  ::RooRealProxy _time;
  ::RooRealProxy _offset;
  ::RooRealProxy _exponent;
  ::RooRealProxy _beta;
  ::RooRealProxy _correction;
};
#ifdef __MistagCalibration
#undef __MistagCalibration
#endif
class __MistagCalibration : public ::RooAbsReal {
  public:
  __MistagCalibration();
  virtual ~__MistagCalibration() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy m_eta;
  ::RooListProxy m_calibcoeffs;
  ::RooRealProxy m_etaavg;
};
#ifdef __SharedArrayImp_double_
#undef __SharedArrayImp_double_
#endif
class __SharedArrayImp_double_ : public ::TObject {
  public:
  __SharedArrayImp_double_();
  virtual ~__SharedArrayImp_double_() throw();
  unsigned int refcount;
  ::std::vector<double> arr;
};
#ifdef __SharedArrayImp_float_
#undef __SharedArrayImp_float_
#endif
class __SharedArrayImp_float_ : public ::TObject {
  public:
  __SharedArrayImp_float_();
  virtual ~__SharedArrayImp_float_() throw();
  unsigned int refcount;
  ::std::vector<float> arr;
};
#ifdef __SharedArrayImp_unsignedslongslong_
#undef __SharedArrayImp_unsignedslongslong_
#endif
class __SharedArrayImp_unsignedslongslong_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedslongslong_();
  virtual ~__SharedArrayImp_unsignedslongslong_() throw();
  unsigned int refcount;
  ::std::vector<unsigned long long> arr;
};
#ifdef __SharedArrayImp_unsignedslong_
#undef __SharedArrayImp_unsignedslong_
#endif
class __SharedArrayImp_unsignedslong_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedslong_();
  virtual ~__SharedArrayImp_unsignedslong_() throw();
  unsigned int refcount;
  ::std::vector<unsigned long> arr;
};
#ifdef __SharedArrayImp_unsignedsint_
#undef __SharedArrayImp_unsignedsint_
#endif
class __SharedArrayImp_unsignedsint_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedsint_();
  virtual ~__SharedArrayImp_unsignedsint_() throw();
  unsigned int refcount;
  ::std::vector<unsigned int> arr;
};
#ifdef __SharedArrayImp_unsignedsshort_
#undef __SharedArrayImp_unsignedsshort_
#endif
class __SharedArrayImp_unsignedsshort_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedsshort_();
  virtual ~__SharedArrayImp_unsignedsshort_() throw();
  unsigned int refcount;
  ::std::vector<unsigned short> arr;
};
#ifdef __SharedArrayImp_unsignedschar_
#undef __SharedArrayImp_unsignedschar_
#endif
class __SharedArrayImp_unsignedschar_ : public ::TObject {
  public:
  __SharedArrayImp_unsignedschar_();
  virtual ~__SharedArrayImp_unsignedschar_() throw();
  unsigned int refcount;
  ::std::vector<unsigned char> arr;
};
#ifdef __SharedArrayImp_longslong_
#undef __SharedArrayImp_longslong_
#endif
class __SharedArrayImp_longslong_ : public ::TObject {
  public:
  __SharedArrayImp_longslong_();
  virtual ~__SharedArrayImp_longslong_() throw();
  unsigned int refcount;
  ::std::vector<long long> arr;
};
#ifdef __SharedArrayImp_long_
#undef __SharedArrayImp_long_
#endif
class __SharedArrayImp_long_ : public ::TObject {
  public:
  __SharedArrayImp_long_();
  virtual ~__SharedArrayImp_long_() throw();
  unsigned int refcount;
  ::std::vector<long> arr;
};
#ifdef __SharedArrayImp_int_
#undef __SharedArrayImp_int_
#endif
class __SharedArrayImp_int_ : public ::TObject {
  public:
  __SharedArrayImp_int_();
  virtual ~__SharedArrayImp_int_() throw();
  unsigned int refcount;
  ::std::vector<int> arr;
};
#ifdef __SharedArrayImp_short_
#undef __SharedArrayImp_short_
#endif
class __SharedArrayImp_short_ : public ::TObject {
  public:
  __SharedArrayImp_short_();
  virtual ~__SharedArrayImp_short_() throw();
  unsigned int refcount;
  ::std::vector<short> arr;
};
#ifdef __SharedArrayImp_char_
#undef __SharedArrayImp_char_
#endif
class __SharedArrayImp_char_ : public ::TObject {
  public:
  __SharedArrayImp_char_();
  virtual ~__SharedArrayImp_char_() throw();
  unsigned int refcount;
  ::std::vector<char> arr;
};
#ifdef __Dilution
#undef __Dilution
#endif
class __Dilution : public ::RooAbsReal {
  public:
  __Dilution();
  virtual ~__Dilution() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy omega;
};
#ifdef __FitMeTool
#undef __FitMeTool
#endif
class __FitMeTool {
  public:
  __FitMeTool();
  virtual ~__FitMeTool() throw();
  void* m_observables;
  void* m_conditionalObservables;
  void* m_externalConstraints;
  bool m_config_debug;
  int m_config_toyNumber;
  int m_config_seed;
  bool m_config_seedSet;
  bool m_config_saveFitResult2File;
  void* m_modelPDF;
  void* m_data;
  void* m_fitResult;
  void* m_outputFile;
  void* m_workSpace;
};
#ifdef __RooCubicSplineFun
#undef __RooCubicSplineFun
#endif
class __RooCubicSplineFun : public ::RooAbsGaussModelEfficiency {
  public:
  __RooCubicSplineFun();
  virtual ~__RooCubicSplineFun() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::std::complex<double> productAnalyticalIntegral(double, double, double, double, std::complex<double> const&) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t maxVal(int) const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy _x;
  ::RooListProxy _coefList;
  ::RooCubicSplineKnot _aux;
};
#ifdef __CPObservable
#undef __CPObservable
#endif
class __CPObservable : public ::RooAbsReal {
  public:
  __CPObservable();
  virtual ~__CPObservable() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy lambda;
  ::RooRealProxy phi_strong;
  ::RooRealProxy phi_weak;
  int what;
};
#ifdef __RooComplementCoef
#undef __RooComplementCoef
#endif
class __RooComplementCoef : public ::RooAbsReal {
  public:
  __RooComplementCoef();
  virtual ~__RooComplementCoef() throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual void printArgs(std::ostream&) const throw();
  ::RooListProxy _coefs;
};
#ifdef __SharedArray_double_
#undef __SharedArray_double_
#endif
class __SharedArray_double_ : public ::TObject {
  public:
  __SharedArray_double_();
  virtual ~__SharedArray_double_() throw();
  void* pimpl;
};
#ifdef __SharedArray_float_
#undef __SharedArray_float_
#endif
class __SharedArray_float_ : public ::TObject {
  public:
  __SharedArray_float_();
  virtual ~__SharedArray_float_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedslongslong_
#undef __SharedArray_unsignedslongslong_
#endif
class __SharedArray_unsignedslongslong_ : public ::TObject {
  public:
  __SharedArray_unsignedslongslong_();
  virtual ~__SharedArray_unsignedslongslong_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedslong_
#undef __SharedArray_unsignedslong_
#endif
class __SharedArray_unsignedslong_ : public ::TObject {
  public:
  __SharedArray_unsignedslong_();
  virtual ~__SharedArray_unsignedslong_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedsint_
#undef __SharedArray_unsignedsint_
#endif
class __SharedArray_unsignedsint_ : public ::TObject {
  public:
  __SharedArray_unsignedsint_();
  virtual ~__SharedArray_unsignedsint_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedsshort_
#undef __SharedArray_unsignedsshort_
#endif
class __SharedArray_unsignedsshort_ : public ::TObject {
  public:
  __SharedArray_unsignedsshort_();
  virtual ~__SharedArray_unsignedsshort_() throw();
  void* pimpl;
};
#ifdef __SharedArray_unsignedschar_
#undef __SharedArray_unsignedschar_
#endif
class __SharedArray_unsignedschar_ : public ::TObject {
  public:
  __SharedArray_unsignedschar_();
  virtual ~__SharedArray_unsignedschar_() throw();
  void* pimpl;
};
#ifdef __SharedArray_longslong_
#undef __SharedArray_longslong_
#endif
class __SharedArray_longslong_ : public ::TObject {
  public:
  __SharedArray_longslong_();
  virtual ~__SharedArray_longslong_() throw();
  void* pimpl;
};
#ifdef __SharedArray_long_
#undef __SharedArray_long_
#endif
class __SharedArray_long_ : public ::TObject {
  public:
  __SharedArray_long_();
  virtual ~__SharedArray_long_() throw();
  void* pimpl;
};
#ifdef __SharedArray_int_
#undef __SharedArray_int_
#endif
class __SharedArray_int_ : public ::TObject {
  public:
  __SharedArray_int_();
  virtual ~__SharedArray_int_() throw();
  void* pimpl;
};
#ifdef __SharedArray_short_
#undef __SharedArray_short_
#endif
class __SharedArray_short_ : public ::TObject {
  public:
  __SharedArray_short_();
  virtual ~__SharedArray_short_() throw();
  void* pimpl;
};
#ifdef __SharedArray_char_
#undef __SharedArray_char_
#endif
class __SharedArray_char_ : public ::TObject {
  public:
  __SharedArray_char_();
  virtual ~__SharedArray_char_() throw();
  void* pimpl;
};
#ifdef __IfThreeWay
#undef __IfThreeWay
#endif
class __IfThreeWay : public ::RooAbsReal {
  public:
  __IfThreeWay();
  virtual ~__IfThreeWay() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy cond;
  ::RooRealProxy pos;
  ::RooRealProxy zero;
  ::RooRealProxy neg;
};
#ifdef __RooCruijff
#undef __RooCruijff
#endif
class __RooCruijff : public ::RooAbsPdf {
  public:
  __RooCruijff();
  virtual ~__RooCruijff() throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  ::RooRealProxy x;
  ::RooRealProxy m0;
  ::RooRealProxy sigmaL;
  ::RooRealProxy sigmaR;
  ::RooRealProxy alphaL;
  ::RooRealProxy alphaR;
};
#ifdef __CombBkgPTPdf
#undef __CombBkgPTPdf
#endif
class __CombBkgPTPdf : public ::RooAbsPdf {
  public:
  __CombBkgPTPdf();
  virtual ~__CombBkgPTPdf() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t evaluate() const throw();
  virtual ::TObject* clone(char const*) const throw();
  ::RooRealProxy t;
  ::RooRealProxy a;
  ::RooRealProxy f;
  ::RooRealProxy alpha;
  ::RooRealProxy beta;
};
#ifdef __RooBinnedFun
#undef __RooBinnedFun
#endif
class __RooBinnedFun : public ::RooAbsGaussModelEfficiency {
  public:
  __RooBinnedFun();
  virtual ~__RooBinnedFun() throw();
  virtual ::Int_t getAnalyticalIntegral(RooArgSet&, RooArgSet&, char const*) const throw();
  virtual ::Double_t analyticalIntegral(int, char const*) const throw();
  virtual ::Int_t getMaxVal(RooArgSet const&) const throw();
  virtual ::TClass* IsA() const throw();
  virtual void Streamer(TBuffer&) throw();
  virtual ::std::complex<double> productAnalyticalIntegral(double, double, double, double, std::complex<double> const&) const throw();
  virtual ::std::list<double>* binBoundaries(RooAbsRealLValue&, double, double) const throw();
  virtual ::Double_t evaluate() const throw();
  virtual void ShowMembers(TMemberInspector&) throw();
  virtual ::Double_t maxVal(int) const throw();
  virtual ::RooBinnedFun* clone(char const*) const throw();
  ::RooRealProxy _x;
  ::RooListProxy _coefList;
  ::std::vector<double> _u;
};
#ifdef __std__vector_double_
#undef __std__vector_double_
#endif
class __std__vector_double_ : protected ::std::_Vector_base<double,std::allocator<double> > {
  public:
  __std__vector_double_();
};
#ifdef __RooCubicSplineKnot__S_jk
#undef __RooCubicSplineKnot__S_jk
#endif
class __RooCubicSplineKnot__S_jk {
  public:
  __RooCubicSplineKnot__S_jk();
  double t;
  double d;
  double s;
  double o;
};
#ifdef __std__vector_RooCubicSplineKnot__S_jk_
#undef __std__vector_RooCubicSplineKnot__S_jk_
#endif
class __std__vector_RooCubicSplineKnot__S_jk_ : protected ::std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > {
  public:
  __std__vector_RooCubicSplineKnot__S_jk_();
};
#ifdef __std__vector_float_
#undef __std__vector_float_
#endif
class __std__vector_float_ : protected ::std::_Vector_base<float,std::allocator<float> > {
  public:
  __std__vector_float_();
};
#ifdef __std__vector_unsignedslongslong_
#undef __std__vector_unsignedslongslong_
#endif
class __std__vector_unsignedslongslong_ : protected ::std::_Vector_base<unsigned long long,std::allocator<unsigned long long> > {
  public:
  __std__vector_unsignedslongslong_();
};
#ifdef __std__vector_unsignedslong_
#undef __std__vector_unsignedslong_
#endif
class __std__vector_unsignedslong_ : protected ::std::_Vector_base<unsigned long,std::allocator<unsigned long> > {
  public:
  __std__vector_unsignedslong_();
};
#ifdef __std__vector_unsignedsint_
#undef __std__vector_unsignedsint_
#endif
class __std__vector_unsignedsint_ : protected ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > {
  public:
  __std__vector_unsignedsint_();
};
#ifdef __std__vector_unsignedsshort_
#undef __std__vector_unsignedsshort_
#endif
class __std__vector_unsignedsshort_ : protected ::std::_Vector_base<unsigned short,std::allocator<unsigned short> > {
  public:
  __std__vector_unsignedsshort_();
};
#ifdef __std__vector_unsignedschar_
#undef __std__vector_unsignedschar_
#endif
class __std__vector_unsignedschar_ : protected ::std::_Vector_base<unsigned char,std::allocator<unsigned char> > {
  public:
  __std__vector_unsignedschar_();
};
#ifdef __std__vector_longslong_
#undef __std__vector_longslong_
#endif
class __std__vector_longslong_ : protected ::std::_Vector_base<long long,std::allocator<long long> > {
  public:
  __std__vector_longslong_();
};
#ifdef __std__vector_long_
#undef __std__vector_long_
#endif
class __std__vector_long_ : protected ::std::_Vector_base<long,std::allocator<long> > {
  public:
  __std__vector_long_();
};
#ifdef __std__vector_int_
#undef __std__vector_int_
#endif
class __std__vector_int_ : protected ::std::_Vector_base<int,std::allocator<int> > {
  public:
  __std__vector_int_();
};
#ifdef __std__vector_short_
#undef __std__vector_short_
#endif
class __std__vector_short_ : protected ::std::_Vector_base<short,std::allocator<short> > {
  public:
  __std__vector_short_();
};
#ifdef __std__vector_char_
#undef __std__vector_char_
#endif
class __std__vector_char_ : protected ::std::_Vector_base<char,std::allocator<char> > {
  public:
  __std__vector_char_();
};
#ifdef __std__vector_RooFitResultp_
#undef __std__vector_RooFitResultp_
#endif
class __std__vector_RooFitResultp_ : protected ::std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> > {
  public:
  __std__vector_RooFitResultp_();
};
#ifdef __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_
#undef __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_
#endif
class __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > > {
  public:
  __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s_();
};
#ifdef __std__vector_std__map_voidp_double_s_
#undef __std__vector_std__map_voidp_double_s_
#endif
class __std__vector_std__map_voidp_double_s_ : protected ::std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > > {
  public:
  __std__vector_std__map_voidp_double_s_();
};
#ifdef __std__vector_std__vector_double_s_
#undef __std__vector_std__vector_double_s_
#endif
class __std__vector_std__vector_double_s_ : protected ::std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > > {
  public:
  __std__vector_std__vector_double_s_();
};
#ifdef __std__vector_constsRooAbsBinningp_
#undef __std__vector_constsRooAbsBinningp_
#endif
class __std__vector_constsRooAbsBinningp_ : protected ::std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > {
  public:
  __std__vector_constsRooAbsBinningp_();
};
#ifdef __std__vector_RooAbsLValuep_
#undef __std__vector_RooAbsLValuep_
#endif
class __std__vector_RooAbsLValuep_ : protected ::std::_Vector_base<RooAbsLValue*,std::allocator<RooAbsLValue*> > {
  public:
  __std__vector_RooAbsLValuep_();
};
#ifdef __std__vector_std__vector_double_p_
#undef __std__vector_std__vector_double_p_
#endif
class __std__vector_std__vector_double_p_ : protected ::std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> > {
  public:
  __std__vector_std__vector_double_p_();
};
#ifdef __std__vector_RooNormSetCache_
#undef __std__vector_RooNormSetCache_
#endif
class __std__vector_RooNormSetCache_ : protected ::std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> > {
  public:
  __std__vector_RooNormSetCache_();
};
#ifdef __std__vector_std__pair_double_TString_s_
#undef __std__vector_std__pair_double_TString_s_
#endif
class __std__vector_std__pair_double_TString_s_ : protected ::std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > > {
  public:
  __std__vector_std__pair_double_TString_s_();
};
#ifdef __std__vector_TString_
#undef __std__vector_TString_
#endif
class __std__vector_TString_ : protected ::std::_Vector_base<TString,std::allocator<TString> > {
  public:
  __std__vector_TString_();
};
#ifdef __std__vector_std__map_int_int_s_
#undef __std__vector_std__map_int_int_s_
#endif
class __std__vector_std__map_int_int_s_ : protected ::std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > > {
  public:
  __std__vector_std__map_int_int_s_();
};
#ifdef __std__vector_RooAbsRealLValuep_
#undef __std__vector_RooAbsRealLValuep_
#endif
class __std__vector_RooAbsRealLValuep_ : protected ::std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > {
  public:
  __std__vector_RooAbsRealLValuep_();
};
#ifdef __std__vector_bool_
#undef __std__vector_bool_
#endif
class __std__vector_bool_ : protected ::std::_Bvector_base<std::allocator<bool> > {
  public:
  __std__vector_bool_();
};
#ifdef __std__vector_RooArgSetp_
#undef __std__vector_RooArgSetp_
#endif
class __std__vector_RooArgSetp_ : protected ::std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> > {
  public:
  __std__vector_RooArgSetp_();
};
#ifdef __std__vector_std__vector_int_s_
#undef __std__vector_std__vector_int_s_
#endif
class __std__vector_std__vector_int_s_ : protected ::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > {
  public:
  __std__vector_std__vector_int_s_();
};
#ifdef __std__vector_std__pair_std__basic_string_char__int_s_
#undef __std__vector_std__pair_std__basic_string_char__int_s_
#endif
class __std__vector_std__pair_std__basic_string_char__int_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > > {
  public:
  __std__vector_std__pair_std__basic_string_char__int_s_();
};
#ifdef __std__vector_RooAbsArgp_
#undef __std__vector_RooAbsArgp_
#endif
class __std__vector_RooAbsArgp_ : protected ::std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> > {
  public:
  __std__vector_RooAbsArgp_();
};
#ifdef __std__vector_RooAbsCacheElementp_
#undef __std__vector_RooAbsCacheElementp_
#endif
class __std__vector_RooAbsCacheElementp_ : protected ::std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > {
  public:
  __std__vector_RooAbsCacheElementp_();
};
#ifdef __std__vector_RooMsgService__StreamConfig_
#undef __std__vector_RooMsgService__StreamConfig_
#endif
class __std__vector_RooMsgService__StreamConfig_ : protected ::std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > {
  public:
  __std__vector_RooMsgService__StreamConfig_();
};
#ifdef __std__vector_TVirtualArrayp_
#undef __std__vector_TVirtualArrayp_
#endif
class __std__vector_TVirtualArrayp_ : protected ::std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> > {
  public:
  __std__vector_TVirtualArrayp_();
};
#ifdef __std__vector_ROOT__TSchemaHelper_
#undef __std__vector_ROOT__TSchemaHelper_
#endif
class __std__vector_ROOT__TSchemaHelper_ : protected ::std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > {
  public:
  __std__vector_ROOT__TSchemaHelper_();
};
#ifdef __std__pair_std__basic_string_char__RooAbsDatap_
#undef __std__pair_std__basic_string_char__RooAbsDatap_
#endif
struct __std__pair_std__basic_string_char__RooAbsDatap_ {
  public:
  __std__pair_std__basic_string_char__RooAbsDatap_();
  ::std::basic_string<char> first;
  void* second;
};
#ifdef __RooCubicSplineKnot__BoundaryConditions
#undef __RooCubicSplineKnot__BoundaryConditions
#endif
class __RooCubicSplineKnot__BoundaryConditions {
  public:
  __RooCubicSplineKnot__BoundaryConditions();
  bool secondDerivative[2];
  double value[2];
};
#ifdef __RooCubicSplineKnot__S_edge
#undef __RooCubicSplineKnot__S_edge
#endif
class __RooCubicSplineKnot__S_edge {
  public:
  __RooCubicSplineKnot__S_edge();
  double alpha;
  double beta;
};
}


#endif // __CINT__
namespace {
} // unnamed namespace

#ifndef G__DICTIONARY
# define G__DICTIONARY
#endif
#include "TClass.h"
#include "TMemberInspector.h"
#include "RtypesImp.h"
#include "TIsAProxy.h"
TClass* ::TagEfficiencyWeight::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("TagEfficiencyWeight");
   return fgIsA;
}
const char * ::TagEfficiencyWeight::Class_Name() {return "TagEfficiencyWeight";}
void ::TagEfficiencyWeight::Dictionary() {}
const char *::TagEfficiencyWeight::ImplFileName() {return "";}
int ::TagEfficiencyWeight::ImplFileLine() {return 1;}
void ::TagEfficiencyWeight::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TagEfficiencyWeight::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "tag", &tag);
   R__insp.InspectMember(tag, "tag.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "eff", &eff);
   R__insp.InspectMember(eff, "eff.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::TagEfficiencyWeight::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TagEfficiencyWeight::Class(),this);
   } else {
      b.WriteClassBuffer(::TagEfficiencyWeight::Class(),this);
   }
}
TClass* ::TagEfficiencyWeight::fgIsA = 0;

template<> TClass* RooBinned1DQuinticBase<RooAbsReal>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinned1DQuinticBase<RooAbsReal>");
   return fgIsA;
}
template<> const char * RooBinned1DQuinticBase<RooAbsReal>::Class_Name() {return "RooBinned1DQuinticBase<RooAbsReal>";}
template<> void RooBinned1DQuinticBase<RooAbsReal>::Dictionary() {}
template<> const char *RooBinned1DQuinticBase<RooAbsReal>::ImplFileName() {return "";}
template<> int RooBinned1DQuinticBase<RooAbsReal>::ImplFileLine() {return 1;}
template<> void RooBinned1DQuinticBase<RooAbsReal>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinned1DQuinticBase<RooAbsReal>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsX", &nBinsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeX", &binSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "isIntegral", &isIntegral);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "coeffs", &coeffs);
   R__insp.InspectMember(coeffs, "coeffs.");
   RooAbsReal::ShowMembers(R__insp);
}
template<> void RooBinned1DQuinticBase<RooAbsReal>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinned1DQuinticBase<RooAbsReal>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinned1DQuinticBase<RooAbsReal>::Class(),this);
   }
}
template<> TClass* RooBinned1DQuinticBase<RooAbsReal>::fgIsA = 0;

TClass* ::DecRateCoeff::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("DecRateCoeff");
   return fgIsA;
}
const char * ::DecRateCoeff::Class_Name() {return "DecRateCoeff";}
void ::DecRateCoeff::Dictionary() {}
const char *::DecRateCoeff::ImplFileName() {return "";}
int ::DecRateCoeff::ImplFileLine() {return 1;}
void ::DecRateCoeff::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::DecRateCoeff::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qf", &m_qf);
   R__insp.InspectMember(m_qf, "m_qf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qt", &m_qt);
   R__insp.InspectMember(m_qt, "m_qt.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Cf", &m_Cf);
   R__insp.InspectMember(m_Cf, "m_Cf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_Cfbar", &m_Cfbar);
   R__insp.InspectMember(m_Cfbar, "m_Cfbar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etaobs", &m_etaobs);
   R__insp.InspectMember(m_etaobs, "m_etaobs.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdf", &m_etapdf);
   R__insp.InspectMember(m_etapdf, "m_etapdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdfutinstance", &m_etapdfutinstance);
   R__insp.InspectMember(m_etapdfutinstance, "m_etapdfutinstance.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdfut", &m_etapdfut);
   R__insp.InspectMember(m_etapdfut, "m_etapdfut.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_tageff", &m_tageff);
   R__insp.InspectMember(m_tageff, "m_tageff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_eta", &m_eta);
   R__insp.InspectMember(m_eta, "m_eta.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etabar", &m_etabar);
   R__insp.InspectMember(m_etabar, "m_etabar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_aprod", &m_aprod);
   R__insp.InspectMember(m_aprod, "m_aprod.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_adet", &m_adet);
   R__insp.InspectMember(m_adet, "m_adet.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_atageff", &m_atageff);
   R__insp.InspectMember(m_atageff, "m_atageff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_cacheMgr", &m_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&m_cacheMgr, "m_cacheMgr.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nsets", &m_nsets);
   R__insp.InspectMember("std::map<unsigned int,RooArgSet>", (void*)&m_nsets, "m_nsets.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_nset", &m_nset);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nsethash", &m_nsethash);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_flags", &m_flags);
   RooAbsReal::ShowMembers(R__insp);
}
void ::DecRateCoeff::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::DecRateCoeff::Class(),this);
   } else {
      b.WriteClassBuffer(::DecRateCoeff::Class(),this);
   }
}
TClass* ::DecRateCoeff::fgIsA = 0;

TClass* ::IfThreeWayPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("IfThreeWayPdf");
   return fgIsA;
}
const char * ::IfThreeWayPdf::Class_Name() {return "IfThreeWayPdf";}
void ::IfThreeWayPdf::Dictionary() {}
const char *::IfThreeWayPdf::ImplFileName() {return "";}
int ::IfThreeWayPdf::ImplFileLine() {return 1;}
void ::IfThreeWayPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::IfThreeWayPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cond", &cond);
   R__insp.InspectMember(cond, "cond.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "pos", &pos);
   R__insp.InspectMember(pos, "pos.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "zero", &zero);
   R__insp.InspectMember(zero, "zero.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "neg", &neg);
   R__insp.InspectMember(neg, "neg.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::IfThreeWayPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::IfThreeWayPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::IfThreeWayPdf::Class(),this);
   }
}
TClass* ::IfThreeWayPdf::fgIsA = 0;

TClass* ::Inverse::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("Inverse");
   return fgIsA;
}
const char * ::Inverse::Class_Name() {return "Inverse";}
void ::Inverse::Dictionary() {}
const char *::Inverse::ImplFileName() {return "";}
int ::Inverse::ImplFileLine() {return 1;}
void ::Inverse::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::Inverse::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "val", &val);
   R__insp.InspectMember(val, "val.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::Inverse::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::Inverse::Class(),this);
   } else {
      b.WriteClassBuffer(::Inverse::Class(),this);
   }
}
TClass* ::Inverse::fgIsA = 0;

TClass* ::RooEffConvGenContext::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooEffConvGenContext");
   return fgIsA;
}
const char * ::RooEffConvGenContext::Class_Name() {return "RooEffConvGenContext";}
void ::RooEffConvGenContext::Dictionary() {}
const char *::RooEffConvGenContext::ImplFileName() {return "";}
int ::RooEffConvGenContext::ImplFileLine() {return 1;}
void ::RooEffConvGenContext::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooEffConvGenContext::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_maxEff", &_maxEff);
   RooConvGenContext::ShowMembers(R__insp);
}
void ::RooEffConvGenContext::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooEffConvGenContext::Class(),this);
   } else {
      b.WriteClassBuffer(::RooEffConvGenContext::Class(),this);
   }
}
TClass* ::RooEffConvGenContext::fgIsA = 0;

TClass* ::BdPTAcceptance::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("BdPTAcceptance");
   return fgIsA;
}
const char * ::BdPTAcceptance::Class_Name() {return "BdPTAcceptance";}
void ::BdPTAcceptance::Dictionary() {}
const char *::BdPTAcceptance::ImplFileName() {return "";}
int ::BdPTAcceptance::ImplFileLine() {return 1;}
void ::BdPTAcceptance::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::BdPTAcceptance::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "t", &t);
   R__insp.InspectMember(t, "t.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "beta", &beta);
   R__insp.InspectMember(beta, "beta.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "slope", &slope);
   R__insp.InspectMember(slope, "slope.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "offset", &offset);
   R__insp.InspectMember(offset, "offset.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::BdPTAcceptance::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::BdPTAcceptance::Class(),this);
   } else {
      b.WriteClassBuffer(::BdPTAcceptance::Class(),this);
   }
}
TClass* ::BdPTAcceptance::fgIsA = 0;

template<> TClass* RooBinned2DBicubicBase<RooAbsPdf>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinned2DBicubicBase<RooAbsPdf>");
   return fgIsA;
}
template<> const char * RooBinned2DBicubicBase<RooAbsPdf>::Class_Name() {return "RooBinned2DBicubicBase<RooAbsPdf>";}
template<> void RooBinned2DBicubicBase<RooAbsPdf>::Dictionary() {}
template<> const char *RooBinned2DBicubicBase<RooAbsPdf>::ImplFileName() {return "";}
template<> int RooBinned2DBicubicBase<RooAbsPdf>::ImplFileLine() {return 1;}
template<> void RooBinned2DBicubicBase<RooAbsPdf>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinned2DBicubicBase<RooAbsPdf>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "y", &y);
   R__insp.InspectMember(y, "y.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsX", &nBinsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsY", &nBinsY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeX", &binSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeY", &binSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ymin", &ymin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ymax", &ymax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "coeffs", &coeffs);
   R__insp.InspectMember(coeffs, "coeffs.");
   RooAbsPdf::ShowMembers(R__insp);
}
template<> void RooBinned2DBicubicBase<RooAbsPdf>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinned2DBicubicBase<RooAbsPdf>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinned2DBicubicBase<RooAbsPdf>::Class(),this);
   }
}
template<> TClass* RooBinned2DBicubicBase<RooAbsPdf>::fgIsA = 0;

template<> TClass* RooBinned2DBicubicBase<RooAbsReal>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinned2DBicubicBase<RooAbsReal>");
   return fgIsA;
}
template<> const char * RooBinned2DBicubicBase<RooAbsReal>::Class_Name() {return "RooBinned2DBicubicBase<RooAbsReal>";}
template<> void RooBinned2DBicubicBase<RooAbsReal>::Dictionary() {}
template<> const char *RooBinned2DBicubicBase<RooAbsReal>::ImplFileName() {return "";}
template<> int RooBinned2DBicubicBase<RooAbsReal>::ImplFileLine() {return 1;}
template<> void RooBinned2DBicubicBase<RooAbsReal>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinned2DBicubicBase<RooAbsReal>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "y", &y);
   R__insp.InspectMember(y, "y.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsX", &nBinsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsY", &nBinsY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeX", &binSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeY", &binSizeY);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ymin", &ymin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ymax", &ymax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "coeffs", &coeffs);
   R__insp.InspectMember(coeffs, "coeffs.");
   RooAbsReal::ShowMembers(R__insp);
}
template<> void RooBinned2DBicubicBase<RooAbsReal>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinned2DBicubicBase<RooAbsReal>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinned2DBicubicBase<RooAbsReal>::Class(),this);
   }
}
template<> TClass* RooBinned2DBicubicBase<RooAbsReal>::fgIsA = 0;

TClass* ::IfThreeWayCatPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("IfThreeWayCatPdf");
   return fgIsA;
}
const char * ::IfThreeWayCatPdf::Class_Name() {return "IfThreeWayCatPdf";}
void ::IfThreeWayCatPdf::Dictionary() {}
const char *::IfThreeWayCatPdf::ImplFileName() {return "";}
int ::IfThreeWayCatPdf::ImplFileLine() {return 1;}
void ::IfThreeWayCatPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::IfThreeWayCatPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cond", &cond);
   R__insp.InspectMember(cond, "cond.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "pos", &pos);
   R__insp.InspectMember(pos, "pos.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "zero", &zero);
   R__insp.InspectMember(zero, "zero.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "neg", &neg);
   R__insp.InspectMember(neg, "neg.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::IfThreeWayCatPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::IfThreeWayCatPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::IfThreeWayCatPdf::Class(),this);
   }
}
TClass* ::IfThreeWayCatPdf::fgIsA = 0;

TClass* ::NonOscTaggingPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("NonOscTaggingPdf");
   return fgIsA;
}
const char * ::NonOscTaggingPdf::Class_Name() {return "NonOscTaggingPdf";}
void ::NonOscTaggingPdf::Dictionary() {}
const char *::NonOscTaggingPdf::ImplFileName() {return "";}
int ::NonOscTaggingPdf::ImplFileLine() {return 1;}
void ::NonOscTaggingPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::NonOscTaggingPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qf", &m_qf);
   R__insp.InspectMember(m_qf, "m_qf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qt", &m_qt);
   R__insp.InspectMember(m_qt, "m_qt.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etaobs", &m_etaobs);
   R__insp.InspectMember(m_etaobs, "m_etaobs.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdf", &m_etapdf);
   R__insp.InspectMember(m_etapdf, "m_etapdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdfutinstance", &m_etapdfutinstance);
   R__insp.InspectMember(m_etapdfutinstance, "m_etapdfutinstance.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etapdfut", &m_etapdfut);
   R__insp.InspectMember(m_etapdfut, "m_etapdfut.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_epsilon", &m_epsilon);
   R__insp.InspectMember(m_epsilon, "m_epsilon.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_adet", &m_adet);
   R__insp.InspectMember(m_adet, "m_adet.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_atageff_f", &m_atageff_f);
   R__insp.InspectMember(m_atageff_f, "m_atageff_f.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_atageff_t", &m_atageff_t);
   R__insp.InspectMember(m_atageff_t, "m_atageff_t.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_cacheMgr", &m_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&m_cacheMgr, "m_cacheMgr.", false);
   RooAbsPdf::ShowMembers(R__insp);
}
void ::NonOscTaggingPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::NonOscTaggingPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::NonOscTaggingPdf::Class(),this);
   }
}
TClass* ::NonOscTaggingPdf::fgIsA = 0;

TClass* ::DTAcceptanceLHCbNote2007041::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("DTAcceptanceLHCbNote2007041");
   return fgIsA;
}
const char * ::DTAcceptanceLHCbNote2007041::Class_Name() {return "DTAcceptanceLHCbNote2007041";}
void ::DTAcceptanceLHCbNote2007041::Dictionary() {}
const char *::DTAcceptanceLHCbNote2007041::ImplFileName() {return "";}
int ::DTAcceptanceLHCbNote2007041::ImplFileLine() {return 1;}
void ::DTAcceptanceLHCbNote2007041::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::DTAcceptanceLHCbNote2007041::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "t", &t);
   R__insp.InspectMember(t, "t.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "s_low", &s_low);
   R__insp.InspectMember(s_low, "s_low.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "s_high", &s_high);
   R__insp.InspectMember(s_high, "s_high.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "n", &n);
   R__insp.InspectMember(n, "n.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "limit", &limit);
   R__insp.InspectMember(limit, "limit.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::DTAcceptanceLHCbNote2007041::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::DTAcceptanceLHCbNote2007041::Class(),this);
   } else {
      b.WriteClassBuffer(::DTAcceptanceLHCbNote2007041::Class(),this);
   }
}
TClass* ::DTAcceptanceLHCbNote2007041::fgIsA = 0;

TClass* ::RooEffResModel::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooEffResModel");
   return fgIsA;
}
const char * ::RooEffResModel::Class_Name() {return "RooEffResModel";}
void ::RooEffResModel::Dictionary() {}
const char *::RooEffResModel::ImplFileName() {return "";}
int ::RooEffResModel::ImplFileLine() {return 1;}
void ::RooEffResModel::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooEffResModel::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_observables", &_observables);
   R__insp.InspectMember(_observables, "_observables.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_model", &_model);
   R__insp.InspectMember(_model, "_model.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_eff", &_eff);
   R__insp.InspectMember(_eff, "_eff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_cacheMgr", &_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&_cacheMgr, "_cacheMgr.", false);
   RooResolutionModel::ShowMembers(R__insp);
   R__insp.GenericShowMembers("RooAbsEffResModel", ( ::RooAbsEffResModel *)(this), false);
}
void ::RooEffResModel::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooEffResModel::Class(),this);
   } else {
      b.WriteClassBuffer(::RooEffResModel::Class(),this);
   }
}
TClass* ::RooEffResModel::fgIsA = 0;

TClass* ::IfThreeWayCat::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("IfThreeWayCat");
   return fgIsA;
}
const char * ::IfThreeWayCat::Class_Name() {return "IfThreeWayCat";}
void ::IfThreeWayCat::Dictionary() {}
const char *::IfThreeWayCat::ImplFileName() {return "";}
int ::IfThreeWayCat::ImplFileLine() {return 1;}
void ::IfThreeWayCat::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::IfThreeWayCat::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cond", &cond);
   R__insp.InspectMember(cond, "cond.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "pos", &pos);
   R__insp.InspectMember(pos, "pos.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "zero", &zero);
   R__insp.InspectMember(zero, "zero.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "neg", &neg);
   R__insp.InspectMember(neg, "neg.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::IfThreeWayCat::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::IfThreeWayCat::Class(),this);
   } else {
      b.WriteClassBuffer(::IfThreeWayCat::Class(),this);
   }
}
TClass* ::IfThreeWayCat::fgIsA = 0;

TClass* ::RooCubicSplineKnot::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooCubicSplineKnot");
   return fgIsA;
}
const char * ::RooCubicSplineKnot::Class_Name() {return "RooCubicSplineKnot";}
void ::RooCubicSplineKnot::Dictionary() {}
const char *::RooCubicSplineKnot::ImplFileName() {return "";}
int ::RooCubicSplineKnot::ImplFileLine() {return 1;}
void ::RooCubicSplineKnot::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooCubicSplineKnot::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_u", &_u);
   R__insp.InspectMember("std::vector<double>", (void*)&_u, "_u.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_PQRS", &_PQRS);
   R__insp.InspectMember("std::vector<double>", (void*)&_PQRS, "_PQRS.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_IABCD", &_IABCD);
   R__insp.InspectMember("std::vector<double>", (void*)&_IABCD, "_IABCD.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_S_jk", &_S_jk);
   R__insp.InspectMember("std::vector<RooCubicSplineKnot::S_jk>", (void*)&_S_jk, "_S_jk.", false);
}
void ::RooCubicSplineKnot::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooCubicSplineKnot::Class(),this);
   } else {
      b.WriteClassBuffer(::RooCubicSplineKnot::Class(),this);
   }
}
TClass* ::RooCubicSplineKnot::fgIsA = 0;

TClass* ::RooBinnedPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinnedPdf");
   return fgIsA;
}
const char * ::RooBinnedPdf::Class_Name() {return "RooBinnedPdf";}
void ::RooBinnedPdf::Dictionary() {}
const char *::RooBinnedPdf::ImplFileName() {return "";}
int ::RooBinnedPdf::ImplFileLine() {return 1;}
void ::RooBinnedPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinnedPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_baseCatsList", &_baseCatsList);
   R__insp.InspectMember(_baseCatsList, "_baseCatsList.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_baseVarsList", &_baseVarsList);
   R__insp.InspectMember(_baseVarsList, "_baseVarsList.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_coefLists", &_coefLists);
   R__insp.InspectMember(_coefLists, "_coefLists.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_function", &_function);
   R__insp.InspectMember(_function, "_function.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_indexPositions", &_indexPositions);
   R__insp.InspectMember("std::vector<std::map<int,int> >", (void*)&_indexPositions, "_indexPositions.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binningNames", &_binningNames);
   R__insp.InspectMember("std::vector<TString>", (void*)&_binningNames, "_binningNames.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_calcCoefZeros", &_calcCoefZeros);
   R__insp.InspectMember("std::vector<bool>", (void*)&_calcCoefZeros, "_calcCoefZeros.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_numCats", &_numCats);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_continuousBase", &_continuousBase);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_forceUnitIntegral", &_forceUnitIntegral);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binIntegralCoefs", &_binIntegralCoefs);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_ignoreFirstBin", &_ignoreFirstBin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_cacheMgr", &m_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&m_cacheMgr, "m_cacheMgr.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_nset", &m_nset);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nsethash", &m_nsethash);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_nsets", &m_nsets);
   R__insp.InspectMember("std::map<unsigned int,RooArgSet>", (void*)&m_nsets, "m_nsets.", false);
   RooAbsPdf::ShowMembers(R__insp);
}
void ::RooBinnedPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinnedPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinnedPdf::Class(),this);
   }
}
TClass* ::RooBinnedPdf::fgIsA = 0;

TClass* ::MistagDistribution::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("MistagDistribution");
   return fgIsA;
}
const char * ::MistagDistribution::Class_Name() {return "MistagDistribution";}
void ::MistagDistribution::Dictionary() {}
const char *::MistagDistribution::ImplFileName() {return "";}
int ::MistagDistribution::ImplFileLine() {return 1;}
void ::MistagDistribution::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::MistagDistribution::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "w", &w);
   R__insp.InspectMember(w, "w.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "w0", &w0);
   R__insp.InspectMember(w0, "w0.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "wa", &wa);
   R__insp.InspectMember(wa, "wa.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "f", &f);
   R__insp.InspectMember(f, "f.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lastw0", &lastw0);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lastwa", &lastwa);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lastf", &lastf);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lastwc", &lastwc);
   RooAbsPdf::ShowMembers(R__insp);
}
void ::MistagDistribution::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::MistagDistribution::Class(),this);
   } else {
      b.WriteClassBuffer(::MistagDistribution::Class(),this);
   }
}
TClass* ::MistagDistribution::fgIsA = 0;

TClass* ::SquaredSum::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SquaredSum");
   return fgIsA;
}
const char * ::SquaredSum::Class_Name() {return "SquaredSum";}
void ::SquaredSum::Dictionary() {}
const char *::SquaredSum::ImplFileName() {return "";}
int ::SquaredSum::ImplFileLine() {return 1;}
void ::SquaredSum::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SquaredSum::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "C", &C);
   R__insp.InspectMember(C, "C.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "D", &D);
   R__insp.InspectMember(D, "D.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "S", &S);
   R__insp.InspectMember(S, "S.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::SquaredSum::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SquaredSum::Class(),this);
   } else {
      b.WriteClassBuffer(::SquaredSum::Class(),this);
   }
}
TClass* ::SquaredSum::fgIsA = 0;

TClass* ::RooGenSmearIntegrandBinding::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooGenSmearIntegrandBinding");
   return fgIsA;
}
const char * ::RooGenSmearIntegrandBinding::Class_Name() {return "RooGenSmearIntegrandBinding";}
void ::RooGenSmearIntegrandBinding::Dictionary() {}
const char *::RooGenSmearIntegrandBinding::ImplFileName() {return "";}
int ::RooGenSmearIntegrandBinding::ImplFileLine() {return 1;}
void ::RooGenSmearIntegrandBinding::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooGenSmearIntegrandBinding::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_func", &_func);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_model", &_model);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_var", &_var);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_nset", &_nset);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_xvecValid", &_xvecValid);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_clipInvalid", &_clipInvalid);
   RooAbsFunc::ShowMembers(R__insp);
}
void ::RooGenSmearIntegrandBinding::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooGenSmearIntegrandBinding::Class(),this);
   } else {
      b.WriteClassBuffer(::RooGenSmearIntegrandBinding::Class(),this);
   }
}
TClass* ::RooGenSmearIntegrandBinding::fgIsA = 0;

TClass* ::RooGaussEfficiencyModel::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooGaussEfficiencyModel");
   return fgIsA;
}
const char * ::RooGaussEfficiencyModel::Class_Name() {return "RooGaussEfficiencyModel";}
void ::RooGaussEfficiencyModel::Dictionary() {}
const char *::RooGaussEfficiencyModel::ImplFileName() {return "";}
int ::RooGaussEfficiencyModel::ImplFileLine() {return 1;}
void ::RooGaussEfficiencyModel::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooGaussEfficiencyModel::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_flatSFInt", &_flatSFInt);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "eff", &eff);
   R__insp.InspectMember(eff, "eff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "mean", &mean);
   R__insp.InspectMember(mean, "mean.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "sigma", &sigma);
   R__insp.InspectMember(sigma, "sigma.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "msf", &msf);
   R__insp.InspectMember(msf, "msf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "ssf", &ssf);
   R__insp.InspectMember(ssf, "ssf.");
   RooResolutionModel::ShowMembers(R__insp);
   R__insp.GenericShowMembers("RooAbsEffResModel", ( ::RooAbsEffResModel *)(this), false);
}
void ::RooGaussEfficiencyModel::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooGaussEfficiencyModel::Class(),this);
   } else {
      b.WriteClassBuffer(::RooGaussEfficiencyModel::Class(),this);
   }
}
TClass* ::RooGaussEfficiencyModel::fgIsA = 0;

template<> TClass* RooGeneralisedSmearingBase<RooAbsPdf>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooGeneralisedSmearingBase<RooAbsPdf>");
   return fgIsA;
}
template<> const char * RooGeneralisedSmearingBase<RooAbsPdf>::Class_Name() {return "RooGeneralisedSmearingBase<RooAbsPdf>";}
template<> void RooGeneralisedSmearingBase<RooAbsPdf>::Dictionary() {}
template<> const char *RooGeneralisedSmearingBase<RooAbsPdf>::ImplFileName() {return "";}
template<> int RooGeneralisedSmearingBase<RooAbsPdf>::ImplFileLine() {return 1;}
template<> void RooGeneralisedSmearingBase<RooAbsPdf>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooGeneralisedSmearingBase<RooAbsPdf>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_init", &_init);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_convIntConfig", &_convIntConfig);
   R__insp.InspectMember(_convIntConfig, "_convIntConfig.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_integrator", &_integrator);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_integrand", &_integrand);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origVar", &_origVar);
   R__insp.InspectMember(_origVar, "_origVar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origPdf", &_origPdf);
   R__insp.InspectMember(_origPdf, "_origPdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origModel", &_origModel);
   R__insp.InspectMember(_origModel, "_origModel.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_cloneVar", &_cloneVar);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_clonePdf", &_clonePdf);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_cloneModel", &_cloneModel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integvarset", &_integvarset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooArgSet> >", (void*)&_integvarset, "_integvarset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integralset", &_integralset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooAbsReal*> >", (void*)&_integralset, "_integralset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integrandset", &_integrandset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> >", (void*)&_integrandset, "_integrandset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integratorset", &_integratorset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> >", (void*)&_integratorset, "_integratorset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_binning", &_binning);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedvar", &_binnedvar);
   R__insp.InspectMember(_binnedvar, "_binnedvar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_binnedvarClone", &_binnedvarClone);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcats", &_binnedcats);
   R__insp.InspectMember(_binnedcats, "_binnedcats.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcache", &_binnedcache);
   R__insp.InspectMember("std::vector<std::vector<double> >", (void*)&_binnedcache, "_binnedcache.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcacheLastVal", &_binnedcacheLastVal);
   R__insp.InspectMember("std::vector<std::map<void*,double> >", (void*)&_binnedcacheLastVal, "_binnedcacheLastVal.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_preferBinnedIntegrals", &_preferBinnedIntegrals);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_useWindow", &_useWindow);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_windowScale", &_windowScale);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_windowParam", &_windowParam);
   R__insp.InspectMember(_windowParam, "_windowParam.");
   RooAbsPdf::ShowMembers(R__insp);
}
template<> void RooGeneralisedSmearingBase<RooAbsPdf>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooGeneralisedSmearingBase<RooAbsPdf>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooGeneralisedSmearingBase<RooAbsPdf>::Class(),this);
   }
}
template<> TClass* RooGeneralisedSmearingBase<RooAbsPdf>::fgIsA = 0;

template<> TClass* RooBinned1DQuinticBase<RooAbsPdf>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinned1DQuinticBase<RooAbsPdf>");
   return fgIsA;
}
template<> const char * RooBinned1DQuinticBase<RooAbsPdf>::Class_Name() {return "RooBinned1DQuinticBase<RooAbsPdf>";}
template<> void RooBinned1DQuinticBase<RooAbsPdf>::Dictionary() {}
template<> const char *RooBinned1DQuinticBase<RooAbsPdf>::ImplFileName() {return "";}
template<> int RooBinned1DQuinticBase<RooAbsPdf>::ImplFileLine() {return 1;}
template<> void RooBinned1DQuinticBase<RooAbsPdf>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinned1DQuinticBase<RooAbsPdf>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "nBinsX", &nBinsX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "binSizeX", &binSizeX);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "isIntegral", &isIntegral);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "coeffs", &coeffs);
   R__insp.InspectMember(coeffs, "coeffs.");
   RooAbsPdf::ShowMembers(R__insp);
}
template<> void RooBinned1DQuinticBase<RooAbsPdf>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinned1DQuinticBase<RooAbsPdf>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinned1DQuinticBase<RooAbsPdf>::Class(),this);
   }
}
template<> TClass* RooBinned1DQuinticBase<RooAbsPdf>::fgIsA = 0;

TClass* ::RooEffHistProd::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooEffHistProd");
   return fgIsA;
}
const char * ::RooEffHistProd::Class_Name() {return "RooEffHistProd";}
void ::RooEffHistProd::Dictionary() {}
const char *::RooEffHistProd::ImplFileName() {return "";}
int ::RooEffHistProd::ImplFileLine() {return 1;}
void ::RooEffHistProd::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooEffHistProd::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binboundaries", &_binboundaries);
   R__insp.InspectMember("std::vector<double>", (void*)&_binboundaries, "_binboundaries.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_pdf", &_pdf);
   R__insp.InspectMember(_pdf, "_pdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_eff", &_eff);
   R__insp.InspectMember(_eff, "_eff.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_observables", &_observables);
   R__insp.InspectMember(_observables, "_observables.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_pdfGenVars", &_pdfGenVars);
   R__insp.InspectMember(_pdfGenVars, "_pdfGenVars.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_pdfGenCode", &_pdfGenCode);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_maxEff", &_maxEff);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_levels", &_levels);
   R__insp.InspectMember("std::vector<std::pair<double,TString> >", (void*)&_levels, "_levels.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_pdfObs", &_pdfObs);
   R__insp.InspectMember("std::map<std::basic_string<char>,RooArgSet*>", (void*)&_pdfObs, "_pdfObs.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_pdfNormSet", &_pdfNormSet);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_fixedNormSet", &_fixedNormSet);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_cacheMgr", &_cacheMgr);
   R__insp.InspectMember("RooObjCacheManager", (void*)&_cacheMgr, "_cacheMgr.", false);
   RooAbsPdf::ShowMembers(R__insp);
}
void ::RooEffHistProd::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooEffHistProd::Class(),this);
   } else {
      b.WriteClassBuffer(::RooEffHistProd::Class(),this);
   }
}
TClass* ::RooEffHistProd::fgIsA = 0;

TClass* ::RooAbsGaussModelEfficiency::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooAbsGaussModelEfficiency");
   return fgIsA;
}
const char * ::RooAbsGaussModelEfficiency::Class_Name() {return "RooAbsGaussModelEfficiency";}
void ::RooAbsGaussModelEfficiency::Dictionary() {}
const char *::RooAbsGaussModelEfficiency::ImplFileName() {return "";}
int ::RooAbsGaussModelEfficiency::ImplFileLine() {return 1;}
void ::RooAbsGaussModelEfficiency::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooAbsGaussModelEfficiency::IsA();
   if (R__cl || R__insp.IsA()) { }
   RooAbsReal::ShowMembers(R__insp);
}
void ::RooAbsGaussModelEfficiency::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooAbsGaussModelEfficiency::Class(),this);
   } else {
      b.WriteClassBuffer(::RooAbsGaussModelEfficiency::Class(),this);
   }
}
TClass* ::RooAbsGaussModelEfficiency::fgIsA = 0;

template<> TClass* RooGeneralisedSmearingBase<RooAbsReal>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooGeneralisedSmearingBase<RooAbsReal>");
   return fgIsA;
}
template<> const char * RooGeneralisedSmearingBase<RooAbsReal>::Class_Name() {return "RooGeneralisedSmearingBase<RooAbsReal>";}
template<> void RooGeneralisedSmearingBase<RooAbsReal>::Dictionary() {}
template<> const char *RooGeneralisedSmearingBase<RooAbsReal>::ImplFileName() {return "";}
template<> int RooGeneralisedSmearingBase<RooAbsReal>::ImplFileLine() {return 1;}
template<> void RooGeneralisedSmearingBase<RooAbsReal>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooGeneralisedSmearingBase<RooAbsReal>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_init", &_init);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_convIntConfig", &_convIntConfig);
   R__insp.InspectMember(_convIntConfig, "_convIntConfig.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_integrator", &_integrator);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_integrand", &_integrand);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origVar", &_origVar);
   R__insp.InspectMember(_origVar, "_origVar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origPdf", &_origPdf);
   R__insp.InspectMember(_origPdf, "_origPdf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_origModel", &_origModel);
   R__insp.InspectMember(_origModel, "_origModel.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_cloneVar", &_cloneVar);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_clonePdf", &_clonePdf);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_cloneModel", &_cloneModel);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integvarset", &_integvarset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooArgSet> >", (void*)&_integvarset, "_integvarset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integralset", &_integralset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooAbsReal*> >", (void*)&_integralset, "_integralset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integrandset", &_integrandset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooGenSmearIntegrandBinding*> >", (void*)&_integrandset, "_integrandset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_integratorset", &_integratorset);
   R__insp.InspectMember("std::map<std::basic_string<char>,std::map<int,RooAbsIntegrator*> >", (void*)&_integratorset, "_integratorset.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_binning", &_binning);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedvar", &_binnedvar);
   R__insp.InspectMember(_binnedvar, "_binnedvar.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*_binnedvarClone", &_binnedvarClone);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcats", &_binnedcats);
   R__insp.InspectMember(_binnedcats, "_binnedcats.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcache", &_binnedcache);
   R__insp.InspectMember("std::vector<std::vector<double> >", (void*)&_binnedcache, "_binnedcache.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_binnedcacheLastVal", &_binnedcacheLastVal);
   R__insp.InspectMember("std::vector<std::map<void*,double> >", (void*)&_binnedcacheLastVal, "_binnedcacheLastVal.", false);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_preferBinnedIntegrals", &_preferBinnedIntegrals);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_useWindow", &_useWindow);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_windowScale", &_windowScale);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_windowParam", &_windowParam);
   R__insp.InspectMember(_windowParam, "_windowParam.");
   RooAbsReal::ShowMembers(R__insp);
}
template<> void RooGeneralisedSmearingBase<RooAbsReal>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooGeneralisedSmearingBase<RooAbsReal>::Class(),this);
   } else {
      b.WriteClassBuffer(::RooGeneralisedSmearingBase<RooAbsReal>::Class(),this);
   }
}
template<> TClass* RooGeneralisedSmearingBase<RooAbsReal>::fgIsA = 0;

TClass* ::TagEfficiencyWeightNoCat::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("TagEfficiencyWeightNoCat");
   return fgIsA;
}
const char * ::TagEfficiencyWeightNoCat::Class_Name() {return "TagEfficiencyWeightNoCat";}
void ::TagEfficiencyWeightNoCat::Dictionary() {}
const char *::TagEfficiencyWeightNoCat::ImplFileName() {return "";}
int ::TagEfficiencyWeightNoCat::ImplFileLine() {return 1;}
void ::TagEfficiencyWeightNoCat::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TagEfficiencyWeightNoCat::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "tag", &tag);
   R__insp.InspectMember(tag, "tag.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "eff", &eff);
   R__insp.InspectMember(eff, "eff.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::TagEfficiencyWeightNoCat::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TagEfficiencyWeightNoCat::Class(),this);
   } else {
      b.WriteClassBuffer(::TagEfficiencyWeightNoCat::Class(),this);
   }
}
TClass* ::TagEfficiencyWeightNoCat::fgIsA = 0;

TClass* ::FinalStateChargePdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("FinalStateChargePdf");
   return fgIsA;
}
const char * ::FinalStateChargePdf::Class_Name() {return "FinalStateChargePdf";}
void ::FinalStateChargePdf::Dictionary() {}
const char *::FinalStateChargePdf::ImplFileName() {return "";}
int ::FinalStateChargePdf::ImplFileLine() {return 1;}
void ::FinalStateChargePdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::FinalStateChargePdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_qf", &m_qf);
   R__insp.InspectMember(m_qf, "m_qf.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_asymm", &m_asymm);
   R__insp.InspectMember(m_asymm, "m_asymm.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::FinalStateChargePdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::FinalStateChargePdf::Class(),this);
   } else {
      b.WriteClassBuffer(::FinalStateChargePdf::Class(),this);
   }
}
TClass* ::FinalStateChargePdf::fgIsA = 0;

TClass* ::TaggingCat::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("TaggingCat");
   return fgIsA;
}
const char * ::TaggingCat::Class_Name() {return "TaggingCat";}
void ::TaggingCat::Dictionary() {}
const char *::TaggingCat::ImplFileName() {return "";}
int ::TaggingCat::ImplFileLine() {return 1;}
void ::TaggingCat::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::TaggingCat::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "qt", &qt);
   R__insp.InspectMember(qt, "qt.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cat", &cat);
   R__insp.InspectMember(cat, "cat.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "catlist", &catlist);
   R__insp.InspectMember(catlist, "catlist.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "untaggedVal", &untaggedVal);
   R__insp.InspectMember(untaggedVal, "untaggedVal.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::TaggingCat::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::TaggingCat::Class(),this);
   } else {
      b.WriteClassBuffer(::TaggingCat::Class(),this);
   }
}
TClass* ::TaggingCat::fgIsA = 0;

TClass* ::RangeAcceptance::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RangeAcceptance");
   return fgIsA;
}
const char * ::RangeAcceptance::Class_Name() {return "RangeAcceptance";}
void ::RangeAcceptance::Dictionary() {}
const char *::RangeAcceptance::ImplFileName() {return "";}
int ::RangeAcceptance::ImplFileLine() {return 1;}
void ::RangeAcceptance::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RangeAcceptance::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmin", &xmin);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "xmax", &xmax);
   RooAbsReal::ShowMembers(R__insp);
}
void ::RangeAcceptance::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RangeAcceptance::Class(),this);
   } else {
      b.WriteClassBuffer(::RangeAcceptance::Class(),this);
   }
}
TClass* ::RangeAcceptance::fgIsA = 0;

TClass* ::PowLawAcceptance::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("PowLawAcceptance");
   return fgIsA;
}
const char * ::PowLawAcceptance::Class_Name() {return "PowLawAcceptance";}
void ::PowLawAcceptance::Dictionary() {}
const char *::PowLawAcceptance::ImplFileName() {return "";}
int ::PowLawAcceptance::ImplFileLine() {return 1;}
void ::PowLawAcceptance::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::PowLawAcceptance::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_turnon", &_turnon);
   R__insp.InspectMember(_turnon, "_turnon.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_time", &_time);
   R__insp.InspectMember(_time, "_time.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_offset", &_offset);
   R__insp.InspectMember(_offset, "_offset.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_exponent", &_exponent);
   R__insp.InspectMember(_exponent, "_exponent.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_beta", &_beta);
   R__insp.InspectMember(_beta, "_beta.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_correction", &_correction);
   R__insp.InspectMember(_correction, "_correction.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::PowLawAcceptance::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::PowLawAcceptance::Class(),this);
   } else {
      b.WriteClassBuffer(::PowLawAcceptance::Class(),this);
   }
}
TClass* ::PowLawAcceptance::fgIsA = 0;

TClass* ::MistagCalibration::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("MistagCalibration");
   return fgIsA;
}
const char * ::MistagCalibration::Class_Name() {return "MistagCalibration";}
void ::MistagCalibration::Dictionary() {}
const char *::MistagCalibration::ImplFileName() {return "";}
int ::MistagCalibration::ImplFileLine() {return 1;}
void ::MistagCalibration::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::MistagCalibration::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_eta", &m_eta);
   R__insp.InspectMember(m_eta, "m_eta.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_calibcoeffs", &m_calibcoeffs);
   R__insp.InspectMember(m_calibcoeffs, "m_calibcoeffs.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_etaavg", &m_etaavg);
   R__insp.InspectMember(m_etaavg, "m_etaavg.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::MistagCalibration::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::MistagCalibration::Class(),this);
   } else {
      b.WriteClassBuffer(::MistagCalibration::Class(),this);
   }
}
TClass* ::MistagCalibration::fgIsA = 0;

template<> TClass* SharedArrayImp<double>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<double>");
   return fgIsA;
}
template<> const char * SharedArrayImp<double>::Class_Name() {return "SharedArrayImp<double>";}
template<> void SharedArrayImp<double>::Dictionary() {}
template<> const char *SharedArrayImp<double>::ImplFileName() {return "";}
template<> int SharedArrayImp<double>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<double>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<double>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<double>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<double>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<double>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<double>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<double>::fgIsA = 0;

template<> TClass* SharedArrayImp<float>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<float>");
   return fgIsA;
}
template<> const char * SharedArrayImp<float>::Class_Name() {return "SharedArrayImp<float>";}
template<> void SharedArrayImp<float>::Dictionary() {}
template<> const char *SharedArrayImp<float>::ImplFileName() {return "";}
template<> int SharedArrayImp<float>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<float>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<float>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<float>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<float>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<float>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<float>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<float>::fgIsA = 0;

template<> TClass* SharedArrayImp<long long unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned long long>");
   return fgIsA;
}
template<> const char * SharedArrayImp<long long unsigned int>::Class_Name() {return "SharedArrayImp<unsigned long long>";}
template<> void SharedArrayImp<long long unsigned int>::Dictionary() {}
template<> const char *SharedArrayImp<long long unsigned int>::ImplFileName() {return "";}
template<> int SharedArrayImp<long long unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<long long unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned long long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned long long>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<long long unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned long long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned long long>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<long long unsigned int>::fgIsA = 0;

template<> TClass* SharedArrayImp<long unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned long>");
   return fgIsA;
}
template<> const char * SharedArrayImp<long unsigned int>::Class_Name() {return "SharedArrayImp<unsigned long>";}
template<> void SharedArrayImp<long unsigned int>::Dictionary() {}
template<> const char *SharedArrayImp<long unsigned int>::ImplFileName() {return "";}
template<> int SharedArrayImp<long unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<long unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned long>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<long unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned long>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<long unsigned int>::fgIsA = 0;

template<> TClass* SharedArrayImp<unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned int>");
   return fgIsA;
}
template<> const char * SharedArrayImp<unsigned int>::Class_Name() {return "SharedArrayImp<unsigned int>";}
template<> void SharedArrayImp<unsigned int>::Dictionary() {}
template<> const char *SharedArrayImp<unsigned int>::ImplFileName() {return "";}
template<> int SharedArrayImp<unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned int>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned int>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned int>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned int>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<unsigned int>::fgIsA = 0;

template<> TClass* SharedArrayImp<short unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned short>");
   return fgIsA;
}
template<> const char * SharedArrayImp<short unsigned int>::Class_Name() {return "SharedArrayImp<unsigned short>";}
template<> void SharedArrayImp<short unsigned int>::Dictionary() {}
template<> const char *SharedArrayImp<short unsigned int>::ImplFileName() {return "";}
template<> int SharedArrayImp<short unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<short unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned short>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned short>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<short unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned short>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned short>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<short unsigned int>::fgIsA = 0;

template<> TClass* SharedArrayImp<unsigned char>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<unsigned char>");
   return fgIsA;
}
template<> const char * SharedArrayImp<unsigned char>::Class_Name() {return "SharedArrayImp<unsigned char>";}
template<> void SharedArrayImp<unsigned char>::Dictionary() {}
template<> const char *SharedArrayImp<unsigned char>::ImplFileName() {return "";}
template<> int SharedArrayImp<unsigned char>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<unsigned char>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<unsigned char>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<unsigned char>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<unsigned char>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<unsigned char>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<unsigned char>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<unsigned char>::fgIsA = 0;

template<> TClass* SharedArrayImp<long long int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<long long>");
   return fgIsA;
}
template<> const char * SharedArrayImp<long long int>::Class_Name() {return "SharedArrayImp<long long>";}
template<> void SharedArrayImp<long long int>::Dictionary() {}
template<> const char *SharedArrayImp<long long int>::ImplFileName() {return "";}
template<> int SharedArrayImp<long long int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<long long int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<long long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<long long>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<long long int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<long long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<long long>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<long long int>::fgIsA = 0;

template<> TClass* SharedArrayImp<long int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<long>");
   return fgIsA;
}
template<> const char * SharedArrayImp<long int>::Class_Name() {return "SharedArrayImp<long>";}
template<> void SharedArrayImp<long int>::Dictionary() {}
template<> const char *SharedArrayImp<long int>::ImplFileName() {return "";}
template<> int SharedArrayImp<long int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<long int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<long>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<long int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<long>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<long int>::fgIsA = 0;

template<> TClass* SharedArrayImp<int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<int>");
   return fgIsA;
}
template<> const char * SharedArrayImp<int>::Class_Name() {return "SharedArrayImp<int>";}
template<> void SharedArrayImp<int>::Dictionary() {}
template<> const char *SharedArrayImp<int>::ImplFileName() {return "";}
template<> int SharedArrayImp<int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<int>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<int>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<int>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<int>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<int>::fgIsA = 0;

template<> TClass* SharedArrayImp<short int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<short>");
   return fgIsA;
}
template<> const char * SharedArrayImp<short int>::Class_Name() {return "SharedArrayImp<short>";}
template<> void SharedArrayImp<short int>::Dictionary() {}
template<> const char *SharedArrayImp<short int>::ImplFileName() {return "";}
template<> int SharedArrayImp<short int>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<short int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<short>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<short>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<short int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<short>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<short>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<short int>::fgIsA = 0;

template<> TClass* SharedArrayImp<char>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArrayImp<char>");
   return fgIsA;
}
template<> const char * SharedArrayImp<char>::Class_Name() {return "SharedArrayImp<char>";}
template<> void SharedArrayImp<char>::Dictionary() {}
template<> const char *SharedArrayImp<char>::ImplFileName() {return "";}
template<> int SharedArrayImp<char>::ImplFileLine() {return 1;}
template<> void SharedArrayImp<char>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArrayImp<char>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "refcount", &refcount);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "arr", &arr);
   R__insp.InspectMember("std::vector<char>", (void*)&arr, "arr.", false);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArrayImp<char>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArrayImp<char>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArrayImp<char>::Class(),this);
   }
}
template<> TClass* SharedArrayImp<char>::fgIsA = 0;

TClass* ::Dilution::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("Dilution");
   return fgIsA;
}
const char * ::Dilution::Class_Name() {return "Dilution";}
void ::Dilution::Dictionary() {}
const char *::Dilution::ImplFileName() {return "";}
int ::Dilution::ImplFileLine() {return 1;}
void ::Dilution::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::Dilution::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "omega", &omega);
   R__insp.InspectMember(omega, "omega.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::Dilution::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::Dilution::Class(),this);
   } else {
      b.WriteClassBuffer(::Dilution::Class(),this);
   }
}
TClass* ::Dilution::fgIsA = 0;

TClass* ::FitMeTool::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("FitMeTool");
   return fgIsA;
}
const char * ::FitMeTool::Class_Name() {return "FitMeTool";}
void ::FitMeTool::Dictionary() {}
const char *::FitMeTool::ImplFileName() {return "";}
int ::FitMeTool::ImplFileLine() {return 1;}
void ::FitMeTool::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::FitMeTool::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_observables", &m_observables);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_conditionalObservables", &m_conditionalObservables);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_externalConstraints", &m_externalConstraints);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_debug", &m_config_debug);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_toyNumber", &m_config_toyNumber);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_seed", &m_config_seed);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_seedSet", &m_config_seedSet);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m_config_saveFitResult2File", &m_config_saveFitResult2File);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_modelPDF", &m_modelPDF);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_data", &m_data);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_fitResult", &m_fitResult);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_outputFile", &m_outputFile);
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*m_workSpace", &m_workSpace);
}
void ::FitMeTool::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::FitMeTool::Class(),this);
   } else {
      b.WriteClassBuffer(::FitMeTool::Class(),this);
   }
}
TClass* ::FitMeTool::fgIsA = 0;

TClass* ::RooCubicSplineFun::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooCubicSplineFun");
   return fgIsA;
}
const char * ::RooCubicSplineFun::Class_Name() {return "RooCubicSplineFun";}
void ::RooCubicSplineFun::Dictionary() {}
const char *::RooCubicSplineFun::ImplFileName() {return "";}
int ::RooCubicSplineFun::ImplFileLine() {return 1;}
void ::RooCubicSplineFun::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooCubicSplineFun::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_x", &_x);
   R__insp.InspectMember(_x, "_x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_coefList", &_coefList);
   R__insp.InspectMember(_coefList, "_coefList.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_aux", &_aux);
   R__insp.InspectMember("RooCubicSplineKnot", (void*)&_aux, "_aux.", false);
   RooAbsGaussModelEfficiency::ShowMembers(R__insp);
}
void ::RooCubicSplineFun::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooCubicSplineFun::Class(),this);
   } else {
      b.WriteClassBuffer(::RooCubicSplineFun::Class(),this);
   }
}
TClass* ::RooCubicSplineFun::fgIsA = 0;

TClass* ::CPObservable::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("CPObservable");
   return fgIsA;
}
const char * ::CPObservable::Class_Name() {return "CPObservable";}
void ::CPObservable::Dictionary() {}
const char *::CPObservable::ImplFileName() {return "";}
int ::CPObservable::ImplFileLine() {return 1;}
void ::CPObservable::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::CPObservable::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "lambda", &lambda);
   R__insp.InspectMember(lambda, "lambda.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "phi_strong", &phi_strong);
   R__insp.InspectMember(phi_strong, "phi_strong.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "phi_weak", &phi_weak);
   R__insp.InspectMember(phi_weak, "phi_weak.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "what", &what);
   RooAbsReal::ShowMembers(R__insp);
}
void ::CPObservable::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::CPObservable::Class(),this);
   } else {
      b.WriteClassBuffer(::CPObservable::Class(),this);
   }
}
TClass* ::CPObservable::fgIsA = 0;

TClass* ::RooComplementCoef::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooComplementCoef");
   return fgIsA;
}
const char * ::RooComplementCoef::Class_Name() {return "RooComplementCoef";}
void ::RooComplementCoef::Dictionary() {}
const char *::RooComplementCoef::ImplFileName() {return "";}
int ::RooComplementCoef::ImplFileLine() {return 1;}
void ::RooComplementCoef::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooComplementCoef::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_coefs", &_coefs);
   R__insp.InspectMember(_coefs, "_coefs.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::RooComplementCoef::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooComplementCoef::Class(),this);
   } else {
      b.WriteClassBuffer(::RooComplementCoef::Class(),this);
   }
}
TClass* ::RooComplementCoef::fgIsA = 0;

template<> TClass* SharedArray<double>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<double>");
   return fgIsA;
}
template<> const char * SharedArray<double>::Class_Name() {return "SharedArray<double>";}
template<> void SharedArray<double>::Dictionary() {}
template<> const char *SharedArray<double>::ImplFileName() {return "";}
template<> int SharedArray<double>::ImplFileLine() {return 1;}
template<> void SharedArray<double>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<double>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<double>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<double>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<double>::Class(),this);
   }
}
template<> TClass* SharedArray<double>::fgIsA = 0;

template<> TClass* SharedArray<float>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<float>");
   return fgIsA;
}
template<> const char * SharedArray<float>::Class_Name() {return "SharedArray<float>";}
template<> void SharedArray<float>::Dictionary() {}
template<> const char *SharedArray<float>::ImplFileName() {return "";}
template<> int SharedArray<float>::ImplFileLine() {return 1;}
template<> void SharedArray<float>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<float>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<float>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<float>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<float>::Class(),this);
   }
}
template<> TClass* SharedArray<float>::fgIsA = 0;

template<> TClass* SharedArray<long long unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned long long>");
   return fgIsA;
}
template<> const char * SharedArray<long long unsigned int>::Class_Name() {return "SharedArray<unsigned long long>";}
template<> void SharedArray<long long unsigned int>::Dictionary() {}
template<> const char *SharedArray<long long unsigned int>::ImplFileName() {return "";}
template<> int SharedArray<long long unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArray<long long unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned long long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<long long unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned long long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned long long>::Class(),this);
   }
}
template<> TClass* SharedArray<long long unsigned int>::fgIsA = 0;

template<> TClass* SharedArray<long unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned long>");
   return fgIsA;
}
template<> const char * SharedArray<long unsigned int>::Class_Name() {return "SharedArray<unsigned long>";}
template<> void SharedArray<long unsigned int>::Dictionary() {}
template<> const char *SharedArray<long unsigned int>::ImplFileName() {return "";}
template<> int SharedArray<long unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArray<long unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<long unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned long>::Class(),this);
   }
}
template<> TClass* SharedArray<long unsigned int>::fgIsA = 0;

template<> TClass* SharedArray<unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned int>");
   return fgIsA;
}
template<> const char * SharedArray<unsigned int>::Class_Name() {return "SharedArray<unsigned int>";}
template<> void SharedArray<unsigned int>::Dictionary() {}
template<> const char *SharedArray<unsigned int>::ImplFileName() {return "";}
template<> int SharedArray<unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArray<unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned int>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned int>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned int>::Class(),this);
   }
}
template<> TClass* SharedArray<unsigned int>::fgIsA = 0;

template<> TClass* SharedArray<short unsigned int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned short>");
   return fgIsA;
}
template<> const char * SharedArray<short unsigned int>::Class_Name() {return "SharedArray<unsigned short>";}
template<> void SharedArray<short unsigned int>::Dictionary() {}
template<> const char *SharedArray<short unsigned int>::ImplFileName() {return "";}
template<> int SharedArray<short unsigned int>::ImplFileLine() {return 1;}
template<> void SharedArray<short unsigned int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned short>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<short unsigned int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned short>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned short>::Class(),this);
   }
}
template<> TClass* SharedArray<short unsigned int>::fgIsA = 0;

template<> TClass* SharedArray<unsigned char>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<unsigned char>");
   return fgIsA;
}
template<> const char * SharedArray<unsigned char>::Class_Name() {return "SharedArray<unsigned char>";}
template<> void SharedArray<unsigned char>::Dictionary() {}
template<> const char *SharedArray<unsigned char>::ImplFileName() {return "";}
template<> int SharedArray<unsigned char>::ImplFileLine() {return 1;}
template<> void SharedArray<unsigned char>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<unsigned char>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<unsigned char>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<unsigned char>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<unsigned char>::Class(),this);
   }
}
template<> TClass* SharedArray<unsigned char>::fgIsA = 0;

template<> TClass* SharedArray<long long int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<long long>");
   return fgIsA;
}
template<> const char * SharedArray<long long int>::Class_Name() {return "SharedArray<long long>";}
template<> void SharedArray<long long int>::Dictionary() {}
template<> const char *SharedArray<long long int>::ImplFileName() {return "";}
template<> int SharedArray<long long int>::ImplFileLine() {return 1;}
template<> void SharedArray<long long int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<long long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<long long int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<long long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<long long>::Class(),this);
   }
}
template<> TClass* SharedArray<long long int>::fgIsA = 0;

template<> TClass* SharedArray<long int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<long>");
   return fgIsA;
}
template<> const char * SharedArray<long int>::Class_Name() {return "SharedArray<long>";}
template<> void SharedArray<long int>::Dictionary() {}
template<> const char *SharedArray<long int>::ImplFileName() {return "";}
template<> int SharedArray<long int>::ImplFileLine() {return 1;}
template<> void SharedArray<long int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<long>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<long int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<long>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<long>::Class(),this);
   }
}
template<> TClass* SharedArray<long int>::fgIsA = 0;

template<> TClass* SharedArray<int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<int>");
   return fgIsA;
}
template<> const char * SharedArray<int>::Class_Name() {return "SharedArray<int>";}
template<> void SharedArray<int>::Dictionary() {}
template<> const char *SharedArray<int>::ImplFileName() {return "";}
template<> int SharedArray<int>::ImplFileLine() {return 1;}
template<> void SharedArray<int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<int>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<int>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<int>::Class(),this);
   }
}
template<> TClass* SharedArray<int>::fgIsA = 0;

template<> TClass* SharedArray<short int>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<short>");
   return fgIsA;
}
template<> const char * SharedArray<short int>::Class_Name() {return "SharedArray<short>";}
template<> void SharedArray<short int>::Dictionary() {}
template<> const char *SharedArray<short int>::ImplFileName() {return "";}
template<> int SharedArray<short int>::ImplFileLine() {return 1;}
template<> void SharedArray<short int>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<short>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<short int>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<short>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<short>::Class(),this);
   }
}
template<> TClass* SharedArray<short int>::fgIsA = 0;

template<> TClass* SharedArray<char>::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("SharedArray<char>");
   return fgIsA;
}
template<> const char * SharedArray<char>::Class_Name() {return "SharedArray<char>";}
template<> void SharedArray<char>::Dictionary() {}
template<> const char *SharedArray<char>::ImplFileName() {return "";}
template<> int SharedArray<char>::ImplFileLine() {return 1;}
template<> void SharedArray<char>::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::SharedArray<char>::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "*pimpl", &pimpl);
   TObject::ShowMembers(R__insp);
}
template<> void SharedArray<char>::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::SharedArray<char>::Class(),this);
   } else {
      b.WriteClassBuffer(::SharedArray<char>::Class(),this);
   }
}
template<> TClass* SharedArray<char>::fgIsA = 0;

TClass* ::IfThreeWay::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("IfThreeWay");
   return fgIsA;
}
const char * ::IfThreeWay::Class_Name() {return "IfThreeWay";}
void ::IfThreeWay::Dictionary() {}
const char *::IfThreeWay::ImplFileName() {return "";}
int ::IfThreeWay::ImplFileLine() {return 1;}
void ::IfThreeWay::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::IfThreeWay::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "cond", &cond);
   R__insp.InspectMember(cond, "cond.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "pos", &pos);
   R__insp.InspectMember(pos, "pos.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "zero", &zero);
   R__insp.InspectMember(zero, "zero.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "neg", &neg);
   R__insp.InspectMember(neg, "neg.");
   RooAbsReal::ShowMembers(R__insp);
}
void ::IfThreeWay::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::IfThreeWay::Class(),this);
   } else {
      b.WriteClassBuffer(::IfThreeWay::Class(),this);
   }
}
TClass* ::IfThreeWay::fgIsA = 0;

TClass* ::RooCruijff::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooCruijff");
   return fgIsA;
}
const char * ::RooCruijff::Class_Name() {return "RooCruijff";}
void ::RooCruijff::Dictionary() {}
const char *::RooCruijff::ImplFileName() {return "";}
int ::RooCruijff::ImplFileLine() {return 1;}
void ::RooCruijff::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooCruijff::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "x", &x);
   R__insp.InspectMember(x, "x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "m0", &m0);
   R__insp.InspectMember(m0, "m0.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "sigmaL", &sigmaL);
   R__insp.InspectMember(sigmaL, "sigmaL.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "sigmaR", &sigmaR);
   R__insp.InspectMember(sigmaR, "sigmaR.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "alphaL", &alphaL);
   R__insp.InspectMember(alphaL, "alphaL.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "alphaR", &alphaR);
   R__insp.InspectMember(alphaR, "alphaR.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::RooCruijff::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooCruijff::Class(),this);
   } else {
      b.WriteClassBuffer(::RooCruijff::Class(),this);
   }
}
TClass* ::RooCruijff::fgIsA = 0;

TClass* ::CombBkgPTPdf::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("CombBkgPTPdf");
   return fgIsA;
}
const char * ::CombBkgPTPdf::Class_Name() {return "CombBkgPTPdf";}
void ::CombBkgPTPdf::Dictionary() {}
const char *::CombBkgPTPdf::ImplFileName() {return "";}
int ::CombBkgPTPdf::ImplFileLine() {return 1;}
void ::CombBkgPTPdf::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::CombBkgPTPdf::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "t", &t);
   R__insp.InspectMember(t, "t.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "a", &a);
   R__insp.InspectMember(a, "a.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "f", &f);
   R__insp.InspectMember(f, "f.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "alpha", &alpha);
   R__insp.InspectMember(alpha, "alpha.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "beta", &beta);
   R__insp.InspectMember(beta, "beta.");
   RooAbsPdf::ShowMembers(R__insp);
}
void ::CombBkgPTPdf::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::CombBkgPTPdf::Class(),this);
   } else {
      b.WriteClassBuffer(::CombBkgPTPdf::Class(),this);
   }
}
TClass* ::CombBkgPTPdf::fgIsA = 0;

TClass* ::RooBinnedFun::Class() {
   if (!fgIsA)
      fgIsA = TClass::GetClass("RooBinnedFun");
   return fgIsA;
}
const char * ::RooBinnedFun::Class_Name() {return "RooBinnedFun";}
void ::RooBinnedFun::Dictionary() {}
const char *::RooBinnedFun::ImplFileName() {return "";}
int ::RooBinnedFun::ImplFileLine() {return 1;}
void ::RooBinnedFun::ShowMembers(TMemberInspector &R__insp) {
   TClass *R__cl = ::RooBinnedFun::IsA();
   if (R__cl || R__insp.IsA()) { }
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_x", &_x);
   R__insp.InspectMember(_x, "_x.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_coefList", &_coefList);
   R__insp.InspectMember(_coefList, "_coefList.");
   R__insp.Inspect(R__cl, R__insp.GetParent(), "_u", &_u);
   R__insp.InspectMember("std::vector<double>", (void*)&_u, "_u.", false);
   RooAbsGaussModelEfficiency::ShowMembers(R__insp);
}
void ::RooBinnedFun::Streamer(TBuffer &b) {
   if (b.IsReading()) {
      b.ReadClassBuffer(::RooBinnedFun::Class(),this);
   } else {
      b.WriteClassBuffer(::RooBinnedFun::Class(),this);
   }
}
TClass* ::RooBinnedFun::fgIsA = 0;


namespace {
//------Stub functions for class TagEfficiencyWeight -------------------------------
static  void operator_4138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TagEfficiencyWeight*)o)->operator=)(*(const ::TagEfficiencyWeight*)arg[0]);
  else   (((::TagEfficiencyWeight*)o)->operator=)(*(const ::TagEfficiencyWeight*)arg[0]);
}

static void constructor_4139( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeight();
  else ::new(mem) ::TagEfficiencyWeight();
}

static void constructor_4140( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeight((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::TagEfficiencyWeight((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_4141( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeight(*(const ::TagEfficiencyWeight*)arg[0]);
  else ::new(mem) ::TagEfficiencyWeight(*(const ::TagEfficiencyWeight*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeight(*(const ::TagEfficiencyWeight*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::TagEfficiencyWeight(*(const ::TagEfficiencyWeight*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_4142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TagEfficiencyWeight*)o)->clone)((const char*)arg[0]));
  else   (((const ::TagEfficiencyWeight*)o)->clone)((const char*)arg[0]);
}

static void destructor_4143(void*, void * o, const std::vector<void*>&, void *) {
(((::TagEfficiencyWeight*)o)->::TagEfficiencyWeight::~TagEfficiencyWeight)();
}
static  void method_4145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeight*)o)->Class)());
  else   (((::TagEfficiencyWeight*)o)->Class)();
}

static  void method_4146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeight*)o)->Class_Name)());
  else   (((::TagEfficiencyWeight*)o)->Class_Name)();
}

static  void method_4147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TagEfficiencyWeight*)o)->Class_Version)());
  else   (((::TagEfficiencyWeight*)o)->Class_Version)();
}

static  void method_4148( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TagEfficiencyWeight*)o)->Dictionary)();
}

static  void method_4149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TagEfficiencyWeight*)o)->IsA)());
  else   (((const ::TagEfficiencyWeight*)o)->IsA)();
}

static  void method_4150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeight*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4151( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeight*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4152( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeight*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeight*)o)->DeclFileName)());
  else   (((::TagEfficiencyWeight*)o)->DeclFileName)();
}

static  void method_4154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TagEfficiencyWeight*)o)->ImplFileLine)());
  else   (((::TagEfficiencyWeight*)o)->ImplFileLine)();
}

static  void method_4155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeight*)o)->ImplFileName)());
  else   (((::TagEfficiencyWeight*)o)->ImplFileName)();
}

static  void method_4156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TagEfficiencyWeight*)o)->DeclFileLine)());
  else   (((::TagEfficiencyWeight*)o)->DeclFileLine)();
}

static void method_newdel_12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeight >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::TagEfficiencyWeight,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagEfficiencyWeight -------------------------------
void __TagEfficiencyWeight_db_datamem(Reflex::Class*);
void __TagEfficiencyWeight_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TagEfficiencyWeight_datamem_bld(&__TagEfficiencyWeight_db_datamem);
Reflex::GenreflexMemberBuilder __TagEfficiencyWeight_funcmem_bld(&__TagEfficiencyWeight_db_funcmem);
void __TagEfficiencyWeight_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TagEfficiencyWeight"), typeid(::TagEfficiencyWeight), sizeof(::TagEfficiencyWeight), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TagEfficiencyWeight::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::TagEfficiencyWeight, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27657, type_27658), Reflex::Literal("operator="), operator_4138, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TagEfficiencyWeight"), constructor_4139, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27659, type_27660), Reflex::Literal("TagEfficiencyWeight"), constructor_4140, 0, "name;title;_tag;_eff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27658, type_4128), Reflex::Literal("TagEfficiencyWeight"), constructor_4141, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagEfficiencyWeight"), destructor_4143, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TagEfficiencyWeight_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TagEfficiencyWeight_funcmem_bld);
}

//------Delayed data member builder for class TagEfficiencyWeight -------------------
void __TagEfficiencyWeight_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("tag"), OffsetOf(__shadow__::__TagEfficiencyWeight, tag), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("eff"), OffsetOf(__shadow__::__TagEfficiencyWeight, eff), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TagEfficiencyWeight -------------------
void __TagEfficiencyWeight_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_4142, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_4145, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_4146, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_4147, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_4148, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_4149, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_4150, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_4151, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_4152, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_4153, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_4154, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_4155, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_4156, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinned1DQuinticBase<RooAbsReal> -------------------------------
static void constructor_4554( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>();
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>();
}

static void constructor_4555( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(bool*)arg[4]);
  }
}

static void constructor_4556( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsReal>(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_4557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinned1DQuinticBase<RooAbsReal>*)o)->operator=)(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0]);
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->operator=)(*(const ::RooBinned1DQuinticBase<RooAbsReal>*)arg[0]);
}

static  void method_4558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->clone)());
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->clone)((const char*)arg[0]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->clone)((const char*)arg[0]);
  }
}

static void destructor_4559(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinned1DQuinticBase<RooAbsReal>*)o)->::RooBinned1DQuinticBase<RooAbsReal>::~RooBinned1DQuinticBase)();
}
static  void method_4560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->evaluate)());
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->evaluate)();
}

static  void method_4561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_4562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_4563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->isBinnedDistribution)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->isBinnedDistribution)(*(const ::RooArgSet*)arg[0]);
}

static  void method_4564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_4565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_4576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class)();
}

static  void method_4577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class_Name)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class_Name)();
}

static  void method_4578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class_Version)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Class_Version)();
}

static  void method_4579( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Dictionary)();
}

static  void method_4580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->IsA)());
  else   (((const ::RooBinned1DQuinticBase<RooAbsReal>*)o)->IsA)();
}

static  void method_4581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_4582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_4583( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_4584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->DeclFileName)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->DeclFileName)();
}

static  void method_4585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ImplFileLine)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ImplFileLine)();
}

static  void method_4586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ImplFileName)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->ImplFileName)();
}

static  void method_4587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned1DQuinticBase<RooAbsReal>*)o)->DeclFileLine)());
  else   (((::RooBinned1DQuinticBase<RooAbsReal>*)o)->DeclFileLine)();
}

static void method_newdel_130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsReal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinned1DQuinticBase<RooAbsReal> -------------------------------
void __RooBinned1DQuinticBase_RooAbsReal__db_datamem(Reflex::Class*);
void __RooBinned1DQuinticBase_RooAbsReal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinned1DQuinticBase_RooAbsReal__datamem_bld(&__RooBinned1DQuinticBase_RooAbsReal__db_datamem);
Reflex::GenreflexMemberBuilder __RooBinned1DQuinticBase_RooAbsReal__funcmem_bld(&__RooBinned1DQuinticBase_RooAbsReal__db_funcmem);
void __RooBinned1DQuinticBase_RooAbsReal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinned1DQuinticBase<RooAbsReal>"), typeid(::RooBinned1DQuinticBase<RooAbsReal>), sizeof(::RooBinned1DQuinticBase<RooAbsReal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinned1DQuinticBase<RooAbsPdf>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooBinned1DQuinticBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsReal>, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_148"), Reflex::Literal("NCoeff=6;CoeffRecLen=7"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinned1DQuinticBase"), constructor_4554, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27745, type_27660, type_667), Reflex::Literal("RooBinned1DQuinticBase"), constructor_4555, 0, "name;title;h;xvar;integral=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27746, type_4128), Reflex::Literal("RooBinned1DQuinticBase"), constructor_4556, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinned1DQuinticBase"), destructor_4559, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinned1DQuinticBase_RooAbsReal__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinned1DQuinticBase_RooAbsReal__funcmem_bld);
}

//------Delayed data member builder for class RooBinned1DQuinticBase<RooAbsReal> -------------------
void __RooBinned1DQuinticBase_RooAbsReal__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, x), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsX"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, nBinsX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeX"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, binSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, xmin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, xmax), ::Reflex::PRIVATE)
  .AddDataMember(type_667, Reflex::Literal("isIntegral"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, isIntegral), ::Reflex::PRIVATE)
  .AddDataMember(type_2203, Reflex::Literal("coeffs"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsReal_, coeffs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinned1DQuinticBase<RooAbsReal> -------------------
void __RooBinned1DQuinticBase_RooAbsReal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27747, type_27746), Reflex::Literal("operator="), operator_4557, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27748, type_4128), Reflex::Literal("clone"), method_4558, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_4560, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_4561, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_4562, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_27673), Reflex::Literal("isBinnedDistribution"), method_4563, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27749, type_27750, type_2317, type_2317), Reflex::Literal("binBoundaries"), method_4564, 0, "var;lo;hi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27749, type_27750, type_2317, type_2317), Reflex::Literal("plotSamplingHint"), method_4565, 0, "var;lo;hi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_4576, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_4577, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_4578, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_4579, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_4580, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_4581, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_4582, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_4583, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_4584, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_4585, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_4586, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_4587, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class DecRateCoeff -------------------------------
static  void operator_5197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DecRateCoeff*)o)->operator=)(*(const ::DecRateCoeff*)arg[0]);
  else   (((::DecRateCoeff*)o)->operator=)(*(const ::DecRateCoeff*)arg[0]);
}

static void constructor_5198( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff();
  else ::new(mem) ::DecRateCoeff();
}

static void constructor_5199( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsRealLValue*)arg[7],
      *(::RooAbsPdf*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12],
      *(::RooAbsReal*)arg[13]);
  else ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsRealLValue*)arg[7],
      *(::RooAbsPdf*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12],
      *(::RooAbsReal*)arg[13]);
}

static void constructor_5200( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsRealLValue*)arg[7],
      *(::RooAbsPdf*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12],
      *(::RooAbsReal*)arg[13],
      *(::RooAbsReal*)arg[14]);
  else ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsRealLValue*)arg[7],
      *(::RooAbsPdf*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12],
      *(::RooAbsReal*)arg[13],
      *(::RooAbsReal*)arg[14]);
}

static void constructor_5201( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11]);
  else ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11]);
}

static void constructor_5202( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12]);
  else ::new(mem) ::DecRateCoeff((const char*)arg[0],
      (const char*)arg[1],
      *(::DecRateCoeff::Flags*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsCategory*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      *(::RooAbsReal*)arg[11],
      *(::RooAbsReal*)arg[12]);
}

static void constructor_5203( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff(*(const ::DecRateCoeff*)arg[0]);
  else ::new(mem) ::DecRateCoeff(*(const ::DecRateCoeff*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DecRateCoeff(*(const ::DecRateCoeff*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::DecRateCoeff(*(const ::DecRateCoeff*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5204( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DecRateCoeff*)o)->clone)((const char*)arg[0]));
  else   (((const ::DecRateCoeff*)o)->clone)((const char*)arg[0]);
}

static void destructor_5205(void*, void * o, const std::vector<void*>&, void *) {
(((::DecRateCoeff*)o)->::DecRateCoeff::~DecRateCoeff)();
}
static  void method_5206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->getValV)((const ::RooArgSet*)arg[0]));
  else   (((const ::DecRateCoeff*)o)->getValV)((const ::RooArgSet*)arg[0]);
}

static  void method_5207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::DecRateCoeff*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::DecRateCoeff*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_5208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const ::RooArgSet*)arg[2]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const ::RooArgSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const ::RooArgSet*)arg[2],
      (const char*)arg[3]));
    else     (((const ::DecRateCoeff*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const ::RooArgSet*)arg[2],
      (const char*)arg[3]);
  }
}

static  void method_5211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
      (const ::RooArgSet*)arg[1]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
      (const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
      (const ::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::DecRateCoeff*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
      (const ::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DecRateCoeff*)o)->Class)());
  else   (((::DecRateCoeff*)o)->Class)();
}

static  void method_5216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DecRateCoeff*)o)->Class_Name)());
  else   (((::DecRateCoeff*)o)->Class_Name)();
}

static  void method_5217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::DecRateCoeff*)o)->Class_Version)());
  else   (((::DecRateCoeff*)o)->Class_Version)();
}

static  void method_5218( void*, void* o, const std::vector<void*>&, void*)
{
  (((::DecRateCoeff*)o)->Dictionary)();
}

static  void method_5219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DecRateCoeff*)o)->IsA)());
  else   (((const ::DecRateCoeff*)o)->IsA)();
}

static  void method_5220( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DecRateCoeff*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5221( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DecRateCoeff*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5222( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DecRateCoeff*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DecRateCoeff*)o)->DeclFileName)());
  else   (((::DecRateCoeff*)o)->DeclFileName)();
}

static  void method_5224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DecRateCoeff*)o)->ImplFileLine)());
  else   (((::DecRateCoeff*)o)->ImplFileLine)();
}

static  void method_5225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DecRateCoeff*)o)->ImplFileName)());
  else   (((::DecRateCoeff*)o)->ImplFileName)();
}

static  void method_5226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DecRateCoeff*)o)->DeclFileLine)());
  else   (((::DecRateCoeff*)o)->DeclFileLine)();
}

static void method_newdel_259( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::DecRateCoeff >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::DecRateCoeff,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::DecRateCoeff,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::DecRateCoeff,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::DecRateCoeff,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::DecRateCoeff,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DecRateCoeff -------------------------------
void __DecRateCoeff_db_datamem(Reflex::Class*);
void __DecRateCoeff_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __DecRateCoeff_datamem_bld(&__DecRateCoeff_db_datamem);
Reflex::GenreflexMemberBuilder __DecRateCoeff_funcmem_bld(&__DecRateCoeff_db_funcmem);
void __DecRateCoeff_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("DecRateCoeff"), typeid(::DecRateCoeff), sizeof(::DecRateCoeff), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::DecRateCoeff::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::DecRateCoeff, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3483, Reflex::Literal("DecRateCoeff::CacheElemPair"))
  .AddEnum(Reflex::Literal("DecRateCoeff::Flags"), Reflex::Literal("CPEven=0;CPOdd=1;Minus=2;AvgDelta=4"), &typeid(DecRateCoeff::Flags), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27860, type_27861), Reflex::Literal("operator="), operator_5197, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DecRateCoeff"), constructor_5198, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_5196, type_27659, type_27659, type_27660, type_27660, type_27750, type_27862, type_27660, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("DecRateCoeff"), constructor_5199, 0, "name;title;flags;qf;qt;Cf;Cfbar;etaobs;etapdf;tageff;eta;aprod;adet;atageff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_5196, type_27659, type_27659, type_27660, type_27660, type_27750, type_27862, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("DecRateCoeff"), constructor_5200, 0, "name;title;flags;qf;qt;Cf;Cfbar;etaobs;etapdf;tageff;eta;etabar;aprod;adet;atageff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_5196, type_27659, type_27659, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("DecRateCoeff"), constructor_5201, 0, "name;title;flags;qf;qt;Cf;Cfbar;tageff;eta;aprod;adet;atageff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_5196, type_27659, type_27659, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("DecRateCoeff"), constructor_5202, 0, "name;title;flags;qf;qt;Cf;Cfbar;tageff;eta;etabar;aprod;adet;atageff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27861, type_4128), Reflex::Literal("DecRateCoeff"), constructor_5203, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DecRateCoeff"), destructor_5205, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_259, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__DecRateCoeff_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__DecRateCoeff_funcmem_bld);
}

//------Delayed data member builder for class DecRateCoeff -------------------
void __DecRateCoeff_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("m_qf"), OffsetOf(__shadow__::__DecRateCoeff, m_qf), ::Reflex::PRIVATE)
  .AddDataMember(type_1173, Reflex::Literal("m_qt"), OffsetOf(__shadow__::__DecRateCoeff, m_qt), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_Cf"), OffsetOf(__shadow__::__DecRateCoeff, m_Cf), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_Cfbar"), OffsetOf(__shadow__::__DecRateCoeff, m_Cfbar), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etaobs"), OffsetOf(__shadow__::__DecRateCoeff, m_etaobs), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etapdf"), OffsetOf(__shadow__::__DecRateCoeff, m_etapdf), ::Reflex::PRIVATE)
  .AddDataMember(type_1874, Reflex::Literal("m_etapdfutinstance"), OffsetOf(__shadow__::__DecRateCoeff, m_etapdfutinstance), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etapdfut"), OffsetOf(__shadow__::__DecRateCoeff, m_etapdfut), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_tageff"), OffsetOf(__shadow__::__DecRateCoeff, m_tageff), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_eta"), OffsetOf(__shadow__::__DecRateCoeff, m_eta), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etabar"), OffsetOf(__shadow__::__DecRateCoeff, m_etabar), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_aprod"), OffsetOf(__shadow__::__DecRateCoeff, m_aprod), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_adet"), OffsetOf(__shadow__::__DecRateCoeff, m_adet), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_atageff"), OffsetOf(__shadow__::__DecRateCoeff, m_atageff), ::Reflex::PRIVATE)
  .AddDataMember(type_2216, Reflex::Literal("m_cacheMgr"), OffsetOf(__shadow__::__DecRateCoeff, m_cacheMgr), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3350, Reflex::Literal("m_nsets"), OffsetOf(__shadow__::__DecRateCoeff, m_nsets), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_27675, Reflex::Literal("m_nset"), OffsetOf(__shadow__::__DecRateCoeff, m_nset), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2834, Reflex::Literal("m_nsethash"), OffsetOf(__shadow__::__DecRateCoeff, m_nsethash), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_5196, Reflex::Literal("m_flags"), OffsetOf(__shadow__::__DecRateCoeff, m_flags), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DecRateCoeff -------------------
void __DecRateCoeff_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_5204, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27675), Reflex::Literal("getValV"), method_5206, 0, "nset", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9885), Reflex::Literal("forceAnalyticalInt"), method_5207, 0, "dep", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_5208, 0, "allVars;anaIntVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_5209, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_27675, type_4128), Reflex::Literal("getAnalyticalIntegralWN"), method_5210, 0, "allVars;anaIntVars;nset=0;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_27675, type_4128), Reflex::Literal("analyticalIntegralWN"), method_5211, 0, "code;nset=0;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_5215, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_5216, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5217, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5218, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_5219, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_5220, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_5221, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_5222, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_5223, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5224, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_5225, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5226, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IfThreeWayPdf -------------------------------
static  void operator_5329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IfThreeWayPdf*)o)->operator=)(*(const ::IfThreeWayPdf*)arg[0]);
  else   (((::IfThreeWayPdf*)o)->operator=)(*(const ::IfThreeWayPdf*)arg[0]);
}

static void constructor_5330( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayPdf();
  else ::new(mem) ::IfThreeWayPdf();
}

static void constructor_5331( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::IfThreeWayPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_5332( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayPdf(*(const ::IfThreeWayPdf*)arg[0]);
  else ::new(mem) ::IfThreeWayPdf(*(const ::IfThreeWayPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayPdf(*(const ::IfThreeWayPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::IfThreeWayPdf(*(const ::IfThreeWayPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::IfThreeWayPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_5334(void*, void * o, const std::vector<void*>&, void *) {
(((::IfThreeWayPdf*)o)->::IfThreeWayPdf::~IfThreeWayPdf)();
}
static  void method_5336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayPdf*)o)->Class)());
  else   (((::IfThreeWayPdf*)o)->Class)();
}

static  void method_5337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayPdf*)o)->Class_Name)());
  else   (((::IfThreeWayPdf*)o)->Class_Name)();
}

static  void method_5338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::IfThreeWayPdf*)o)->Class_Version)());
  else   (((::IfThreeWayPdf*)o)->Class_Version)();
}

static  void method_5339( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IfThreeWayPdf*)o)->Dictionary)();
}

static  void method_5340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayPdf*)o)->IsA)());
  else   (((const ::IfThreeWayPdf*)o)->IsA)();
}

static  void method_5341( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5342( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5343( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayPdf*)o)->DeclFileName)());
  else   (((::IfThreeWayPdf*)o)->DeclFileName)();
}

static  void method_5345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayPdf*)o)->ImplFileLine)());
  else   (((::IfThreeWayPdf*)o)->ImplFileLine)();
}

static  void method_5346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayPdf*)o)->ImplFileName)());
  else   (((::IfThreeWayPdf*)o)->ImplFileName)();
}

static  void method_5347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayPdf*)o)->DeclFileLine)());
  else   (((::IfThreeWayPdf*)o)->DeclFileLine)();
}

static void method_newdel_266( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IfThreeWayPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::IfThreeWayPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IfThreeWayPdf -------------------------------
void __IfThreeWayPdf_db_datamem(Reflex::Class*);
void __IfThreeWayPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IfThreeWayPdf_datamem_bld(&__IfThreeWayPdf_db_datamem);
Reflex::GenreflexMemberBuilder __IfThreeWayPdf_funcmem_bld(&__IfThreeWayPdf_db_funcmem);
void __IfThreeWayPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IfThreeWayPdf"), typeid(::IfThreeWayPdf), sizeof(::IfThreeWayPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::IfThreeWayPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::IfThreeWayPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27867, type_27868), Reflex::Literal("operator="), operator_5329, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IfThreeWayPdf"), constructor_5330, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("IfThreeWayPdf"), constructor_5331, 0, "name;title;_cond;_pos;_zero;_neg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27868, type_4128), Reflex::Literal("IfThreeWayPdf"), constructor_5332, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IfThreeWayPdf"), destructor_5334, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_266, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IfThreeWayPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IfThreeWayPdf_funcmem_bld);
}

//------Delayed data member builder for class IfThreeWayPdf -------------------
void __IfThreeWayPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("cond"), OffsetOf(__shadow__::__IfThreeWayPdf, cond), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("pos"), OffsetOf(__shadow__::__IfThreeWayPdf, pos), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("zero"), OffsetOf(__shadow__::__IfThreeWayPdf, zero), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("neg"), OffsetOf(__shadow__::__IfThreeWayPdf, neg), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class IfThreeWayPdf -------------------
void __IfThreeWayPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_5333, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_5336, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_5337, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5338, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5339, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_5340, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_5341, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_5342, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_5343, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_5344, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5345, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_5346, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5347, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Inverse -------------------------------
static  void operator_5358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Inverse*)o)->operator=)(*(const ::Inverse*)arg[0]);
  else   (((::Inverse*)o)->operator=)(*(const ::Inverse*)arg[0]);
}

static void constructor_5359( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Inverse();
  else ::new(mem) ::Inverse();
}

static void constructor_5360( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Inverse((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2]);
  else ::new(mem) ::Inverse((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2]);
}

static void constructor_5361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Inverse(*(const ::Inverse*)arg[0]);
  else ::new(mem) ::Inverse(*(const ::Inverse*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Inverse(*(const ::Inverse*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::Inverse(*(const ::Inverse*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Inverse*)o)->clone)((const char*)arg[0]));
  else   (((const ::Inverse*)o)->clone)((const char*)arg[0]);
}

static void destructor_5363(void*, void * o, const std::vector<void*>&, void *) {
(((::Inverse*)o)->::Inverse::~Inverse)();
}
static  void method_5365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Inverse*)o)->Class)());
  else   (((::Inverse*)o)->Class)();
}

static  void method_5366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Inverse*)o)->Class_Name)());
  else   (((::Inverse*)o)->Class_Name)();
}

static  void method_5367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::Inverse*)o)->Class_Version)());
  else   (((::Inverse*)o)->Class_Version)();
}

static  void method_5368( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Inverse*)o)->Dictionary)();
}

static  void method_5369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Inverse*)o)->IsA)());
  else   (((const ::Inverse*)o)->IsA)();
}

static  void method_5370( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Inverse*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5371( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Inverse*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Inverse*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Inverse*)o)->DeclFileName)());
  else   (((::Inverse*)o)->DeclFileName)();
}

static  void method_5374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Inverse*)o)->ImplFileLine)());
  else   (((::Inverse*)o)->ImplFileLine)();
}

static  void method_5375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Inverse*)o)->ImplFileName)());
  else   (((::Inverse*)o)->ImplFileName)();
}

static  void method_5376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Inverse*)o)->DeclFileLine)());
  else   (((::Inverse*)o)->DeclFileLine)();
}

static void method_newdel_286( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Inverse >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Inverse >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Inverse >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Inverse >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Inverse >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::Inverse,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::Inverse,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::Inverse,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::Inverse,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::Inverse,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Inverse -------------------------------
void __Inverse_db_datamem(Reflex::Class*);
void __Inverse_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Inverse_datamem_bld(&__Inverse_db_datamem);
Reflex::GenreflexMemberBuilder __Inverse_funcmem_bld(&__Inverse_db_funcmem);
void __Inverse_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Inverse"), typeid(::Inverse), sizeof(::Inverse), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::Inverse::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::Inverse, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27872, type_27873), Reflex::Literal("operator="), operator_5358, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Inverse"), constructor_5359, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660), Reflex::Literal("Inverse"), constructor_5360, 0, "name;title;_val", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27873, type_4128), Reflex::Literal("Inverse"), constructor_5361, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Inverse"), destructor_5363, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_286, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Inverse_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Inverse_funcmem_bld);
}

//------Delayed data member builder for class Inverse -------------------
void __Inverse_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("val"), OffsetOf(__shadow__::__Inverse, val), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Inverse -------------------
void __Inverse_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_5362, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_5365, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_5366, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5367, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5368, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_5369, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_5370, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_5371, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_5372, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_5373, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5374, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_5375, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5376, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooEffConvGenContext -------------------------------
static  void operator_5487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooEffConvGenContext*)o)->operator=)(*(const ::RooEffConvGenContext*)arg[0]);
  else   (((::RooEffConvGenContext*)o)->operator=)(*(const ::RooEffConvGenContext*)arg[0]);
}

static void constructor_5488( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooFFTConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void constructor_5489( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooNumConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void constructor_5490( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooEffConvGenContext(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void destructor_5491(void*, void * o, const std::vector<void*>&, void *) {
(((::RooEffConvGenContext*)o)->::RooEffConvGenContext::~RooEffConvGenContext)();
}
static  void method_5492( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffConvGenContext*)o)->attach)(*(const ::RooArgSet*)arg[0]);
}

static  void method_5497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffConvGenContext*)o)->Class)());
  else   (((::RooEffConvGenContext*)o)->Class)();
}

static  void method_5498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffConvGenContext*)o)->Class_Name)());
  else   (((::RooEffConvGenContext*)o)->Class_Name)();
}

static  void method_5499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooEffConvGenContext*)o)->Class_Version)());
  else   (((::RooEffConvGenContext*)o)->Class_Version)();
}

static  void method_5500( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooEffConvGenContext*)o)->Dictionary)();
}

static  void method_5501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffConvGenContext*)o)->IsA)());
  else   (((const ::RooEffConvGenContext*)o)->IsA)();
}

static  void method_5502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffConvGenContext*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffConvGenContext*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5504( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffConvGenContext*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffConvGenContext*)o)->DeclFileName)());
  else   (((::RooEffConvGenContext*)o)->DeclFileName)();
}

static  void method_5506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffConvGenContext*)o)->ImplFileLine)());
  else   (((::RooEffConvGenContext*)o)->ImplFileLine)();
}

static  void method_5507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffConvGenContext*)o)->ImplFileName)());
  else   (((::RooEffConvGenContext*)o)->ImplFileName)();
}

static  void method_5508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffConvGenContext*)o)->DeclFileLine)());
  else   (((::RooEffConvGenContext*)o)->DeclFileLine)();
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooConvGenContext")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::RooConvGenContext >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGenContext")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::RooAbsGenContext >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooEffConvGenContext,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooEffConvGenContext -------------------------------
void __RooEffConvGenContext_db_datamem(Reflex::Class*);
void __RooEffConvGenContext_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooEffConvGenContext_datamem_bld(&__RooEffConvGenContext_db_datamem);
Reflex::GenreflexMemberBuilder __RooEffConvGenContext_funcmem_bld(&__RooEffConvGenContext_db_funcmem);
void __RooEffConvGenContext_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooEffConvGenContext"), typeid(::RooEffConvGenContext), sizeof(::RooEffConvGenContext), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooEffConvGenContext::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_755, ::Reflex::BaseOffset< ::RooEffConvGenContext, ::RooConvGenContext >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27887, type_27888), Reflex::Literal("operator="), operator_5487, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27889, type_27673, type_27674, type_27675, type_668), Reflex::Literal("RooEffConvGenContext"), constructor_5488, 0, "model;vars;prototype=0;auxProto=0;_verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27890, type_27673, type_27674, type_27675, type_668), Reflex::Literal("RooEffConvGenContext"), constructor_5489, 0, "model;vars;prototype=0;auxProto=0;_verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27672, type_27673, type_27674, type_27675, type_668), Reflex::Literal("RooEffConvGenContext"), constructor_5490, 0, "model;vars;prototype=0;auxProto=0;_verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooEffConvGenContext"), destructor_5491, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooEffConvGenContext_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooEffConvGenContext_funcmem_bld);
}

//------Delayed data member builder for class RooEffConvGenContext -------------------
void __RooEffConvGenContext_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_694, Reflex::Literal("_maxEff"), OffsetOf(__shadow__::__RooEffConvGenContext, _maxEff), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooEffConvGenContext -------------------
void __RooEffConvGenContext_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27673), Reflex::Literal("attach"), method_5492, 0, "params", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_5497, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_5498, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5499, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5500, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_5501, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_5502, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_5503, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_5504, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_5505, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5506, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_5507, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5508, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class BdPTAcceptance -------------------------------
static  void operator_5514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BdPTAcceptance*)o)->operator=)(*(const ::BdPTAcceptance*)arg[0]);
  else   (((::BdPTAcceptance*)o)->operator=)(*(const ::BdPTAcceptance*)arg[0]);
}

static void constructor_5515( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BdPTAcceptance();
  else ::new(mem) ::BdPTAcceptance();
}

static void constructor_5516( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BdPTAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::BdPTAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_5517( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::BdPTAcceptance(*(const ::BdPTAcceptance*)arg[0]);
  else ::new(mem) ::BdPTAcceptance(*(const ::BdPTAcceptance*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::BdPTAcceptance(*(const ::BdPTAcceptance*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::BdPTAcceptance(*(const ::BdPTAcceptance*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::BdPTAcceptance*)o)->clone)((const char*)arg[0]));
  else   (((const ::BdPTAcceptance*)o)->clone)((const char*)arg[0]);
}

static void destructor_5519(void*, void * o, const std::vector<void*>&, void *) {
(((::BdPTAcceptance*)o)->::BdPTAcceptance::~BdPTAcceptance)();
}
static  void method_5520( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::BdPTAcceptance*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::BdPTAcceptance*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::BdPTAcceptance*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::BdPTAcceptance*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::BdPTAcceptance*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::BdPTAcceptance*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::BdPTAcceptance*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::BdPTAcceptance*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::BdPTAcceptance*)o)->Class)());
  else   (((::BdPTAcceptance*)o)->Class)();
}

static  void method_5525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::BdPTAcceptance*)o)->Class_Name)());
  else   (((::BdPTAcceptance*)o)->Class_Name)();
}

static  void method_5526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::BdPTAcceptance*)o)->Class_Version)());
  else   (((::BdPTAcceptance*)o)->Class_Version)();
}

static  void method_5527( void*, void* o, const std::vector<void*>&, void*)
{
  (((::BdPTAcceptance*)o)->Dictionary)();
}

static  void method_5528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::BdPTAcceptance*)o)->IsA)());
  else   (((const ::BdPTAcceptance*)o)->IsA)();
}

static  void method_5529( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::BdPTAcceptance*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5530( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::BdPTAcceptance*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5531( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::BdPTAcceptance*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::BdPTAcceptance*)o)->DeclFileName)());
  else   (((::BdPTAcceptance*)o)->DeclFileName)();
}

static  void method_5533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::BdPTAcceptance*)o)->ImplFileLine)());
  else   (((::BdPTAcceptance*)o)->ImplFileLine)();
}

static  void method_5534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::BdPTAcceptance*)o)->ImplFileName)());
  else   (((::BdPTAcceptance*)o)->ImplFileName)();
}

static  void method_5535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::BdPTAcceptance*)o)->DeclFileLine)());
  else   (((::BdPTAcceptance*)o)->DeclFileLine)();
}

static void method_newdel_327( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BdPTAcceptance >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::BdPTAcceptance,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::BdPTAcceptance,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::BdPTAcceptance,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::BdPTAcceptance,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::BdPTAcceptance,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class BdPTAcceptance -------------------------------
void __BdPTAcceptance_db_datamem(Reflex::Class*);
void __BdPTAcceptance_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BdPTAcceptance_datamem_bld(&__BdPTAcceptance_db_datamem);
Reflex::GenreflexMemberBuilder __BdPTAcceptance_funcmem_bld(&__BdPTAcceptance_db_funcmem);
void __BdPTAcceptance_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BdPTAcceptance"), typeid(::BdPTAcceptance), sizeof(::BdPTAcceptance), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::BdPTAcceptance::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::BdPTAcceptance, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27892, type_27893), Reflex::Literal("operator="), operator_5514, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BdPTAcceptance"), constructor_5515, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("BdPTAcceptance"), constructor_5516, 0, "name;title;_t;_beta;_slope;_offset", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27893, type_4128), Reflex::Literal("BdPTAcceptance"), constructor_5517, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BdPTAcceptance"), destructor_5519, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_327, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BdPTAcceptance_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__BdPTAcceptance_funcmem_bld);
}

//------Delayed data member builder for class BdPTAcceptance -------------------
void __BdPTAcceptance_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("t"), OffsetOf(__shadow__::__BdPTAcceptance, t), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("beta"), OffsetOf(__shadow__::__BdPTAcceptance, beta), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("slope"), OffsetOf(__shadow__::__BdPTAcceptance, slope), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("offset"), OffsetOf(__shadow__::__BdPTAcceptance, offset), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class BdPTAcceptance -------------------
void __BdPTAcceptance_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_5518, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_5520, 0, "integ;anaIntSet;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_5521, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_5524, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_5525, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5526, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5527, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_5528, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_5529, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_5530, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_5531, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_5532, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5533, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_5534, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5535, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinned2DBicubicBase<RooAbsPdf> -------------------------------
static void constructor_5707( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>();
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>();
}

static void constructor_5708( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH2*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH2*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_5709( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsPdf>(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_5710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->operator=)(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0]);
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->operator=)(*(const ::RooBinned2DBicubicBase<RooAbsPdf>*)arg[0]);
}

static  void method_5711( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->clone)());
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]);
  }
}

static void destructor_5712(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->::RooBinned2DBicubicBase<RooAbsPdf>::~RooBinned2DBicubicBase)();
}
static  void method_5713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->evaluate)());
  else   (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->evaluate)();
}

static  void method_5714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class)();
}

static  void method_5729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class_Name)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class_Name)();
}

static  void method_5730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class_Version)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Class_Version)();
}

static  void method_5731( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Dictionary)();
}

static  void method_5732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->IsA)());
  else   (((const ::RooBinned2DBicubicBase<RooAbsPdf>*)o)->IsA)();
}

static  void method_5733( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5734( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->DeclFileName)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->DeclFileName)();
}

static  void method_5737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ImplFileLine)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ImplFileLine)();
}

static  void method_5738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ImplFileName)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->ImplFileName)();
}

static  void method_5739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->DeclFileLine)());
  else   (((::RooBinned2DBicubicBase<RooAbsPdf>*)o)->DeclFileLine)();
}

static void method_newdel_449( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsPdf> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinned2DBicubicBase<RooAbsPdf> -------------------------------
void __RooBinned2DBicubicBase_RooAbsPdf__db_datamem(Reflex::Class*);
void __RooBinned2DBicubicBase_RooAbsPdf__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinned2DBicubicBase_RooAbsPdf__datamem_bld(&__RooBinned2DBicubicBase_RooAbsPdf__db_datamem);
Reflex::GenreflexMemberBuilder __RooBinned2DBicubicBase_RooAbsPdf__funcmem_bld(&__RooBinned2DBicubicBase_RooAbsPdf__db_funcmem);
void __RooBinned2DBicubicBase_RooAbsPdf__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinned2DBicubicBase<RooAbsPdf>"), typeid(::RooBinned2DBicubicBase<RooAbsPdf>), sizeof(::RooBinned2DBicubicBase<RooAbsPdf>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinned2DBicubicBase<RooAbsReal>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooBinned2DBicubicBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsPdf>, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_147"), Reflex::Literal("NCoeff=16;CoeffRecLen=17"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5707, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27948, type_27660, type_27660), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5708, 0, "name;title;h;xvar;yvar", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27949, type_4128), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5709, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinned2DBicubicBase"), destructor_5712, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_449, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinned2DBicubicBase_RooAbsPdf__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinned2DBicubicBase_RooAbsPdf__funcmem_bld);
}

//------Delayed data member builder for class RooBinned2DBicubicBase<RooAbsPdf> -------------------
void __RooBinned2DBicubicBase_RooAbsPdf__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, x), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("y"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, y), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsX"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, nBinsX), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsY"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, nBinsY), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeX"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, binSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeY"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, binSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, xmin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, xmax), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("ymin"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, ymin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("ymax"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, ymax), ::Reflex::PRIVATE)
  .AddDataMember(type_2203, Reflex::Literal("coeffs"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsPdf_, coeffs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinned2DBicubicBase<RooAbsPdf> -------------------
void __RooBinned2DBicubicBase_RooAbsPdf__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27950, type_27949), Reflex::Literal("operator="), operator_5710, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27951, type_4128), Reflex::Literal("clone"), method_5711, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_5713, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_5714, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_5715, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_5728, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_5729, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5730, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5731, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_5732, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_5733, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_5734, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_5735, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_5736, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5737, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_5738, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5739, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinned2DBicubicBase<RooAbsReal> -------------------------------
static void constructor_5754( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>();
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>();
}

static void constructor_5755( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH2*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH2*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_5756( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinned2DBicubicBase<RooAbsReal>(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_5757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinned2DBicubicBase<RooAbsReal>*)o)->operator=)(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0]);
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->operator=)(*(const ::RooBinned2DBicubicBase<RooAbsReal>*)arg[0]);
}

static  void method_5758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->clone)());
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->clone)((const char*)arg[0]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->clone)((const char*)arg[0]);
  }
}

static void destructor_5759(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinned2DBicubicBase<RooAbsReal>*)o)->::RooBinned2DBicubicBase<RooAbsReal>::~RooBinned2DBicubicBase)();
}
static  void method_5760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->evaluate)());
  else   (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->evaluate)();
}

static  void method_5761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class)();
}

static  void method_5776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class_Name)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class_Name)();
}

static  void method_5777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class_Version)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Class_Version)();
}

static  void method_5778( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Dictionary)();
}

static  void method_5779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->IsA)());
  else   (((const ::RooBinned2DBicubicBase<RooAbsReal>*)o)->IsA)();
}

static  void method_5780( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5781( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5782( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->DeclFileName)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->DeclFileName)();
}

static  void method_5784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ImplFileLine)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ImplFileLine)();
}

static  void method_5785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ImplFileName)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->ImplFileName)();
}

static  void method_5786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned2DBicubicBase<RooAbsReal>*)o)->DeclFileLine)());
  else   (((::RooBinned2DBicubicBase<RooAbsReal>*)o)->DeclFileLine)();
}

static void method_newdel_450( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinned2DBicubicBase<RooAbsReal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinned2DBicubicBase<RooAbsReal> -------------------------------
void __RooBinned2DBicubicBase_RooAbsReal__db_datamem(Reflex::Class*);
void __RooBinned2DBicubicBase_RooAbsReal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinned2DBicubicBase_RooAbsReal__datamem_bld(&__RooBinned2DBicubicBase_RooAbsReal__db_datamem);
Reflex::GenreflexMemberBuilder __RooBinned2DBicubicBase_RooAbsReal__funcmem_bld(&__RooBinned2DBicubicBase_RooAbsReal__db_funcmem);
void __RooBinned2DBicubicBase_RooAbsReal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinned2DBicubicBase<RooAbsReal>"), typeid(::RooBinned2DBicubicBase<RooAbsReal>), sizeof(::RooBinned2DBicubicBase<RooAbsReal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinned2DBicubicBase<RooAbsReal>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooBinned2DBicubicBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooBinned2DBicubicBase<RooAbsReal>, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_147"), Reflex::Literal("NCoeff=16;CoeffRecLen=17"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5754, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27948, type_27660, type_27660), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5755, 0, "name;title;h;xvar;yvar", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27957, type_4128), Reflex::Literal("RooBinned2DBicubicBase"), constructor_5756, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinned2DBicubicBase"), destructor_5759, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_450, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinned2DBicubicBase_RooAbsReal__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinned2DBicubicBase_RooAbsReal__funcmem_bld);
}

//------Delayed data member builder for class RooBinned2DBicubicBase<RooAbsReal> -------------------
void __RooBinned2DBicubicBase_RooAbsReal__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, x), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("y"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, y), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsX"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, nBinsX), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsY"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, nBinsY), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeX"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, binSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeY"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, binSizeY), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, xmin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, xmax), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("ymin"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, ymin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("ymax"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, ymax), ::Reflex::PRIVATE)
  .AddDataMember(type_2203, Reflex::Literal("coeffs"), OffsetOf(__shadow__::__RooBinned2DBicubicBase_RooAbsReal_, coeffs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinned2DBicubicBase<RooAbsReal> -------------------
void __RooBinned2DBicubicBase_RooAbsReal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27958, type_27957), Reflex::Literal("operator="), operator_5757, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27959, type_4128), Reflex::Literal("clone"), method_5758, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_5760, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_5761, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_5762, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_5775, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_5776, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5777, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5778, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_5779, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_5780, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_5781, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_5782, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_5783, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5784, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_5785, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5786, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IfThreeWayCatPdf -------------------------------
static  void operator_5846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IfThreeWayCatPdf*)o)->operator=)(*(const ::IfThreeWayCatPdf*)arg[0]);
  else   (((::IfThreeWayCatPdf*)o)->operator=)(*(const ::IfThreeWayCatPdf*)arg[0]);
}

static void constructor_5847( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCatPdf();
  else ::new(mem) ::IfThreeWayCatPdf();
}

static void constructor_5848( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCatPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::IfThreeWayCatPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_5849( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCatPdf(*(const ::IfThreeWayCatPdf*)arg[0]);
  else ::new(mem) ::IfThreeWayCatPdf(*(const ::IfThreeWayCatPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCatPdf(*(const ::IfThreeWayCatPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::IfThreeWayCatPdf(*(const ::IfThreeWayCatPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayCatPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::IfThreeWayCatPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_5851(void*, void * o, const std::vector<void*>&, void *) {
(((::IfThreeWayCatPdf*)o)->::IfThreeWayCatPdf::~IfThreeWayCatPdf)();
}
static  void method_5853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCatPdf*)o)->Class)());
  else   (((::IfThreeWayCatPdf*)o)->Class)();
}

static  void method_5854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCatPdf*)o)->Class_Name)());
  else   (((::IfThreeWayCatPdf*)o)->Class_Name)();
}

static  void method_5855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::IfThreeWayCatPdf*)o)->Class_Version)());
  else   (((::IfThreeWayCatPdf*)o)->Class_Version)();
}

static  void method_5856( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IfThreeWayCatPdf*)o)->Dictionary)();
}

static  void method_5857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayCatPdf*)o)->IsA)());
  else   (((const ::IfThreeWayCatPdf*)o)->IsA)();
}

static  void method_5858( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCatPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_5859( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCatPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_5860( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCatPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_5861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCatPdf*)o)->DeclFileName)());
  else   (((::IfThreeWayCatPdf*)o)->DeclFileName)();
}

static  void method_5862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayCatPdf*)o)->ImplFileLine)());
  else   (((::IfThreeWayCatPdf*)o)->ImplFileLine)();
}

static  void method_5863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCatPdf*)o)->ImplFileName)());
  else   (((::IfThreeWayCatPdf*)o)->ImplFileName)();
}

static  void method_5864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayCatPdf*)o)->DeclFileLine)());
  else   (((::IfThreeWayCatPdf*)o)->DeclFileLine)();
}

static void method_newdel_485( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IfThreeWayCatPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::IfThreeWayCatPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IfThreeWayCatPdf -------------------------------
void __IfThreeWayCatPdf_db_datamem(Reflex::Class*);
void __IfThreeWayCatPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IfThreeWayCatPdf_datamem_bld(&__IfThreeWayCatPdf_db_datamem);
Reflex::GenreflexMemberBuilder __IfThreeWayCatPdf_funcmem_bld(&__IfThreeWayCatPdf_db_funcmem);
void __IfThreeWayCatPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IfThreeWayCatPdf"), typeid(::IfThreeWayCatPdf), sizeof(::IfThreeWayCatPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::IfThreeWayCatPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::IfThreeWayCatPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27972, type_27973), Reflex::Literal("operator="), operator_5846, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IfThreeWayCatPdf"), constructor_5847, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27659, type_27660, type_27660, type_27660), Reflex::Literal("IfThreeWayCatPdf"), constructor_5848, 0, "name;title;_cond;_pos;_zero;_neg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27973, type_4128), Reflex::Literal("IfThreeWayCatPdf"), constructor_5849, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IfThreeWayCatPdf"), destructor_5851, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_485, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IfThreeWayCatPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IfThreeWayCatPdf_funcmem_bld);
}

//------Delayed data member builder for class IfThreeWayCatPdf -------------------
void __IfThreeWayCatPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("cond"), OffsetOf(__shadow__::__IfThreeWayCatPdf, cond), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("pos"), OffsetOf(__shadow__::__IfThreeWayCatPdf, pos), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("zero"), OffsetOf(__shadow__::__IfThreeWayCatPdf, zero), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("neg"), OffsetOf(__shadow__::__IfThreeWayCatPdf, neg), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class IfThreeWayCatPdf -------------------
void __IfThreeWayCatPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_5850, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_5853, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_5854, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_5855, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_5856, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_5857, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_5858, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_5859, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_5860, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_5861, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_5862, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_5863, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_5864, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class NonOscTaggingPdf -------------------------------
static  void operator_5987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::NonOscTaggingPdf*)o)->operator=)(*(const ::NonOscTaggingPdf*)arg[0]);
  else   (((::NonOscTaggingPdf*)o)->operator=)(*(const ::NonOscTaggingPdf*)arg[0]);
}

static void constructor_5988( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf();
  else ::new(mem) ::NonOscTaggingPdf();
}

static void constructor_5989( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsRealLValue*)arg[4],
      *(::RooAbsPdf*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9]);
  else ::new(mem) ::NonOscTaggingPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsRealLValue*)arg[4],
      *(::RooAbsPdf*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      *(::RooAbsReal*)arg[9]);
}

static void constructor_5990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
  else ::new(mem) ::NonOscTaggingPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
}

static void constructor_5991( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf(*(const ::NonOscTaggingPdf*)arg[0]);
  else ::new(mem) ::NonOscTaggingPdf(*(const ::NonOscTaggingPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::NonOscTaggingPdf(*(const ::NonOscTaggingPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::NonOscTaggingPdf(*(const ::NonOscTaggingPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::NonOscTaggingPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::NonOscTaggingPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_5993(void*, void * o, const std::vector<void*>&, void *) {
(((::NonOscTaggingPdf*)o)->::NonOscTaggingPdf::~NonOscTaggingPdf)();
}
static  void method_5994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::NonOscTaggingPdf*)o)->selfNormalized)());
  else   (((const ::NonOscTaggingPdf*)o)->selfNormalized)();
}

static  void method_5995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::NonOscTaggingPdf*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::NonOscTaggingPdf*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_5996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_5997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::NonOscTaggingPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::NonOscTaggingPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::NonOscTaggingPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::NonOscTaggingPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_5998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const ::RooArgSet*)arg[2],
    (const char*)arg[3]));
  else   (((const ::NonOscTaggingPdf*)o)->getAnalyticalIntegralWN)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const ::RooArgSet*)arg[2],
    (const char*)arg[3]);
}

static  void method_5999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::NonOscTaggingPdf*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
    (const ::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::NonOscTaggingPdf*)o)->analyticalIntegralWN)(*(::Int_t*)arg[0],
    (const ::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_6002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::NonOscTaggingPdf*)o)->Class)());
  else   (((::NonOscTaggingPdf*)o)->Class)();
}

static  void method_6003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::NonOscTaggingPdf*)o)->Class_Name)());
  else   (((::NonOscTaggingPdf*)o)->Class_Name)();
}

static  void method_6004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::NonOscTaggingPdf*)o)->Class_Version)());
  else   (((::NonOscTaggingPdf*)o)->Class_Version)();
}

static  void method_6005( void*, void* o, const std::vector<void*>&, void*)
{
  (((::NonOscTaggingPdf*)o)->Dictionary)();
}

static  void method_6006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::NonOscTaggingPdf*)o)->IsA)());
  else   (((const ::NonOscTaggingPdf*)o)->IsA)();
}

static  void method_6007( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NonOscTaggingPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6008( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NonOscTaggingPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6009( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::NonOscTaggingPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::NonOscTaggingPdf*)o)->DeclFileName)());
  else   (((::NonOscTaggingPdf*)o)->DeclFileName)();
}

static  void method_6011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::NonOscTaggingPdf*)o)->ImplFileLine)());
  else   (((::NonOscTaggingPdf*)o)->ImplFileLine)();
}

static  void method_6012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::NonOscTaggingPdf*)o)->ImplFileName)());
  else   (((::NonOscTaggingPdf*)o)->ImplFileName)();
}

static  void method_6013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::NonOscTaggingPdf*)o)->DeclFileLine)());
  else   (((::NonOscTaggingPdf*)o)->DeclFileLine)();
}

static void method_newdel_515( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::NonOscTaggingPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::NonOscTaggingPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class NonOscTaggingPdf -------------------------------
void __NonOscTaggingPdf_db_datamem(Reflex::Class*);
void __NonOscTaggingPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __NonOscTaggingPdf_datamem_bld(&__NonOscTaggingPdf_db_datamem);
Reflex::GenreflexMemberBuilder __NonOscTaggingPdf_funcmem_bld(&__NonOscTaggingPdf_db_funcmem);
void __NonOscTaggingPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("NonOscTaggingPdf"), typeid(::NonOscTaggingPdf), sizeof(::NonOscTaggingPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::NonOscTaggingPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::NonOscTaggingPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3484, Reflex::Literal("NonOscTaggingPdf::CacheElemPair"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28000, type_28001), Reflex::Literal("operator="), operator_5987, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("NonOscTaggingPdf"), constructor_5988, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27659, type_27659, type_27750, type_27862, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("NonOscTaggingPdf"), constructor_5989, 0, "name;title;qf;qt;etaobs;etapdf;epsilon;adet;atageff_f;atageff_t", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27659, type_27659, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("NonOscTaggingPdf"), constructor_5990, 0, "name;title;qf;qt;epsilon;adet;atageff_f;atageff_t", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28001, type_4128), Reflex::Literal("NonOscTaggingPdf"), constructor_5991, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~NonOscTaggingPdf"), destructor_5993, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_515, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__NonOscTaggingPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__NonOscTaggingPdf_funcmem_bld);
}

//------Delayed data member builder for class NonOscTaggingPdf -------------------
void __NonOscTaggingPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("m_qf"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_qf), ::Reflex::PRIVATE)
  .AddDataMember(type_1173, Reflex::Literal("m_qt"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_qt), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etaobs"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_etaobs), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etapdf"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_etapdf), ::Reflex::PRIVATE)
  .AddDataMember(type_1874, Reflex::Literal("m_etapdfutinstance"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_etapdfutinstance), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etapdfut"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_etapdfut), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_epsilon"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_epsilon), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_adet"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_adet), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_atageff_f"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_atageff_f), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_atageff_t"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_atageff_t), ::Reflex::PRIVATE)
  .AddDataMember(type_2216, Reflex::Literal("m_cacheMgr"), OffsetOf(__shadow__::__NonOscTaggingPdf, m_cacheMgr), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class NonOscTaggingPdf -------------------
void __NonOscTaggingPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_5992, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("selfNormalized"), method_5994, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9885), Reflex::Literal("forceAnalyticalInt"), method_5995, 0, "dep", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_5996, 0, "allVars;anaIntVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_5997, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_27675, type_4128), Reflex::Literal("getAnalyticalIntegralWN"), method_5998, 0, "allVars;anaIntVars;nset;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_27675, type_4128), Reflex::Literal("analyticalIntegralWN"), method_5999, 0, "code;nset;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_6002, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_6003, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_6004, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_6005, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_6006, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_6007, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_6008, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_6009, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_6010, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_6011, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_6012, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_6013, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class DTAcceptanceLHCbNote2007041 -------------------------------
static  void operator_6077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::DTAcceptanceLHCbNote2007041*)o)->operator=)(*(const ::DTAcceptanceLHCbNote2007041*)arg[0]);
  else   (((::DTAcceptanceLHCbNote2007041*)o)->operator=)(*(const ::DTAcceptanceLHCbNote2007041*)arg[0]);
}

static void constructor_6078( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DTAcceptanceLHCbNote2007041();
  else ::new(mem) ::DTAcceptanceLHCbNote2007041();
}

static void constructor_6079( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::DTAcceptanceLHCbNote2007041((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
  else ::new(mem) ::DTAcceptanceLHCbNote2007041((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
}

static void constructor_6080( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::DTAcceptanceLHCbNote2007041(*(const ::DTAcceptanceLHCbNote2007041*)arg[0]);
  else ::new(mem) ::DTAcceptanceLHCbNote2007041(*(const ::DTAcceptanceLHCbNote2007041*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::DTAcceptanceLHCbNote2007041(*(const ::DTAcceptanceLHCbNote2007041*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::DTAcceptanceLHCbNote2007041(*(const ::DTAcceptanceLHCbNote2007041*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_6081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DTAcceptanceLHCbNote2007041*)o)->clone)((const char*)arg[0]));
  else   (((const ::DTAcceptanceLHCbNote2007041*)o)->clone)((const char*)arg[0]);
}

static void destructor_6082(void*, void * o, const std::vector<void*>&, void *) {
(((::DTAcceptanceLHCbNote2007041*)o)->::DTAcceptanceLHCbNote2007041::~DTAcceptanceLHCbNote2007041)();
}
static  void method_6084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DTAcceptanceLHCbNote2007041*)o)->Class)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->Class)();
}

static  void method_6085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DTAcceptanceLHCbNote2007041*)o)->Class_Name)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->Class_Name)();
}

static  void method_6086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::DTAcceptanceLHCbNote2007041*)o)->Class_Version)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->Class_Version)();
}

static  void method_6087( void*, void* o, const std::vector<void*>&, void*)
{
  (((::DTAcceptanceLHCbNote2007041*)o)->Dictionary)();
}

static  void method_6088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::DTAcceptanceLHCbNote2007041*)o)->IsA)());
  else   (((const ::DTAcceptanceLHCbNote2007041*)o)->IsA)();
}

static  void method_6089( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DTAcceptanceLHCbNote2007041*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DTAcceptanceLHCbNote2007041*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6091( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::DTAcceptanceLHCbNote2007041*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DTAcceptanceLHCbNote2007041*)o)->DeclFileName)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->DeclFileName)();
}

static  void method_6093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DTAcceptanceLHCbNote2007041*)o)->ImplFileLine)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->ImplFileLine)();
}

static  void method_6094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::DTAcceptanceLHCbNote2007041*)o)->ImplFileName)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->ImplFileName)();
}

static  void method_6095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::DTAcceptanceLHCbNote2007041*)o)->DeclFileLine)());
  else   (((::DTAcceptanceLHCbNote2007041*)o)->DeclFileLine)();
}

static void method_newdel_577( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::DTAcceptanceLHCbNote2007041 >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class DTAcceptanceLHCbNote2007041 -------------------------------
void __DTAcceptanceLHCbNote2007041_db_datamem(Reflex::Class*);
void __DTAcceptanceLHCbNote2007041_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __DTAcceptanceLHCbNote2007041_datamem_bld(&__DTAcceptanceLHCbNote2007041_db_datamem);
Reflex::GenreflexMemberBuilder __DTAcceptanceLHCbNote2007041_funcmem_bld(&__DTAcceptanceLHCbNote2007041_db_funcmem);
void __DTAcceptanceLHCbNote2007041_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("DTAcceptanceLHCbNote2007041"), typeid(::DTAcceptanceLHCbNote2007041), sizeof(::DTAcceptanceLHCbNote2007041), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::DTAcceptanceLHCbNote2007041::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::DTAcceptanceLHCbNote2007041, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28010, type_28011), Reflex::Literal("operator="), operator_6077, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DTAcceptanceLHCbNote2007041"), constructor_6078, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("DTAcceptanceLHCbNote2007041"), constructor_6079, 0, "name;title;_t;_s_low;_s_high;_n;_limit", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28011, type_4128), Reflex::Literal("DTAcceptanceLHCbNote2007041"), constructor_6080, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DTAcceptanceLHCbNote2007041"), destructor_6082, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_577, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__DTAcceptanceLHCbNote2007041_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__DTAcceptanceLHCbNote2007041_funcmem_bld);
}

//------Delayed data member builder for class DTAcceptanceLHCbNote2007041 -------------------
void __DTAcceptanceLHCbNote2007041_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("t"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, t), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("s_low"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, s_low), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("s_high"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, s_high), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("n"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, n), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("limit"), OffsetOf(__shadow__::__DTAcceptanceLHCbNote2007041, limit), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class DTAcceptanceLHCbNote2007041 -------------------
void __DTAcceptanceLHCbNote2007041_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_6081, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_6084, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_6085, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_6086, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_6087, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_6088, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_6089, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_6090, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_6091, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_6092, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_6093, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_6094, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_6095, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooEffResModel -------------------------------
static  void operator_6350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooEffResModel*)o)->operator=)(*(const ::RooEffResModel*)arg[0]);
  else   (((::RooEffResModel*)o)->operator=)(*(const ::RooEffResModel*)arg[0]);
}

static void constructor_6351( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffResModel();
  else ::new(mem) ::RooEffResModel();
}

static void constructor_6352( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffResModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooResolutionModel*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::RooEffResModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooResolutionModel*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_6353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffResModel(*(const ::RooEffResModel*)arg[0]);
  else ::new(mem) ::RooEffResModel(*(const ::RooEffResModel*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffResModel(*(const ::RooEffResModel*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooEffResModel(*(const ::RooEffResModel*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_6354( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooEffResModel*)o)->clone)((const char*)arg[0]);
}

static void destructor_6355(void*, void * o, const std::vector<void*>&, void *) {
(((::RooEffResModel*)o)->::RooEffResModel::~RooEffResModel)();
}
static  void method_6356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->basisCode)((const char*)arg[0]));
  else   (((const ::RooEffResModel*)o)->basisCode)((const char*)arg[0]);
}

static  void method_6357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooEffResModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooEffResModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_6358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooEffResModel*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::RooEffResModel*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_6359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooEffResModel*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooEffResModel*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_6360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooEffResModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffResModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      *(::Bool_t*)arg[2]));
    else     (((const ::RooEffResModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      *(::Bool_t*)arg[2]);
  }
}

static  void method_6361( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->initGenerator)(*(::Int_t*)arg[0]);
}

static  void method_6362( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->generateEvent)(*(::Int_t*)arg[0]);
}

static  void method_6363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]));
    else     (((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]));
    else     (((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]));
    else     (((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((const ::RooEffResModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_6364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->efficiency)());
  else   (((const ::RooEffResModel*)o)->efficiency)();
}

static  void method_6365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<RooAbsReal*>)((((const ::RooEffResModel*)o)->efficiencies)());
  else   (((const ::RooEffResModel*)o)->efficiencies)();
}

static  void method_6366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooEffResModel*)o)->model)();
  else   (((const ::RooEffResModel*)o)->model)();
}

static  void method_6367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->observables)());
  else   (((const ::RooEffResModel*)o)->observables)();
}

static  void method_6371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffResModel*)o)->Class)());
  else   (((::RooEffResModel*)o)->Class)();
}

static  void method_6372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffResModel*)o)->Class_Name)());
  else   (((::RooEffResModel*)o)->Class_Name)();
}

static  void method_6373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooEffResModel*)o)->Class_Version)());
  else   (((::RooEffResModel*)o)->Class_Version)();
}

static  void method_6374( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooEffResModel*)o)->Dictionary)();
}

static  void method_6375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffResModel*)o)->IsA)());
  else   (((const ::RooEffResModel*)o)->IsA)();
}

static  void method_6376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6377( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6378( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffResModel*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffResModel*)o)->DeclFileName)());
  else   (((::RooEffResModel*)o)->DeclFileName)();
}

static  void method_6380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffResModel*)o)->ImplFileLine)());
  else   (((::RooEffResModel*)o)->ImplFileLine)();
}

static  void method_6381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffResModel*)o)->ImplFileName)());
  else   (((::RooEffResModel*)o)->ImplFileName)();
}

static  void method_6382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffResModel*)o)->DeclFileLine)());
  else   (((::RooEffResModel*)o)->DeclFileLine)();
}

static void method_newdel_664( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooEffResModel >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooResolutionModel")), ::Reflex::BaseOffset< ::RooEffResModel,::RooResolutionModel >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooEffResModel,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooEffResModel,::RooAbsReal >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooEffResModel,::RooAbsArg >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooEffResModel,::TNamed >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooEffResModel,::TObject >::Get(),::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooEffResModel,::RooPrintable >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsEffResModel")), ::Reflex::BaseOffset< ::RooEffResModel,::RooAbsEffResModel >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooEffResModel -------------------------------
void __RooEffResModel_db_datamem(Reflex::Class*);
void __RooEffResModel_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooEffResModel_datamem_bld(&__RooEffResModel_db_datamem);
Reflex::GenreflexMemberBuilder __RooEffResModel_funcmem_bld(&__RooEffResModel_db_funcmem);
void __RooEffResModel_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooEffResModel"), typeid(::RooEffResModel), sizeof(::RooEffResModel), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooEffResModel::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_39, ::Reflex::BaseOffset< ::RooEffResModel, ::RooResolutionModel >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_670, ::Reflex::BaseOffset< ::RooEffResModel, ::RooAbsEffResModel >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28061, type_28062), Reflex::Literal("operator="), operator_6350, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooEffResModel"), constructor_6351, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27668, type_27660), Reflex::Literal("RooEffResModel"), constructor_6352, 0, "name;title;model;eff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28062, type_4128), Reflex::Literal("RooEffResModel"), constructor_6353, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooEffResModel"), destructor_6355, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_664, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooEffResModel_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooEffResModel_funcmem_bld);
}

//------Delayed data member builder for class RooEffResModel -------------------
void __RooEffResModel_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_878, Reflex::Literal("_observables"), OffsetOf(__shadow__::__RooEffResModel, _observables), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("_model"), OffsetOf(__shadow__::__RooEffResModel, _model), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("_eff"), OffsetOf(__shadow__::__RooEffResModel, _eff), ::Reflex::PRIVATE)
  .AddDataMember(type_2216, Reflex::Literal("_cacheMgr"), OffsetOf(__shadow__::__RooEffResModel, _cacheMgr), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class RooEffResModel -------------------
void __RooEffResModel_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28063, type_4128), Reflex::Literal("clone"), method_6354, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_4128), Reflex::Literal("basisCode"), method_6356, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_6357, 0, "allVars;analVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_6358, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9885), Reflex::Literal("forceAnalyticalInt"), method_6359, 0, "dep", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27673, type_27678, type_668), Reflex::Literal("getGenerator"), method_6360, 0, "directVars;generateVars;staticInitOK=kTRUE", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("initGenerator"), method_6361, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("generateEvent"), method_6362, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27671, type_27672, type_27673, type_27674, type_27675, type_668), Reflex::Literal("modelGenContext"), method_6363, 0, "convPdf;vars;prototype=0;auxProto=0;verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28025), Reflex::Literal("efficiency"), method_6364, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3112), Reflex::Literal("efficiencies"), method_6365, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27668), Reflex::Literal("model"), method_6366, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2835), Reflex::Literal("observables"), method_6367, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_6371, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_6372, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_6373, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_6374, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_6375, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_6376, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_6377, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_6378, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_6379, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_6380, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_6381, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_6382, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooAbsEffResModel -------------------------------
static  void operator_6383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooAbsEffResModel*)o)->operator=)(*(const ::RooAbsEffResModel*)arg[0]);
  else   (((::RooAbsEffResModel*)o)->operator=)(*(const ::RooAbsEffResModel*)arg[0]);
}

static void destructor_6386(void*, void * o, const std::vector<void*>&, void *) {
(((::RooAbsEffResModel*)o)->::RooAbsEffResModel::~RooAbsEffResModel)();
}
static  void method_6387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooAbsEffResModel*)o)->observables)());
  else   (((const ::RooAbsEffResModel*)o)->observables)();
}

static  void method_6388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooAbsEffResModel*)o)->efficiency)());
  else   (((const ::RooAbsEffResModel*)o)->efficiency)();
}

//------Dictionary for class RooAbsEffResModel -------------------------------
void __RooAbsEffResModel_db_datamem(Reflex::Class*);
void __RooAbsEffResModel_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooAbsEffResModel_datamem_bld(&__RooAbsEffResModel_db_datamem);
Reflex::GenreflexMemberBuilder __RooAbsEffResModel_funcmem_bld(&__RooAbsEffResModel_db_funcmem);
void __RooAbsEffResModel_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooAbsEffResModel"), typeid(::RooAbsEffResModel), sizeof(::RooAbsEffResModel), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28065, type_28066), Reflex::Literal("operator="), operator_6383, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooAbsEffResModel"), destructor_6386, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__RooAbsEffResModel_funcmem_bld);
}

//------Delayed data member builder for class RooAbsEffResModel -------------------
void __RooAbsEffResModel_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RooAbsEffResModel -------------------
void __RooAbsEffResModel_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2835), Reflex::Literal("observables"), method_6387, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27891), Reflex::Literal("efficiency"), method_6388, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class IfThreeWayCat -------------------------------
static  void operator_6441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IfThreeWayCat*)o)->operator=)(*(const ::IfThreeWayCat*)arg[0]);
  else   (((::IfThreeWayCat*)o)->operator=)(*(const ::IfThreeWayCat*)arg[0]);
}

static void constructor_6442( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCat();
  else ::new(mem) ::IfThreeWayCat();
}

static void constructor_6443( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::IfThreeWayCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_6444( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCat(*(const ::IfThreeWayCat*)arg[0]);
  else ::new(mem) ::IfThreeWayCat(*(const ::IfThreeWayCat*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWayCat(*(const ::IfThreeWayCat*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::IfThreeWayCat(*(const ::IfThreeWayCat*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_6445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayCat*)o)->clone)((const char*)arg[0]));
  else   (((const ::IfThreeWayCat*)o)->clone)((const char*)arg[0]);
}

static void destructor_6446(void*, void * o, const std::vector<void*>&, void *) {
(((::IfThreeWayCat*)o)->::IfThreeWayCat::~IfThreeWayCat)();
}
static  void method_6448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCat*)o)->Class)());
  else   (((::IfThreeWayCat*)o)->Class)();
}

static  void method_6449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCat*)o)->Class_Name)());
  else   (((::IfThreeWayCat*)o)->Class_Name)();
}

static  void method_6450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::IfThreeWayCat*)o)->Class_Version)());
  else   (((::IfThreeWayCat*)o)->Class_Version)();
}

static  void method_6451( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IfThreeWayCat*)o)->Dictionary)();
}

static  void method_6452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWayCat*)o)->IsA)());
  else   (((const ::IfThreeWayCat*)o)->IsA)();
}

static  void method_6453( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCat*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_6454( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCat*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_6455( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWayCat*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_6456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCat*)o)->DeclFileName)());
  else   (((::IfThreeWayCat*)o)->DeclFileName)();
}

static  void method_6457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayCat*)o)->ImplFileLine)());
  else   (((::IfThreeWayCat*)o)->ImplFileLine)();
}

static  void method_6458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWayCat*)o)->ImplFileName)());
  else   (((::IfThreeWayCat*)o)->ImplFileName)();
}

static  void method_6459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWayCat*)o)->DeclFileLine)());
  else   (((::IfThreeWayCat*)o)->DeclFileLine)();
}

static void method_newdel_723( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IfThreeWayCat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::IfThreeWayCat,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::IfThreeWayCat,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::IfThreeWayCat,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::IfThreeWayCat,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::IfThreeWayCat,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IfThreeWayCat -------------------------------
void __IfThreeWayCat_db_datamem(Reflex::Class*);
void __IfThreeWayCat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IfThreeWayCat_datamem_bld(&__IfThreeWayCat_db_datamem);
Reflex::GenreflexMemberBuilder __IfThreeWayCat_funcmem_bld(&__IfThreeWayCat_db_funcmem);
void __IfThreeWayCat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IfThreeWayCat"), typeid(::IfThreeWayCat), sizeof(::IfThreeWayCat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::IfThreeWayCat::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::IfThreeWayCat, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28078, type_28079), Reflex::Literal("operator="), operator_6441, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IfThreeWayCat"), constructor_6442, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27659, type_27660, type_27660, type_27660), Reflex::Literal("IfThreeWayCat"), constructor_6443, 0, "name;title;_cond;_pos;_zero;_neg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28079, type_4128), Reflex::Literal("IfThreeWayCat"), constructor_6444, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IfThreeWayCat"), destructor_6446, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_723, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IfThreeWayCat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IfThreeWayCat_funcmem_bld);
}

//------Delayed data member builder for class IfThreeWayCat -------------------
void __IfThreeWayCat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("cond"), OffsetOf(__shadow__::__IfThreeWayCat, cond), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("pos"), OffsetOf(__shadow__::__IfThreeWayCat, pos), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("zero"), OffsetOf(__shadow__::__IfThreeWayCat, zero), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("neg"), OffsetOf(__shadow__::__IfThreeWayCat, neg), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class IfThreeWayCat -------------------
void __IfThreeWayCat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_6445, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_6448, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_6449, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_6450, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_6451, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_6452, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_6453, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_6454, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_6455, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_6456, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_6457, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_6458, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_6459, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooCubicSplineKnot -------------------------------
static void destructor_7151(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineKnot*)o)->::RooCubicSplineKnot::~RooCubicSplineKnot)();
}
static  void operator_7152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot*)o)->operator=)(*(const ::RooCubicSplineKnot*)arg[0]);
  else   (((::RooCubicSplineKnot*)o)->operator=)(*(const ::RooCubicSplineKnot*)arg[0]);
}

static void constructor_7153( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot(*(const ::RooCubicSplineKnot*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot(*(const ::RooCubicSplineKnot*)arg[0]);
}

static void constructor_7154( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot((const double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot((const double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_7155( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot(*(const ::std::vector<double>*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot(*(const ::std::vector<double>*)arg[0]);
}

static  void method_7156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot*)o)->u)(*(int*)arg[0]));
  else   (((const ::RooCubicSplineKnot*)o)->u)(*(int*)arg[0]);
}

static  void method_7157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RooCubicSplineKnot*)o)->size)());
  else   (((const ::RooCubicSplineKnot*)o)->size)();
}

static  void method_7158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot*)o)->evaluate)(*(double*)arg[0],
    *(const ::RooArgList*)arg[1]));
  else   (((const ::RooCubicSplineKnot*)o)->evaluate)(*(double*)arg[0],
    *(const ::RooArgList*)arg[1]);
}

static  void method_7159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot*)o)->analyticalIntegral)(*(const ::RooArgList*)arg[0]));
  else   (((const ::RooCubicSplineKnot*)o)->analyticalIntegral)(*(const ::RooArgList*)arg[0]);
}

static  void method_7160( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((const ::RooCubicSplineKnot*)o)->computeCoefficients)(*(::std::vector<double>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((const ::RooCubicSplineKnot*)o)->computeCoefficients)(*(::std::vector<double>*)arg[0],
      *(::RooCubicSplineKnot::BoundaryConditions*)arg[1]);
  }
}

static  void method_7161( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::RooCubicSplineKnot*)o)->smooth)(*(::std::vector<double>*)arg[0],
    *(const ::std::vector<double>*)arg[1],
    *(double*)arg[2]);
}

static  void method_7162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooCubicSplineKnot*)o)->knots)();
  else   (((const ::RooCubicSplineKnot*)o)->knots)();
}

static  void method_7163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot*)o)->S_jk_sum)(*(int*)arg[0],
    *(const ::RooArgList*)arg[1]));
  else   (((const ::RooCubicSplineKnot*)o)->S_jk_sum)(*(int*)arg[0],
    *(const ::RooArgList*)arg[1]);
}

static  void method_7164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_edge)((((const ::RooCubicSplineKnot*)o)->S_jk_edge)(*(bool*)arg[0],
    *(const ::RooArgList*)arg[1]));
  else   (((const ::RooCubicSplineKnot*)o)->S_jk_edge)(*(bool*)arg[0],
    *(const ::RooArgList*)arg[1]);
}

static  void method_7165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot*)o)->expIntegral)((const ::TH1*)arg[0],
    *(double*)arg[1],
    *(::TVectorD*)arg[2],
    *(::TMatrixD*)arg[3]));
  else   (((const ::RooCubicSplineKnot*)o)->expIntegral)((const ::TH1*)arg[0],
    *(double*)arg[1],
    *(::TVectorD*)arg[2],
    *(::TMatrixD*)arg[3]);
}

static  void method_7189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineKnot*)o)->Class)());
  else   (((::RooCubicSplineKnot*)o)->Class)();
}

static  void method_7190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineKnot*)o)->Class_Name)());
  else   (((::RooCubicSplineKnot*)o)->Class_Name)();
}

static  void method_7191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooCubicSplineKnot*)o)->Class_Version)());
  else   (((::RooCubicSplineKnot*)o)->Class_Version)();
}

static  void method_7192( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooCubicSplineKnot*)o)->Dictionary)();
}

static  void method_7193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCubicSplineKnot*)o)->IsA)());
  else   (((const ::RooCubicSplineKnot*)o)->IsA)();
}

static  void method_7194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineKnot*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineKnot*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7196( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineKnot*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineKnot*)o)->DeclFileName)());
  else   (((::RooCubicSplineKnot*)o)->DeclFileName)();
}

static  void method_7198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCubicSplineKnot*)o)->ImplFileLine)());
  else   (((::RooCubicSplineKnot*)o)->ImplFileLine)();
}

static  void method_7199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineKnot*)o)->ImplFileName)());
  else   (((::RooCubicSplineKnot*)o)->ImplFileName)();
}

static  void method_7200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCubicSplineKnot*)o)->DeclFileLine)());
  else   (((::RooCubicSplineKnot*)o)->DeclFileLine)();
}

//------Dictionary for class RooCubicSplineKnot -------------------------------
void __RooCubicSplineKnot_db_datamem(Reflex::Class*);
void __RooCubicSplineKnot_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot_datamem_bld(&__RooCubicSplineKnot_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot_funcmem_bld(&__RooCubicSplineKnot_db_funcmem);
void __RooCubicSplineKnot_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineKnot"), typeid(::RooCubicSplineKnot), sizeof(::RooCubicSplineKnot), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooCubicSplineKnot::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 0)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooCubicSplineKnot"), destructor_7151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28226, type_28227), Reflex::Literal("operator="), operator_7152, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28227), Reflex::Literal("RooCubicSplineKnot"), constructor_7153, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17837, type_141), Reflex::Literal("RooCubicSplineKnot"), constructor_7154, 0, "array;nEntries", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18881), Reflex::Literal("RooCubicSplineKnot"), constructor_7155, 0, "_knots", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineKnot_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCubicSplineKnot_funcmem_bld);
}

//------Delayed data member builder for class RooCubicSplineKnot -------------------
void __RooCubicSplineKnot_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3089, Reflex::Literal("_u"), OffsetOf(__shadow__::__RooCubicSplineKnot, _u), ::Reflex::PRIVATE)
  .AddDataMember(type_3089, Reflex::Literal("_PQRS"), OffsetOf(__shadow__::__RooCubicSplineKnot, _PQRS), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3089, Reflex::Literal("_IABCD"), OffsetOf(__shadow__::__RooCubicSplineKnot, _IABCD), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3090, Reflex::Literal("_S_jk"), OffsetOf(__shadow__::__RooCubicSplineKnot, _S_jk), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class RooCubicSplineKnot -------------------
void __RooCubicSplineKnot_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_141), Reflex::Literal("u"), method_7156, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("size"), method_7157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_694, type_27821), Reflex::Literal("evaluate"), method_7158, 0, "_u;b", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_27821), Reflex::Literal("analyticalIntegral"), method_7159, 0, "b", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18879, type_7148), Reflex::Literal("computeCoefficients"), method_7160, 0, "y;bc=RooCubicSplineKnot::BoundaryConditions(1, 1, 0.0, 0.0)", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18879, type_18881, type_694), Reflex::Literal("smooth"), method_7161, 0, "y;dy;lambda", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18881), Reflex::Literal("knots"), method_7162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7149, type_141, type_27821), Reflex::Literal("S_jk_sum"), method_7163, 0, "i;b", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7150, type_667, type_27821), Reflex::Literal("S_jk_edge"), method_7164, 0, "left;b", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_28133, type_694, type_28228, type_28229), Reflex::Literal("expIntegral"), method_7165, 0, "hist;gamma;coefficients;covarianceMatrix", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_7189, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_7190, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_7191, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_7192, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_7193, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_7194, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_7195, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_7196, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_7197, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_7198, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_7199, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_7200, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinnedPdf -------------------------------
static  void operator_7936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinnedPdf*)o)->operator=)(*(const ::RooBinnedPdf*)arg[0]);
  else   (((::RooBinnedPdf*)o)->operator=)(*(const ::RooBinnedPdf*)arg[0]);
}

static void constructor_7937( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf();
  else ::new(mem) ::RooBinnedPdf();
}

static void constructor_7938( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(const ::RooArgList*)arg[3]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(const ::RooArgList*)arg[3]);
}

static void constructor_7939( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::RooArgList*)arg[3]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::RooArgList*)arg[3]);
}

static void constructor_7940( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void constructor_7941( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsRealLValue*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsRealLValue*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsRealLValue*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4],
      *(::Bool_t*)arg[5]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsRealLValue*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static void constructor_7942( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::RooArgList*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::RooArgList*)arg[4],
      *(::Bool_t*)arg[5]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::RooArgList*)arg[4],
      *(::Bool_t*)arg[5]);
  }
}

static void constructor_7943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4],
      *(::Bool_t*)arg[5]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4],
      *(::Bool_t*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Bool_t*)arg[6]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(const ::TObjArray*)arg[4],
      *(::Bool_t*)arg[5],
      *(::Bool_t*)arg[6]);
  }
}

static void constructor_7944( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsArg*)arg[2],
      (const char*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsArg*)arg[2],
      (const char*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_7945( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooBinnedPdf((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2],
      *(const ::TObjArray*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_7946( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf(*(const ::RooBinnedPdf*)arg[0]);
  else ::new(mem) ::RooBinnedPdf(*(const ::RooBinnedPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedPdf(*(const ::RooBinnedPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinnedPdf(*(const ::RooBinnedPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_7947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooBinnedPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_7948(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinnedPdf*)o)->::RooBinnedPdf::~RooBinnedPdf)();
}
static  void method_7949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedPdf*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinnedPdf*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_7950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedPdf*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinnedPdf*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_7951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->baseVariables)());
  else   (((::RooBinnedPdf*)o)->baseVariables)();
}

static  void method_7952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinnedPdf*)o)->continuousBase)());
  else   (((const ::RooBinnedPdf*)o)->continuousBase)();
}

static  void method_7953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((::RooBinnedPdf*)o)->forceUnitIntegral)());
  else   (((::RooBinnedPdf*)o)->forceUnitIntegral)();
}

static  void method_7954( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooBinnedPdf*)o)->setForceUnitIntegral)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooBinnedPdf*)o)->setForceUnitIntegral)(*(::Bool_t*)arg[0]);
  }
}

static  void method_7955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinnedPdf*)o)->binIntegralCoefs)());
  else   (((const ::RooBinnedPdf*)o)->binIntegralCoefs)();
}

static  void method_7956( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooBinnedPdf*)o)->setBinIntegralCoefs)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooBinnedPdf*)o)->setBinIntegralCoefs)(*(::Bool_t*)arg[0]);
  }
}

static  void method_7957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinnedPdf*)o)->ignoreFirstBin)());
  else   (((const ::RooBinnedPdf*)o)->ignoreFirstBin)();
}

static  void method_7958( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooBinnedPdf*)o)->setIgnoreFirstBin)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooBinnedPdf*)o)->setIgnoreFirstBin)(*(::Bool_t*)arg[0]);
  }
}

static  void method_7959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinnedPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinnedPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_7960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinnedPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinnedPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_7961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedPdf*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinnedPdf*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_7962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedPdf*)o)->maxVal)(*(::Int_t*)arg[0]));
  else   (((const ::RooBinnedPdf*)o)->maxVal)(*(::Int_t*)arg[0]);
}

static  void method_7963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedPdf*)o)->getValV)((const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinnedPdf*)o)->getValV)((const ::RooArgSet*)arg[0]);
}

static  void method_7974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->Class)());
  else   (((::RooBinnedPdf*)o)->Class)();
}

static  void method_7975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->Class_Name)());
  else   (((::RooBinnedPdf*)o)->Class_Name)();
}

static  void method_7976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinnedPdf*)o)->Class_Version)());
  else   (((::RooBinnedPdf*)o)->Class_Version)();
}

static  void method_7977( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinnedPdf*)o)->Dictionary)();
}

static  void method_7978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedPdf*)o)->IsA)());
  else   (((const ::RooBinnedPdf*)o)->IsA)();
}

static  void method_7979( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_7980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_7981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_7982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->DeclFileName)());
  else   (((::RooBinnedPdf*)o)->DeclFileName)();
}

static  void method_7983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinnedPdf*)o)->ImplFileLine)());
  else   (((::RooBinnedPdf*)o)->ImplFileLine)();
}

static  void method_7984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedPdf*)o)->ImplFileName)());
  else   (((::RooBinnedPdf*)o)->ImplFileName)();
}

static  void method_7985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinnedPdf*)o)->DeclFileLine)());
  else   (((::RooBinnedPdf*)o)->DeclFileLine)();
}

static void method_newdel_995( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinnedPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooBinnedPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinnedPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinnedPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinnedPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinnedPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinnedPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinnedPdf -------------------------------
void __RooBinnedPdf_db_datamem(Reflex::Class*);
void __RooBinnedPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinnedPdf_datamem_bld(&__RooBinnedPdf_db_datamem);
Reflex::GenreflexMemberBuilder __RooBinnedPdf_funcmem_bld(&__RooBinnedPdf_db_funcmem);
void __RooBinnedPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinnedPdf"), typeid(::RooBinnedPdf), sizeof(::RooBinnedPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinnedPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooBinnedPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28292, type_28293), Reflex::Literal("operator="), operator_7936, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinnedPdf"), constructor_7937, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27659, type_27821), Reflex::Literal("RooBinnedPdf"), constructor_7938, 0, "name;title;baseCat;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27821, type_27821), Reflex::Literal("RooBinnedPdf"), constructor_7939, 0, "name;title;baseCats;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27821, type_28294, type_668), Reflex::Literal("RooBinnedPdf"), constructor_7940, 0, "name;title;baseCats;coefLists;ignoreFirstBin=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27750, type_4128, type_27821, type_668), Reflex::Literal("RooBinnedPdf"), constructor_7941, 0, "name;title;baseVar;binning;coefList;binIntegralCoefs=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27821, type_28294, type_27821, type_668), Reflex::Literal("RooBinnedPdf"), constructor_7942, 0, "name;title;baseVars;binningNames;coefList;binIntegralCoefs=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27821, type_28294, type_28294, type_668, type_668), Reflex::Literal("RooBinnedPdf"), constructor_7943, 0, "name;title;baseVars;binningNames;coefLists;binIntegralCoefs=kFALSE;ignoreFirstBin=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_6054, type_4128, type_27660), Reflex::Literal("RooBinnedPdf"), constructor_7944, 0, "name;title;baseVar;binning;function", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27821, type_28294, type_27660), Reflex::Literal("RooBinnedPdf"), constructor_7945, 0, "name;title;baseVars;binningNames;function", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28293, type_4128), Reflex::Literal("RooBinnedPdf"), constructor_7946, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinnedPdf"), destructor_7948, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_995, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinnedPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinnedPdf_funcmem_bld);
}

//------Delayed data member builder for class RooBinnedPdf -------------------
void __RooBinnedPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_646, Reflex::Literal("_baseCatsList"), OffsetOf(__shadow__::__RooBinnedPdf, _baseCatsList), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("_baseVarsList"), OffsetOf(__shadow__::__RooBinnedPdf, _baseVarsList), ::Reflex::PRIVATE)
  .AddDataMember(type_2579, Reflex::Literal("_coefLists"), OffsetOf(__shadow__::__RooBinnedPdf, _coefLists), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("_function"), OffsetOf(__shadow__::__RooBinnedPdf, _function), ::Reflex::PRIVATE)
  .AddDataMember(type_3114, Reflex::Literal("_indexPositions"), OffsetOf(__shadow__::__RooBinnedPdf, _indexPositions), ::Reflex::PRIVATE)
  .AddDataMember(type_3113, Reflex::Literal("_binningNames"), OffsetOf(__shadow__::__RooBinnedPdf, _binningNames), ::Reflex::PRIVATE)
  .AddDataMember(type_3116, Reflex::Literal("_calcCoefZeros"), OffsetOf(__shadow__::__RooBinnedPdf, _calcCoefZeros), ::Reflex::PRIVATE)
  .AddDataMember(type_1309, Reflex::Literal("_numCats"), OffsetOf(__shadow__::__RooBinnedPdf, _numCats), ::Reflex::PRIVATE)
  .AddDataMember(type_668, Reflex::Literal("_continuousBase"), OffsetOf(__shadow__::__RooBinnedPdf, _continuousBase), ::Reflex::PRIVATE)
  .AddDataMember(type_668, Reflex::Literal("_forceUnitIntegral"), OffsetOf(__shadow__::__RooBinnedPdf, _forceUnitIntegral), ::Reflex::PRIVATE)
  .AddDataMember(type_668, Reflex::Literal("_binIntegralCoefs"), OffsetOf(__shadow__::__RooBinnedPdf, _binIntegralCoefs), ::Reflex::PRIVATE)
  .AddDataMember(type_668, Reflex::Literal("_ignoreFirstBin"), OffsetOf(__shadow__::__RooBinnedPdf, _ignoreFirstBin), ::Reflex::PRIVATE)
  .AddDataMember(type_2216, Reflex::Literal("m_cacheMgr"), OffsetOf(__shadow__::__RooBinnedPdf, m_cacheMgr), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2835, Reflex::Literal("m_nset"), OffsetOf(__shadow__::__RooBinnedPdf, m_nset), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2834, Reflex::Literal("m_nsethash"), OffsetOf(__shadow__::__RooBinnedPdf, m_nsethash), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3350, Reflex::Literal("m_nsets"), OffsetOf(__shadow__::__RooBinnedPdf, m_nsets), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class RooBinnedPdf -------------------
void __RooBinnedPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_7947, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27749, type_27750, type_2317, type_2317), Reflex::Literal("binBoundaries"), method_7949, 0, "obs;xlo;xhi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27749, type_27750, type_2317, type_2317), Reflex::Literal("plotSamplingHint"), method_7950, 0, "obs;xlo;xhi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2013), Reflex::Literal("baseVariables"), method_7951, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("continuousBase"), method_7952, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("forceUnitIntegral"), method_7953, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_668), Reflex::Literal("setForceUnitIntegral"), method_7954, 0, "force=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("binIntegralCoefs"), method_7955, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_668), Reflex::Literal("setBinIntegralCoefs"), method_7956, 0, "integralCoefs=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668), Reflex::Literal("ignoreFirstBin"), method_7957, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_668), Reflex::Literal("setIgnoreFirstBin"), method_7958, 0, "ignFirstBin=kTRUE", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_7959, 0, "allVars;analVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_7960, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27673), Reflex::Literal("getMaxVal"), method_7961, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("maxVal"), method_7962, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27675), Reflex::Literal("getValV"), method_7963, 0, "nset", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_7974, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_7975, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_7976, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_7977, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_7978, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_7979, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_7980, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_7981, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_7982, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_7983, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_7984, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_7985, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class MistagDistribution -------------------------------
static  void operator_8071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MistagDistribution*)o)->operator=)(*(const ::MistagDistribution*)arg[0]);
  else   (((::MistagDistribution*)o)->operator=)(*(const ::MistagDistribution*)arg[0]);
}

static void constructor_8072( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagDistribution();
  else ::new(mem) ::MistagDistribution();
}

static void constructor_8073( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagDistribution((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::MistagDistribution((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_8074( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::MistagDistribution(*(const ::MistagDistribution*)arg[0]);
  else ::new(mem) ::MistagDistribution(*(const ::MistagDistribution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MistagDistribution(*(const ::MistagDistribution*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::MistagDistribution(*(const ::MistagDistribution*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_8075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MistagDistribution*)o)->clone)((const char*)arg[0]));
  else   (((const ::MistagDistribution*)o)->clone)((const char*)arg[0]);
}

static void destructor_8076(void*, void * o, const std::vector<void*>&, void *) {
(((::MistagDistribution*)o)->::MistagDistribution::~MistagDistribution)();
}
static  void method_8077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::MistagDistribution*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::MistagDistribution*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::MistagDistribution*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::MistagDistribution*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_8078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::MistagDistribution*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::MistagDistribution*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::MistagDistribution*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::MistagDistribution*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_8081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagDistribution*)o)->Class)());
  else   (((::MistagDistribution*)o)->Class)();
}

static  void method_8082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagDistribution*)o)->Class_Name)());
  else   (((::MistagDistribution*)o)->Class_Name)();
}

static  void method_8083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::MistagDistribution*)o)->Class_Version)());
  else   (((::MistagDistribution*)o)->Class_Version)();
}

static  void method_8084( void*, void* o, const std::vector<void*>&, void*)
{
  (((::MistagDistribution*)o)->Dictionary)();
}

static  void method_8085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MistagDistribution*)o)->IsA)());
  else   (((const ::MistagDistribution*)o)->IsA)();
}

static  void method_8086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagDistribution*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_8087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagDistribution*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_8088( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagDistribution*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_8089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagDistribution*)o)->DeclFileName)());
  else   (((::MistagDistribution*)o)->DeclFileName)();
}

static  void method_8090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MistagDistribution*)o)->ImplFileLine)());
  else   (((::MistagDistribution*)o)->ImplFileLine)();
}

static  void method_8091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagDistribution*)o)->ImplFileName)());
  else   (((::MistagDistribution*)o)->ImplFileName)();
}

static  void method_8092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MistagDistribution*)o)->DeclFileLine)());
  else   (((::MistagDistribution*)o)->DeclFileLine)();
}

static void method_newdel_1073( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MistagDistribution >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::MistagDistribution,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::MistagDistribution,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::MistagDistribution,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::MistagDistribution,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::MistagDistribution,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::MistagDistribution,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MistagDistribution -------------------------------
void __MistagDistribution_db_datamem(Reflex::Class*);
void __MistagDistribution_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MistagDistribution_datamem_bld(&__MistagDistribution_db_datamem);
Reflex::GenreflexMemberBuilder __MistagDistribution_funcmem_bld(&__MistagDistribution_db_funcmem);
void __MistagDistribution_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MistagDistribution"), typeid(::MistagDistribution), sizeof(::MistagDistribution), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::MistagDistribution::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::MistagDistribution, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28309, type_28310), Reflex::Literal("operator="), operator_8071, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MistagDistribution"), constructor_8072, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("MistagDistribution"), constructor_8073, 0, "name;title;_w;_w0;_wa;_f", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28310, type_4128), Reflex::Literal("MistagDistribution"), constructor_8074, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MistagDistribution"), destructor_8076, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1073, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__MistagDistribution_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__MistagDistribution_funcmem_bld);
}

//------Delayed data member builder for class MistagDistribution -------------------
void __MistagDistribution_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("w"), OffsetOf(__shadow__::__MistagDistribution, w), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("w0"), OffsetOf(__shadow__::__MistagDistribution, w0), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("wa"), OffsetOf(__shadow__::__MistagDistribution, wa), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("f"), OffsetOf(__shadow__::__MistagDistribution, f), ::Reflex::PROTECTED)
  .AddDataMember(type_694, Reflex::Literal("lastw0"), OffsetOf(__shadow__::__MistagDistribution, lastw0), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_694, Reflex::Literal("lastwa"), OffsetOf(__shadow__::__MistagDistribution, lastwa), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_694, Reflex::Literal("lastf"), OffsetOf(__shadow__::__MistagDistribution, lastf), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_694, Reflex::Literal("lastwc"), OffsetOf(__shadow__::__MistagDistribution, lastwc), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class MistagDistribution -------------------
void __MistagDistribution_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_8075, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_8077, 0, "integ;anaIntSet;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_8078, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_8081, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_8082, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_8083, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_8084, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_8085, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_8086, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_8087, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_8088, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_8089, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_8090, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_8091, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_8092, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SquaredSum -------------------------------
static  void operator_9163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SquaredSum*)o)->operator=)(*(const ::SquaredSum*)arg[0]);
  else   (((::SquaredSum*)o)->operator=)(*(const ::SquaredSum*)arg[0]);
}

static void constructor_9164( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SquaredSum();
  else ::new(mem) ::SquaredSum();
}

static void constructor_9165( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SquaredSum((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::SquaredSum((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_9166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::SquaredSum(*(const ::SquaredSum*)arg[0]);
  else ::new(mem) ::SquaredSum(*(const ::SquaredSum*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::SquaredSum(*(const ::SquaredSum*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::SquaredSum(*(const ::SquaredSum*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_9167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SquaredSum*)o)->clone)((const char*)arg[0]));
  else   (((const ::SquaredSum*)o)->clone)((const char*)arg[0]);
}

static void destructor_9168(void*, void * o, const std::vector<void*>&, void *) {
(((::SquaredSum*)o)->::SquaredSum::~SquaredSum)();
}
static  void method_9170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SquaredSum*)o)->Class)());
  else   (((::SquaredSum*)o)->Class)();
}

static  void method_9171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SquaredSum*)o)->Class_Name)());
  else   (((::SquaredSum*)o)->Class_Name)();
}

static  void method_9172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SquaredSum*)o)->Class_Version)());
  else   (((::SquaredSum*)o)->Class_Version)();
}

static  void method_9173( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SquaredSum*)o)->Dictionary)();
}

static  void method_9174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SquaredSum*)o)->IsA)());
  else   (((const ::SquaredSum*)o)->IsA)();
}

static  void method_9175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SquaredSum*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SquaredSum*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SquaredSum*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SquaredSum*)o)->DeclFileName)());
  else   (((::SquaredSum*)o)->DeclFileName)();
}

static  void method_9179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SquaredSum*)o)->ImplFileLine)());
  else   (((::SquaredSum*)o)->ImplFileLine)();
}

static  void method_9180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SquaredSum*)o)->ImplFileName)());
  else   (((::SquaredSum*)o)->ImplFileName)();
}

static  void method_9181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SquaredSum*)o)->DeclFileLine)());
  else   (((::SquaredSum*)o)->DeclFileLine)();
}

static void method_newdel_1305( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SquaredSum >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SquaredSum >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SquaredSum >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SquaredSum >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SquaredSum >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x32( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::SquaredSum,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::SquaredSum,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::SquaredSum,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SquaredSum,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::SquaredSum,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SquaredSum -------------------------------
void __SquaredSum_db_datamem(Reflex::Class*);
void __SquaredSum_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SquaredSum_datamem_bld(&__SquaredSum_db_datamem);
Reflex::GenreflexMemberBuilder __SquaredSum_funcmem_bld(&__SquaredSum_db_funcmem);
void __SquaredSum_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SquaredSum"), typeid(::SquaredSum), sizeof(::SquaredSum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SquaredSum::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::SquaredSum, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28429, type_28430), Reflex::Literal("operator="), operator_9163, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SquaredSum"), constructor_9164, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660), Reflex::Literal("SquaredSum"), constructor_9165, 0, "name;title;_C;_D;_S", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28430, type_4128), Reflex::Literal("SquaredSum"), constructor_9166, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SquaredSum"), destructor_9168, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1305, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x32, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SquaredSum_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SquaredSum_funcmem_bld);
}

//------Delayed data member builder for class SquaredSum -------------------
void __SquaredSum_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("C"), OffsetOf(__shadow__::__SquaredSum, C), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("D"), OffsetOf(__shadow__::__SquaredSum, D), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("S"), OffsetOf(__shadow__::__SquaredSum, S), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class SquaredSum -------------------
void __SquaredSum_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_9167, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_9170, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_9171, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_9172, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_9173, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_9174, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_9175, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_9176, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_9177, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_9178, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_9179, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_9180, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_9181, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooGenSmearIntegrandBinding -------------------------------
static  void operator_9485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGenSmearIntegrandBinding*)o)->operator=)(*(const ::RooGenSmearIntegrandBinding*)arg[0]);
  else   (((::RooGenSmearIntegrandBinding*)o)->operator=)(*(const ::RooGenSmearIntegrandBinding*)arg[0]);
}

static void constructor_9486( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooGenSmearIntegrandBinding*)arg[0]);
  else ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooGenSmearIntegrandBinding*)arg[0]);
}

static void constructor_9487( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2]);
  else ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      (const ::RooArgSet*)arg[3]);
  else ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  else ::new(mem) ::RooGenSmearIntegrandBinding(*(const ::RooAbsReal*)arg[0],
      *(const ::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static void destructor_9488(void*, void * o, const std::vector<void*>&, void *) {
(((::RooGenSmearIntegrandBinding*)o)->::RooGenSmearIntegrandBinding::~RooGenSmearIntegrandBinding)();
}
static  void operator_9489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGenSmearIntegrandBinding*)o)->operator())((const ::Double_t*)arg[0]));
  else   (((const ::RooGenSmearIntegrandBinding*)o)->operator())((const ::Double_t*)arg[0]);
}

static  void method_9490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGenSmearIntegrandBinding*)o)->getMinLimit)(*(::UInt_t*)arg[0]));
  else   (((const ::RooGenSmearIntegrandBinding*)o)->getMinLimit)(*(::UInt_t*)arg[0]);
}

static  void method_9491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGenSmearIntegrandBinding*)o)->getMaxLimit)(*(::UInt_t*)arg[0]));
  else   (((const ::RooGenSmearIntegrandBinding*)o)->getMaxLimit)(*(::UInt_t*)arg[0]);
}

static  void method_9492( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->setNormalizationSet)((const ::RooArgSet*)arg[0]);
}

static  void method_9494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGenSmearIntegrandBinding*)o)->Class)());
  else   (((::RooGenSmearIntegrandBinding*)o)->Class)();
}

static  void method_9495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGenSmearIntegrandBinding*)o)->Class_Name)());
  else   (((::RooGenSmearIntegrandBinding*)o)->Class_Name)();
}

static  void method_9496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooGenSmearIntegrandBinding*)o)->Class_Version)());
  else   (((::RooGenSmearIntegrandBinding*)o)->Class_Version)();
}

static  void method_9497( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->Dictionary)();
}

static  void method_9498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGenSmearIntegrandBinding*)o)->IsA)());
  else   (((const ::RooGenSmearIntegrandBinding*)o)->IsA)();
}

static  void method_9499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9500( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9501( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGenSmearIntegrandBinding*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGenSmearIntegrandBinding*)o)->DeclFileName)());
  else   (((::RooGenSmearIntegrandBinding*)o)->DeclFileName)();
}

static  void method_9503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGenSmearIntegrandBinding*)o)->ImplFileLine)());
  else   (((::RooGenSmearIntegrandBinding*)o)->ImplFileLine)();
}

static  void method_9504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGenSmearIntegrandBinding*)o)->ImplFileName)());
  else   (((::RooGenSmearIntegrandBinding*)o)->ImplFileName)();
}

static  void method_9505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGenSmearIntegrandBinding*)o)->DeclFileLine)());
  else   (((::RooGenSmearIntegrandBinding*)o)->DeclFileLine)();
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsFunc")), ::Reflex::BaseOffset< ::RooGenSmearIntegrandBinding,::RooAbsFunc >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooGenSmearIntegrandBinding -------------------------------
void __RooGenSmearIntegrandBinding_db_datamem(Reflex::Class*);
void __RooGenSmearIntegrandBinding_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooGenSmearIntegrandBinding_datamem_bld(&__RooGenSmearIntegrandBinding_db_datamem);
Reflex::GenreflexMemberBuilder __RooGenSmearIntegrandBinding_funcmem_bld(&__RooGenSmearIntegrandBinding_db_funcmem);
void __RooGenSmearIntegrandBinding_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooGenSmearIntegrandBinding"), typeid(::RooGenSmearIntegrandBinding), sizeof(::RooGenSmearIntegrandBinding), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooGenSmearIntegrandBinding::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 0)
  .AddBase(type_2683, ::Reflex::BaseOffset< ::RooGenSmearIntegrandBinding, ::RooAbsFunc >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28479, type_28480), Reflex::Literal("operator="), operator_9485, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28480), Reflex::Literal("RooGenSmearIntegrandBinding"), constructor_9486, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27751, type_27751, type_27660, type_27675, type_668), Reflex::Literal("RooGenSmearIntegrandBinding"), constructor_9487, 0, "func;model;k;nset=0;clipInvalid=kFALSE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooGenSmearIntegrandBinding"), destructor_9488, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooGenSmearIntegrandBinding_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooGenSmearIntegrandBinding_funcmem_bld);
}

//------Delayed data member builder for class RooGenSmearIntegrandBinding -------------------
void __RooGenSmearIntegrandBinding_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_27891, Reflex::Literal("_func"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _func), ::Reflex::PROTECTED)
  .AddDataMember(type_27891, Reflex::Literal("_model"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _model), ::Reflex::PROTECTED)
  .AddDataMember(type_19390, Reflex::Literal("_var"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _var), ::Reflex::PROTECTED)
  .AddDataMember(type_27675, Reflex::Literal("_nset"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _nset), ::Reflex::PROTECTED)
  .AddDataMember(type_668, Reflex::Literal("_xvecValid"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _xvecValid), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_668, Reflex::Literal("_clipInvalid"), OffsetOf(__shadow__::__RooGenSmearIntegrandBinding, _clipInvalid), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooGenSmearIntegrandBinding -------------------
void __RooGenSmearIntegrandBinding_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27725), Reflex::Literal("operator()"), operator_9489, 0, "xvector", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_2834), Reflex::Literal("getMinLimit"), method_9490, 0, "dimension", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_2834), Reflex::Literal("getMaxLimit"), method_9491, 0, "dimension", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27675), Reflex::Literal("setNormalizationSet"), method_9492, 0, "nset", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_9494, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_9495, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_9496, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_9497, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_9498, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_9499, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_9500, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_9501, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_9502, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_9503, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_9504, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_9505, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooGaussEfficiencyModel -------------------------------
static  void operator_9753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGaussEfficiencyModel*)o)->operator=)(*(const ::RooGaussEfficiencyModel*)arg[0]);
  else   (((::RooGaussEfficiencyModel*)o)->operator=)(*(const ::RooGaussEfficiencyModel*)arg[0]);
}

static void constructor_9754( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel();
  else ::new(mem) ::RooGaussEfficiencyModel();
}

static void constructor_9755( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsGaussModelEfficiency*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::RooGaussEfficiencyModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsGaussModelEfficiency*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_9756( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsGaussModelEfficiency*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
  else ::new(mem) ::RooGaussEfficiencyModel((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsGaussModelEfficiency*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
}

static void constructor_9757( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel(*(const ::RooGaussEfficiencyModel*)arg[0]);
  else ::new(mem) ::RooGaussEfficiencyModel(*(const ::RooGaussEfficiencyModel*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGaussEfficiencyModel(*(const ::RooGaussEfficiencyModel*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooGaussEfficiencyModel(*(const ::RooGaussEfficiencyModel*)arg[0],
      (const char*)arg[1]);
  }
}

static void destructor_9758(void*, void * o, const std::vector<void*>&, void *) {
(((::RooGaussEfficiencyModel*)o)->::RooGaussEfficiencyModel::~RooGaussEfficiencyModel)();
}
static  void method_9759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooGaussEfficiencyModel*)o)->clone)((const char*)arg[0]);
}

static  void method_9760( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooGaussEfficiencyModel*)o)->basisCode)((const char*)arg[0]));
  else   (((const ::RooGaussEfficiencyModel*)o)->basisCode)((const char*)arg[0]);
}

static  void method_9761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGaussEfficiencyModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooGaussEfficiencyModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGaussEfficiencyModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooGaussEfficiencyModel*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_9762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGaussEfficiencyModel*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::RooGaussEfficiencyModel*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_9763( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]));
    else     (((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]));
    else     (((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]));
    else     (((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]));
    else     (((const ::RooGaussEfficiencyModel*)o)->modelGenContext)(*(const ::RooAbsAnaConvPdf*)arg[0],
      *(const ::RooArgSet*)arg[1],
      (const ::RooDataSet*)arg[2],
      (const ::RooArgSet*)arg[3],
      *(::Bool_t*)arg[4]);
  }
}

static  void method_9764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooGaussEfficiencyModel*)o)->isDirectGenSafe)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooGaussEfficiencyModel*)o)->isDirectGenSafe)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_9765( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooGaussEfficiencyModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    *(::Bool_t*)arg[2]));
  else   (((const ::RooGaussEfficiencyModel*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    *(::Bool_t*)arg[2]);
}

static  void method_9766( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->generateEvent)(*(::Int_t*)arg[0]);
}

static  void method_9767( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->advertiseFlatScaleFactorIntegral)(*(::Bool_t*)arg[0]);
}

static  void method_9768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->efficiency)());
  else   (((const ::RooGaussEfficiencyModel*)o)->efficiency)();
}

static  void method_9769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->observables)());
  else   (((const ::RooGaussEfficiencyModel*)o)->observables)();
}

static  void method_9772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGaussEfficiencyModel*)o)->Class)());
  else   (((::RooGaussEfficiencyModel*)o)->Class)();
}

static  void method_9773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGaussEfficiencyModel*)o)->Class_Name)());
  else   (((::RooGaussEfficiencyModel*)o)->Class_Name)();
}

static  void method_9774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooGaussEfficiencyModel*)o)->Class_Version)());
  else   (((::RooGaussEfficiencyModel*)o)->Class_Version)();
}

static  void method_9775( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGaussEfficiencyModel*)o)->Dictionary)();
}

static  void method_9776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGaussEfficiencyModel*)o)->IsA)());
  else   (((const ::RooGaussEfficiencyModel*)o)->IsA)();
}

static  void method_9777( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9778( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9779( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGaussEfficiencyModel*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGaussEfficiencyModel*)o)->DeclFileName)());
  else   (((::RooGaussEfficiencyModel*)o)->DeclFileName)();
}

static  void method_9781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGaussEfficiencyModel*)o)->ImplFileLine)());
  else   (((::RooGaussEfficiencyModel*)o)->ImplFileLine)();
}

static  void method_9782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGaussEfficiencyModel*)o)->ImplFileName)());
  else   (((::RooGaussEfficiencyModel*)o)->ImplFileName)();
}

static  void method_9783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGaussEfficiencyModel*)o)->DeclFileLine)());
  else   (((::RooGaussEfficiencyModel*)o)->DeclFileLine)();
}

static void method_newdel_1438( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooGaussEfficiencyModel >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooResolutionModel")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooResolutionModel >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooAbsReal >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooAbsArg >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::TNamed >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::TObject >::Get(),::Reflex::PUBLIC), 5));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooPrintable >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsEffResModel")), ::Reflex::BaseOffset< ::RooGaussEfficiencyModel,::RooAbsEffResModel >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooGaussEfficiencyModel -------------------------------
void __RooGaussEfficiencyModel_db_datamem(Reflex::Class*);
void __RooGaussEfficiencyModel_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooGaussEfficiencyModel_datamem_bld(&__RooGaussEfficiencyModel_db_datamem);
Reflex::GenreflexMemberBuilder __RooGaussEfficiencyModel_funcmem_bld(&__RooGaussEfficiencyModel_db_funcmem);
void __RooGaussEfficiencyModel_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooGaussEfficiencyModel"), typeid(::RooGaussEfficiencyModel), sizeof(::RooGaussEfficiencyModel), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooGaussEfficiencyModel::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_39, ::Reflex::BaseOffset< ::RooGaussEfficiencyModel, ::RooResolutionModel >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_670, ::Reflex::BaseOffset< ::RooGaussEfficiencyModel, ::RooAbsEffResModel >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28514, type_28515), Reflex::Literal("operator="), operator_9753, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooGaussEfficiencyModel"), constructor_9754, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_28516, type_27660, type_27660), Reflex::Literal("RooGaussEfficiencyModel"), constructor_9755, 0, "name;title;x;spline;mean;sigma", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_28516, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("RooGaussEfficiencyModel"), constructor_9756, 0, "name;title;x;spline;mean;sigma;meanSF;sigmaSF", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28515, type_4128), Reflex::Literal("RooGaussEfficiencyModel"), constructor_9757, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooGaussEfficiencyModel"), destructor_9758, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1438, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooGaussEfficiencyModel_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooGaussEfficiencyModel_funcmem_bld);
}

//------Delayed data member builder for class RooGaussEfficiencyModel -------------------
void __RooGaussEfficiencyModel_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_668, Reflex::Literal("_flatSFInt"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, _flatSFInt), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("eff"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, eff), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("mean"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, mean), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("sigma"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, sigma), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("msf"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, msf), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("ssf"), OffsetOf(__shadow__::__RooGaussEfficiencyModel, ssf), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooGaussEfficiencyModel -------------------
void __RooGaussEfficiencyModel_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_9759, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_4128), Reflex::Literal("basisCode"), method_9760, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_9761, 0, "allVars;analVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_9762, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27671, type_27672, type_27673, type_27674, type_27675, type_668), Reflex::Literal("modelGenContext"), method_9763, 0, "convPdf;vars;prototype=0;auxProto=0;verbose=kFALSE", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9885), Reflex::Literal("isDirectGenSafe"), method_9764, 0, "arg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27673, type_27678, type_668), Reflex::Literal("getGenerator"), method_9765, 0, "directVars;generateVars;staticInitOK", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("generateEvent"), method_9766, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_668), Reflex::Literal("advertiseFlatScaleFactorIntegral"), method_9767, 0, "flag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27891), Reflex::Literal("efficiency"), method_9768, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2835), Reflex::Literal("observables"), method_9769, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_9772, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_9773, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_9774, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_9775, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_9776, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_9777, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_9778, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_9779, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_9780, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_9781, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_9782, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_9783, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooGeneralisedSmearingBase<RooAbsPdf> -------------------------------
static void constructor_9828( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>();
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>();
}

static void constructor_9829( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_9830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsPdf>(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_9831( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->operator=)(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0]);
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->operator=)(*(const ::RooGeneralisedSmearingBase<RooAbsPdf>*)arg[0]);
}

static  void method_9832( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]);
}

static void destructor_9833(void*, void * o, const std::vector<void*>&, void *) {
(((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->::RooGeneralisedSmearingBase<RooAbsPdf>::~RooGeneralisedSmearingBase)();
}
static  void method_9834( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)((::RooRealVar*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1],
      (const ::RooArgSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1],
      (const ::RooArgSet*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_9835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->evaluate)());
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->evaluate)();
}

static  void method_9836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->convIntConfig)();
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->convIntConfig)();
}

static  void method_9837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->convIntConfig)();
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->convIntConfig)();
}

static  void method_9838( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->clearConvolutionWindow)();
}

static  void method_9839( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setConvolutionWindow)(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->setConvolutionWindow)(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::Double_t*)arg[2]);
  }
}

static  void method_9840( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_9841( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_9842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_9843( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_9844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getMax)(*(::Int_t*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->getMax)(*(::Int_t*)arg[0]);
}

static  void method_9865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class)();
}

static  void method_9866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class_Name)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class_Name)();
}

static  void method_9867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class_Version)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Class_Version)();
}

static  void method_9868( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Dictionary)();
}

static  void method_9869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->IsA)());
  else   (((const ::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->IsA)();
}

static  void method_9870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_9871( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_9872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_9873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->DeclFileName)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->DeclFileName)();
}

static  void method_9874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ImplFileLine)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ImplFileLine)();
}

static  void method_9875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ImplFileName)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->ImplFileName)();
}

static  void method_9876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->DeclFileLine)());
  else   (((::RooGeneralisedSmearingBase<RooAbsPdf>*)o)->DeclFileLine)();
}

static void method_newdel_1473( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsPdf> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooGeneralisedSmearingBase<RooAbsPdf> -------------------------------
void __RooGeneralisedSmearingBase_RooAbsPdf__db_datamem(Reflex::Class*);
void __RooGeneralisedSmearingBase_RooAbsPdf__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooGeneralisedSmearingBase_RooAbsPdf__datamem_bld(&__RooGeneralisedSmearingBase_RooAbsPdf__db_datamem);
Reflex::GenreflexMemberBuilder __RooGeneralisedSmearingBase_RooAbsPdf__funcmem_bld(&__RooGeneralisedSmearingBase_RooAbsPdf__db_funcmem);
void __RooGeneralisedSmearingBase_RooAbsPdf__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooGeneralisedSmearingBase<RooAbsPdf>"), typeid(::RooGeneralisedSmearingBase<RooAbsPdf>), sizeof(::RooGeneralisedSmearingBase<RooAbsPdf>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooGeneralisedSmearingBase<RooAbsReal>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooGeneralisedSmearingBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsPdf>, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_9828, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_27660, type_27660), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_9829, 0, "name;title;k;pdf;resmodel", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28525, type_4128), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_9830, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooGeneralisedSmearingBase"), destructor_9833, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1473, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooGeneralisedSmearingBase_RooAbsPdf__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooGeneralisedSmearingBase_RooAbsPdf__funcmem_bld);
}

//------Delayed data member builder for class RooGeneralisedSmearingBase<RooAbsPdf> -------------------
void __RooGeneralisedSmearingBase_RooAbsPdf__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_668, Reflex::Literal("_init"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _init), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_2970, Reflex::Literal("_convIntConfig"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _convIntConfig), ::Reflex::PROTECTED)
  .AddDataMember(type_28523, Reflex::Literal("_integrator"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integrator), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_28524, Reflex::Literal("_integrand"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integrand), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1249, Reflex::Literal("_origVar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _origVar), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_origPdf"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _origPdf), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_origModel"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _origModel), ::Reflex::PROTECTED)
  .AddDataMember(type_28025, Reflex::Literal("_cloneVar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _cloneVar), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_28025, Reflex::Literal("_clonePdf"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _clonePdf), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_28025, Reflex::Literal("_cloneModel"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _cloneModel), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_3358, Reflex::Literal("_integvarset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integvarset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3356, Reflex::Literal("_integralset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integralset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3354, Reflex::Literal("_integrandset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integrandset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3352, Reflex::Literal("_integratorset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _integratorset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2786, Reflex::Literal("_binning"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binning), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_binnedvar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedvar), ::Reflex::PROTECTED)
  .AddDataMember(type_22885, Reflex::Literal("_binnedvarClone"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedvarClone), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1126, Reflex::Literal("_binnedcats"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedcats), ::Reflex::PROTECTED)
  .AddDataMember(type_3105, Reflex::Literal("_binnedcache"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedcache), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3104, Reflex::Literal("_binnedcacheLastVal"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _binnedcacheLastVal), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_667, Reflex::Literal("_preferBinnedIntegrals"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _preferBinnedIntegrals), ::Reflex::PROTECTED)
  .AddDataMember(type_668, Reflex::Literal("_useWindow"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _useWindow), ::Reflex::PROTECTED)
  .AddDataMember(type_2317, Reflex::Literal("_windowScale"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _windowScale), ::Reflex::PROTECTED)
  .AddDataMember(type_646, Reflex::Literal("_windowParam"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsPdf_, _windowParam), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooGeneralisedSmearingBase<RooAbsPdf> -------------------
void __RooGeneralisedSmearingBase_RooAbsPdf__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28526, type_28525), Reflex::Literal("operator="), operator_9831, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_9832, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_22885, type_4128, type_27675, type_667), Reflex::Literal("setBinnedCache"), method_9834, 0, "var=0;binningName=0;binnedcats=0;preferBinnedIntegrals=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_9835, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28527), Reflex::Literal("convIntConfig"), method_9836, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28528), Reflex::Literal("convIntConfig"), method_9837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clearConvolutionWindow"), method_9838, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27660, type_27660, type_2317), Reflex::Literal("setConvolutionWindow"), method_9839, 0, "centerParam;widthParam;widthScaleFactor=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_9840, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_9841, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9885), Reflex::Literal("forceAnalyticalInt"), method_9842, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27673), Reflex::Literal("getMaxVal"), method_9843, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("getMax"), method_9844, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_9865, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_9866, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_9867, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_9868, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_9869, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_9870, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_9871, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_9872, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_9873, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_9874, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_9875, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_9876, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinned1DQuinticBase<RooAbsPdf> -------------------------------
static void constructor_10061( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>();
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>();
}

static void constructor_10062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>((const char*)arg[0],
      (const char*)arg[1],
      *(const ::TH1*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(bool*)arg[4]);
  }
}

static void constructor_10063( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinned1DQuinticBase<RooAbsPdf>(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_10064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->operator=)(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0]);
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->operator=)(*(const ::RooBinned1DQuinticBase<RooAbsPdf>*)arg[0]);
}

static  void method_10065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->clone)());
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->clone)((const char*)arg[0]);
  }
}

static void destructor_10066(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->::RooBinned1DQuinticBase<RooAbsPdf>::~RooBinned1DQuinticBase)();
}
static  void method_10067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->evaluate)());
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->evaluate)();
}

static  void method_10068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_10069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->isBinnedDistribution)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->isBinnedDistribution)(*(const ::RooArgSet*)arg[0]);
}

static  void method_10071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_10072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->plotSamplingHint)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_10083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class)();
}

static  void method_10084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class_Name)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class_Name)();
}

static  void method_10085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class_Version)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Class_Version)();
}

static  void method_10086( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Dictionary)();
}

static  void method_10087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->IsA)());
  else   (((const ::RooBinned1DQuinticBase<RooAbsPdf>*)o)->IsA)();
}

static  void method_10088( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10089( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->DeclFileName)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->DeclFileName)();
}

static  void method_10092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ImplFileLine)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ImplFileLine)();
}

static  void method_10093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ImplFileName)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->ImplFileName)();
}

static  void method_10094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->DeclFileLine)());
  else   (((::RooBinned1DQuinticBase<RooAbsPdf>*)o)->DeclFileLine)();
}

static void method_newdel_1576( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinned1DQuinticBase<RooAbsPdf> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinned1DQuinticBase<RooAbsPdf> -------------------------------
void __RooBinned1DQuinticBase_RooAbsPdf__db_datamem(Reflex::Class*);
void __RooBinned1DQuinticBase_RooAbsPdf__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinned1DQuinticBase_RooAbsPdf__datamem_bld(&__RooBinned1DQuinticBase_RooAbsPdf__db_datamem);
Reflex::GenreflexMemberBuilder __RooBinned1DQuinticBase_RooAbsPdf__funcmem_bld(&__RooBinned1DQuinticBase_RooAbsPdf__db_funcmem);
void __RooBinned1DQuinticBase_RooAbsPdf__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinned1DQuinticBase<RooAbsPdf>"), typeid(::RooBinned1DQuinticBase<RooAbsPdf>), sizeof(::RooBinned1DQuinticBase<RooAbsPdf>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinned1DQuinticBase<RooAbsPdf>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooBinned1DQuinticBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooBinned1DQuinticBase<RooAbsPdf>, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("_148"), Reflex::Literal("NCoeff=6;CoeffRecLen=7"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinned1DQuinticBase"), constructor_10061, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27745, type_27660, type_667), Reflex::Literal("RooBinned1DQuinticBase"), constructor_10062, 0, "name;title;h;xvar;integral=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28558, type_4128), Reflex::Literal("RooBinned1DQuinticBase"), constructor_10063, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinned1DQuinticBase"), destructor_10066, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1576, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinned1DQuinticBase_RooAbsPdf__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinned1DQuinticBase_RooAbsPdf__funcmem_bld);
}

//------Delayed data member builder for class RooBinned1DQuinticBase<RooAbsPdf> -------------------
void __RooBinned1DQuinticBase_RooAbsPdf__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, x), ::Reflex::PRIVATE)
  .AddDataMember(type_141, Reflex::Literal("nBinsX"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, nBinsX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("binSizeX"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, binSizeX), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, xmin), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, xmax), ::Reflex::PRIVATE)
  .AddDataMember(type_667, Reflex::Literal("isIntegral"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, isIntegral), ::Reflex::PRIVATE)
  .AddDataMember(type_2203, Reflex::Literal("coeffs"), OffsetOf(__shadow__::__RooBinned1DQuinticBase_RooAbsPdf_, coeffs), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinned1DQuinticBase<RooAbsPdf> -------------------
void __RooBinned1DQuinticBase_RooAbsPdf__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28559, type_28558), Reflex::Literal("operator="), operator_10064, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28560, type_4128), Reflex::Literal("clone"), method_10065, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_10067, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_10068, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_10069, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_27673), Reflex::Literal("isBinnedDistribution"), method_10070, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27749, type_27750, type_2317, type_2317), Reflex::Literal("binBoundaries"), method_10071, 0, "var;lo;hi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27749, type_27750, type_2317, type_2317), Reflex::Literal("plotSamplingHint"), method_10072, 0, "var;lo;hi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_10083, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_10084, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10085, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10086, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_10087, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_10088, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_10089, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_10090, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_10091, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10092, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_10093, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10094, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooEffHistProd -------------------------------
static  void operator_10343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooEffHistProd*)o)->operator=)(*(const ::RooEffHistProd*)arg[0]);
  else   (((::RooEffHistProd*)o)->operator=)(*(const ::RooEffHistProd*)arg[0]);
}

static void constructor_10344( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffHistProd();
  else ::new(mem) ::RooEffHistProd();
}

static void destructor_10345(void*, void * o, const std::vector<void*>&, void *) {
(((::RooEffHistProd*)o)->::RooEffHistProd::~RooEffHistProd)();
}
static void constructor_10346( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffHistProd((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsPdf*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::RooEffHistProd((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsPdf*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_10347( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffHistProd(*(const ::RooEffHistProd*)arg[0]);
  else ::new(mem) ::RooEffHistProd(*(const ::RooEffHistProd*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooEffHistProd(*(const ::RooEffHistProd*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooEffHistProd(*(const ::RooEffHistProd*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooEffHistProd*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooEffHistProd*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_10349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooEffHistProd*)o)->clone)((const char*)arg[0]);
}

static  void method_10350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->genContext)(*(const ::RooArgSet*)arg[0],
    (const ::RooDataSet*)arg[1],
    (const ::RooArgSet*)arg[2],
    *(::Bool_t*)arg[3]));
  else   (((const ::RooEffHistProd*)o)->genContext)(*(const ::RooArgSet*)arg[0],
    (const ::RooDataSet*)arg[1],
    (const ::RooArgSet*)arg[2],
    *(::Bool_t*)arg[3]);
}

static  void method_10351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooEffHistProd*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    *(::Bool_t*)arg[2]));
  else   (((const ::RooEffHistProd*)o)->getGenerator)(*(const ::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    *(::Bool_t*)arg[2]);
}

static  void method_10352( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->initGenerator)(*(::Int_t*)arg[0]);
}

static  void method_10353( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->generateEvent)(*(::Int_t*)arg[0]);
}

static  void method_10354( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffHistProd*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooEffHistProd*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooEffHistProd*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooEffHistProd*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_10355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooEffHistProd*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooEffHistProd*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10356( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->selectNormalization)((const ::RooArgSet*)arg[0],
    *(::Bool_t*)arg[1]);
}

static  void method_10357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::RooEffHistProd*)o)->extendMode)());
  else   (((const ::RooEffHistProd*)o)->extendMode)();
}

static  void method_10358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->expectedEvents)((const ::RooArgSet*)arg[0]));
  else   (((const ::RooEffHistProd*)o)->expectedEvents)((const ::RooArgSet*)arg[0]);
}

static  void method_10359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->getValV)());
    else     (((const ::RooEffHistProd*)o)->getValV)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooEffHistProd*)o)->getValV)((const ::RooArgSet*)arg[0]));
    else     (((const ::RooEffHistProd*)o)->getValV)((const ::RooArgSet*)arg[0]);
  }
}

static  void method_10360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->pdf)());
  else   (((const ::RooEffHistProd*)o)->pdf)();
}

static  void method_10361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->efficiency)());
  else   (((const ::RooEffHistProd*)o)->efficiency)();
}

static  void method_10362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->observables)());
  else   (((const ::RooEffHistProd*)o)->observables)();
}

static  void method_10363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::RooEffHistProd*)o)->getIntegralBins)((const ::RooArgSet*)arg[0]);
    else     (((const ::RooEffHistProd*)o)->getIntegralBins)((const ::RooArgSet*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::RooEffHistProd*)o)->getIntegralBins)((const ::RooArgSet*)arg[0],
      (const char*)arg[1]);
    else     (((const ::RooEffHistProd*)o)->getIntegralBins)((const ::RooArgSet*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffHistProd*)o)->Class)());
  else   (((::RooEffHistProd*)o)->Class)();
}

static  void method_10371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffHistProd*)o)->Class_Name)());
  else   (((::RooEffHistProd*)o)->Class_Name)();
}

static  void method_10372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooEffHistProd*)o)->Class_Version)());
  else   (((::RooEffHistProd*)o)->Class_Version)();
}

static  void method_10373( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooEffHistProd*)o)->Dictionary)();
}

static  void method_10374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooEffHistProd*)o)->IsA)());
  else   (((const ::RooEffHistProd*)o)->IsA)();
}

static  void method_10375( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10377( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooEffHistProd*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffHistProd*)o)->DeclFileName)());
  else   (((::RooEffHistProd*)o)->DeclFileName)();
}

static  void method_10379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffHistProd*)o)->ImplFileLine)());
  else   (((::RooEffHistProd*)o)->ImplFileLine)();
}

static  void method_10380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooEffHistProd*)o)->ImplFileName)());
  else   (((::RooEffHistProd*)o)->ImplFileName)();
}

static  void method_10381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooEffHistProd*)o)->DeclFileLine)());
  else   (((::RooEffHistProd*)o)->DeclFileLine)();
}

static void method_newdel_1630( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooEffHistProd >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooEffHistProd,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooEffHistProd,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooEffHistProd,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooEffHistProd,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooEffHistProd,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooEffHistProd,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooEffHistProd -------------------------------
void __RooEffHistProd_db_datamem(Reflex::Class*);
void __RooEffHistProd_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooEffHistProd_datamem_bld(&__RooEffHistProd_db_datamem);
Reflex::GenreflexMemberBuilder __RooEffHistProd_funcmem_bld(&__RooEffHistProd_db_funcmem);
void __RooEffHistProd_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooEffHistProd"), typeid(::RooEffHistProd), sizeof(::RooEffHistProd), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooEffHistProd::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooEffHistProd, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3089, Reflex::Literal("RooEffHistProd::BinBoundaries"))
  .AddTypedef(type_3111, Reflex::Literal("RooEffHistProd::Levels"))
  .AddTypedef(type_3363, Reflex::Literal("RooEffHistProd::argMap_t"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28595, type_28596), Reflex::Literal("operator="), operator_10343, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooEffHistProd"), constructor_10344, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooEffHistProd"), destructor_10345, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27862, type_27660), Reflex::Literal("RooEffHistProd"), constructor_10346, 0, "name;title;pdf;efficiency", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28596, type_4128), Reflex::Literal("RooEffHistProd"), constructor_10347, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1630, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooEffHistProd_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooEffHistProd_funcmem_bld);
}

//------Delayed data member builder for class RooEffHistProd -------------------
void __RooEffHistProd_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3089, Reflex::Literal("_binboundaries"), OffsetOf(__shadow__::__RooEffHistProd, _binboundaries), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_pdf"), OffsetOf(__shadow__::__RooEffHistProd, _pdf), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("_eff"), OffsetOf(__shadow__::__RooEffHistProd, _eff), ::Reflex::PRIVATE)
  .AddDataMember(type_878, Reflex::Literal("_observables"), OffsetOf(__shadow__::__RooEffHistProd, _observables), ::Reflex::PRIVATE)
  .AddDataMember(type_1126, Reflex::Literal("_pdfGenVars"), OffsetOf(__shadow__::__RooEffHistProd, _pdfGenVars), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_1309, Reflex::Literal("_pdfGenCode"), OffsetOf(__shadow__::__RooEffHistProd, _pdfGenCode), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_2317, Reflex::Literal("_maxEff"), OffsetOf(__shadow__::__RooEffHistProd, _maxEff), ::Reflex::PRIVATE)
  .AddDataMember(type_3111, Reflex::Literal("_levels"), OffsetOf(__shadow__::__RooEffHistProd, _levels), ::Reflex::PRIVATE)
  .AddDataMember(type_3363, Reflex::Literal("_pdfObs"), OffsetOf(__shadow__::__RooEffHistProd, _pdfObs), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_27675, Reflex::Literal("_pdfNormSet"), OffsetOf(__shadow__::__RooEffHistProd, _pdfNormSet), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_27675, Reflex::Literal("_fixedNormSet"), OffsetOf(__shadow__::__RooEffHistProd, _fixedNormSet), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_2216, Reflex::Literal("_cacheMgr"), OffsetOf(__shadow__::__RooEffHistProd, _cacheMgr), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class RooEffHistProd -------------------
void __RooEffHistProd_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9885), Reflex::Literal("forceAnalyticalInt"), method_10348, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_10349, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27671, type_27673, type_27674, type_27675, type_668), Reflex::Literal("genContext"), method_10350, 0, "vars;prototype;auxProto;verbose", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27673, type_27678, type_668), Reflex::Literal("getGenerator"), method_10351, 0, "dv;gv;si", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("initGenerator"), method_10352, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_1309), Reflex::Literal("generateEvent"), method_10353, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_10354, 0, "allVars;analVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_10355, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27675, type_668), Reflex::Literal("selectNormalization"), method_10356, 0, ";", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12434), Reflex::Literal("extendMode"), method_10357, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27675), Reflex::Literal("expectedEvents"), method_10358, 0, "nset", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_27675), Reflex::Literal("getValV"), method_10359, 0, "set=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27917), Reflex::Literal("pdf"), method_10360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28025), Reflex::Literal("efficiency"), method_10361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27675), Reflex::Literal("observables"), method_10362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27821, type_27675, type_4128), Reflex::Literal("getIntegralBins"), method_10363, 0, "iset;rangeName=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_10370, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_10371, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10372, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10373, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_10374, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_10375, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_10376, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_10377, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_10378, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10379, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_10380, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10381, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooAbsGaussModelEfficiency -------------------------------
static  void operator_10493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooAbsGaussModelEfficiency*)o)->operator=)(*(const ::RooAbsGaussModelEfficiency*)arg[0]);
  else   (((::RooAbsGaussModelEfficiency*)o)->operator=)(*(const ::RooAbsGaussModelEfficiency*)arg[0]);
}

static void destructor_10497(void*, void * o, const std::vector<void*>&, void *) {
(((::RooAbsGaussModelEfficiency*)o)->::RooAbsGaussModelEfficiency::~RooAbsGaussModelEfficiency)();
}
static  void method_10498( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::complex<double>)((((const ::RooAbsGaussModelEfficiency*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]));
  else   (((const ::RooAbsGaussModelEfficiency*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]);
}

static  void method_10499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooAbsGaussModelEfficiency*)o)->Class)());
  else   (((::RooAbsGaussModelEfficiency*)o)->Class)();
}

static  void method_10500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooAbsGaussModelEfficiency*)o)->Class_Name)());
  else   (((::RooAbsGaussModelEfficiency*)o)->Class_Name)();
}

static  void method_10501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooAbsGaussModelEfficiency*)o)->Class_Version)());
  else   (((::RooAbsGaussModelEfficiency*)o)->Class_Version)();
}

static  void method_10502( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooAbsGaussModelEfficiency*)o)->Dictionary)();
}

static  void method_10503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooAbsGaussModelEfficiency*)o)->IsA)());
  else   (((const ::RooAbsGaussModelEfficiency*)o)->IsA)();
}

static  void method_10504( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooAbsGaussModelEfficiency*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10505( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooAbsGaussModelEfficiency*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10506( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooAbsGaussModelEfficiency*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooAbsGaussModelEfficiency*)o)->DeclFileName)());
  else   (((::RooAbsGaussModelEfficiency*)o)->DeclFileName)();
}

static  void method_10508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooAbsGaussModelEfficiency*)o)->ImplFileLine)());
  else   (((::RooAbsGaussModelEfficiency*)o)->ImplFileLine)();
}

static  void method_10509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooAbsGaussModelEfficiency*)o)->ImplFileName)());
  else   (((::RooAbsGaussModelEfficiency*)o)->ImplFileName)();
}

static  void method_10510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooAbsGaussModelEfficiency*)o)->DeclFileLine)());
  else   (((::RooAbsGaussModelEfficiency*)o)->DeclFileLine)();
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooAbsGaussModelEfficiency -------------------------------
void __RooAbsGaussModelEfficiency_db_datamem(Reflex::Class*);
void __RooAbsGaussModelEfficiency_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooAbsGaussModelEfficiency_datamem_bld(&__RooAbsGaussModelEfficiency_db_datamem);
Reflex::GenreflexMemberBuilder __RooAbsGaussModelEfficiency_funcmem_bld(&__RooAbsGaussModelEfficiency_db_funcmem);
void __RooAbsGaussModelEfficiency_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooAbsGaussModelEfficiency"), typeid(::RooAbsGaussModelEfficiency), sizeof(::RooAbsGaussModelEfficiency), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooAbsGaussModelEfficiency::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooAbsGaussModelEfficiency, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28516, type_28608), Reflex::Literal("operator="), operator_10493, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooAbsGaussModelEfficiency"), destructor_10497, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__RooAbsGaussModelEfficiency_funcmem_bld);
}

//------Delayed data member builder for class RooAbsGaussModelEfficiency -------------------
void __RooAbsGaussModelEfficiency_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RooAbsGaussModelEfficiency -------------------
void __RooAbsGaussModelEfficiency_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3635, type_2317, type_2317, type_2317, type_2317, type_22775), Reflex::Literal("productAnalyticalIntegral"), method_10498, 0, "umin;umax;scale;offset;z", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_10499, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_10500, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10501, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10502, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_10503, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_10504, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_10505, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_10506, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_10507, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10508, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_10509, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10510, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooGeneralisedSmearingBase<RooAbsReal> -------------------------------
static void constructor_10536( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>();
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>();
}

static void constructor_10537( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_10538( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooGeneralisedSmearingBase<RooAbsReal>(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_10539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->operator=)(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0]);
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->operator=)(*(const ::RooGeneralisedSmearingBase<RooAbsReal>*)arg[0]);
}

static  void method_10540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->clone)((const char*)arg[0]);
}

static void destructor_10541(void*, void * o, const std::vector<void*>&, void *) {
(((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->::RooGeneralisedSmearingBase<RooAbsReal>::~RooGeneralisedSmearingBase)();
}
static  void method_10542( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)();
  }
  else if ( arg.size() == 1 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)((::RooRealVar*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1],
      (const ::RooArgSet*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setBinnedCache)((::RooRealVar*)arg[0],
      (const char*)arg[1],
      (const ::RooArgSet*)arg[2],
      *(bool*)arg[3]);
  }
}

static  void method_10543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->evaluate)());
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->evaluate)();
}

static  void method_10544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->convIntConfig)();
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->convIntConfig)();
}

static  void method_10545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->convIntConfig)();
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->convIntConfig)();
}

static  void method_10546( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->clearConvolutionWindow)();
}

static  void method_10547( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setConvolutionWindow)(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->setConvolutionWindow)(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::Double_t*)arg[2]);
  }
}

static  void method_10548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_10549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Bool_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->forceAnalyticalInt)(*(const ::RooAbsArg*)arg[0]);
}

static  void method_10551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_10552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getMax)(*(::Int_t*)arg[0]));
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->getMax)(*(::Int_t*)arg[0]);
}

static  void method_10573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class)();
}

static  void method_10574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class_Name)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class_Name)();
}

static  void method_10575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class_Version)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Class_Version)();
}

static  void method_10576( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Dictionary)();
}

static  void method_10577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->IsA)());
  else   (((const ::RooGeneralisedSmearingBase<RooAbsReal>*)o)->IsA)();
}

static  void method_10578( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10579( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10580( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->DeclFileName)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->DeclFileName)();
}

static  void method_10582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ImplFileLine)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ImplFileLine)();
}

static  void method_10583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ImplFileName)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->ImplFileName)();
}

static  void method_10584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->DeclFileLine)());
  else   (((::RooGeneralisedSmearingBase<RooAbsReal>*)o)->DeclFileLine)();
}

static void method_newdel_1675( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooGeneralisedSmearingBase<RooAbsReal> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooGeneralisedSmearingBase<RooAbsReal> -------------------------------
void __RooGeneralisedSmearingBase_RooAbsReal__db_datamem(Reflex::Class*);
void __RooGeneralisedSmearingBase_RooAbsReal__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooGeneralisedSmearingBase_RooAbsReal__datamem_bld(&__RooGeneralisedSmearingBase_RooAbsReal__db_datamem);
Reflex::GenreflexMemberBuilder __RooGeneralisedSmearingBase_RooAbsReal__funcmem_bld(&__RooGeneralisedSmearingBase_RooAbsReal__db_funcmem);
void __RooGeneralisedSmearingBase_RooAbsReal__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooGeneralisedSmearingBase<RooAbsReal>"), typeid(::RooGeneralisedSmearingBase<RooAbsReal>), sizeof(::RooGeneralisedSmearingBase<RooAbsReal>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooGeneralisedSmearingBase<RooAbsReal>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "RooGeneralisedSmearingBase<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooGeneralisedSmearingBase<RooAbsReal>, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_10536, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_27660, type_27660), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_10537, 0, "name;title;k;pdf;resmodel", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28609, type_4128), Reflex::Literal("RooGeneralisedSmearingBase"), constructor_10538, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooGeneralisedSmearingBase"), destructor_10541, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1675, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooGeneralisedSmearingBase_RooAbsReal__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooGeneralisedSmearingBase_RooAbsReal__funcmem_bld);
}

//------Delayed data member builder for class RooGeneralisedSmearingBase<RooAbsReal> -------------------
void __RooGeneralisedSmearingBase_RooAbsReal__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_668, Reflex::Literal("_init"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _init), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_2970, Reflex::Literal("_convIntConfig"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _convIntConfig), ::Reflex::PROTECTED)
  .AddDataMember(type_28523, Reflex::Literal("_integrator"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integrator), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_28524, Reflex::Literal("_integrand"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integrand), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1249, Reflex::Literal("_origVar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _origVar), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_origPdf"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _origPdf), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_origModel"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _origModel), ::Reflex::PROTECTED)
  .AddDataMember(type_28025, Reflex::Literal("_cloneVar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _cloneVar), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_28025, Reflex::Literal("_clonePdf"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _clonePdf), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_28025, Reflex::Literal("_cloneModel"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _cloneModel), ::Reflex::PROTECTED | ::Reflex::MUTABLE)
  .AddDataMember(type_3358, Reflex::Literal("_integvarset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integvarset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3356, Reflex::Literal("_integralset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integralset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3354, Reflex::Literal("_integrandset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integrandset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3352, Reflex::Literal("_integratorset"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _integratorset), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2786, Reflex::Literal("_binning"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binning), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_binnedvar"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedvar), ::Reflex::PROTECTED)
  .AddDataMember(type_22885, Reflex::Literal("_binnedvarClone"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedvarClone), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_1126, Reflex::Literal("_binnedcats"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedcats), ::Reflex::PROTECTED)
  .AddDataMember(type_3105, Reflex::Literal("_binnedcache"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedcache), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_3104, Reflex::Literal("_binnedcacheLastVal"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _binnedcacheLastVal), ::Reflex::PROTECTED | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_667, Reflex::Literal("_preferBinnedIntegrals"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _preferBinnedIntegrals), ::Reflex::PROTECTED)
  .AddDataMember(type_668, Reflex::Literal("_useWindow"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _useWindow), ::Reflex::PROTECTED)
  .AddDataMember(type_2317, Reflex::Literal("_windowScale"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _windowScale), ::Reflex::PROTECTED)
  .AddDataMember(type_646, Reflex::Literal("_windowParam"), OffsetOf(__shadow__::__RooGeneralisedSmearingBase_RooAbsReal_, _windowParam), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooGeneralisedSmearingBase<RooAbsReal> -------------------
void __RooGeneralisedSmearingBase_RooAbsReal__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28610, type_28609), Reflex::Literal("operator="), operator_10539, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_10540, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_22885, type_4128, type_27675, type_667), Reflex::Literal("setBinnedCache"), method_10542, 0, "var=0;binningName=0;binnedcats=0;preferBinnedIntegrals=false", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("evaluate"), method_10543, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28527), Reflex::Literal("convIntConfig"), method_10544, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28528), Reflex::Literal("convIntConfig"), method_10545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clearConvolutionWindow"), method_10546, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27660, type_27660, type_2317), Reflex::Literal("setConvolutionWindow"), method_10547, 0, "centerParam;widthParam;widthScaleFactor=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_10548, 0, "allVars;integVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_10549, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_668, type_9885), Reflex::Literal("forceAnalyticalInt"), method_10550, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27673), Reflex::Literal("getMaxVal"), method_10551, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("getMax"), method_10552, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_10573, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_10574, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10575, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10576, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_10577, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_10578, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_10579, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_10580, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_10581, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10582, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_10583, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10584, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TagEfficiencyWeightNoCat -------------------------------
static  void operator_10589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TagEfficiencyWeightNoCat*)o)->operator=)(*(const ::TagEfficiencyWeightNoCat*)arg[0]);
  else   (((::TagEfficiencyWeightNoCat*)o)->operator=)(*(const ::TagEfficiencyWeightNoCat*)arg[0]);
}

static void constructor_10590( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeightNoCat();
  else ::new(mem) ::TagEfficiencyWeightNoCat();
}

static void constructor_10591( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeightNoCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::TagEfficiencyWeightNoCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_10592( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeightNoCat(*(const ::TagEfficiencyWeightNoCat*)arg[0]);
  else ::new(mem) ::TagEfficiencyWeightNoCat(*(const ::TagEfficiencyWeightNoCat*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TagEfficiencyWeightNoCat(*(const ::TagEfficiencyWeightNoCat*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::TagEfficiencyWeightNoCat(*(const ::TagEfficiencyWeightNoCat*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_10593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TagEfficiencyWeightNoCat*)o)->clone)((const char*)arg[0]));
  else   (((const ::TagEfficiencyWeightNoCat*)o)->clone)((const char*)arg[0]);
}

static void destructor_10594(void*, void * o, const std::vector<void*>&, void *) {
(((::TagEfficiencyWeightNoCat*)o)->::TagEfficiencyWeightNoCat::~TagEfficiencyWeightNoCat)();
}
static  void method_10596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeightNoCat*)o)->Class)());
  else   (((::TagEfficiencyWeightNoCat*)o)->Class)();
}

static  void method_10597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeightNoCat*)o)->Class_Name)());
  else   (((::TagEfficiencyWeightNoCat*)o)->Class_Name)();
}

static  void method_10598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TagEfficiencyWeightNoCat*)o)->Class_Version)());
  else   (((::TagEfficiencyWeightNoCat*)o)->Class_Version)();
}

static  void method_10599( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TagEfficiencyWeightNoCat*)o)->Dictionary)();
}

static  void method_10600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TagEfficiencyWeightNoCat*)o)->IsA)());
  else   (((const ::TagEfficiencyWeightNoCat*)o)->IsA)();
}

static  void method_10601( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeightNoCat*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_10602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeightNoCat*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_10603( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TagEfficiencyWeightNoCat*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_10604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeightNoCat*)o)->DeclFileName)());
  else   (((::TagEfficiencyWeightNoCat*)o)->DeclFileName)();
}

static  void method_10605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TagEfficiencyWeightNoCat*)o)->ImplFileLine)());
  else   (((::TagEfficiencyWeightNoCat*)o)->ImplFileLine)();
}

static  void method_10606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TagEfficiencyWeightNoCat*)o)->ImplFileName)());
  else   (((::TagEfficiencyWeightNoCat*)o)->ImplFileName)();
}

static  void method_10607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TagEfficiencyWeightNoCat*)o)->DeclFileLine)());
  else   (((::TagEfficiencyWeightNoCat*)o)->DeclFileLine)();
}

static void method_newdel_1679( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TagEfficiencyWeightNoCat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TagEfficiencyWeightNoCat -------------------------------
void __TagEfficiencyWeightNoCat_db_datamem(Reflex::Class*);
void __TagEfficiencyWeightNoCat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TagEfficiencyWeightNoCat_datamem_bld(&__TagEfficiencyWeightNoCat_db_datamem);
Reflex::GenreflexMemberBuilder __TagEfficiencyWeightNoCat_funcmem_bld(&__TagEfficiencyWeightNoCat_db_funcmem);
void __TagEfficiencyWeightNoCat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TagEfficiencyWeightNoCat"), typeid(::TagEfficiencyWeightNoCat), sizeof(::TagEfficiencyWeightNoCat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TagEfficiencyWeightNoCat::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::TagEfficiencyWeightNoCat, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28611, type_28612), Reflex::Literal("operator="), operator_10589, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TagEfficiencyWeightNoCat"), constructor_10590, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660), Reflex::Literal("TagEfficiencyWeightNoCat"), constructor_10591, 0, "name;title;_tag;_eff", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28612, type_4128), Reflex::Literal("TagEfficiencyWeightNoCat"), constructor_10592, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TagEfficiencyWeightNoCat"), destructor_10594, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1679, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TagEfficiencyWeightNoCat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TagEfficiencyWeightNoCat_funcmem_bld);
}

//------Delayed data member builder for class TagEfficiencyWeightNoCat -------------------
void __TagEfficiencyWeightNoCat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("tag"), OffsetOf(__shadow__::__TagEfficiencyWeightNoCat, tag), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("eff"), OffsetOf(__shadow__::__TagEfficiencyWeightNoCat, eff), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TagEfficiencyWeightNoCat -------------------
void __TagEfficiencyWeightNoCat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_10593, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_10596, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_10597, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_10598, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_10599, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_10600, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_10601, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_10602, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_10603, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_10604, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_10605, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_10606, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_10607, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class FinalStateChargePdf -------------------------------
static  void operator_11091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::FinalStateChargePdf*)o)->operator=)(*(const ::FinalStateChargePdf*)arg[0]);
  else   (((::FinalStateChargePdf*)o)->operator=)(*(const ::FinalStateChargePdf*)arg[0]);
}

static void constructor_11092( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::FinalStateChargePdf();
  else ::new(mem) ::FinalStateChargePdf();
}

static void constructor_11093( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::FinalStateChargePdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3]);
  else ::new(mem) ::FinalStateChargePdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsReal*)arg[3]);
}

static void constructor_11094( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::FinalStateChargePdf(*(const ::FinalStateChargePdf*)arg[0]);
  else ::new(mem) ::FinalStateChargePdf(*(const ::FinalStateChargePdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::FinalStateChargePdf(*(const ::FinalStateChargePdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::FinalStateChargePdf(*(const ::FinalStateChargePdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FinalStateChargePdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::FinalStateChargePdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_11096(void*, void * o, const std::vector<void*>&, void *) {
(((::FinalStateChargePdf*)o)->::FinalStateChargePdf::~FinalStateChargePdf)();
}
static  void method_11097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (Int_t)((((const ::FinalStateChargePdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]));
    else     (((const ::FinalStateChargePdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (Int_t)((((const ::FinalStateChargePdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]));
    else     (((const ::FinalStateChargePdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
      *(::RooArgSet*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_11098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (Double_t)((((const ::FinalStateChargePdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]));
    else     (((const ::FinalStateChargePdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (Double_t)((((const ::FinalStateChargePdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]));
    else     (((const ::FinalStateChargePdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FinalStateChargePdf*)o)->Class)());
  else   (((::FinalStateChargePdf*)o)->Class)();
}

static  void method_11102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FinalStateChargePdf*)o)->Class_Name)());
  else   (((::FinalStateChargePdf*)o)->Class_Name)();
}

static  void method_11103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::FinalStateChargePdf*)o)->Class_Version)());
  else   (((::FinalStateChargePdf*)o)->Class_Version)();
}

static  void method_11104( void*, void* o, const std::vector<void*>&, void*)
{
  (((::FinalStateChargePdf*)o)->Dictionary)();
}

static  void method_11105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FinalStateChargePdf*)o)->IsA)());
  else   (((const ::FinalStateChargePdf*)o)->IsA)();
}

static  void method_11106( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FinalStateChargePdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11107( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FinalStateChargePdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11108( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FinalStateChargePdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FinalStateChargePdf*)o)->DeclFileName)());
  else   (((::FinalStateChargePdf*)o)->DeclFileName)();
}

static  void method_11110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FinalStateChargePdf*)o)->ImplFileLine)());
  else   (((::FinalStateChargePdf*)o)->ImplFileLine)();
}

static  void method_11111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FinalStateChargePdf*)o)->ImplFileName)());
  else   (((::FinalStateChargePdf*)o)->ImplFileName)();
}

static  void method_11112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FinalStateChargePdf*)o)->DeclFileLine)());
  else   (((::FinalStateChargePdf*)o)->DeclFileLine)();
}

static void method_newdel_1744( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::FinalStateChargePdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::FinalStateChargePdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class FinalStateChargePdf -------------------------------
void __FinalStateChargePdf_db_datamem(Reflex::Class*);
void __FinalStateChargePdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __FinalStateChargePdf_datamem_bld(&__FinalStateChargePdf_db_datamem);
Reflex::GenreflexMemberBuilder __FinalStateChargePdf_funcmem_bld(&__FinalStateChargePdf_db_funcmem);
void __FinalStateChargePdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("FinalStateChargePdf"), typeid(::FinalStateChargePdf), sizeof(::FinalStateChargePdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::FinalStateChargePdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::FinalStateChargePdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30948, type_30949), Reflex::Literal("operator="), operator_11091, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FinalStateChargePdf"), constructor_11092, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27659, type_27660), Reflex::Literal("FinalStateChargePdf"), constructor_11093, 0, "name;title;qf;asymm", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30949, type_4128), Reflex::Literal("FinalStateChargePdf"), constructor_11094, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FinalStateChargePdf"), destructor_11096, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1744, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__FinalStateChargePdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__FinalStateChargePdf_funcmem_bld);
}

//------Delayed data member builder for class FinalStateChargePdf -------------------
void __FinalStateChargePdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("m_qf"), OffsetOf(__shadow__::__FinalStateChargePdf, m_qf), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("m_asymm"), OffsetOf(__shadow__::__FinalStateChargePdf, m_asymm), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class FinalStateChargePdf -------------------
void __FinalStateChargePdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_11095, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_11097, 0, "allVars;anaIntVars;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_11098, 0, "code;rangeName=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11101, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11103, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11104, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11105, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11106, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11107, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11108, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11109, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11110, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11111, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11112, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class TaggingCat -------------------------------
static  void operator_11435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TaggingCat*)o)->operator=)(*(const ::TaggingCat*)arg[0]);
  else   (((::TaggingCat*)o)->operator=)(*(const ::TaggingCat*)arg[0]);
}

static void constructor_11436( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TaggingCat();
  else ::new(mem) ::TaggingCat();
}

static void constructor_11437( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TaggingCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooArgList*)arg[4]);
  else ::new(mem) ::TaggingCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooArgList*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TaggingCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooArgList*)arg[4],
      *(bool*)arg[5]);
  else ::new(mem) ::TaggingCat((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsCategory*)arg[2],
      *(::RooAbsCategory*)arg[3],
      *(::RooArgList*)arg[4],
      *(bool*)arg[5]);
  }
}

static void constructor_11438( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::TaggingCat(*(const ::TaggingCat*)arg[0]);
  else ::new(mem) ::TaggingCat(*(const ::TaggingCat*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::TaggingCat(*(const ::TaggingCat*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::TaggingCat(*(const ::TaggingCat*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TaggingCat*)o)->clone)((const char*)arg[0]));
  else   (((const ::TaggingCat*)o)->clone)((const char*)arg[0]);
}

static void destructor_11440(void*, void * o, const std::vector<void*>&, void *) {
(((::TaggingCat*)o)->::TaggingCat::~TaggingCat)();
}
static  void method_11442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TaggingCat*)o)->Class)());
  else   (((::TaggingCat*)o)->Class)();
}

static  void method_11443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TaggingCat*)o)->Class_Name)());
  else   (((::TaggingCat*)o)->Class_Name)();
}

static  void method_11444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::TaggingCat*)o)->Class_Version)());
  else   (((::TaggingCat*)o)->Class_Version)();
}

static  void method_11445( void*, void* o, const std::vector<void*>&, void*)
{
  (((::TaggingCat*)o)->Dictionary)();
}

static  void method_11446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TaggingCat*)o)->IsA)());
  else   (((const ::TaggingCat*)o)->IsA)();
}

static  void method_11447( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TaggingCat*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11448( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TaggingCat*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11449( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TaggingCat*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TaggingCat*)o)->DeclFileName)());
  else   (((::TaggingCat*)o)->DeclFileName)();
}

static  void method_11451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TaggingCat*)o)->ImplFileLine)());
  else   (((::TaggingCat*)o)->ImplFileLine)();
}

static  void method_11452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::TaggingCat*)o)->ImplFileName)());
  else   (((::TaggingCat*)o)->ImplFileName)();
}

static  void method_11453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::TaggingCat*)o)->DeclFileLine)());
  else   (((::TaggingCat*)o)->DeclFileLine)();
}

static void method_newdel_1831( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TaggingCat >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TaggingCat >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TaggingCat >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TaggingCat >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TaggingCat >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::TaggingCat,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::TaggingCat,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::TaggingCat,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::TaggingCat,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::TaggingCat,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TaggingCat -------------------------------
void __TaggingCat_db_datamem(Reflex::Class*);
void __TaggingCat_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TaggingCat_datamem_bld(&__TaggingCat_db_datamem);
Reflex::GenreflexMemberBuilder __TaggingCat_funcmem_bld(&__TaggingCat_db_funcmem);
void __TaggingCat_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TaggingCat"), typeid(::TaggingCat), sizeof(::TaggingCat), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::TaggingCat::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::TaggingCat, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30982, type_30983), Reflex::Literal("operator="), operator_11435, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TaggingCat"), constructor_11436, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27659, type_27659, type_28509, type_667), Reflex::Literal("TaggingCat"), constructor_11437, 0, "name;title;_qt;_cat;_vars;_isTagEff=false", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30983, type_4128), Reflex::Literal("TaggingCat"), constructor_11438, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TaggingCat"), destructor_11440, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1831, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TaggingCat_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TaggingCat_funcmem_bld);
}

//------Delayed data member builder for class TaggingCat -------------------
void __TaggingCat_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1173, Reflex::Literal("qt"), OffsetOf(__shadow__::__TaggingCat, qt), ::Reflex::PROTECTED)
  .AddDataMember(type_1173, Reflex::Literal("cat"), OffsetOf(__shadow__::__TaggingCat, cat), ::Reflex::PROTECTED)
  .AddDataMember(type_646, Reflex::Literal("catlist"), OffsetOf(__shadow__::__TaggingCat, catlist), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("untaggedVal"), OffsetOf(__shadow__::__TaggingCat, untaggedVal), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TaggingCat -------------------
void __TaggingCat_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_11439, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11442, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11443, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11444, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11445, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11446, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11447, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11448, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11449, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11450, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11451, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11452, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11453, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RangeAcceptance -------------------------------
static  void operator_11510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RangeAcceptance*)o)->operator=)(*(const ::RangeAcceptance*)arg[0]);
  else   (((::RangeAcceptance*)o)->operator=)(*(const ::RangeAcceptance*)arg[0]);
}

static void constructor_11511( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RangeAcceptance();
  else ::new(mem) ::RangeAcceptance();
}

static void constructor_11512( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RangeAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::RangeAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
}

static void constructor_11513( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RangeAcceptance(*(const ::RangeAcceptance*)arg[0]);
  else ::new(mem) ::RangeAcceptance(*(const ::RangeAcceptance*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RangeAcceptance(*(const ::RangeAcceptance*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RangeAcceptance(*(const ::RangeAcceptance*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RangeAcceptance*)o)->clone)((const char*)arg[0]));
  else   (((const ::RangeAcceptance*)o)->clone)((const char*)arg[0]);
}

static void destructor_11515(void*, void * o, const std::vector<void*>&, void *) {
(((::RangeAcceptance*)o)->::RangeAcceptance::~RangeAcceptance)();
}
static  void method_11517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RangeAcceptance*)o)->Class)());
  else   (((::RangeAcceptance*)o)->Class)();
}

static  void method_11518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RangeAcceptance*)o)->Class_Name)());
  else   (((::RangeAcceptance*)o)->Class_Name)();
}

static  void method_11519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RangeAcceptance*)o)->Class_Version)());
  else   (((::RangeAcceptance*)o)->Class_Version)();
}

static  void method_11520( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RangeAcceptance*)o)->Dictionary)();
}

static  void method_11521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RangeAcceptance*)o)->IsA)());
  else   (((const ::RangeAcceptance*)o)->IsA)();
}

static  void method_11522( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RangeAcceptance*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11523( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RangeAcceptance*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11524( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RangeAcceptance*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RangeAcceptance*)o)->DeclFileName)());
  else   (((::RangeAcceptance*)o)->DeclFileName)();
}

static  void method_11526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RangeAcceptance*)o)->ImplFileLine)());
  else   (((::RangeAcceptance*)o)->ImplFileLine)();
}

static  void method_11527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RangeAcceptance*)o)->ImplFileName)());
  else   (((::RangeAcceptance*)o)->ImplFileName)();
}

static  void method_11528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RangeAcceptance*)o)->DeclFileLine)());
  else   (((::RangeAcceptance*)o)->DeclFileLine)();
}

static void method_newdel_1880( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RangeAcceptance >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RangeAcceptance,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RangeAcceptance,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RangeAcceptance,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RangeAcceptance,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RangeAcceptance,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RangeAcceptance -------------------------------
void __RangeAcceptance_db_datamem(Reflex::Class*);
void __RangeAcceptance_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RangeAcceptance_datamem_bld(&__RangeAcceptance_db_datamem);
Reflex::GenreflexMemberBuilder __RangeAcceptance_funcmem_bld(&__RangeAcceptance_db_funcmem);
void __RangeAcceptance_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RangeAcceptance"), typeid(::RangeAcceptance), sizeof(::RangeAcceptance), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RangeAcceptance::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RangeAcceptance, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30990, type_30991), Reflex::Literal("operator="), operator_11510, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RangeAcceptance"), constructor_11511, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_694, type_694), Reflex::Literal("RangeAcceptance"), constructor_11512, 0, "name;title;_x;_xmin;_xmax", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30991, type_4128), Reflex::Literal("RangeAcceptance"), constructor_11513, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RangeAcceptance"), destructor_11515, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1880, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RangeAcceptance_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RangeAcceptance_funcmem_bld);
}

//------Delayed data member builder for class RangeAcceptance -------------------
void __RangeAcceptance_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RangeAcceptance, x), ::Reflex::PROTECTED)
  .AddDataMember(type_694, Reflex::Literal("xmin"), OffsetOf(__shadow__::__RangeAcceptance, xmin), ::Reflex::PROTECTED)
  .AddDataMember(type_694, Reflex::Literal("xmax"), OffsetOf(__shadow__::__RangeAcceptance, xmax), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RangeAcceptance -------------------
void __RangeAcceptance_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_11514, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11517, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11518, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11519, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11520, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11521, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11522, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11523, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11524, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11525, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11526, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11527, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11528, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PowLawAcceptance -------------------------------
static void constructor_11584( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance();
  else ::new(mem) ::PowLawAcceptance();
}

static void constructor_11585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 7 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
  else ::new(mem) ::PowLawAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      (::RooAbsReal*)arg[7]);
  else ::new(mem) ::PowLawAcceptance((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      (::RooAbsReal*)arg[7]);
  }
}

static void constructor_11586( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0]);
  else ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0],
      (const char*)arg[1]);
  }
}

static void constructor_11587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0],
      (const char*)arg[1],
      (::RooAbsReal*)arg[2]);
  else ::new(mem) ::PowLawAcceptance(*(const ::PowLawAcceptance*)arg[0],
      (const char*)arg[1],
      (::RooAbsReal*)arg[2]);
}

static void destructor_11588(void*, void * o, const std::vector<void*>&, void *) {
(((::PowLawAcceptance*)o)->::PowLawAcceptance::~PowLawAcceptance)();
}
static  void method_11589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PowLawAcceptance*)o)->clone)((const char*)arg[0]));
  else   (((const ::PowLawAcceptance*)o)->clone)((const char*)arg[0]);
}

static  void operator_11590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PowLawAcceptance*)o)->operator=)(*(const ::PowLawAcceptance*)arg[0]);
  else   (((::PowLawAcceptance*)o)->operator=)(*(const ::PowLawAcceptance*)arg[0]);
}

static  void method_11592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PowLawAcceptance*)o)->Class)());
  else   (((::PowLawAcceptance*)o)->Class)();
}

static  void method_11593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PowLawAcceptance*)o)->Class_Name)());
  else   (((::PowLawAcceptance*)o)->Class_Name)();
}

static  void method_11594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::PowLawAcceptance*)o)->Class_Version)());
  else   (((::PowLawAcceptance*)o)->Class_Version)();
}

static  void method_11595( void*, void* o, const std::vector<void*>&, void*)
{
  (((::PowLawAcceptance*)o)->Dictionary)();
}

static  void method_11596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PowLawAcceptance*)o)->IsA)());
  else   (((const ::PowLawAcceptance*)o)->IsA)();
}

static  void method_11597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PowLawAcceptance*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11598( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PowLawAcceptance*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11599( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PowLawAcceptance*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PowLawAcceptance*)o)->DeclFileName)());
  else   (((::PowLawAcceptance*)o)->DeclFileName)();
}

static  void method_11601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::PowLawAcceptance*)o)->ImplFileLine)());
  else   (((::PowLawAcceptance*)o)->ImplFileLine)();
}

static  void method_11602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::PowLawAcceptance*)o)->ImplFileName)());
  else   (((::PowLawAcceptance*)o)->ImplFileName)();
}

static  void method_11603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::PowLawAcceptance*)o)->DeclFileLine)());
  else   (((::PowLawAcceptance*)o)->DeclFileLine)();
}

static void method_newdel_1909( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PowLawAcceptance >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x54( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::PowLawAcceptance,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::PowLawAcceptance,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::PowLawAcceptance,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::PowLawAcceptance,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::PowLawAcceptance,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PowLawAcceptance -------------------------------
void __PowLawAcceptance_db_datamem(Reflex::Class*);
void __PowLawAcceptance_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PowLawAcceptance_datamem_bld(&__PowLawAcceptance_db_datamem);
Reflex::GenreflexMemberBuilder __PowLawAcceptance_funcmem_bld(&__PowLawAcceptance_db_funcmem);
void __PowLawAcceptance_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PowLawAcceptance"), typeid(::PowLawAcceptance), sizeof(::PowLawAcceptance), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::PowLawAcceptance::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::PowLawAcceptance, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PowLawAcceptance"), constructor_11584, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_27660, type_27660, type_28025), Reflex::Literal("PowLawAcceptance"), constructor_11585, 0, "name;title;turnon;time;__offset;exponent;beta;correction=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30996, type_4128), Reflex::Literal("PowLawAcceptance"), constructor_11586, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30996, type_4128, type_28025), Reflex::Literal("PowLawAcceptance"), constructor_11587, 0, "other;name;correction", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PowLawAcceptance"), destructor_11588, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1909, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x54, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PowLawAcceptance_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PowLawAcceptance_funcmem_bld);
}

//------Delayed data member builder for class PowLawAcceptance -------------------
void __PowLawAcceptance_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("_turnon"), OffsetOf(__shadow__::__PowLawAcceptance, _turnon), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_time"), OffsetOf(__shadow__::__PowLawAcceptance, _time), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_offset"), OffsetOf(__shadow__::__PowLawAcceptance, _offset), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_exponent"), OffsetOf(__shadow__::__PowLawAcceptance, _exponent), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_beta"), OffsetOf(__shadow__::__PowLawAcceptance, _beta), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("_correction"), OffsetOf(__shadow__::__PowLawAcceptance, _correction), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class PowLawAcceptance -------------------
void __PowLawAcceptance_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_11589, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30997, type_30996), Reflex::Literal("operator="), operator_11590, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11592, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11593, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11594, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11595, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11596, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11597, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11598, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11599, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11600, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11601, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11602, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11603, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class MistagCalibration -------------------------------
static  void operator_11648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MistagCalibration*)o)->operator=)(*(const ::MistagCalibration*)arg[0]);
  else   (((::MistagCalibration*)o)->operator=)(*(const ::MistagCalibration*)arg[0]);
}

static void constructor_11649( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration();
  else ::new(mem) ::MistagCalibration();
}

static void constructor_11650( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_11651( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_11652( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooArgList*)arg[3],
      *(::RooAbsReal*)arg[4]);
  else ::new(mem) ::MistagCalibration((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooArgList*)arg[3],
      *(::RooAbsReal*)arg[4]);
}

static void constructor_11653( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration(*(const ::MistagCalibration*)arg[0]);
  else ::new(mem) ::MistagCalibration(*(const ::MistagCalibration*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::MistagCalibration(*(const ::MistagCalibration*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::MistagCalibration(*(const ::MistagCalibration*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_11654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MistagCalibration*)o)->clone)((const char*)arg[0]));
  else   (((const ::MistagCalibration*)o)->clone)((const char*)arg[0]);
}

static void destructor_11655(void*, void * o, const std::vector<void*>&, void *) {
(((::MistagCalibration*)o)->::MistagCalibration::~MistagCalibration)();
}
static  void method_11656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::MistagCalibration*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::MistagCalibration*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_11657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::MistagCalibration*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::MistagCalibration*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_11661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagCalibration*)o)->Class)());
  else   (((::MistagCalibration*)o)->Class)();
}

static  void method_11662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagCalibration*)o)->Class_Name)());
  else   (((::MistagCalibration*)o)->Class_Name)();
}

static  void method_11663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::MistagCalibration*)o)->Class_Version)());
  else   (((::MistagCalibration*)o)->Class_Version)();
}

static  void method_11664( void*, void* o, const std::vector<void*>&, void*)
{
  (((::MistagCalibration*)o)->Dictionary)();
}

static  void method_11665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::MistagCalibration*)o)->IsA)());
  else   (((const ::MistagCalibration*)o)->IsA)();
}

static  void method_11666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagCalibration*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagCalibration*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11668( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MistagCalibration*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagCalibration*)o)->DeclFileName)());
  else   (((::MistagCalibration*)o)->DeclFileName)();
}

static  void method_11670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MistagCalibration*)o)->ImplFileLine)());
  else   (((::MistagCalibration*)o)->ImplFileLine)();
}

static  void method_11671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::MistagCalibration*)o)->ImplFileName)());
  else   (((::MistagCalibration*)o)->ImplFileName)();
}

static  void method_11672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::MistagCalibration*)o)->DeclFileLine)());
  else   (((::MistagCalibration*)o)->DeclFileLine)();
}

static void method_newdel_1927( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MistagCalibration >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x56( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::MistagCalibration,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::MistagCalibration,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::MistagCalibration,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::MistagCalibration,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::MistagCalibration,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MistagCalibration -------------------------------
void __MistagCalibration_db_datamem(Reflex::Class*);
void __MistagCalibration_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MistagCalibration_datamem_bld(&__MistagCalibration_db_datamem);
Reflex::GenreflexMemberBuilder __MistagCalibration_funcmem_bld(&__MistagCalibration_db_funcmem);
void __MistagCalibration_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MistagCalibration"), typeid(::MistagCalibration), sizeof(::MistagCalibration), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::MistagCalibration::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::MistagCalibration, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30998, type_30999), Reflex::Literal("operator="), operator_11648, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MistagCalibration"), constructor_11649, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660), Reflex::Literal("MistagCalibration"), constructor_11650, 0, "name;title;eta;p0;p1", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("MistagCalibration"), constructor_11651, 0, "name;title;eta;p0;p1;etaavg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_28509, type_27660), Reflex::Literal("MistagCalibration"), constructor_11652, 0, "name;title;eta;calibcoeffs;etaavg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30999, type_4128), Reflex::Literal("MistagCalibration"), constructor_11653, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MistagCalibration"), destructor_11655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1927, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x56, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__MistagCalibration_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__MistagCalibration_funcmem_bld);
}

//------Delayed data member builder for class MistagCalibration -------------------
void __MistagCalibration_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("m_eta"), OffsetOf(__shadow__::__MistagCalibration, m_eta), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("m_calibcoeffs"), OffsetOf(__shadow__::__MistagCalibration, m_calibcoeffs), ::Reflex::PRIVATE)
  .AddDataMember(type_1249, Reflex::Literal("m_etaavg"), OffsetOf(__shadow__::__MistagCalibration, m_etaavg), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class MistagCalibration -------------------
void __MistagCalibration_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_11654, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_11656, 0, "allVars;anaIntVars;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_11657, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11661, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11662, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11663, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11664, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11665, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11666, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11667, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11668, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11669, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11670, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11671, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11672, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<double> -------------------------------
static  void operator_11715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<double>*)o)->operator=)(*(const ::SharedArrayImp<double>*)arg[0]);
  else   (((::SharedArrayImp<double>*)o)->operator=)(*(const ::SharedArrayImp<double>*)arg[0]);
}

static void constructor_11716( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<double>();
  else ::new(mem) ::SharedArrayImp<double>();
}

static void constructor_11717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<double>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<double>(*(unsigned int*)arg[0]);
}

static void constructor_11718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<double>(*(const ::SharedArrayImp<double>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<double>(*(const ::SharedArrayImp<double>*)arg[0]);
}

static  void method_11719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<double>*)o)->Clone)());
    else     (((const ::SharedArrayImp<double>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<double>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<double>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11720(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<double>*)o)->::SharedArrayImp<double>::~SharedArrayImp)();
}
static  void method_11721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<double>*)o)->refCount)());
  else   (((const ::SharedArrayImp<double>*)o)->refCount)();
}

static  void method_11722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->acquire)());
  else   (((::SharedArrayImp<double>*)o)->acquire)();
}

static  void method_11723( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<double>*)o)->release)();
}

static  void method_11724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<double>*)o)->size)());
  else   (((const ::SharedArrayImp<double>*)o)->size)();
}

static  void operator_11725( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<double>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<double>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<double>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<double>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->Class)());
  else   (((::SharedArrayImp<double>*)o)->Class)();
}

static  void method_11728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->Class_Name)());
  else   (((::SharedArrayImp<double>*)o)->Class_Name)();
}

static  void method_11729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<double>*)o)->Class_Version)());
  else   (((::SharedArrayImp<double>*)o)->Class_Version)();
}

static  void method_11730( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<double>*)o)->Dictionary)();
}

static  void method_11731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<double>*)o)->IsA)());
  else   (((const ::SharedArrayImp<double>*)o)->IsA)();
}

static  void method_11732( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<double>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11733( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<double>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11734( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<double>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<double>*)o)->DeclFileName)();
}

static  void method_11736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<double>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<double>*)o)->ImplFileLine)();
}

static  void method_11737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<double>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<double>*)o)->ImplFileName)();
}

static  void method_11738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<double>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<double>*)o)->DeclFileLine)();
}

static void method_newdel_1939( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x58( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<double>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<double> -------------------------------
void __SharedArrayImp_double__db_datamem(Reflex::Class*);
void __SharedArrayImp_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_double__datamem_bld(&__SharedArrayImp_double__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_double__funcmem_bld(&__SharedArrayImp_double__db_funcmem);
void __SharedArrayImp_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<double>"), typeid(::SharedArrayImp<double>), sizeof(::SharedArrayImp<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<double>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31002, type_31003), Reflex::Literal("operator="), operator_11715, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11716, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11717, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31003), Reflex::Literal("SharedArrayImp"), constructor_11718, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11720, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1939, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x58, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_double__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<double> -------------------
void __SharedArrayImp_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_double_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3089, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_double_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<double> -------------------
void __SharedArrayImp_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31004, type_4128), Reflex::Literal("Clone"), method_11719, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31004), Reflex::Literal("acquire"), method_11722, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11723, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841, type_211), Reflex::Literal("operator[]"), operator_11725, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839, type_211), Reflex::Literal("operator[]"), operator_11726, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11727, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11728, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11729, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11730, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11731, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11732, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11733, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11734, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11735, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11736, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11737, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11738, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<float> -------------------------------
static  void operator_11742( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<float>*)o)->operator=)(*(const ::SharedArrayImp<float>*)arg[0]);
  else   (((::SharedArrayImp<float>*)o)->operator=)(*(const ::SharedArrayImp<float>*)arg[0]);
}

static void constructor_11743( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<float>();
  else ::new(mem) ::SharedArrayImp<float>();
}

static void constructor_11744( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<float>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<float>(*(unsigned int*)arg[0]);
}

static void constructor_11745( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<float>(*(const ::SharedArrayImp<float>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<float>(*(const ::SharedArrayImp<float>*)arg[0]);
}

static  void method_11746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<float>*)o)->Clone)());
    else     (((const ::SharedArrayImp<float>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<float>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<float>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11747(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<float>*)o)->::SharedArrayImp<float>::~SharedArrayImp)();
}
static  void method_11748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<float>*)o)->refCount)());
  else   (((const ::SharedArrayImp<float>*)o)->refCount)();
}

static  void method_11749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->acquire)());
  else   (((::SharedArrayImp<float>*)o)->acquire)();
}

static  void method_11750( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<float>*)o)->release)();
}

static  void method_11751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<float>*)o)->size)());
  else   (((const ::SharedArrayImp<float>*)o)->size)();
}

static  void operator_11752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<float>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<float>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<float>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<float>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->Class)());
  else   (((::SharedArrayImp<float>*)o)->Class)();
}

static  void method_11755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->Class_Name)());
  else   (((::SharedArrayImp<float>*)o)->Class_Name)();
}

static  void method_11756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<float>*)o)->Class_Version)());
  else   (((::SharedArrayImp<float>*)o)->Class_Version)();
}

static  void method_11757( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<float>*)o)->Dictionary)();
}

static  void method_11758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<float>*)o)->IsA)());
  else   (((const ::SharedArrayImp<float>*)o)->IsA)();
}

static  void method_11759( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<float>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11760( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<float>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11761( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<float>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<float>*)o)->DeclFileName)();
}

static  void method_11763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<float>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<float>*)o)->ImplFileLine)();
}

static  void method_11764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<float>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<float>*)o)->ImplFileName)();
}

static  void method_11765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<float>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<float>*)o)->DeclFileLine)();
}

static void method_newdel_1940( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x60( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<float>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<float> -------------------------------
void __SharedArrayImp_float__db_datamem(Reflex::Class*);
void __SharedArrayImp_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_float__datamem_bld(&__SharedArrayImp_float__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_float__funcmem_bld(&__SharedArrayImp_float__db_funcmem);
void __SharedArrayImp_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<float>"), typeid(::SharedArrayImp<float>), sizeof(::SharedArrayImp<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<float>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31005, type_31006), Reflex::Literal("operator="), operator_11742, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11743, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11744, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31006), Reflex::Literal("SharedArrayImp"), constructor_11745, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11747, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1940, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x60, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_float__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<float> -------------------
void __SharedArrayImp_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_float_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3091, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_float_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<float> -------------------
void __SharedArrayImp_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31007, type_4128), Reflex::Literal("Clone"), method_11746, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31007), Reflex::Literal("acquire"), method_11749, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11750, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17971, type_211), Reflex::Literal("operator[]"), operator_11752, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17969, type_211), Reflex::Literal("operator[]"), operator_11753, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11754, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11755, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11756, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11757, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11758, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11759, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11760, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11761, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11762, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11763, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11764, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11765, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<long long unsigned int> -------------------------------
static  void operator_11769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned long long>*)o)->operator=)(*(const ::SharedArrayImp<unsigned long long>*)arg[0]);
  else   (((::SharedArrayImp<unsigned long long>*)o)->operator=)(*(const ::SharedArrayImp<unsigned long long>*)arg[0]);
}

static void constructor_11770( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long long>();
  else ::new(mem) ::SharedArrayImp<unsigned long long>();
}

static void constructor_11771( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned long long>(*(unsigned int*)arg[0]);
}

static void constructor_11772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long long>(*(const ::SharedArrayImp<unsigned long long>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned long long>(*(const ::SharedArrayImp<unsigned long long>*)arg[0]);
}

static  void method_11773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long long>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned long long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned long long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11774(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned long long>*)o)->::SharedArrayImp<unsigned long long>::~SharedArrayImp)();
}
static  void method_11775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned long long>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned long long>*)o)->refCount)();
}

static  void method_11776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->acquire)();
}

static  void method_11777( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->release)();
}

static  void method_11778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned long long>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned long long>*)o)->size)();
}

static  void operator_11779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->Class)();
}

static  void method_11782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->Class_Name)();
}

static  void method_11783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned long long>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->Class_Version)();
}

static  void method_11784( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->Dictionary)();
}

static  void method_11785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long long>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned long long>*)o)->IsA)();
}

static  void method_11786( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11787( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11788( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->DeclFileName)();
}

static  void method_11790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned long long>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->ImplFileLine)();
}

static  void method_11791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long long>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->ImplFileName)();
}

static  void method_11792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned long long>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned long long>*)o)->DeclFileLine)();
}

static void method_newdel_1941( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x62( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned long long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<long long unsigned int> -------------------------------
void __SharedArrayImp_unsignedslongslong__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedslongslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedslongslong__datamem_bld(&__SharedArrayImp_unsignedslongslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedslongslong__funcmem_bld(&__SharedArrayImp_unsignedslongslong__db_funcmem);
void __SharedArrayImp_unsignedslongslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned long long>"), typeid(::SharedArrayImp<unsigned long long>), sizeof(::SharedArrayImp<unsigned long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned long long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31008, type_31009), Reflex::Literal("operator="), operator_11769, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11770, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11771, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31009), Reflex::Literal("SharedArrayImp"), constructor_11772, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11774, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1941, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x62, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedslongslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedslongslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<long long unsigned int> -------------------
void __SharedArrayImp_unsignedslongslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedslongslong_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3092, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedslongslong_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<long long unsigned int> -------------------
void __SharedArrayImp_unsignedslongslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31010, type_4128), Reflex::Literal("Clone"), method_11773, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31010), Reflex::Literal("acquire"), method_11776, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11777, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18036, type_211), Reflex::Literal("operator[]"), operator_11779, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18034, type_211), Reflex::Literal("operator[]"), operator_11780, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11781, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11782, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11783, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11784, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11785, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11786, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11787, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11788, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11789, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11790, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11791, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11792, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<long unsigned int> -------------------------------
static  void operator_11796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned long>*)o)->operator=)(*(const ::SharedArrayImp<unsigned long>*)arg[0]);
  else   (((::SharedArrayImp<unsigned long>*)o)->operator=)(*(const ::SharedArrayImp<unsigned long>*)arg[0]);
}

static void constructor_11797( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long>();
  else ::new(mem) ::SharedArrayImp<unsigned long>();
}

static void constructor_11798( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned long>(*(unsigned int*)arg[0]);
}

static void constructor_11799( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned long>(*(const ::SharedArrayImp<unsigned long>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned long>(*(const ::SharedArrayImp<unsigned long>*)arg[0]);
}

static  void method_11800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11801(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned long>*)o)->::SharedArrayImp<unsigned long>::~SharedArrayImp)();
}
static  void method_11802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned long>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned long>*)o)->refCount)();
}

static  void method_11803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned long>*)o)->acquire)();
}

static  void method_11804( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->release)();
}

static  void method_11805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned long>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned long>*)o)->size)();
}

static  void operator_11806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned long>*)o)->Class)();
}

static  void method_11809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned long>*)o)->Class_Name)();
}

static  void method_11810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned long>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned long>*)o)->Class_Version)();
}

static  void method_11811( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->Dictionary)();
}

static  void method_11812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned long>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned long>*)o)->IsA)();
}

static  void method_11813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11814( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned long>*)o)->DeclFileName)();
}

static  void method_11817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned long>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned long>*)o)->ImplFileLine)();
}

static  void method_11818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned long>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned long>*)o)->ImplFileName)();
}

static  void method_11819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned long>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned long>*)o)->DeclFileLine)();
}

static void method_newdel_1942( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x64( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<long unsigned int> -------------------------------
void __SharedArrayImp_unsignedslong__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedslong__datamem_bld(&__SharedArrayImp_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedslong__funcmem_bld(&__SharedArrayImp_unsignedslong__db_funcmem);
void __SharedArrayImp_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned long>"), typeid(::SharedArrayImp<unsigned long>), sizeof(::SharedArrayImp<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31011, type_31012), Reflex::Literal("operator="), operator_11796, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11797, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11798, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31012), Reflex::Literal("SharedArrayImp"), constructor_11799, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11801, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1942, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x64, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<long unsigned int> -------------------
void __SharedArrayImp_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedslong_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3093, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedslong_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<long unsigned int> -------------------
void __SharedArrayImp_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31013, type_4128), Reflex::Literal("Clone"), method_11800, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31013), Reflex::Literal("acquire"), method_11803, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11804, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18101, type_211), Reflex::Literal("operator[]"), operator_11806, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18099, type_211), Reflex::Literal("operator[]"), operator_11807, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11808, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11809, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11810, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11811, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11812, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11813, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11814, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11815, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11816, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11817, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11818, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11819, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<unsigned int> -------------------------------
static  void operator_11823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned int>*)o)->operator=)(*(const ::SharedArrayImp<unsigned int>*)arg[0]);
  else   (((::SharedArrayImp<unsigned int>*)o)->operator=)(*(const ::SharedArrayImp<unsigned int>*)arg[0]);
}

static void constructor_11824( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned int>();
  else ::new(mem) ::SharedArrayImp<unsigned int>();
}

static void constructor_11825( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned int>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned int>(*(unsigned int*)arg[0]);
}

static void constructor_11826( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned int>(*(const ::SharedArrayImp<unsigned int>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned int>(*(const ::SharedArrayImp<unsigned int>*)arg[0]);
}

static  void method_11827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned int>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned int>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned int>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned int>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11828(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned int>*)o)->::SharedArrayImp<unsigned int>::~SharedArrayImp)();
}
static  void method_11829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned int>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned int>*)o)->refCount)();
}

static  void method_11830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned int>*)o)->acquire)();
}

static  void method_11831( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->release)();
}

static  void method_11832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned int>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned int>*)o)->size)();
}

static  void operator_11833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned int>*)o)->Class)();
}

static  void method_11836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned int>*)o)->Class_Name)();
}

static  void method_11837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned int>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned int>*)o)->Class_Version)();
}

static  void method_11838( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->Dictionary)();
}

static  void method_11839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned int>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned int>*)o)->IsA)();
}

static  void method_11840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11842( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned int>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned int>*)o)->DeclFileName)();
}

static  void method_11844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned int>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned int>*)o)->ImplFileLine)();
}

static  void method_11845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned int>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned int>*)o)->ImplFileName)();
}

static  void method_11846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned int>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned int>*)o)->DeclFileLine)();
}

static void method_newdel_1943( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x66( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned int>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<unsigned int> -------------------------------
void __SharedArrayImp_unsignedsint__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedsint__datamem_bld(&__SharedArrayImp_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedsint__funcmem_bld(&__SharedArrayImp_unsignedsint__db_funcmem);
void __SharedArrayImp_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned int>"), typeid(::SharedArrayImp<unsigned int>), sizeof(::SharedArrayImp<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned int>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31014, type_31015), Reflex::Literal("operator="), operator_11823, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11824, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11825, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31015), Reflex::Literal("SharedArrayImp"), constructor_11826, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11828, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1943, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x66, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<unsigned int> -------------------
void __SharedArrayImp_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedsint_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3094, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedsint_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<unsigned int> -------------------
void __SharedArrayImp_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31016, type_4128), Reflex::Literal("Clone"), method_11827, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31016), Reflex::Literal("acquire"), method_11830, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11831, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18166, type_211), Reflex::Literal("operator[]"), operator_11833, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18164, type_211), Reflex::Literal("operator[]"), operator_11834, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11835, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11836, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11837, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11838, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11839, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11840, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11841, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11842, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11843, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11844, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11845, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11846, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<short unsigned int> -------------------------------
static  void operator_11850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned short>*)o)->operator=)(*(const ::SharedArrayImp<unsigned short>*)arg[0]);
  else   (((::SharedArrayImp<unsigned short>*)o)->operator=)(*(const ::SharedArrayImp<unsigned short>*)arg[0]);
}

static void constructor_11851( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned short>();
  else ::new(mem) ::SharedArrayImp<unsigned short>();
}

static void constructor_11852( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned short>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned short>(*(unsigned int*)arg[0]);
}

static void constructor_11853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned short>(*(const ::SharedArrayImp<unsigned short>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned short>(*(const ::SharedArrayImp<unsigned short>*)arg[0]);
}

static  void method_11854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned short>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned short>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned short>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned short>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11855(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned short>*)o)->::SharedArrayImp<unsigned short>::~SharedArrayImp)();
}
static  void method_11856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned short>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned short>*)o)->refCount)();
}

static  void method_11857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned short>*)o)->acquire)();
}

static  void method_11858( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->release)();
}

static  void method_11859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned short>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned short>*)o)->size)();
}

static  void operator_11860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned short>*)o)->Class)();
}

static  void method_11863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned short>*)o)->Class_Name)();
}

static  void method_11864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned short>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned short>*)o)->Class_Version)();
}

static  void method_11865( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->Dictionary)();
}

static  void method_11866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned short>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned short>*)o)->IsA)();
}

static  void method_11867( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11868( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11869( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned short>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned short>*)o)->DeclFileName)();
}

static  void method_11871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned short>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned short>*)o)->ImplFileLine)();
}

static  void method_11872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned short>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned short>*)o)->ImplFileName)();
}

static  void method_11873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned short>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned short>*)o)->DeclFileLine)();
}

static void method_newdel_1944( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x68( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned short>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<short unsigned int> -------------------------------
void __SharedArrayImp_unsignedsshort__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedsshort__datamem_bld(&__SharedArrayImp_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedsshort__funcmem_bld(&__SharedArrayImp_unsignedsshort__db_funcmem);
void __SharedArrayImp_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned short>"), typeid(::SharedArrayImp<unsigned short>), sizeof(::SharedArrayImp<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned short>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31017, type_31018), Reflex::Literal("operator="), operator_11850, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11851, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11852, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31018), Reflex::Literal("SharedArrayImp"), constructor_11853, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11855, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1944, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x68, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedsshort__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedsshort__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<short unsigned int> -------------------
void __SharedArrayImp_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedsshort_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3095, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedsshort_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<short unsigned int> -------------------
void __SharedArrayImp_unsignedsshort__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31019, type_4128), Reflex::Literal("Clone"), method_11854, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31019), Reflex::Literal("acquire"), method_11857, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11858, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18231, type_211), Reflex::Literal("operator[]"), operator_11860, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18229, type_211), Reflex::Literal("operator[]"), operator_11861, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11862, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11863, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11864, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11865, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11866, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11867, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11868, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11869, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11870, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11871, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11872, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11873, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<unsigned char> -------------------------------
static  void operator_11877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned char>*)o)->operator=)(*(const ::SharedArrayImp<unsigned char>*)arg[0]);
  else   (((::SharedArrayImp<unsigned char>*)o)->operator=)(*(const ::SharedArrayImp<unsigned char>*)arg[0]);
}

static void constructor_11878( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned char>();
  else ::new(mem) ::SharedArrayImp<unsigned char>();
}

static void constructor_11879( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned char>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned char>(*(unsigned int*)arg[0]);
}

static void constructor_11880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<unsigned char>(*(const ::SharedArrayImp<unsigned char>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<unsigned char>(*(const ::SharedArrayImp<unsigned char>*)arg[0]);
}

static  void method_11881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned char>*)o)->Clone)());
    else     (((const ::SharedArrayImp<unsigned char>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned char>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<unsigned char>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11882(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<unsigned char>*)o)->::SharedArrayImp<unsigned char>::~SharedArrayImp)();
}
static  void method_11883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned char>*)o)->refCount)());
  else   (((const ::SharedArrayImp<unsigned char>*)o)->refCount)();
}

static  void method_11884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->acquire)());
  else   (((::SharedArrayImp<unsigned char>*)o)->acquire)();
}

static  void method_11885( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->release)();
}

static  void method_11886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<unsigned char>*)o)->size)());
  else   (((const ::SharedArrayImp<unsigned char>*)o)->size)();
}

static  void operator_11887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->Class)());
  else   (((::SharedArrayImp<unsigned char>*)o)->Class)();
}

static  void method_11890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->Class_Name)());
  else   (((::SharedArrayImp<unsigned char>*)o)->Class_Name)();
}

static  void method_11891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<unsigned char>*)o)->Class_Version)());
  else   (((::SharedArrayImp<unsigned char>*)o)->Class_Version)();
}

static  void method_11892( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->Dictionary)();
}

static  void method_11893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<unsigned char>*)o)->IsA)());
  else   (((const ::SharedArrayImp<unsigned char>*)o)->IsA)();
}

static  void method_11894( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<unsigned char>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<unsigned char>*)o)->DeclFileName)();
}

static  void method_11898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned char>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<unsigned char>*)o)->ImplFileLine)();
}

static  void method_11899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<unsigned char>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<unsigned char>*)o)->ImplFileName)();
}

static  void method_11900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<unsigned char>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<unsigned char>*)o)->DeclFileLine)();
}

static void method_newdel_1945( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<unsigned char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x70( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<unsigned char>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<unsigned char> -------------------------------
void __SharedArrayImp_unsignedschar__db_datamem(Reflex::Class*);
void __SharedArrayImp_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedschar__datamem_bld(&__SharedArrayImp_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_unsignedschar__funcmem_bld(&__SharedArrayImp_unsignedschar__db_funcmem);
void __SharedArrayImp_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<unsigned char>"), typeid(::SharedArrayImp<unsigned char>), sizeof(::SharedArrayImp<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<unsigned char>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31020, type_31021), Reflex::Literal("operator="), operator_11877, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11878, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11879, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31021), Reflex::Literal("SharedArrayImp"), constructor_11880, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11882, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1945, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x70, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_unsignedschar__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_unsignedschar__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<unsigned char> -------------------
void __SharedArrayImp_unsignedschar__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_unsignedschar_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3096, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_unsignedschar_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<unsigned char> -------------------
void __SharedArrayImp_unsignedschar__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31022, type_4128), Reflex::Literal("Clone"), method_11881, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31022), Reflex::Literal("acquire"), method_11884, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11885, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18296, type_211), Reflex::Literal("operator[]"), operator_11887, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18294, type_211), Reflex::Literal("operator[]"), operator_11888, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11889, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11890, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11891, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11892, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11893, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11894, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11895, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11896, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11897, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11898, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11899, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11900, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<long long int> -------------------------------
static  void operator_11904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<long long>*)o)->operator=)(*(const ::SharedArrayImp<long long>*)arg[0]);
  else   (((::SharedArrayImp<long long>*)o)->operator=)(*(const ::SharedArrayImp<long long>*)arg[0]);
}

static void constructor_11905( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long long>();
  else ::new(mem) ::SharedArrayImp<long long>();
}

static void constructor_11906( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<long long>(*(unsigned int*)arg[0]);
}

static void constructor_11907( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long long>(*(const ::SharedArrayImp<long long>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<long long>(*(const ::SharedArrayImp<long long>*)arg[0]);
}

static  void method_11908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long long>*)o)->Clone)());
    else     (((const ::SharedArrayImp<long long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<long long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11909(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<long long>*)o)->::SharedArrayImp<long long>::~SharedArrayImp)();
}
static  void method_11910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<long long>*)o)->refCount)());
  else   (((const ::SharedArrayImp<long long>*)o)->refCount)();
}

static  void method_11911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->acquire)());
  else   (((::SharedArrayImp<long long>*)o)->acquire)();
}

static  void method_11912( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<long long>*)o)->release)();
}

static  void method_11913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<long long>*)o)->size)());
  else   (((const ::SharedArrayImp<long long>*)o)->size)();
}

static  void operator_11914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->Class)());
  else   (((::SharedArrayImp<long long>*)o)->Class)();
}

static  void method_11917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->Class_Name)());
  else   (((::SharedArrayImp<long long>*)o)->Class_Name)();
}

static  void method_11918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<long long>*)o)->Class_Version)());
  else   (((::SharedArrayImp<long long>*)o)->Class_Version)();
}

static  void method_11919( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<long long>*)o)->Dictionary)();
}

static  void method_11920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long long>*)o)->IsA)());
  else   (((const ::SharedArrayImp<long long>*)o)->IsA)();
}

static  void method_11921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11923( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<long long>*)o)->DeclFileName)();
}

static  void method_11925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<long long>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<long long>*)o)->ImplFileLine)();
}

static  void method_11926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long long>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<long long>*)o)->ImplFileName)();
}

static  void method_11927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<long long>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<long long>*)o)->DeclFileLine)();
}

static void method_newdel_1946( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x72( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<long long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<long long int> -------------------------------
void __SharedArrayImp_longslong__db_datamem(Reflex::Class*);
void __SharedArrayImp_longslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_longslong__datamem_bld(&__SharedArrayImp_longslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_longslong__funcmem_bld(&__SharedArrayImp_longslong__db_funcmem);
void __SharedArrayImp_longslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<long long>"), typeid(::SharedArrayImp<long long>), sizeof(::SharedArrayImp<long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<long long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31023, type_31024), Reflex::Literal("operator="), operator_11904, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11905, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11906, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31024), Reflex::Literal("SharedArrayImp"), constructor_11907, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11909, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1946, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x72, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_longslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_longslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<long long int> -------------------
void __SharedArrayImp_longslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_longslong_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3097, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_longslong_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<long long int> -------------------
void __SharedArrayImp_longslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31025, type_4128), Reflex::Literal("Clone"), method_11908, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31025), Reflex::Literal("acquire"), method_11911, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11912, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18361, type_211), Reflex::Literal("operator[]"), operator_11914, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18359, type_211), Reflex::Literal("operator[]"), operator_11915, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11916, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11917, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11918, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11919, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11920, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11921, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11922, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11923, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11924, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11925, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11926, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11927, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<long int> -------------------------------
static  void operator_11931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<long>*)o)->operator=)(*(const ::SharedArrayImp<long>*)arg[0]);
  else   (((::SharedArrayImp<long>*)o)->operator=)(*(const ::SharedArrayImp<long>*)arg[0]);
}

static void constructor_11932( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long>();
  else ::new(mem) ::SharedArrayImp<long>();
}

static void constructor_11933( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<long>(*(unsigned int*)arg[0]);
}

static void constructor_11934( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<long>(*(const ::SharedArrayImp<long>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<long>(*(const ::SharedArrayImp<long>*)arg[0]);
}

static  void method_11935( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long>*)o)->Clone)());
    else     (((const ::SharedArrayImp<long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11936(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<long>*)o)->::SharedArrayImp<long>::~SharedArrayImp)();
}
static  void method_11937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<long>*)o)->refCount)());
  else   (((const ::SharedArrayImp<long>*)o)->refCount)();
}

static  void method_11938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->acquire)());
  else   (((::SharedArrayImp<long>*)o)->acquire)();
}

static  void method_11939( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<long>*)o)->release)();
}

static  void method_11940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<long>*)o)->size)());
  else   (((const ::SharedArrayImp<long>*)o)->size)();
}

static  void operator_11941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<long>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->Class)());
  else   (((::SharedArrayImp<long>*)o)->Class)();
}

static  void method_11944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->Class_Name)());
  else   (((::SharedArrayImp<long>*)o)->Class_Name)();
}

static  void method_11945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<long>*)o)->Class_Version)());
  else   (((::SharedArrayImp<long>*)o)->Class_Version)();
}

static  void method_11946( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<long>*)o)->Dictionary)();
}

static  void method_11947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<long>*)o)->IsA)());
  else   (((const ::SharedArrayImp<long>*)o)->IsA)();
}

static  void method_11948( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11949( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11950( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<long>*)o)->DeclFileName)();
}

static  void method_11952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<long>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<long>*)o)->ImplFileLine)();
}

static  void method_11953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<long>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<long>*)o)->ImplFileName)();
}

static  void method_11954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<long>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<long>*)o)->DeclFileLine)();
}

static void method_newdel_1947( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x74( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<long int> -------------------------------
void __SharedArrayImp_long__db_datamem(Reflex::Class*);
void __SharedArrayImp_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_long__datamem_bld(&__SharedArrayImp_long__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_long__funcmem_bld(&__SharedArrayImp_long__db_funcmem);
void __SharedArrayImp_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<long>"), typeid(::SharedArrayImp<long>), sizeof(::SharedArrayImp<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31026, type_31027), Reflex::Literal("operator="), operator_11931, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11932, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11933, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31027), Reflex::Literal("SharedArrayImp"), constructor_11934, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11936, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1947, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x74, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_long__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_long__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<long int> -------------------
void __SharedArrayImp_long__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_long_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3098, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_long_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<long int> -------------------
void __SharedArrayImp_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31028, type_4128), Reflex::Literal("Clone"), method_11935, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31028), Reflex::Literal("acquire"), method_11938, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11939, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18426, type_211), Reflex::Literal("operator[]"), operator_11941, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18424, type_211), Reflex::Literal("operator[]"), operator_11942, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11943, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11944, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11945, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11946, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11947, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11948, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11949, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11950, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11951, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11952, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11953, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11954, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<int> -------------------------------
static  void operator_11958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<int>*)o)->operator=)(*(const ::SharedArrayImp<int>*)arg[0]);
  else   (((::SharedArrayImp<int>*)o)->operator=)(*(const ::SharedArrayImp<int>*)arg[0]);
}

static void constructor_11959( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<int>();
  else ::new(mem) ::SharedArrayImp<int>();
}

static void constructor_11960( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<int>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<int>(*(unsigned int*)arg[0]);
}

static void constructor_11961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<int>(*(const ::SharedArrayImp<int>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<int>(*(const ::SharedArrayImp<int>*)arg[0]);
}

static  void method_11962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<int>*)o)->Clone)());
    else     (((const ::SharedArrayImp<int>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<int>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<int>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11963(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<int>*)o)->::SharedArrayImp<int>::~SharedArrayImp)();
}
static  void method_11964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<int>*)o)->refCount)());
  else   (((const ::SharedArrayImp<int>*)o)->refCount)();
}

static  void method_11965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->acquire)());
  else   (((::SharedArrayImp<int>*)o)->acquire)();
}

static  void method_11966( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<int>*)o)->release)();
}

static  void method_11967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<int>*)o)->size)());
  else   (((const ::SharedArrayImp<int>*)o)->size)();
}

static  void operator_11968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<int>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<int>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->Class)());
  else   (((::SharedArrayImp<int>*)o)->Class)();
}

static  void method_11971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->Class_Name)());
  else   (((::SharedArrayImp<int>*)o)->Class_Name)();
}

static  void method_11972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<int>*)o)->Class_Version)());
  else   (((::SharedArrayImp<int>*)o)->Class_Version)();
}

static  void method_11973( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<int>*)o)->Dictionary)();
}

static  void method_11974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<int>*)o)->IsA)());
  else   (((const ::SharedArrayImp<int>*)o)->IsA)();
}

static  void method_11975( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<int>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_11976( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<int>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_11977( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<int>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_11978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<int>*)o)->DeclFileName)();
}

static  void method_11979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<int>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<int>*)o)->ImplFileLine)();
}

static  void method_11980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<int>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<int>*)o)->ImplFileName)();
}

static  void method_11981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<int>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<int>*)o)->DeclFileLine)();
}

static void method_newdel_1948( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x76( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<int>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<int> -------------------------------
void __SharedArrayImp_int__db_datamem(Reflex::Class*);
void __SharedArrayImp_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_int__datamem_bld(&__SharedArrayImp_int__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_int__funcmem_bld(&__SharedArrayImp_int__db_funcmem);
void __SharedArrayImp_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<int>"), typeid(::SharedArrayImp<int>), sizeof(::SharedArrayImp<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<int>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31029, type_31030), Reflex::Literal("operator="), operator_11958, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11959, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11960, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31030), Reflex::Literal("SharedArrayImp"), constructor_11961, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11963, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1948, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x76, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_int__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<int> -------------------
void __SharedArrayImp_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_int_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3099, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_int_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<int> -------------------
void __SharedArrayImp_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31031, type_4128), Reflex::Literal("Clone"), method_11962, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31031), Reflex::Literal("acquire"), method_11965, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11966, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18491, type_211), Reflex::Literal("operator[]"), operator_11968, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18489, type_211), Reflex::Literal("operator[]"), operator_11969, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11970, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11971, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11972, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_11973, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_11974, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_11975, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_11976, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_11977, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_11978, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_11979, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_11980, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_11981, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<short int> -------------------------------
static  void operator_11985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<short>*)o)->operator=)(*(const ::SharedArrayImp<short>*)arg[0]);
  else   (((::SharedArrayImp<short>*)o)->operator=)(*(const ::SharedArrayImp<short>*)arg[0]);
}

static void constructor_11986( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<short>();
  else ::new(mem) ::SharedArrayImp<short>();
}

static void constructor_11987( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<short>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<short>(*(unsigned int*)arg[0]);
}

static void constructor_11988( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<short>(*(const ::SharedArrayImp<short>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<short>(*(const ::SharedArrayImp<short>*)arg[0]);
}

static  void method_11989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<short>*)o)->Clone)());
    else     (((const ::SharedArrayImp<short>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<short>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<short>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_11990(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<short>*)o)->::SharedArrayImp<short>::~SharedArrayImp)();
}
static  void method_11991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<short>*)o)->refCount)());
  else   (((const ::SharedArrayImp<short>*)o)->refCount)();
}

static  void method_11992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->acquire)());
  else   (((::SharedArrayImp<short>*)o)->acquire)();
}

static  void method_11993( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<short>*)o)->release)();
}

static  void method_11994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<short>*)o)->size)());
  else   (((const ::SharedArrayImp<short>*)o)->size)();
}

static  void operator_11995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<short>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_11996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<short>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_11997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->Class)());
  else   (((::SharedArrayImp<short>*)o)->Class)();
}

static  void method_11998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->Class_Name)());
  else   (((::SharedArrayImp<short>*)o)->Class_Name)();
}

static  void method_11999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<short>*)o)->Class_Version)());
  else   (((::SharedArrayImp<short>*)o)->Class_Version)();
}

static  void method_12000( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<short>*)o)->Dictionary)();
}

static  void method_12001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<short>*)o)->IsA)());
  else   (((const ::SharedArrayImp<short>*)o)->IsA)();
}

static  void method_12002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<short>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_12003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<short>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_12004( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<short>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_12005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<short>*)o)->DeclFileName)();
}

static  void method_12006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<short>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<short>*)o)->ImplFileLine)();
}

static  void method_12007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<short>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<short>*)o)->ImplFileName)();
}

static  void method_12008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<short>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<short>*)o)->DeclFileLine)();
}

static void method_newdel_1949( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x78( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<short>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<short int> -------------------------------
void __SharedArrayImp_short__db_datamem(Reflex::Class*);
void __SharedArrayImp_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_short__datamem_bld(&__SharedArrayImp_short__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_short__funcmem_bld(&__SharedArrayImp_short__db_funcmem);
void __SharedArrayImp_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<short>"), typeid(::SharedArrayImp<short>), sizeof(::SharedArrayImp<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<short>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31032, type_31033), Reflex::Literal("operator="), operator_11985, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_11986, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_11987, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31033), Reflex::Literal("SharedArrayImp"), constructor_11988, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_11990, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1949, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x78, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_short__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_short__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<short int> -------------------
void __SharedArrayImp_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_short_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3100, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_short_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<short int> -------------------
void __SharedArrayImp_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31034, type_4128), Reflex::Literal("Clone"), method_11989, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_11991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31034), Reflex::Literal("acquire"), method_11992, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_11993, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_11994, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18556, type_211), Reflex::Literal("operator[]"), operator_11995, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18554, type_211), Reflex::Literal("operator[]"), operator_11996, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_11997, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_11998, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_11999, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_12000, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_12001, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_12002, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_12003, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_12004, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_12005, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_12006, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_12007, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_12008, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArrayImp<char> -------------------------------
static  void operator_12012( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<char>*)o)->operator=)(*(const ::SharedArrayImp<char>*)arg[0]);
  else   (((::SharedArrayImp<char>*)o)->operator=)(*(const ::SharedArrayImp<char>*)arg[0]);
}

static void constructor_12013( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<char>();
  else ::new(mem) ::SharedArrayImp<char>();
}

static void constructor_12014( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<char>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArrayImp<char>(*(unsigned int*)arg[0]);
}

static void constructor_12015( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArrayImp<char>(*(const ::SharedArrayImp<char>*)arg[0]);
  else ::new(mem) ::SharedArrayImp<char>(*(const ::SharedArrayImp<char>*)arg[0]);
}

static  void method_12016( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<char>*)o)->Clone)());
    else     (((const ::SharedArrayImp<char>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<char>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArrayImp<char>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_12017(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArrayImp<char>*)o)->::SharedArrayImp<char>::~SharedArrayImp)();
}
static  void method_12018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<char>*)o)->refCount)());
  else   (((const ::SharedArrayImp<char>*)o)->refCount)();
}

static  void method_12019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->acquire)());
  else   (((::SharedArrayImp<char>*)o)->acquire)();
}

static  void method_12020( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<char>*)o)->release)();
}

static  void method_12021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArrayImp<char>*)o)->size)());
  else   (((const ::SharedArrayImp<char>*)o)->size)();
}

static  void operator_12022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::SharedArrayImp<char>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((const ::SharedArrayImp<char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_12023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArrayImp<char>*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::SharedArrayImp<char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_12024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->Class)());
  else   (((::SharedArrayImp<char>*)o)->Class)();
}

static  void method_12025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->Class_Name)());
  else   (((::SharedArrayImp<char>*)o)->Class_Name)();
}

static  void method_12026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArrayImp<char>*)o)->Class_Version)());
  else   (((::SharedArrayImp<char>*)o)->Class_Version)();
}

static  void method_12027( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArrayImp<char>*)o)->Dictionary)();
}

static  void method_12028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArrayImp<char>*)o)->IsA)());
  else   (((const ::SharedArrayImp<char>*)o)->IsA)();
}

static  void method_12029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<char>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_12030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<char>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_12031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArrayImp<char>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_12032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->DeclFileName)());
  else   (((::SharedArrayImp<char>*)o)->DeclFileName)();
}

static  void method_12033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<char>*)o)->ImplFileLine)());
  else   (((::SharedArrayImp<char>*)o)->ImplFileLine)();
}

static  void method_12034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArrayImp<char>*)o)->ImplFileName)());
  else   (((::SharedArrayImp<char>*)o)->ImplFileName)();
}

static  void method_12035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArrayImp<char>*)o)->DeclFileLine)());
  else   (((::SharedArrayImp<char>*)o)->DeclFileLine)();
}

static void method_newdel_1950( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SharedArrayImp<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x80( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArrayImp<char>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArrayImp<char> -------------------------------
void __SharedArrayImp_char__db_datamem(Reflex::Class*);
void __SharedArrayImp_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArrayImp_char__datamem_bld(&__SharedArrayImp_char__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArrayImp_char__funcmem_bld(&__SharedArrayImp_char__db_funcmem);
void __SharedArrayImp_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArrayImp<char>"), typeid(::SharedArrayImp<char>), sizeof(::SharedArrayImp<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArrayImp<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArrayImp<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArrayImp<char>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31035, type_31036), Reflex::Literal("operator="), operator_12012, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SharedArrayImp"), constructor_12013, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArrayImp"), constructor_12014, 0, "size", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31036), Reflex::Literal("SharedArrayImp"), constructor_12015, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArrayImp"), destructor_12017, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1950, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x80, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArrayImp_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArrayImp_char__funcmem_bld);
}

//------Delayed data member builder for class SharedArrayImp<char> -------------------
void __SharedArrayImp_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_211, Reflex::Literal("refcount"), OffsetOf(__shadow__::__SharedArrayImp_char_, refcount), ::Reflex::PRIVATE)
  .AddDataMember(type_3101, Reflex::Literal("arr"), OffsetOf(__shadow__::__SharedArrayImp_char_, arr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArrayImp<char> -------------------
void __SharedArrayImp_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31037, type_4128), Reflex::Literal("Clone"), method_12016, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("refCount"), method_12018, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31037), Reflex::Literal("acquire"), method_12019, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("release"), method_12020, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_12021, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18620, type_211), Reflex::Literal("operator[]"), operator_12022, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618, type_211), Reflex::Literal("operator[]"), operator_12023, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_12024, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_12025, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_12026, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_12027, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_12028, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_12029, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_12030, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_12031, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_12032, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_12033, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_12034, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_12035, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Dilution -------------------------------
static  void operator_12871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Dilution*)o)->operator=)(*(const ::Dilution*)arg[0]);
  else   (((::Dilution*)o)->operator=)(*(const ::Dilution*)arg[0]);
}

static void constructor_12872( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Dilution();
  else ::new(mem) ::Dilution();
}

static void constructor_12873( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Dilution((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2]);
  else ::new(mem) ::Dilution((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2]);
}

static void constructor_12874( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::Dilution(*(const ::Dilution*)arg[0]);
  else ::new(mem) ::Dilution(*(const ::Dilution*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::Dilution(*(const ::Dilution*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::Dilution(*(const ::Dilution*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_12875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Dilution*)o)->clone)((const char*)arg[0]));
  else   (((const ::Dilution*)o)->clone)((const char*)arg[0]);
}

static void destructor_12876(void*, void * o, const std::vector<void*>&, void *) {
(((::Dilution*)o)->::Dilution::~Dilution)();
}
static  void method_12878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Dilution*)o)->Class)());
  else   (((::Dilution*)o)->Class)();
}

static  void method_12879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Dilution*)o)->Class_Name)());
  else   (((::Dilution*)o)->Class_Name)();
}

static  void method_12880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::Dilution*)o)->Class_Version)());
  else   (((::Dilution*)o)->Class_Version)();
}

static  void method_12881( void*, void* o, const std::vector<void*>&, void*)
{
  (((::Dilution*)o)->Dictionary)();
}

static  void method_12882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::Dilution*)o)->IsA)());
  else   (((const ::Dilution*)o)->IsA)();
}

static  void method_12883( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Dilution*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_12884( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Dilution*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_12885( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::Dilution*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_12886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Dilution*)o)->DeclFileName)());
  else   (((::Dilution*)o)->DeclFileName)();
}

static  void method_12887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Dilution*)o)->ImplFileLine)());
  else   (((::Dilution*)o)->ImplFileLine)();
}

static  void method_12888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::Dilution*)o)->ImplFileName)());
  else   (((::Dilution*)o)->ImplFileName)();
}

static  void method_12889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::Dilution*)o)->DeclFileLine)());
  else   (((::Dilution*)o)->DeclFileLine)();
}

static void method_newdel_2072( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Dilution >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Dilution >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Dilution >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Dilution >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Dilution >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x82( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::Dilution,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::Dilution,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::Dilution,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::Dilution,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::Dilution,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Dilution -------------------------------
void __Dilution_db_datamem(Reflex::Class*);
void __Dilution_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Dilution_datamem_bld(&__Dilution_db_datamem);
Reflex::GenreflexMemberBuilder __Dilution_funcmem_bld(&__Dilution_db_funcmem);
void __Dilution_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Dilution"), typeid(::Dilution), sizeof(::Dilution), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::Dilution::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::Dilution, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31138, type_31139), Reflex::Literal("operator="), operator_12871, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Dilution"), constructor_12872, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660), Reflex::Literal("Dilution"), constructor_12873, 0, "name;title;_omega", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31139, type_4128), Reflex::Literal("Dilution"), constructor_12874, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Dilution"), destructor_12876, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2072, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x82, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Dilution_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__Dilution_funcmem_bld);
}

//------Delayed data member builder for class Dilution -------------------
void __Dilution_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("omega"), OffsetOf(__shadow__::__Dilution, omega), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Dilution -------------------
void __Dilution_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_12875, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_12878, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_12879, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_12880, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_12881, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_12882, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_12883, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_12884, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_12885, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_12886, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_12887, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_12888, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_12889, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class FitMeTool -------------------------------
static  void operator_12904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::FitMeTool*)o)->operator=)(*(const ::FitMeTool*)arg[0]);
  else   (((::FitMeTool*)o)->operator=)(*(const ::FitMeTool*)arg[0]);
}

static void constructor_12905( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool(*(const ::FitMeTool*)arg[0]);
  else ::new(mem) ::FitMeTool(*(const ::FitMeTool*)arg[0]);
}

static void constructor_12906( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool();
  else ::new(mem) ::FitMeTool();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool(*(bool*)arg[0]);
  else ::new(mem) ::FitMeTool(*(bool*)arg[0]);
  }
}

static void constructor_12907( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool(*(int*)arg[0]);
  else ::new(mem) ::FitMeTool(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool(*(int*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::FitMeTool(*(int*)arg[0],
      *(bool*)arg[1]);
  }
}

static void destructor_12908(void*, void * o, const std::vector<void*>&, void *) {
(((::FitMeTool*)o)->::FitMeTool::~FitMeTool)();
}
static  void method_12909( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->generate)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0],
      *(const ::RooCmdArg*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::FitMeTool*)o)->generate)(*(long*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4]);
  }
}

static  void method_12910( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->fit)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4],
      *(const ::RooCmdArg*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4],
      *(const ::RooCmdArg*)arg[5],
      *(const ::RooCmdArg*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    (((::FitMeTool*)o)->fit)(*(bool*)arg[0],
      *(const ::RooCmdArg*)arg[1],
      *(const ::RooCmdArg*)arg[2],
      *(const ::RooCmdArg*)arg[3],
      *(const ::RooCmdArg*)arg[4],
      *(const ::RooCmdArg*)arg[5],
      *(const ::RooCmdArg*)arg[6],
      *(const ::RooCmdArg*)arg[7]);
  }
}

static  void method_12911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->getFitResult)());
  else   (((::FitMeTool*)o)->getFitResult)();
}

static  void method_12912( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->setSeed)(*(int*)arg[0]);
}

static  void method_12913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FitMeTool*)o)->getSeed)());
  else   (((::FitMeTool*)o)->getSeed)();
}

static  void method_12914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->setDebug)(*(bool*)arg[0]);
}

static  void method_12915( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setObservables)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setObservables)((::RooArgSet*)arg[0]);
  }
}

static  void method_12916( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setConditionalObservables)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setConditionalObservables)((::RooArgSet*)arg[0]);
  }
}

static  void method_12917( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setExternalConstraints)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setExternalConstraints)((::RooArgSet*)arg[0]);
  }
}

static  void method_12918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FitMeTool*)o)->getObservables)());
  else   (((const ::FitMeTool*)o)->getObservables)();
}

static  void method_12919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FitMeTool*)o)->getConditionalObservables)());
  else   (((const ::FitMeTool*)o)->getConditionalObservables)();
}

static  void method_12920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FitMeTool*)o)->getExternalConstraints)());
  else   (((const ::FitMeTool*)o)->getExternalConstraints)();
}

static  void method_12921( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setModelPDFandData)((::RooWorkspace*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setModelPDFandData)((::RooWorkspace*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setModelPDFandData)((::RooWorkspace*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_12922( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setModelPDF)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setModelPDF)((::RooAbsPdf*)arg[0]);
  }
}

static  void method_12923( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setModelPDF)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setModelPDF)((const char*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setModelPDF)((const char*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_12924( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setModelPDF)((::RooWorkspace*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setModelPDF)((::RooWorkspace*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_12925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->getModelPDF)());
  else   (((::FitMeTool*)o)->getModelPDF)();
}

static  void method_12926( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->setData)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->setData)((::RooAbsData*)arg[0]);
  }
}

static  void method_12927( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setData)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setData)((const char*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setData)((const char*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
}

static  void method_12928( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::FitMeTool*)o)->setData)((::RooWorkspace*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::FitMeTool*)o)->setData)((::RooWorkspace*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_12929( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::FitMeTool*)o)->setDataSet)((const char*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setDataSet)((const char*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::FitMeTool*)o)->setDataSet)((const char*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2],
      (const char*)arg[3]);
  }
}

static  void method_12930( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::FitMeTool*)o)->setDataSet)(*(::std::vector<std::basic_string<char> >*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::FitMeTool*)o)->setDataSet)(*(::std::vector<std::basic_string<char> >*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    (((::FitMeTool*)o)->setDataSet)(*(::std::vector<std::basic_string<char> >*)arg[0],
      (const char*)arg[1],
      (const char*)arg[2],
      (const char*)arg[3]);
  }
}

static  void method_12931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->getData)());
  else   (((::FitMeTool*)o)->getData)();
}

static  void method_12932( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->saveModelPDF)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->saveModelPDF)((const char*)arg[0]);
  }
}

static  void method_12933( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->saveData)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->saveData)((const char*)arg[0]);
  }
}

static  void method_12934( void*, void* o, const std::vector<void*>&, void*)
{
  (((::FitMeTool*)o)->printModelStructure)();
}

static  void method_12935( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::FitMeTool*)o)->produceGraphicalModelStructure)();
  }
  else if ( arg.size() == 1 ) { 
    (((::FitMeTool*)o)->produceGraphicalModelStructure)((const char*)arg[0]);
  }
}

static  void method_12936( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::FitMeTool*)o)->printYieldsInRange)((const char*)arg[0],
      (const char*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::FitMeTool*)o)->printYieldsInRange)((const char*)arg[0],
      (const char*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4]);
  }
}

static  void method_12937( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    (((::FitMeTool*)o)->printYieldInRange)((const char*)arg[0],
      (const char*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    (((::FitMeTool*)o)->printYieldInRange)((const char*)arg[0],
      (const char*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4]);
  }
}

static  void method_12938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->blindValue)(*(::RooRealVar*)arg[0],
      *(::RooCategory*)arg[1]));
    else     (((::FitMeTool*)o)->blindValue)(*(::RooRealVar*)arg[0],
      *(::RooCategory*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->blindValue)(*(::RooRealVar*)arg[0],
      *(::RooCategory*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((::FitMeTool*)o)->blindValue)(*(::RooRealVar*)arg[0],
      *(::RooCategory*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_12939( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->savesWeights)((const char*)arg[0],
    (::RooDataSet*)arg[1],
    *(::TString*)arg[2]);
}

static  void method_12946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->Class)());
  else   (((::FitMeTool*)o)->Class)();
}

static  void method_12947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->Class_Name)());
  else   (((::FitMeTool*)o)->Class_Name)();
}

static  void method_12948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::FitMeTool*)o)->Class_Version)());
  else   (((::FitMeTool*)o)->Class_Version)();
}

static  void method_12949( void*, void* o, const std::vector<void*>&, void*)
{
  (((::FitMeTool*)o)->Dictionary)();
}

static  void method_12950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::FitMeTool*)o)->IsA)());
  else   (((const ::FitMeTool*)o)->IsA)();
}

static  void method_12951( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_12952( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_12953( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::FitMeTool*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_12954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->DeclFileName)());
  else   (((::FitMeTool*)o)->DeclFileName)();
}

static  void method_12955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FitMeTool*)o)->ImplFileLine)());
  else   (((::FitMeTool*)o)->ImplFileLine)();
}

static  void method_12956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::FitMeTool*)o)->ImplFileName)());
  else   (((::FitMeTool*)o)->ImplFileName)();
}

static  void method_12957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::FitMeTool*)o)->DeclFileLine)());
  else   (((::FitMeTool*)o)->DeclFileLine)();
}

static void constructor_x83( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::FitMeTool();
  else ::new(mem) ::FitMeTool();
}

static void method_newdel_2078( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::FitMeTool >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::FitMeTool >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::FitMeTool >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::FitMeTool >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::FitMeTool >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class FitMeTool -------------------------------
void __FitMeTool_db_datamem(Reflex::Class*);
void __FitMeTool_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __FitMeTool_datamem_bld(&__FitMeTool_db_datamem);
Reflex::GenreflexMemberBuilder __FitMeTool_funcmem_bld(&__FitMeTool_db_funcmem);
void __FitMeTool_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("FitMeTool"), typeid(::FitMeTool), sizeof(::FitMeTool), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::FitMeTool::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 0)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31140, type_31141), Reflex::Literal("operator="), operator_12904, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31141), Reflex::Literal("FitMeTool"), constructor_12905, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_667), Reflex::Literal("FitMeTool"), constructor_12906, 0, "debug=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_141, type_667), Reflex::Literal("FitMeTool"), constructor_12907, 0, "toyNumber;debug=false", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~FitMeTool"), destructor_12908, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("FitMeTool"), constructor_x83, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2078, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__FitMeTool_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__FitMeTool_funcmem_bld);
}

//------Delayed data member builder for class FitMeTool -------------------
void __FitMeTool_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2835, Reflex::Literal("m_observables"), OffsetOf(__shadow__::__FitMeTool, m_observables), ::Reflex::PROTECTED)
  .AddDataMember(type_2835, Reflex::Literal("m_conditionalObservables"), OffsetOf(__shadow__::__FitMeTool, m_conditionalObservables), ::Reflex::PROTECTED)
  .AddDataMember(type_2835, Reflex::Literal("m_externalConstraints"), OffsetOf(__shadow__::__FitMeTool, m_externalConstraints), ::Reflex::PROTECTED)
  .AddDataMember(type_667, Reflex::Literal("m_config_debug"), OffsetOf(__shadow__::__FitMeTool, m_config_debug), ::Reflex::PROTECTED)
  .AddDataMember(type_141, Reflex::Literal("m_config_toyNumber"), OffsetOf(__shadow__::__FitMeTool, m_config_toyNumber), ::Reflex::PROTECTED)
  .AddDataMember(type_141, Reflex::Literal("m_config_seed"), OffsetOf(__shadow__::__FitMeTool, m_config_seed), ::Reflex::PROTECTED)
  .AddDataMember(type_667, Reflex::Literal("m_config_seedSet"), OffsetOf(__shadow__::__FitMeTool, m_config_seedSet), ::Reflex::PROTECTED)
  .AddDataMember(type_667, Reflex::Literal("m_config_saveFitResult2File"), OffsetOf(__shadow__::__FitMeTool, m_config_saveFitResult2File), ::Reflex::PROTECTED)
  .AddDataMember(type_27917, Reflex::Literal("m_modelPDF"), OffsetOf(__shadow__::__FitMeTool, m_modelPDF), ::Reflex::PROTECTED)
  .AddDataMember(type_22352, Reflex::Literal("m_data"), OffsetOf(__shadow__::__FitMeTool, m_data), ::Reflex::PROTECTED)
  .AddDataMember(type_18675, Reflex::Literal("m_fitResult"), OffsetOf(__shadow__::__FitMeTool, m_fitResult), ::Reflex::PROTECTED)
  .AddDataMember(type_28187, Reflex::Literal("m_outputFile"), OffsetOf(__shadow__::__FitMeTool, m_outputFile), ::Reflex::PROTECTED)
  .AddDataMember(type_27699, Reflex::Literal("m_workSpace"), OffsetOf(__shadow__::__FitMeTool, m_workSpace), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class FitMeTool -------------------
void __FitMeTool_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_194, type_27721, type_27721, type_27721, type_27721), Reflex::Literal("generate"), method_12909, 0, "nevents=0;arg1=RooCmdArg::none();arg2=RooCmdArg::none();arg3=RooCmdArg::none();arg4=RooCmdArg::none()", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_667, type_27721, type_27721, type_27721, type_27721, type_27721, type_27721, type_27721), Reflex::Literal("fit"), method_12910, 0, "save2file=true;arg1=RooCmdArg::none();arg2=RooCmdArg::none();arg3=RooCmdArg::none();arg4=RooCmdArg::none();arg5=RooCmdArg::none();arg6=RooCmdArg::none();arg7=RooCmdArg::none()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18675), Reflex::Literal("getFitResult"), method_12911, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_141), Reflex::Literal("setSeed"), method_12912, 0, "seed", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("getSeed"), method_12913, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_667), Reflex::Literal("setDebug"), method_12914, 0, "yesNo", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_2835), Reflex::Literal("setObservables"), method_12915, 0, "observables=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_2835), Reflex::Literal("setConditionalObservables"), method_12916, 0, "condObs=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_2835), Reflex::Literal("setExternalConstraints"), method_12917, 0, "extConstraints=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27675), Reflex::Literal("getObservables"), method_12918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27675), Reflex::Literal("getConditionalObservables"), method_12919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27675), Reflex::Literal("getExternalConstraints"), method_12920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27699, type_4128, type_4128), Reflex::Literal("setModelPDFandData"), method_12921, 0, "ws;modelName=\"UNSPECIFIED\";dataName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27917), Reflex::Literal("setModelPDF"), method_12922, 0, "modelPDF=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4128, type_4128, type_4128), Reflex::Literal("setModelPDF"), method_12923, 0, "fileName;wsName=\"UNSPECIFIED\";modelName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27699, type_4128), Reflex::Literal("setModelPDF"), method_12924, 0, "ws;modelName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27917), Reflex::Literal("getModelPDF"), method_12925, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_22352), Reflex::Literal("setData"), method_12926, 0, "data=0l", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4128, type_4128, type_4128), Reflex::Literal("setData"), method_12927, 0, "fileName;wsName=\"UNSPECIFIED\";dataName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27699, type_4128), Reflex::Literal("setData"), method_12928, 0, "ws;dataName=\"UNSPECIFIED\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4128, type_4128, type_4128, type_4128), Reflex::Literal("setDataSet"), method_12929, 0, "fileName;treeName;subDir=0l;cuts=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3106, type_4128, type_4128, type_4128), Reflex::Literal("setDataSet"), method_12930, 0, "filesList;treeName;subDir=0l;cuts=\"\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22352), Reflex::Literal("getData"), method_12931, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4128), Reflex::Literal("saveModelPDF"), method_12932, 0, "workspaceFileName=\"FitMeTool\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4128), Reflex::Literal("saveData"), method_12933, 0, "workspaceFileName=\"FitMeTool\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("printModelStructure"), method_12934, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4128), Reflex::Literal("produceGraphicalModelStructure"), method_12935, 0, "fileName=\"model.gif\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4128, type_4128, type_694, type_694, type_4128), Reflex::Literal("printYieldsInRange"), method_12936, 0, "wildcard;observableName;low;high;rangeName=\"SignalRegion\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4128, type_4128, type_694, type_694, type_4128), Reflex::Literal("printYieldInRange"), method_12937, 0, "yieldVarName;observableName;low;high;rangeName=\"SignalRegion\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31142, type_27670, type_28605, type_3157c), Reflex::Literal("blindValue"), method_12938, 0, "varToBeBlinded;category;prefix=\"blinded\"", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_4128, type_27919, type_6056), Reflex::Literal("savesWeights"), method_12939, 0, "observableName;data;mode", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_12946, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_12947, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_12948, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_12949, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_12950, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_12951, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_12952, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_12953, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_12954, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_12955, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_12956, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_12957, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooCubicSplineFun -------------------------------
static  void operator_13064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineFun*)o)->operator=)(*(const ::RooCubicSplineFun*)arg[0]);
  else   (((::RooCubicSplineFun*)o)->operator=)(*(const ::RooCubicSplineFun*)arg[0]);
}

static void constructor_13065( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun();
  else ::new(mem) ::RooCubicSplineFun();
}

static void constructor_13066( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5],
      *(double*)arg[6]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5],
      *(double*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5],
      *(double*)arg[6],
      *(bool*)arg[7]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::std::vector<double>*)arg[4],
      *(const ::std::vector<double>*)arg[5],
      *(double*)arg[6],
      *(bool*)arg[7]);
  }
}

static void constructor_13067( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraph*)arg[3]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraph*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraph*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraph*)arg[3],
      *(bool*)arg[4]);
  }
}

static void constructor_13068( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  }
}

static void constructor_13069( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3],
      *(double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TGraphErrors*)arg[3],
      *(double*)arg[4],
      *(bool*)arg[5]);
  }
}

static void constructor_13070( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
}

static void constructor_13071( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooCubicSplineFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      *(const ::std::vector<double>*)arg[3],
      *(const ::RooArgList*)arg[4]);
}

static void destructor_13072(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineFun*)o)->::RooCubicSplineFun::~RooCubicSplineFun)();
}
static void constructor_13073( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun(*(const ::RooCubicSplineFun*)arg[0]);
  else ::new(mem) ::RooCubicSplineFun(*(const ::RooCubicSplineFun*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineFun(*(const ::RooCubicSplineFun*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooCubicSplineFun(*(const ::RooCubicSplineFun*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_13074( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCubicSplineFun*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooCubicSplineFun*)o)->clone)((const char*)arg[0]);
}

static  void method_13075( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooCubicSplineFun*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::RooCubicSplineFun*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_13076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooCubicSplineFun*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::RooCubicSplineFun*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_13077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooCubicSplineFun*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooCubicSplineFun*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_13078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooCubicSplineFun*)o)->maxVal)(*(::Int_t*)arg[0]));
  else   (((const ::RooCubicSplineFun*)o)->maxVal)(*(::Int_t*)arg[0]);
}

static  void method_13079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::complex<double>)((((const ::RooCubicSplineFun*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]));
  else   (((const ::RooCubicSplineFun*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]);
}

static  void method_13080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::RooCubicSplineFun*)o)->knotSize)());
  else   (((const ::RooCubicSplineFun*)o)->knotSize)();
}

static  void method_13081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineFun*)o)->u)(*(int*)arg[0]));
  else   (((const ::RooCubicSplineFun*)o)->u)(*(int*)arg[0]);
}

static  void method_13082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooCubicSplineFun*)o)->knots)();
  else   (((const ::RooCubicSplineFun*)o)->knots)();
}

static  void method_13083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooCubicSplineFun*)o)->coefficients)();
  else   (((const ::RooCubicSplineFun*)o)->coefficients)();
}

static  void method_13087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineFun*)o)->Class)());
  else   (((::RooCubicSplineFun*)o)->Class)();
}

static  void method_13088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineFun*)o)->Class_Name)());
  else   (((::RooCubicSplineFun*)o)->Class_Name)();
}

static  void method_13089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooCubicSplineFun*)o)->Class_Version)());
  else   (((::RooCubicSplineFun*)o)->Class_Version)();
}

static  void method_13090( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooCubicSplineFun*)o)->Dictionary)();
}

static  void method_13091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCubicSplineFun*)o)->IsA)());
  else   (((const ::RooCubicSplineFun*)o)->IsA)();
}

static  void method_13092( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineFun*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineFun*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13094( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCubicSplineFun*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineFun*)o)->DeclFileName)());
  else   (((::RooCubicSplineFun*)o)->DeclFileName)();
}

static  void method_13096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCubicSplineFun*)o)->ImplFileLine)());
  else   (((::RooCubicSplineFun*)o)->ImplFileLine)();
}

static  void method_13097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCubicSplineFun*)o)->ImplFileName)());
  else   (((::RooCubicSplineFun*)o)->ImplFileName)();
}

static  void method_13098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCubicSplineFun*)o)->DeclFileLine)());
  else   (((::RooCubicSplineFun*)o)->DeclFileLine)();
}

static void method_newdel_2117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooCubicSplineFun >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x86( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGaussModelEfficiency")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::RooAbsGaussModelEfficiency >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooCubicSplineFun,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooCubicSplineFun -------------------------------
void __RooCubicSplineFun_db_datamem(Reflex::Class*);
void __RooCubicSplineFun_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineFun_datamem_bld(&__RooCubicSplineFun_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineFun_funcmem_bld(&__RooCubicSplineFun_db_funcmem);
void __RooCubicSplineFun_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineFun"), typeid(::RooCubicSplineFun), sizeof(::RooCubicSplineFun), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooCubicSplineFun::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1672, ::Reflex::BaseOffset< ::RooCubicSplineFun, ::RooAbsGaussModelEfficiency >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31153, type_31154), Reflex::Literal("operator="), operator_13064, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooCubicSplineFun"), constructor_13065, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_18881, type_18881, type_18881, type_694, type_667), Reflex::Literal("RooCubicSplineFun"), constructor_13066, 0, "name;title;x;knots;values;errors=std::vector<double, std::allocator<double> >();smooth=0;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_30976, type_667), Reflex::Literal("RooCubicSplineFun"), constructor_13067, 0, "name;title;x;graph;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_28133, type_694, type_667), Reflex::Literal("RooCubicSplineFun"), constructor_13068, 0, "name;title;x;hist;smooth=0;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_31155, type_694, type_667), Reflex::Literal("RooCubicSplineFun"), constructor_13069, 0, "name;title;x;graph;smooth=0;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_4128, type_27821), Reflex::Literal("RooCubicSplineFun"), constructor_13070, 0, "name;title;x;knotBinningName;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_18881, type_27821), Reflex::Literal("RooCubicSplineFun"), constructor_13071, 0, "name;title;x;knots;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooCubicSplineFun"), destructor_13072, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31154, type_4128), Reflex::Literal("RooCubicSplineFun"), constructor_13073, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x86, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineFun_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCubicSplineFun_funcmem_bld);
}

//------Delayed data member builder for class RooCubicSplineFun -------------------
void __RooCubicSplineFun_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("_x"), OffsetOf(__shadow__::__RooCubicSplineFun, _x), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("_coefList"), OffsetOf(__shadow__::__RooCubicSplineFun, _coefList), ::Reflex::PRIVATE)
  .AddDataMember(type_855, Reflex::Literal("_aux"), OffsetOf(__shadow__::__RooCubicSplineFun, _aux), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooCubicSplineFun -------------------
void __RooCubicSplineFun_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_13074, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_13075, 0, "allVars;analVars;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_13076, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27673), Reflex::Literal("getMaxVal"), method_13077, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("maxVal"), method_13078, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3635, type_2317, type_2317, type_2317, type_2317, type_22775), Reflex::Literal("productAnalyticalIntegral"), method_13079, 0, "umin;umax;scale;offset;z", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("knotSize"), method_13080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_141), Reflex::Literal("u"), method_13081, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18881), Reflex::Literal("knots"), method_13082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27821), Reflex::Literal("coefficients"), method_13083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13087, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13088, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13089, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13090, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13091, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13092, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13093, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13094, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13095, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13096, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13097, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13098, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class CPObservable -------------------------------
static void constructor_13485( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CPObservable();
  else ::new(mem) ::CPObservable();
}

static void constructor_13486( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CPObservable((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::CPObservable::which*)arg[5]);
  else ::new(mem) ::CPObservable((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::CPObservable::which*)arg[5]);
}

static void constructor_13487( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::CPObservable(*(const ::CPObservable*)arg[0]);
  else ::new(mem) ::CPObservable(*(const ::CPObservable*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::CPObservable(*(const ::CPObservable*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::CPObservable(*(const ::CPObservable*)arg[0],
      (const char*)arg[1]);
  }
}

static  void operator_13488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CPObservable*)o)->operator=)(*(const ::CPObservable*)arg[0]);
  else   (((::CPObservable*)o)->operator=)(*(const ::CPObservable*)arg[0]);
}

static  void method_13489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::CPObservable*)o)->clone)((const char*)arg[0]));
  else   (((const ::CPObservable*)o)->clone)((const char*)arg[0]);
}

static void destructor_13490(void*, void * o, const std::vector<void*>&, void *) {
(((::CPObservable*)o)->::CPObservable::~CPObservable)();
}
static  void method_13492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CPObservable*)o)->Class)());
  else   (((::CPObservable*)o)->Class)();
}

static  void method_13493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CPObservable*)o)->Class_Name)());
  else   (((::CPObservable*)o)->Class_Name)();
}

static  void method_13494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::CPObservable*)o)->Class_Version)());
  else   (((::CPObservable*)o)->Class_Version)();
}

static  void method_13495( void*, void* o, const std::vector<void*>&, void*)
{
  (((::CPObservable*)o)->Dictionary)();
}

static  void method_13496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::CPObservable*)o)->IsA)());
  else   (((const ::CPObservable*)o)->IsA)();
}

static  void method_13497( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CPObservable*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13498( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CPObservable*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CPObservable*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CPObservable*)o)->DeclFileName)());
  else   (((::CPObservable*)o)->DeclFileName)();
}

static  void method_13501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::CPObservable*)o)->ImplFileLine)());
  else   (((::CPObservable*)o)->ImplFileLine)();
}

static  void method_13502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CPObservable*)o)->ImplFileName)());
  else   (((::CPObservable*)o)->ImplFileName)();
}

static  void method_13503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::CPObservable*)o)->DeclFileLine)());
  else   (((::CPObservable*)o)->DeclFileLine)();
}

static void method_newdel_2165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CPObservable >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CPObservable >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CPObservable >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CPObservable >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CPObservable >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x88( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::CPObservable,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::CPObservable,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::CPObservable,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::CPObservable,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::CPObservable,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CPObservable -------------------------------
void __CPObservable_db_datamem(Reflex::Class*);
void __CPObservable_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CPObservable_datamem_bld(&__CPObservable_db_datamem);
Reflex::GenreflexMemberBuilder __CPObservable_funcmem_bld(&__CPObservable_db_funcmem);
void __CPObservable_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CPObservable"), typeid(::CPObservable), sizeof(::CPObservable), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::CPObservable::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::CPObservable, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddEnum(Reflex::Literal("CPObservable::which"), Reflex::Literal("C=0;D=1;S=2;Dbar=3;Sbar=4"), &typeid(CPObservable::which), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CPObservable"), constructor_13485, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_13484), Reflex::Literal("CPObservable"), constructor_13486, 0, "name;title;_lambda;_phi_strong;_phi_weak;_what", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31283, type_4128), Reflex::Literal("CPObservable"), constructor_13487, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CPObservable"), destructor_13490, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x88, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CPObservable_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CPObservable_funcmem_bld);
}

//------Delayed data member builder for class CPObservable -------------------
void __CPObservable_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("lambda"), OffsetOf(__shadow__::__CPObservable, lambda), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("phi_strong"), OffsetOf(__shadow__::__CPObservable, phi_strong), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("phi_weak"), OffsetOf(__shadow__::__CPObservable, phi_weak), ::Reflex::PROTECTED)
  .AddDataMember(type_141, Reflex::Literal("what"), OffsetOf(__shadow__::__CPObservable, what), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class CPObservable -------------------
void __CPObservable_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31284, type_31283), Reflex::Literal("operator="), operator_13488, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_13489, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13492, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13493, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13494, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13495, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13496, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13497, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13498, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13499, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13500, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13501, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13502, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13503, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooComplementCoef -------------------------------
static  void operator_13552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooComplementCoef*)o)->operator=)(*(const ::RooComplementCoef*)arg[0]);
  else   (((::RooComplementCoef*)o)->operator=)(*(const ::RooComplementCoef*)arg[0]);
}

static void constructor_13553( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooComplementCoef();
  else ::new(mem) ::RooComplementCoef();
}

static void constructor_13554( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooComplementCoef((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2]);
  else ::new(mem) ::RooComplementCoef((const char*)arg[0],
      (const char*)arg[1],
      *(const ::RooArgList*)arg[2]);
}

static void constructor_13555( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooComplementCoef(*(const ::RooComplementCoef*)arg[0]);
  else ::new(mem) ::RooComplementCoef(*(const ::RooComplementCoef*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooComplementCoef(*(const ::RooComplementCoef*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooComplementCoef(*(const ::RooComplementCoef*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_13556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooComplementCoef*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooComplementCoef*)o)->clone)((const char*)arg[0]);
}

static void destructor_13557(void*, void * o, const std::vector<void*>&, void *) {
(((::RooComplementCoef*)o)->::RooComplementCoef::~RooComplementCoef)();
}
static  void method_13558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (RooArgList)((((const ::RooComplementCoef*)o)->coefficients)());
  else   (((const ::RooComplementCoef*)o)->coefficients)();
}

static  void method_13559( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::RooComplementCoef*)o)->printArgs)(*(::std::ostream*)arg[0]);
}

static  void method_13561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooComplementCoef*)o)->Class)());
  else   (((::RooComplementCoef*)o)->Class)();
}

static  void method_13562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooComplementCoef*)o)->Class_Name)());
  else   (((::RooComplementCoef*)o)->Class_Name)();
}

static  void method_13563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooComplementCoef*)o)->Class_Version)());
  else   (((::RooComplementCoef*)o)->Class_Version)();
}

static  void method_13564( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooComplementCoef*)o)->Dictionary)();
}

static  void method_13565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooComplementCoef*)o)->IsA)());
  else   (((const ::RooComplementCoef*)o)->IsA)();
}

static  void method_13566( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooComplementCoef*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13567( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooComplementCoef*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13568( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooComplementCoef*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooComplementCoef*)o)->DeclFileName)());
  else   (((::RooComplementCoef*)o)->DeclFileName)();
}

static  void method_13570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooComplementCoef*)o)->ImplFileLine)());
  else   (((::RooComplementCoef*)o)->ImplFileLine)();
}

static  void method_13571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooComplementCoef*)o)->ImplFileName)());
  else   (((::RooComplementCoef*)o)->ImplFileName)();
}

static  void method_13572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooComplementCoef*)o)->DeclFileLine)());
  else   (((::RooComplementCoef*)o)->DeclFileLine)();
}

static void method_newdel_2200( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooComplementCoef >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x90( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooComplementCoef,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooComplementCoef,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooComplementCoef,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooComplementCoef,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooComplementCoef,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooComplementCoef -------------------------------
void __RooComplementCoef_db_datamem(Reflex::Class*);
void __RooComplementCoef_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooComplementCoef_datamem_bld(&__RooComplementCoef_db_datamem);
Reflex::GenreflexMemberBuilder __RooComplementCoef_funcmem_bld(&__RooComplementCoef_db_funcmem);
void __RooComplementCoef_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooComplementCoef"), typeid(::RooComplementCoef), sizeof(::RooComplementCoef), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooComplementCoef::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::RooComplementCoef, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31286, type_31287), Reflex::Literal("operator="), operator_13552, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooComplementCoef"), constructor_13553, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27821), Reflex::Literal("RooComplementCoef"), constructor_13554, 0, "name;title;coefficients", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31287, type_4128), Reflex::Literal("RooComplementCoef"), constructor_13555, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooComplementCoef"), destructor_13557, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x90, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooComplementCoef_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooComplementCoef_funcmem_bld);
}

//------Delayed data member builder for class RooComplementCoef -------------------
void __RooComplementCoef_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_646, Reflex::Literal("_coefs"), OffsetOf(__shadow__::__RooComplementCoef, _coefs), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooComplementCoef -------------------
void __RooComplementCoef_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_13556, 0, "name", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1620), Reflex::Literal("coefficients"), method_13558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_9883), Reflex::Literal("printArgs"), method_13559, 0, "os", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13561, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13562, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13563, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13564, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13565, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13566, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13567, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13568, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13569, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13570, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13571, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13572, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<double> -------------------------------
static void constructor_13577( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<double>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<double>(*(unsigned int*)arg[0]);
}

static void constructor_13578( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<double>(*(const ::SharedArray<double>*)arg[0]);
  else ::new(mem) ::SharedArray<double>(*(const ::SharedArray<double>*)arg[0]);
}

static  void method_13579( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<double>*)o)->Clone)());
    else     (((const ::SharedArray<double>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<double>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<double>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13580(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<double>*)o)->::SharedArray<double>::~SharedArray)();
}
static  void operator_13581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<double>*)o)->operator=)(*(const ::SharedArray<double>*)arg[0]);
  else   (((::SharedArray<double>*)o)->operator=)(*(const ::SharedArray<double>*)arg[0]);
}

static  void method_13582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<double>*)o)->size)());
  else   (((const ::SharedArray<double>*)o)->size)();
}

static  void operator_13583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<double>::RWProxy)((((const ::SharedArray<double>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<double>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<double>::RWProxy)((((::SharedArray<double>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<double>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<double>*)o)->Class)());
  else   (((::SharedArray<double>*)o)->Class)();
}

static  void method_13587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<double>*)o)->Class_Name)());
  else   (((::SharedArray<double>*)o)->Class_Name)();
}

static  void method_13588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<double>*)o)->Class_Version)());
  else   (((::SharedArray<double>*)o)->Class_Version)();
}

static  void method_13589( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<double>*)o)->Dictionary)();
}

static  void method_13590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<double>*)o)->IsA)());
  else   (((const ::SharedArray<double>*)o)->IsA)();
}

static  void method_13591( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<double>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13592( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<double>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<double>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<double>*)o)->DeclFileName)());
  else   (((::SharedArray<double>*)o)->DeclFileName)();
}

static  void method_13595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<double>*)o)->ImplFileLine)());
  else   (((::SharedArray<double>*)o)->ImplFileLine)();
}

static  void method_13596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<double>*)o)->ImplFileName)());
  else   (((::SharedArray<double>*)o)->ImplFileName)();
}

static  void method_13597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<double>*)o)->DeclFileLine)());
  else   (((::SharedArray<double>*)o)->DeclFileLine)();
}

static void method_x91( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<double>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<double> -------------------------------
void __SharedArray_double__db_datamem(Reflex::Class*);
void __SharedArray_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_double__datamem_bld(&__SharedArray_double__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_double__funcmem_bld(&__SharedArray_double__db_funcmem);
void __SharedArray_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<double>"), typeid(::SharedArray<double>), sizeof(::SharedArray<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<double>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13577, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31320), Reflex::Literal("SharedArray"), constructor_13578, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13580, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x91, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_double__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<double> -------------------
void __SharedArray_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31004, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_double_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<double> -------------------
void __SharedArray_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31321, type_4128), Reflex::Literal("Clone"), method_13579, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31322, type_31320), Reflex::Literal("operator="), operator_13581, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13575c, type_211), Reflex::Literal("operator[]"), operator_13583, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13575, type_211), Reflex::Literal("operator[]"), operator_13584, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13586, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13587, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13588, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13589, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13590, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13591, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13592, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13593, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13594, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13595, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13596, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13597, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<float> -------------------------------
static void constructor_13602( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<float>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<float>(*(unsigned int*)arg[0]);
}

static void constructor_13603( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<float>(*(const ::SharedArray<float>*)arg[0]);
  else ::new(mem) ::SharedArray<float>(*(const ::SharedArray<float>*)arg[0]);
}

static  void method_13604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<float>*)o)->Clone)());
    else     (((const ::SharedArray<float>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<float>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<float>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13605(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<float>*)o)->::SharedArray<float>::~SharedArray)();
}
static  void operator_13606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<float>*)o)->operator=)(*(const ::SharedArray<float>*)arg[0]);
  else   (((::SharedArray<float>*)o)->operator=)(*(const ::SharedArray<float>*)arg[0]);
}

static  void method_13607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<float>*)o)->size)());
  else   (((const ::SharedArray<float>*)o)->size)();
}

static  void operator_13608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<float>::RWProxy)((((const ::SharedArray<float>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<float>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<float>::RWProxy)((((::SharedArray<float>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<float>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<float>*)o)->Class)());
  else   (((::SharedArray<float>*)o)->Class)();
}

static  void method_13612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<float>*)o)->Class_Name)());
  else   (((::SharedArray<float>*)o)->Class_Name)();
}

static  void method_13613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<float>*)o)->Class_Version)());
  else   (((::SharedArray<float>*)o)->Class_Version)();
}

static  void method_13614( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<float>*)o)->Dictionary)();
}

static  void method_13615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<float>*)o)->IsA)());
  else   (((const ::SharedArray<float>*)o)->IsA)();
}

static  void method_13616( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<float>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<float>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13618( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<float>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<float>*)o)->DeclFileName)());
  else   (((::SharedArray<float>*)o)->DeclFileName)();
}

static  void method_13620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<float>*)o)->ImplFileLine)());
  else   (((::SharedArray<float>*)o)->ImplFileLine)();
}

static  void method_13621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<float>*)o)->ImplFileName)());
  else   (((::SharedArray<float>*)o)->ImplFileName)();
}

static  void method_13622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<float>*)o)->DeclFileLine)());
  else   (((::SharedArray<float>*)o)->DeclFileLine)();
}

static void method_x92( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<float>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<float> -------------------------------
void __SharedArray_float__db_datamem(Reflex::Class*);
void __SharedArray_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_float__datamem_bld(&__SharedArray_float__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_float__funcmem_bld(&__SharedArray_float__db_funcmem);
void __SharedArray_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<float>"), typeid(::SharedArray<float>), sizeof(::SharedArray<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<float>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13602, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31356), Reflex::Literal("SharedArray"), constructor_13603, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13605, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x92, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_float__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<float> -------------------
void __SharedArray_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31007, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_float_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<float> -------------------
void __SharedArray_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31357, type_4128), Reflex::Literal("Clone"), method_13604, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31358, type_31356), Reflex::Literal("operator="), operator_13606, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13600c, type_211), Reflex::Literal("operator[]"), operator_13608, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13600, type_211), Reflex::Literal("operator[]"), operator_13609, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13611, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13612, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13613, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13614, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13615, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13616, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13617, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13618, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13619, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13620, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13621, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13622, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<long long unsigned int> -------------------------------
static void constructor_13627( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned long long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned long long>(*(unsigned int*)arg[0]);
}

static void constructor_13628( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned long long>(*(const ::SharedArray<unsigned long long>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned long long>(*(const ::SharedArray<unsigned long long>*)arg[0]);
}

static  void method_13629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long long>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned long long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned long long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13630(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned long long>*)o)->::SharedArray<unsigned long long>::~SharedArray)();
}
static  void operator_13631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned long long>*)o)->operator=)(*(const ::SharedArray<unsigned long long>*)arg[0]);
  else   (((::SharedArray<unsigned long long>*)o)->operator=)(*(const ::SharedArray<unsigned long long>*)arg[0]);
}

static  void method_13632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned long long>*)o)->size)());
  else   (((const ::SharedArray<unsigned long long>*)o)->size)();
}

static  void operator_13633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned long long>::RWProxy)((((const ::SharedArray<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned long long>::RWProxy)((((::SharedArray<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long long>*)o)->Class)());
  else   (((::SharedArray<unsigned long long>*)o)->Class)();
}

static  void method_13637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long long>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned long long>*)o)->Class_Name)();
}

static  void method_13638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned long long>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned long long>*)o)->Class_Version)();
}

static  void method_13639( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned long long>*)o)->Dictionary)();
}

static  void method_13640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long long>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned long long>*)o)->IsA)();
}

static  void method_13641( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13642( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13643( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long long>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned long long>*)o)->DeclFileName)();
}

static  void method_13645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned long long>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned long long>*)o)->ImplFileLine)();
}

static  void method_13646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long long>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned long long>*)o)->ImplFileName)();
}

static  void method_13647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned long long>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned long long>*)o)->DeclFileLine)();
}

static void method_x93( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned long long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<long long unsigned int> -------------------------------
void __SharedArray_unsignedslongslong__db_datamem(Reflex::Class*);
void __SharedArray_unsignedslongslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedslongslong__datamem_bld(&__SharedArray_unsignedslongslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedslongslong__funcmem_bld(&__SharedArray_unsignedslongslong__db_funcmem);
void __SharedArray_unsignedslongslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned long long>"), typeid(::SharedArray<unsigned long long>), sizeof(::SharedArray<unsigned long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned long long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13627, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31392), Reflex::Literal("SharedArray"), constructor_13628, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13630, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x93, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedslongslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedslongslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<long long unsigned int> -------------------
void __SharedArray_unsignedslongslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31010, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedslongslong_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<long long unsigned int> -------------------
void __SharedArray_unsignedslongslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31393, type_4128), Reflex::Literal("Clone"), method_13629, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31394, type_31392), Reflex::Literal("operator="), operator_13631, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13632, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13625c, type_211), Reflex::Literal("operator[]"), operator_13633, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13625, type_211), Reflex::Literal("operator[]"), operator_13634, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13636, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13637, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13638, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13639, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13640, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13641, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13642, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13643, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13644, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13645, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13646, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13647, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<long unsigned int> -------------------------------
static void constructor_13652( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned long>(*(unsigned int*)arg[0]);
}

static void constructor_13653( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned long>(*(const ::SharedArray<unsigned long>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned long>(*(const ::SharedArray<unsigned long>*)arg[0]);
}

static  void method_13654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13655(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned long>*)o)->::SharedArray<unsigned long>::~SharedArray)();
}
static  void operator_13656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned long>*)o)->operator=)(*(const ::SharedArray<unsigned long>*)arg[0]);
  else   (((::SharedArray<unsigned long>*)o)->operator=)(*(const ::SharedArray<unsigned long>*)arg[0]);
}

static  void method_13657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned long>*)o)->size)());
  else   (((const ::SharedArray<unsigned long>*)o)->size)();
}

static  void operator_13658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned long>::RWProxy)((((const ::SharedArray<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned long>::RWProxy)((((::SharedArray<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long>*)o)->Class)());
  else   (((::SharedArray<unsigned long>*)o)->Class)();
}

static  void method_13662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned long>*)o)->Class_Name)();
}

static  void method_13663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned long>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned long>*)o)->Class_Version)();
}

static  void method_13664( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned long>*)o)->Dictionary)();
}

static  void method_13665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned long>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned long>*)o)->IsA)();
}

static  void method_13666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13668( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned long>*)o)->DeclFileName)();
}

static  void method_13670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned long>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned long>*)o)->ImplFileLine)();
}

static  void method_13671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned long>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned long>*)o)->ImplFileName)();
}

static  void method_13672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned long>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned long>*)o)->DeclFileLine)();
}

static void method_x94( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<long unsigned int> -------------------------------
void __SharedArray_unsignedslong__db_datamem(Reflex::Class*);
void __SharedArray_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedslong__datamem_bld(&__SharedArray_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedslong__funcmem_bld(&__SharedArray_unsignedslong__db_funcmem);
void __SharedArray_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned long>"), typeid(::SharedArray<unsigned long>), sizeof(::SharedArray<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13652, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31428), Reflex::Literal("SharedArray"), constructor_13653, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13655, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x94, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<long unsigned int> -------------------
void __SharedArray_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31013, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedslong_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<long unsigned int> -------------------
void __SharedArray_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31429, type_4128), Reflex::Literal("Clone"), method_13654, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31430, type_31428), Reflex::Literal("operator="), operator_13656, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13650c, type_211), Reflex::Literal("operator[]"), operator_13658, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13650, type_211), Reflex::Literal("operator[]"), operator_13659, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13661, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13662, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13663, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13664, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13665, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13666, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13667, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13668, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13669, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13670, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13671, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13672, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<unsigned int> -------------------------------
static void constructor_13677( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned int>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned int>(*(unsigned int*)arg[0]);
}

static void constructor_13678( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned int>(*(const ::SharedArray<unsigned int>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned int>(*(const ::SharedArray<unsigned int>*)arg[0]);
}

static  void method_13679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned int>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned int>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned int>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned int>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13680(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned int>*)o)->::SharedArray<unsigned int>::~SharedArray)();
}
static  void operator_13681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned int>*)o)->operator=)(*(const ::SharedArray<unsigned int>*)arg[0]);
  else   (((::SharedArray<unsigned int>*)o)->operator=)(*(const ::SharedArray<unsigned int>*)arg[0]);
}

static  void method_13682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned int>*)o)->size)());
  else   (((const ::SharedArray<unsigned int>*)o)->size)();
}

static  void operator_13683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned int>::RWProxy)((((const ::SharedArray<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned int>::RWProxy)((((::SharedArray<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned int>*)o)->Class)());
  else   (((::SharedArray<unsigned int>*)o)->Class)();
}

static  void method_13687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned int>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned int>*)o)->Class_Name)();
}

static  void method_13688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned int>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned int>*)o)->Class_Version)();
}

static  void method_13689( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned int>*)o)->Dictionary)();
}

static  void method_13690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned int>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned int>*)o)->IsA)();
}

static  void method_13691( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned int>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned int>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13693( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned int>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned int>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned int>*)o)->DeclFileName)();
}

static  void method_13695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned int>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned int>*)o)->ImplFileLine)();
}

static  void method_13696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned int>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned int>*)o)->ImplFileName)();
}

static  void method_13697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned int>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned int>*)o)->DeclFileLine)();
}

static void method_x95( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned int>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<unsigned int> -------------------------------
void __SharedArray_unsignedsint__db_datamem(Reflex::Class*);
void __SharedArray_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedsint__datamem_bld(&__SharedArray_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedsint__funcmem_bld(&__SharedArray_unsignedsint__db_funcmem);
void __SharedArray_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned int>"), typeid(::SharedArray<unsigned int>), sizeof(::SharedArray<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned int>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13677, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31464), Reflex::Literal("SharedArray"), constructor_13678, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13680, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x95, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<unsigned int> -------------------
void __SharedArray_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31016, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedsint_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<unsigned int> -------------------
void __SharedArray_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31465, type_4128), Reflex::Literal("Clone"), method_13679, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31466, type_31464), Reflex::Literal("operator="), operator_13681, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13675c, type_211), Reflex::Literal("operator[]"), operator_13683, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13675, type_211), Reflex::Literal("operator[]"), operator_13684, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13686, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13687, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13688, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13689, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13690, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13691, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13692, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13693, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13694, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13695, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13696, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13697, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<short unsigned int> -------------------------------
static void constructor_13702( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned short>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned short>(*(unsigned int*)arg[0]);
}

static void constructor_13703( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned short>(*(const ::SharedArray<unsigned short>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned short>(*(const ::SharedArray<unsigned short>*)arg[0]);
}

static  void method_13704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned short>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned short>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned short>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned short>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13705(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned short>*)o)->::SharedArray<unsigned short>::~SharedArray)();
}
static  void operator_13706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned short>*)o)->operator=)(*(const ::SharedArray<unsigned short>*)arg[0]);
  else   (((::SharedArray<unsigned short>*)o)->operator=)(*(const ::SharedArray<unsigned short>*)arg[0]);
}

static  void method_13707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned short>*)o)->size)());
  else   (((const ::SharedArray<unsigned short>*)o)->size)();
}

static  void operator_13708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned short>::RWProxy)((((const ::SharedArray<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned short>::RWProxy)((((::SharedArray<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned short>*)o)->Class)());
  else   (((::SharedArray<unsigned short>*)o)->Class)();
}

static  void method_13712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned short>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned short>*)o)->Class_Name)();
}

static  void method_13713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned short>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned short>*)o)->Class_Version)();
}

static  void method_13714( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned short>*)o)->Dictionary)();
}

static  void method_13715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned short>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned short>*)o)->IsA)();
}

static  void method_13716( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned short>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13717( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned short>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned short>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned short>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned short>*)o)->DeclFileName)();
}

static  void method_13720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned short>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned short>*)o)->ImplFileLine)();
}

static  void method_13721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned short>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned short>*)o)->ImplFileName)();
}

static  void method_13722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned short>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned short>*)o)->DeclFileLine)();
}

static void method_x96( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned short>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<short unsigned int> -------------------------------
void __SharedArray_unsignedsshort__db_datamem(Reflex::Class*);
void __SharedArray_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedsshort__datamem_bld(&__SharedArray_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedsshort__funcmem_bld(&__SharedArray_unsignedsshort__db_funcmem);
void __SharedArray_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned short>"), typeid(::SharedArray<unsigned short>), sizeof(::SharedArray<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned short>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13702, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31500), Reflex::Literal("SharedArray"), constructor_13703, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13705, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x96, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedsshort__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedsshort__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<short unsigned int> -------------------
void __SharedArray_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31019, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedsshort_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<short unsigned int> -------------------
void __SharedArray_unsignedsshort__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31501, type_4128), Reflex::Literal("Clone"), method_13704, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31502, type_31500), Reflex::Literal("operator="), operator_13706, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13700c, type_211), Reflex::Literal("operator[]"), operator_13708, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13700, type_211), Reflex::Literal("operator[]"), operator_13709, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13711, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13712, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13713, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13714, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13715, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13716, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13717, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13718, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13719, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13720, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13721, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13722, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<unsigned char> -------------------------------
static void constructor_13727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned char>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned char>(*(unsigned int*)arg[0]);
}

static void constructor_13728( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<unsigned char>(*(const ::SharedArray<unsigned char>*)arg[0]);
  else ::new(mem) ::SharedArray<unsigned char>(*(const ::SharedArray<unsigned char>*)arg[0]);
}

static  void method_13729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned char>*)o)->Clone)());
    else     (((const ::SharedArray<unsigned char>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned char>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<unsigned char>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13730(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<unsigned char>*)o)->::SharedArray<unsigned char>::~SharedArray)();
}
static  void operator_13731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<unsigned char>*)o)->operator=)(*(const ::SharedArray<unsigned char>*)arg[0]);
  else   (((::SharedArray<unsigned char>*)o)->operator=)(*(const ::SharedArray<unsigned char>*)arg[0]);
}

static  void method_13732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<unsigned char>*)o)->size)());
  else   (((const ::SharedArray<unsigned char>*)o)->size)();
}

static  void operator_13733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned char>::RWProxy)((((const ::SharedArray<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<unsigned char>::RWProxy)((((::SharedArray<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<unsigned char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned char>*)o)->Class)());
  else   (((::SharedArray<unsigned char>*)o)->Class)();
}

static  void method_13737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned char>*)o)->Class_Name)());
  else   (((::SharedArray<unsigned char>*)o)->Class_Name)();
}

static  void method_13738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<unsigned char>*)o)->Class_Version)());
  else   (((::SharedArray<unsigned char>*)o)->Class_Version)();
}

static  void method_13739( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<unsigned char>*)o)->Dictionary)();
}

static  void method_13740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<unsigned char>*)o)->IsA)());
  else   (((const ::SharedArray<unsigned char>*)o)->IsA)();
}

static  void method_13741( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned char>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13742( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned char>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13743( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<unsigned char>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned char>*)o)->DeclFileName)());
  else   (((::SharedArray<unsigned char>*)o)->DeclFileName)();
}

static  void method_13745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned char>*)o)->ImplFileLine)());
  else   (((::SharedArray<unsigned char>*)o)->ImplFileLine)();
}

static  void method_13746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<unsigned char>*)o)->ImplFileName)());
  else   (((::SharedArray<unsigned char>*)o)->ImplFileName)();
}

static  void method_13747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<unsigned char>*)o)->DeclFileLine)());
  else   (((::SharedArray<unsigned char>*)o)->DeclFileLine)();
}

static void method_x97( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<unsigned char>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<unsigned char> -------------------------------
void __SharedArray_unsignedschar__db_datamem(Reflex::Class*);
void __SharedArray_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedschar__datamem_bld(&__SharedArray_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_unsignedschar__funcmem_bld(&__SharedArray_unsignedschar__db_funcmem);
void __SharedArray_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<unsigned char>"), typeid(::SharedArray<unsigned char>), sizeof(::SharedArray<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<unsigned char>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13727, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31536), Reflex::Literal("SharedArray"), constructor_13728, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13730, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x97, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_unsignedschar__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_unsignedschar__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<unsigned char> -------------------
void __SharedArray_unsignedschar__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31022, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_unsignedschar_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<unsigned char> -------------------
void __SharedArray_unsignedschar__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31537, type_4128), Reflex::Literal("Clone"), method_13729, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31538, type_31536), Reflex::Literal("operator="), operator_13731, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13725c, type_211), Reflex::Literal("operator[]"), operator_13733, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13725, type_211), Reflex::Literal("operator[]"), operator_13734, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13736, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13737, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13738, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13739, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13740, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13741, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13742, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13743, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13744, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13745, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13746, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13747, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<long long int> -------------------------------
static void constructor_13752( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<long long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<long long>(*(unsigned int*)arg[0]);
}

static void constructor_13753( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<long long>(*(const ::SharedArray<long long>*)arg[0]);
  else ::new(mem) ::SharedArray<long long>(*(const ::SharedArray<long long>*)arg[0]);
}

static  void method_13754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long long>*)o)->Clone)());
    else     (((const ::SharedArray<long long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<long long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13755(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<long long>*)o)->::SharedArray<long long>::~SharedArray)();
}
static  void operator_13756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<long long>*)o)->operator=)(*(const ::SharedArray<long long>*)arg[0]);
  else   (((::SharedArray<long long>*)o)->operator=)(*(const ::SharedArray<long long>*)arg[0]);
}

static  void method_13757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<long long>*)o)->size)());
  else   (((const ::SharedArray<long long>*)o)->size)();
}

static  void operator_13758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<long long>::RWProxy)((((const ::SharedArray<long long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<long long>::RWProxy)((((::SharedArray<long long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<long long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long long>*)o)->Class)());
  else   (((::SharedArray<long long>*)o)->Class)();
}

static  void method_13762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long long>*)o)->Class_Name)());
  else   (((::SharedArray<long long>*)o)->Class_Name)();
}

static  void method_13763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<long long>*)o)->Class_Version)());
  else   (((::SharedArray<long long>*)o)->Class_Version)();
}

static  void method_13764( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<long long>*)o)->Dictionary)();
}

static  void method_13765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long long>*)o)->IsA)());
  else   (((const ::SharedArray<long long>*)o)->IsA)();
}

static  void method_13766( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13767( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13768( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long long>*)o)->DeclFileName)());
  else   (((::SharedArray<long long>*)o)->DeclFileName)();
}

static  void method_13770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<long long>*)o)->ImplFileLine)());
  else   (((::SharedArray<long long>*)o)->ImplFileLine)();
}

static  void method_13771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long long>*)o)->ImplFileName)());
  else   (((::SharedArray<long long>*)o)->ImplFileName)();
}

static  void method_13772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<long long>*)o)->DeclFileLine)());
  else   (((::SharedArray<long long>*)o)->DeclFileLine)();
}

static void method_x98( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<long long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<long long int> -------------------------------
void __SharedArray_longslong__db_datamem(Reflex::Class*);
void __SharedArray_longslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_longslong__datamem_bld(&__SharedArray_longslong__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_longslong__funcmem_bld(&__SharedArray_longslong__db_funcmem);
void __SharedArray_longslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<long long>"), typeid(::SharedArray<long long>), sizeof(::SharedArray<long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<long long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13752, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31572), Reflex::Literal("SharedArray"), constructor_13753, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13755, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x98, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_longslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_longslong__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<long long int> -------------------
void __SharedArray_longslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31025, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_longslong_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<long long int> -------------------
void __SharedArray_longslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31573, type_4128), Reflex::Literal("Clone"), method_13754, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31574, type_31572), Reflex::Literal("operator="), operator_13756, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13757, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13750c, type_211), Reflex::Literal("operator[]"), operator_13758, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13750, type_211), Reflex::Literal("operator[]"), operator_13759, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13761, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13762, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13763, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13764, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13765, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13766, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13767, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13768, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13769, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13770, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13771, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13772, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<long int> -------------------------------
static void constructor_13777( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<long>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<long>(*(unsigned int*)arg[0]);
}

static void constructor_13778( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<long>(*(const ::SharedArray<long>*)arg[0]);
  else ::new(mem) ::SharedArray<long>(*(const ::SharedArray<long>*)arg[0]);
}

static  void method_13779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long>*)o)->Clone)());
    else     (((const ::SharedArray<long>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<long>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13780(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<long>*)o)->::SharedArray<long>::~SharedArray)();
}
static  void operator_13781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<long>*)o)->operator=)(*(const ::SharedArray<long>*)arg[0]);
  else   (((::SharedArray<long>*)o)->operator=)(*(const ::SharedArray<long>*)arg[0]);
}

static  void method_13782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<long>*)o)->size)());
  else   (((const ::SharedArray<long>*)o)->size)();
}

static  void operator_13783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<long>::RWProxy)((((const ::SharedArray<long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<long>::RWProxy)((((::SharedArray<long>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<long>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long>*)o)->Class)());
  else   (((::SharedArray<long>*)o)->Class)();
}

static  void method_13787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long>*)o)->Class_Name)());
  else   (((::SharedArray<long>*)o)->Class_Name)();
}

static  void method_13788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<long>*)o)->Class_Version)());
  else   (((::SharedArray<long>*)o)->Class_Version)();
}

static  void method_13789( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<long>*)o)->Dictionary)();
}

static  void method_13790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<long>*)o)->IsA)());
  else   (((const ::SharedArray<long>*)o)->IsA)();
}

static  void method_13791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13793( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<long>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long>*)o)->DeclFileName)());
  else   (((::SharedArray<long>*)o)->DeclFileName)();
}

static  void method_13795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<long>*)o)->ImplFileLine)());
  else   (((::SharedArray<long>*)o)->ImplFileLine)();
}

static  void method_13796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<long>*)o)->ImplFileName)());
  else   (((::SharedArray<long>*)o)->ImplFileName)();
}

static  void method_13797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<long>*)o)->DeclFileLine)());
  else   (((::SharedArray<long>*)o)->DeclFileLine)();
}

static void method_x99( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<long>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<long int> -------------------------------
void __SharedArray_long__db_datamem(Reflex::Class*);
void __SharedArray_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_long__datamem_bld(&__SharedArray_long__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_long__funcmem_bld(&__SharedArray_long__db_funcmem);
void __SharedArray_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<long>"), typeid(::SharedArray<long>), sizeof(::SharedArray<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<long>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13777, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31608), Reflex::Literal("SharedArray"), constructor_13778, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13780, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x99, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_long__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_long__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<long int> -------------------
void __SharedArray_long__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31028, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_long_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<long int> -------------------
void __SharedArray_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31609, type_4128), Reflex::Literal("Clone"), method_13779, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31610, type_31608), Reflex::Literal("operator="), operator_13781, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13775c, type_211), Reflex::Literal("operator[]"), operator_13783, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13775, type_211), Reflex::Literal("operator[]"), operator_13784, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13786, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13787, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13788, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13789, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13790, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13791, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13792, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13793, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13794, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13795, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13796, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13797, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<int> -------------------------------
static void constructor_13802( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<int>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<int>(*(unsigned int*)arg[0]);
}

static void constructor_13803( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<int>(*(const ::SharedArray<int>*)arg[0]);
  else ::new(mem) ::SharedArray<int>(*(const ::SharedArray<int>*)arg[0]);
}

static  void method_13804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<int>*)o)->Clone)());
    else     (((const ::SharedArray<int>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<int>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<int>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13805(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<int>*)o)->::SharedArray<int>::~SharedArray)();
}
static  void operator_13806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<int>*)o)->operator=)(*(const ::SharedArray<int>*)arg[0]);
  else   (((::SharedArray<int>*)o)->operator=)(*(const ::SharedArray<int>*)arg[0]);
}

static  void method_13807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<int>*)o)->size)());
  else   (((const ::SharedArray<int>*)o)->size)();
}

static  void operator_13808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<int>::RWProxy)((((const ::SharedArray<int>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<int>::RWProxy)((((::SharedArray<int>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<int>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<int>*)o)->Class)());
  else   (((::SharedArray<int>*)o)->Class)();
}

static  void method_13812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<int>*)o)->Class_Name)());
  else   (((::SharedArray<int>*)o)->Class_Name)();
}

static  void method_13813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<int>*)o)->Class_Version)());
  else   (((::SharedArray<int>*)o)->Class_Version)();
}

static  void method_13814( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<int>*)o)->Dictionary)();
}

static  void method_13815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<int>*)o)->IsA)());
  else   (((const ::SharedArray<int>*)o)->IsA)();
}

static  void method_13816( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<int>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13817( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<int>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13818( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<int>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<int>*)o)->DeclFileName)());
  else   (((::SharedArray<int>*)o)->DeclFileName)();
}

static  void method_13820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<int>*)o)->ImplFileLine)());
  else   (((::SharedArray<int>*)o)->ImplFileLine)();
}

static  void method_13821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<int>*)o)->ImplFileName)());
  else   (((::SharedArray<int>*)o)->ImplFileName)();
}

static  void method_13822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<int>*)o)->DeclFileLine)());
  else   (((::SharedArray<int>*)o)->DeclFileLine)();
}

static void method_x100( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<int>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<int> -------------------------------
void __SharedArray_int__db_datamem(Reflex::Class*);
void __SharedArray_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_int__datamem_bld(&__SharedArray_int__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_int__funcmem_bld(&__SharedArray_int__db_funcmem);
void __SharedArray_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<int>"), typeid(::SharedArray<int>), sizeof(::SharedArray<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<int>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13802, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31644), Reflex::Literal("SharedArray"), constructor_13803, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13805, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_int__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<int> -------------------
void __SharedArray_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31031, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_int_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<int> -------------------
void __SharedArray_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31645, type_4128), Reflex::Literal("Clone"), method_13804, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31646, type_31644), Reflex::Literal("operator="), operator_13806, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13800c, type_211), Reflex::Literal("operator[]"), operator_13808, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13800, type_211), Reflex::Literal("operator[]"), operator_13809, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13811, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13812, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13813, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13814, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13815, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13816, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13817, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13818, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13819, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13820, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13821, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13822, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<short int> -------------------------------
static void constructor_13827( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<short>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<short>(*(unsigned int*)arg[0]);
}

static void constructor_13828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<short>(*(const ::SharedArray<short>*)arg[0]);
  else ::new(mem) ::SharedArray<short>(*(const ::SharedArray<short>*)arg[0]);
}

static  void method_13829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<short>*)o)->Clone)());
    else     (((const ::SharedArray<short>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<short>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<short>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13830(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<short>*)o)->::SharedArray<short>::~SharedArray)();
}
static  void operator_13831( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<short>*)o)->operator=)(*(const ::SharedArray<short>*)arg[0]);
  else   (((::SharedArray<short>*)o)->operator=)(*(const ::SharedArray<short>*)arg[0]);
}

static  void method_13832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<short>*)o)->size)());
  else   (((const ::SharedArray<short>*)o)->size)();
}

static  void operator_13833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<short>::RWProxy)((((const ::SharedArray<short>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<short>::RWProxy)((((::SharedArray<short>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<short>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<short>*)o)->Class)());
  else   (((::SharedArray<short>*)o)->Class)();
}

static  void method_13837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<short>*)o)->Class_Name)());
  else   (((::SharedArray<short>*)o)->Class_Name)();
}

static  void method_13838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<short>*)o)->Class_Version)());
  else   (((::SharedArray<short>*)o)->Class_Version)();
}

static  void method_13839( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<short>*)o)->Dictionary)();
}

static  void method_13840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<short>*)o)->IsA)());
  else   (((const ::SharedArray<short>*)o)->IsA)();
}

static  void method_13841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<short>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13842( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<short>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13843( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<short>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<short>*)o)->DeclFileName)());
  else   (((::SharedArray<short>*)o)->DeclFileName)();
}

static  void method_13845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<short>*)o)->ImplFileLine)());
  else   (((::SharedArray<short>*)o)->ImplFileLine)();
}

static  void method_13846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<short>*)o)->ImplFileName)());
  else   (((::SharedArray<short>*)o)->ImplFileName)();
}

static  void method_13847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<short>*)o)->DeclFileLine)());
  else   (((::SharedArray<short>*)o)->DeclFileLine)();
}

static void method_x101( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<short>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<short int> -------------------------------
void __SharedArray_short__db_datamem(Reflex::Class*);
void __SharedArray_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_short__datamem_bld(&__SharedArray_short__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_short__funcmem_bld(&__SharedArray_short__db_funcmem);
void __SharedArray_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<short>"), typeid(::SharedArray<short>), sizeof(::SharedArray<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<short>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13827, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31680), Reflex::Literal("SharedArray"), constructor_13828, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13830, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_short__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_short__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<short int> -------------------
void __SharedArray_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31034, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_short_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<short int> -------------------
void __SharedArray_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31681, type_4128), Reflex::Literal("Clone"), method_13829, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31682, type_31680), Reflex::Literal("operator="), operator_13831, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13825c, type_211), Reflex::Literal("operator[]"), operator_13833, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13825, type_211), Reflex::Literal("operator[]"), operator_13834, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13836, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13837, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13838, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13839, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13840, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13841, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13842, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13843, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13844, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13845, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13846, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13847, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class SharedArray<char> -------------------------------
static void constructor_13852( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<char>(*(unsigned int*)arg[0]);
  else ::new(mem) ::SharedArray<char>(*(unsigned int*)arg[0]);
}

static void constructor_13853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SharedArray<char>(*(const ::SharedArray<char>*)arg[0]);
  else ::new(mem) ::SharedArray<char>(*(const ::SharedArray<char>*)arg[0]);
}

static  void method_13854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<char>*)o)->Clone)());
    else     (((const ::SharedArray<char>*)o)->Clone)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<char>*)o)->Clone)((const char*)arg[0]));
    else     (((const ::SharedArray<char>*)o)->Clone)((const char*)arg[0]);
  }
}

static void destructor_13855(void*, void * o, const std::vector<void*>&, void *) {
(((::SharedArray<char>*)o)->::SharedArray<char>::~SharedArray)();
}
static  void operator_13856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SharedArray<char>*)o)->operator=)(*(const ::SharedArray<char>*)arg[0]);
  else   (((::SharedArray<char>*)o)->operator=)(*(const ::SharedArray<char>*)arg[0]);
}

static  void method_13857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::SharedArray<char>*)o)->size)());
  else   (((const ::SharedArray<char>*)o)->size)();
}

static  void operator_13858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<char>::RWProxy)((((const ::SharedArray<char>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::SharedArray<char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_13859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (SharedArray<char>::RWProxy)((((::SharedArray<char>*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((::SharedArray<char>*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_13861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<char>*)o)->Class)());
  else   (((::SharedArray<char>*)o)->Class)();
}

static  void method_13862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<char>*)o)->Class_Name)());
  else   (((::SharedArray<char>*)o)->Class_Name)();
}

static  void method_13863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::SharedArray<char>*)o)->Class_Version)());
  else   (((::SharedArray<char>*)o)->Class_Version)();
}

static  void method_13864( void*, void* o, const std::vector<void*>&, void*)
{
  (((::SharedArray<char>*)o)->Dictionary)();
}

static  void method_13865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::SharedArray<char>*)o)->IsA)());
  else   (((const ::SharedArray<char>*)o)->IsA)();
}

static  void method_13866( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<char>*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13867( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<char>*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13868( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SharedArray<char>*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<char>*)o)->DeclFileName)());
  else   (((::SharedArray<char>*)o)->DeclFileName)();
}

static  void method_13870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<char>*)o)->ImplFileLine)());
  else   (((::SharedArray<char>*)o)->ImplFileLine)();
}

static  void method_13871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::SharedArray<char>*)o)->ImplFileName)());
  else   (((::SharedArray<char>*)o)->ImplFileName)();
}

static  void method_13872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::SharedArray<char>*)o)->DeclFileLine)());
  else   (((::SharedArray<char>*)o)->DeclFileLine)();
}

static void method_x102( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::SharedArray<char>,::TObject >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class SharedArray<char> -------------------------------
void __SharedArray_char__db_datamem(Reflex::Class*);
void __SharedArray_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SharedArray_char__datamem_bld(&__SharedArray_char__db_datamem);
Reflex::GenreflexMemberBuilder __SharedArray_char__funcmem_bld(&__SharedArray_char__db_funcmem);
void __SharedArray_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SharedArray<char>"), typeid(::SharedArray<char>), sizeof(::SharedArray<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::SharedArray<char>::Class_Version())
  .AddProperty(Reflex::Literal("n_pattern"), "SharedArray<*>")
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1129, ::Reflex::BaseOffset< ::SharedArray<char>, ::TObject >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_211), Reflex::Literal("SharedArray"), constructor_13852, 0, "sz", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31716), Reflex::Literal("SharedArray"), constructor_13853, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SharedArray"), destructor_13855, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x102, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SharedArray_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SharedArray_char__funcmem_bld);
}

//------Delayed data member builder for class SharedArray<char> -------------------
void __SharedArray_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_31037, Reflex::Literal("pimpl"), OffsetOf(__shadow__::__SharedArray_char_, pimpl), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SharedArray<char> -------------------
void __SharedArray_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31717, type_4128), Reflex::Literal("Clone"), method_13854, 0, "newname=0", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31718, type_31716), Reflex::Literal("operator="), operator_13856, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_211), Reflex::Literal("size"), method_13857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13850c, type_211), Reflex::Literal("operator[]"), operator_13858, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13850, type_211), Reflex::Literal("operator[]"), operator_13859, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13861, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13862, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13863, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13864, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13865, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13866, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13867, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13868, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13869, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13870, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13871, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13872, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IfThreeWay -------------------------------
static  void operator_13909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::IfThreeWay*)o)->operator=)(*(const ::IfThreeWay*)arg[0]);
  else   (((::IfThreeWay*)o)->operator=)(*(const ::IfThreeWay*)arg[0]);
}

static void constructor_13910( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWay();
  else ::new(mem) ::IfThreeWay();
}

static void constructor_13911( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWay((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
  else ::new(mem) ::IfThreeWay((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5]);
}

static void constructor_13912( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWay(*(const ::IfThreeWay*)arg[0]);
  else ::new(mem) ::IfThreeWay(*(const ::IfThreeWay*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::IfThreeWay(*(const ::IfThreeWay*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::IfThreeWay(*(const ::IfThreeWay*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_13913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWay*)o)->clone)((const char*)arg[0]));
  else   (((const ::IfThreeWay*)o)->clone)((const char*)arg[0]);
}

static void destructor_13914(void*, void * o, const std::vector<void*>&, void *) {
(((::IfThreeWay*)o)->::IfThreeWay::~IfThreeWay)();
}
static  void method_13916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWay*)o)->Class)());
  else   (((::IfThreeWay*)o)->Class)();
}

static  void method_13917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWay*)o)->Class_Name)());
  else   (((::IfThreeWay*)o)->Class_Name)();
}

static  void method_13918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::IfThreeWay*)o)->Class_Version)());
  else   (((::IfThreeWay*)o)->Class_Version)();
}

static  void method_13919( void*, void* o, const std::vector<void*>&, void*)
{
  (((::IfThreeWay*)o)->Dictionary)();
}

static  void method_13920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::IfThreeWay*)o)->IsA)());
  else   (((const ::IfThreeWay*)o)->IsA)();
}

static  void method_13921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWay*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_13922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWay*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_13923( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::IfThreeWay*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_13924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWay*)o)->DeclFileName)());
  else   (((::IfThreeWay*)o)->DeclFileName)();
}

static  void method_13925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWay*)o)->ImplFileLine)());
  else   (((::IfThreeWay*)o)->ImplFileLine)();
}

static  void method_13926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::IfThreeWay*)o)->ImplFileName)());
  else   (((::IfThreeWay*)o)->ImplFileName)();
}

static  void method_13927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::IfThreeWay*)o)->DeclFileLine)());
  else   (((::IfThreeWay*)o)->DeclFileLine)();
}

static void method_newdel_2231( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::IfThreeWay >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::IfThreeWay,::RooAbsReal >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::IfThreeWay,::RooAbsArg >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::IfThreeWay,::TNamed >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::IfThreeWay,::TObject >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::IfThreeWay,::RooPrintable >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IfThreeWay -------------------------------
void __IfThreeWay_db_datamem(Reflex::Class*);
void __IfThreeWay_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __IfThreeWay_datamem_bld(&__IfThreeWay_db_datamem);
Reflex::GenreflexMemberBuilder __IfThreeWay_funcmem_bld(&__IfThreeWay_db_funcmem);
void __IfThreeWay_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("IfThreeWay"), typeid(::IfThreeWay), sizeof(::IfThreeWay), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::IfThreeWay::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2525, ::Reflex::BaseOffset< ::IfThreeWay, ::RooAbsReal >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31723, type_31724), Reflex::Literal("operator="), operator_13909, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IfThreeWay"), constructor_13910, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("IfThreeWay"), constructor_13911, 0, "name;title;_cond;_pos;_zero;_neg", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31724, type_4128), Reflex::Literal("IfThreeWay"), constructor_13912, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IfThreeWay"), destructor_13914, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2231, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__IfThreeWay_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__IfThreeWay_funcmem_bld);
}

//------Delayed data member builder for class IfThreeWay -------------------
void __IfThreeWay_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("cond"), OffsetOf(__shadow__::__IfThreeWay, cond), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("pos"), OffsetOf(__shadow__::__IfThreeWay, pos), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("zero"), OffsetOf(__shadow__::__IfThreeWay, zero), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("neg"), OffsetOf(__shadow__::__IfThreeWay, neg), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class IfThreeWay -------------------
void __IfThreeWay_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_13913, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_13916, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_13917, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_13918, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_13919, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_13920, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_13921, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_13922, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_13923, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_13924, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_13925, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_13926, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_13927, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooCruijff -------------------------------
static  void operator_14361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCruijff*)o)->operator=)(*(const ::RooCruijff*)arg[0]);
  else   (((::RooCruijff*)o)->operator=)(*(const ::RooCruijff*)arg[0]);
}

static void constructor_14362( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCruijff();
  else ::new(mem) ::RooCruijff();
}

static void constructor_14363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCruijff((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
  else ::new(mem) ::RooCruijff((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7]);
}

static void constructor_14364( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCruijff(*(const ::RooCruijff*)arg[0]);
  else ::new(mem) ::RooCruijff(*(const ::RooCruijff*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCruijff(*(const ::RooCruijff*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooCruijff(*(const ::RooCruijff*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_14365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCruijff*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooCruijff*)o)->clone)((const char*)arg[0]);
}

static void destructor_14366(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCruijff*)o)->::RooCruijff::~RooCruijff)();
}
static  void method_14368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCruijff*)o)->Class)());
  else   (((::RooCruijff*)o)->Class)();
}

static  void method_14369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCruijff*)o)->Class_Name)());
  else   (((::RooCruijff*)o)->Class_Name)();
}

static  void method_14370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooCruijff*)o)->Class_Version)());
  else   (((::RooCruijff*)o)->Class_Version)();
}

static  void method_14371( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooCruijff*)o)->Dictionary)();
}

static  void method_14372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooCruijff*)o)->IsA)());
  else   (((const ::RooCruijff*)o)->IsA)();
}

static  void method_14373( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCruijff*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_14374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCruijff*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_14375( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooCruijff*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_14376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCruijff*)o)->DeclFileName)());
  else   (((::RooCruijff*)o)->DeclFileName)();
}

static  void method_14377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCruijff*)o)->ImplFileLine)());
  else   (((::RooCruijff*)o)->ImplFileLine)();
}

static  void method_14378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooCruijff*)o)->ImplFileName)());
  else   (((::RooCruijff*)o)->ImplFileName)();
}

static  void method_14379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooCruijff*)o)->DeclFileLine)());
  else   (((::RooCruijff*)o)->DeclFileLine)();
}

static void method_newdel_2502( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooCruijff >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooCruijff >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooCruijff >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooCruijff >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooCruijff >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x106( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::RooCruijff,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooCruijff,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooCruijff,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooCruijff,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooCruijff,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooCruijff,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooCruijff -------------------------------
void __RooCruijff_db_datamem(Reflex::Class*);
void __RooCruijff_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCruijff_datamem_bld(&__RooCruijff_db_datamem);
Reflex::GenreflexMemberBuilder __RooCruijff_funcmem_bld(&__RooCruijff_db_funcmem);
void __RooCruijff_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCruijff"), typeid(::RooCruijff), sizeof(::RooCruijff), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooCruijff::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::RooCruijff, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31775, type_31776), Reflex::Literal("operator="), operator_14361, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooCruijff"), constructor_14362, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("RooCruijff"), constructor_14363, 0, "name;title;_x;_m0;_sigmaL;_sigmaR;_alphaL;_alphaR", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31776, type_4128), Reflex::Literal("RooCruijff"), constructor_14364, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooCruijff"), destructor_14366, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2502, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooCruijff_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCruijff_funcmem_bld);
}

//------Delayed data member builder for class RooCruijff -------------------
void __RooCruijff_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("x"), OffsetOf(__shadow__::__RooCruijff, x), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("m0"), OffsetOf(__shadow__::__RooCruijff, m0), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("sigmaL"), OffsetOf(__shadow__::__RooCruijff, sigmaL), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("sigmaR"), OffsetOf(__shadow__::__RooCruijff, sigmaR), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("alphaL"), OffsetOf(__shadow__::__RooCruijff, alphaL), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("alphaR"), OffsetOf(__shadow__::__RooCruijff, alphaR), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class RooCruijff -------------------
void __RooCruijff_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_14365, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_14368, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_14369, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_14370, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_14371, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_14372, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_14373, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_14374, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_14375, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_14376, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_14377, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_14378, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_14379, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class CombBkgPTPdf -------------------------------
static  void operator_14715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CombBkgPTPdf*)o)->operator=)(*(const ::CombBkgPTPdf*)arg[0]);
  else   (((::CombBkgPTPdf*)o)->operator=)(*(const ::CombBkgPTPdf*)arg[0]);
}

static void constructor_14716( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CombBkgPTPdf();
  else ::new(mem) ::CombBkgPTPdf();
}

static void constructor_14717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CombBkgPTPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
  else ::new(mem) ::CombBkgPTPdf((const char*)arg[0],
      (const char*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6]);
}

static void constructor_14718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::CombBkgPTPdf(*(const ::CombBkgPTPdf*)arg[0]);
  else ::new(mem) ::CombBkgPTPdf(*(const ::CombBkgPTPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::CombBkgPTPdf(*(const ::CombBkgPTPdf*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::CombBkgPTPdf(*(const ::CombBkgPTPdf*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_14719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::CombBkgPTPdf*)o)->clone)((const char*)arg[0]));
  else   (((const ::CombBkgPTPdf*)o)->clone)((const char*)arg[0]);
}

static void destructor_14720(void*, void * o, const std::vector<void*>&, void *) {
(((::CombBkgPTPdf*)o)->::CombBkgPTPdf::~CombBkgPTPdf)();
}
static  void method_14721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::CombBkgPTPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::CombBkgPTPdf*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_14722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::CombBkgPTPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::CombBkgPTPdf*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_14725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CombBkgPTPdf*)o)->Class)());
  else   (((::CombBkgPTPdf*)o)->Class)();
}

static  void method_14726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CombBkgPTPdf*)o)->Class_Name)());
  else   (((::CombBkgPTPdf*)o)->Class_Name)();
}

static  void method_14727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::CombBkgPTPdf*)o)->Class_Version)());
  else   (((::CombBkgPTPdf*)o)->Class_Version)();
}

static  void method_14728( void*, void* o, const std::vector<void*>&, void*)
{
  (((::CombBkgPTPdf*)o)->Dictionary)();
}

static  void method_14729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::CombBkgPTPdf*)o)->IsA)());
  else   (((const ::CombBkgPTPdf*)o)->IsA)();
}

static  void method_14730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CombBkgPTPdf*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_14731( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CombBkgPTPdf*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_14732( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CombBkgPTPdf*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_14733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CombBkgPTPdf*)o)->DeclFileName)());
  else   (((::CombBkgPTPdf*)o)->DeclFileName)();
}

static  void method_14734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::CombBkgPTPdf*)o)->ImplFileLine)());
  else   (((::CombBkgPTPdf*)o)->ImplFileLine)();
}

static  void method_14735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::CombBkgPTPdf*)o)->ImplFileName)());
  else   (((::CombBkgPTPdf*)o)->ImplFileName)();
}

static  void method_14736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::CombBkgPTPdf*)o)->DeclFileLine)());
  else   (((::CombBkgPTPdf*)o)->DeclFileLine)();
}

static void method_newdel_2590( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CombBkgPTPdf >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x108( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsPdf")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::RooAbsPdf >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::CombBkgPTPdf,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CombBkgPTPdf -------------------------------
void __CombBkgPTPdf_db_datamem(Reflex::Class*);
void __CombBkgPTPdf_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CombBkgPTPdf_datamem_bld(&__CombBkgPTPdf_db_datamem);
Reflex::GenreflexMemberBuilder __CombBkgPTPdf_funcmem_bld(&__CombBkgPTPdf_db_funcmem);
void __CombBkgPTPdf_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CombBkgPTPdf"), typeid(::CombBkgPTPdf), sizeof(::CombBkgPTPdf), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::CombBkgPTPdf::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_2033, ::Reflex::BaseOffset< ::CombBkgPTPdf, ::RooAbsPdf >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31840, type_31841), Reflex::Literal("operator="), operator_14715, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CombBkgPTPdf"), constructor_14716, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27660, type_27660, type_27660, type_27660, type_27660), Reflex::Literal("CombBkgPTPdf"), constructor_14717, 0, "name;title;_t;_a;_f;_alpha;_beta", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31841, type_4128), Reflex::Literal("CombBkgPTPdf"), constructor_14718, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CombBkgPTPdf"), destructor_14720, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2590, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x108, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CombBkgPTPdf_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CombBkgPTPdf_funcmem_bld);
}

//------Delayed data member builder for class CombBkgPTPdf -------------------
void __CombBkgPTPdf_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("t"), OffsetOf(__shadow__::__CombBkgPTPdf, t), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("a"), OffsetOf(__shadow__::__CombBkgPTPdf, a), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("f"), OffsetOf(__shadow__::__CombBkgPTPdf, f), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("alpha"), OffsetOf(__shadow__::__CombBkgPTPdf, alpha), ::Reflex::PROTECTED)
  .AddDataMember(type_1249, Reflex::Literal("beta"), OffsetOf(__shadow__::__CombBkgPTPdf, beta), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class CombBkgPTPdf -------------------
void __CombBkgPTPdf_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25463, type_4128), Reflex::Literal("clone"), method_14719, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_14721, 0, "allVars;integVars;range", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_14722, 0, "code;range", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_14725, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_14726, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_14727, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_14728, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_14729, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_14730, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_14731, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_14732, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_14733, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_14734, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_14735, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_14736, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RooBinnedFun -------------------------------
static  void operator_15382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooBinnedFun*)o)->operator=)(*(const ::RooBinnedFun*)arg[0]);
  else   (((::RooBinnedFun*)o)->operator=)(*(const ::RooBinnedFun*)arg[0]);
}

static void constructor_15383( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun();
  else ::new(mem) ::RooBinnedFun();
}

static void constructor_15384( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
  else ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const char*)arg[3],
      *(const ::RooArgList*)arg[4]);
}

static void constructor_15385( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3]);
  else ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(bool*)arg[4]);
  else ::new(mem) ::RooBinnedFun((const char*)arg[0],
      (const char*)arg[1],
      *(::RooRealVar*)arg[2],
      (const ::TH1*)arg[3],
      *(bool*)arg[4]);
  }
}

static void destructor_15386(void*, void * o, const std::vector<void*>&, void *) {
(((::RooBinnedFun*)o)->::RooBinnedFun::~RooBinnedFun)();
}
static void constructor_15387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun(*(const ::RooBinnedFun*)arg[0]);
  else ::new(mem) ::RooBinnedFun(*(const ::RooBinnedFun*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooBinnedFun(*(const ::RooBinnedFun*)arg[0],
      (const char*)arg[1]);
  else ::new(mem) ::RooBinnedFun(*(const ::RooBinnedFun*)arg[0],
      (const char*)arg[1]);
  }
}

static  void method_15388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedFun*)o)->clone)((const char*)arg[0]));
  else   (((const ::RooBinnedFun*)o)->clone)((const char*)arg[0]);
}

static  void method_15389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedFun*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]));
  else   (((const ::RooBinnedFun*)o)->getAnalyticalIntegral)(*(::RooArgSet*)arg[0],
    *(::RooArgSet*)arg[1],
    (const char*)arg[2]);
}

static  void method_15390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedFun*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]));
  else   (((const ::RooBinnedFun*)o)->analyticalIntegral)(*(::Int_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_15391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Int_t)((((const ::RooBinnedFun*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]));
  else   (((const ::RooBinnedFun*)o)->getMaxVal)(*(const ::RooArgSet*)arg[0]);
}

static  void method_15392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (Double_t)((((const ::RooBinnedFun*)o)->maxVal)(*(::Int_t*)arg[0]));
  else   (((const ::RooBinnedFun*)o)->maxVal)(*(::Int_t*)arg[0]);
}

static  void method_15393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedFun*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]));
  else   (((const ::RooBinnedFun*)o)->binBoundaries)(*(::RooAbsRealLValue*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2]);
}

static  void method_15394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::complex<double>)((((const ::RooBinnedFun*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]));
  else   (((const ::RooBinnedFun*)o)->productAnalyticalIntegral)(*(::Double_t*)arg[0],
    *(::Double_t*)arg[1],
    *(::Double_t*)arg[2],
    *(::Double_t*)arg[3],
    *(const ::std::complex<double>*)arg[4]);
}

static  void method_15395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::RooBinnedFun*)o)->coefficients)();
  else   (((const ::RooBinnedFun*)o)->coefficients)();
}

static  void method_15397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedFun*)o)->Class)());
  else   (((::RooBinnedFun*)o)->Class)();
}

static  void method_15398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedFun*)o)->Class_Name)());
  else   (((::RooBinnedFun*)o)->Class_Name)();
}

static  void method_15399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (Version_t)((((::RooBinnedFun*)o)->Class_Version)());
  else   (((::RooBinnedFun*)o)->Class_Version)();
}

static  void method_15400( void*, void* o, const std::vector<void*>&, void*)
{
  (((::RooBinnedFun*)o)->Dictionary)();
}

static  void method_15401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::RooBinnedFun*)o)->IsA)());
  else   (((const ::RooBinnedFun*)o)->IsA)();
}

static  void method_15402( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedFun*)o)->ShowMembers)(*(::TMemberInspector*)arg[0]);
}

static  void method_15403( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedFun*)o)->Streamer)(*(::TBuffer*)arg[0]);
}

static  void method_15404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::RooBinnedFun*)o)->StreamerNVirtual)(*(::TBuffer*)arg[0]);
}

static  void method_15405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedFun*)o)->DeclFileName)());
  else   (((::RooBinnedFun*)o)->DeclFileName)();
}

static  void method_15406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinnedFun*)o)->ImplFileLine)());
  else   (((::RooBinnedFun*)o)->ImplFileLine)();
}

static  void method_15407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::RooBinnedFun*)o)->ImplFileName)());
  else   (((::RooBinnedFun*)o)->ImplFileName)();
}

static  void method_15408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::RooBinnedFun*)o)->DeclFileLine)());
  else   (((::RooBinnedFun*)o)->DeclFileLine)();
}

static void method_newdel_2744( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooBinnedFun >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsGaussModelEfficiency")), ::Reflex::BaseOffset< ::RooBinnedFun,::RooAbsGaussModelEfficiency >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsReal")), ::Reflex::BaseOffset< ::RooBinnedFun,::RooAbsReal >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooAbsArg")), ::Reflex::BaseOffset< ::RooBinnedFun,::RooAbsArg >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TNamed")), ::Reflex::BaseOffset< ::RooBinnedFun,::TNamed >::Get(),::Reflex::PUBLIC), 3));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TObject")), ::Reflex::BaseOffset< ::RooBinnedFun,::TObject >::Get(),::Reflex::PUBLIC), 4));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("RooPrintable")), ::Reflex::BaseOffset< ::RooBinnedFun,::RooPrintable >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RooBinnedFun -------------------------------
void __RooBinnedFun_db_datamem(Reflex::Class*);
void __RooBinnedFun_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooBinnedFun_datamem_bld(&__RooBinnedFun_db_datamem);
Reflex::GenreflexMemberBuilder __RooBinnedFun_funcmem_bld(&__RooBinnedFun_db_funcmem);
void __RooBinnedFun_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooBinnedFun"), typeid(::RooBinnedFun), sizeof(::RooBinnedFun), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::RooBinnedFun::Class_Version())
  .AddProperty(Reflex::Literal("ClassDef"), 1)
  .AddBase(type_1672, ::Reflex::BaseOffset< ::RooBinnedFun, ::RooAbsGaussModelEfficiency >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31914, type_31915), Reflex::Literal("operator="), operator_15382, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RooBinnedFun"), constructor_15383, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_4128, type_27821), Reflex::Literal("RooBinnedFun"), constructor_15384, 0, "name;title;x;binningName;coefList", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4128, type_4128, type_27670, type_28133, type_667), Reflex::Literal("RooBinnedFun"), constructor_15385, 0, "name;title;x;hist;constCoeffs=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RooBinnedFun"), destructor_15386, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31915, type_4128), Reflex::Literal("RooBinnedFun"), constructor_15387, 0, "other;name=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2744, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooBinnedFun_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooBinnedFun_funcmem_bld);
}

//------Delayed data member builder for class RooBinnedFun -------------------
void __RooBinnedFun_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1249, Reflex::Literal("_x"), OffsetOf(__shadow__::__RooBinnedFun, _x), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("_coefList"), OffsetOf(__shadow__::__RooBinnedFun, _coefList), ::Reflex::PRIVATE)
  .AddDataMember(type_3089, Reflex::Literal("_u"), OffsetOf(__shadow__::__RooBinnedFun, _u), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RooBinnedFun -------------------
void __RooBinnedFun_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31916, type_4128), Reflex::Literal("clone"), method_15388, 0, "newname", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27678, type_27678, type_4128), Reflex::Literal("getAnalyticalIntegral"), method_15389, 0, "allVars;analVars;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309, type_4128), Reflex::Literal("analyticalIntegral"), method_15390, 0, "code;rangeName", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_27673), Reflex::Literal("getMaxVal"), method_15391, 0, "vars", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_1309), Reflex::Literal("maxVal"), method_15392, 0, "code", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27749, type_27750, type_2317, type_2317), Reflex::Literal("binBoundaries"), method_15393, 0, "obs;xlo;xhi", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3635, type_2317, type_2317, type_2317, type_2317, type_22775), Reflex::Literal("productAnalyticalIntegral"), method_15394, 0, "umin;umax;scale;offset;z", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27821), Reflex::Literal("coefficients"), method_15395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("Class"), method_15397, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("Class_Name"), method_15398, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2654), Reflex::Literal("Class_Version"), method_15399, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("Dictionary"), method_15400, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8018), Reflex::Literal("IsA"), method_15401, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_27661), Reflex::Literal("ShowMembers"), method_15402, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("Streamer"), method_15403, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_6045), Reflex::Literal("StreamerNVirtual"), method_15404, 0, "ClassDef_StreamerNVirtual_b", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("DeclFileName"), method_15405, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("ImplFileLine"), method_15406, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("ImplFileName"), method_15407, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_141), Reflex::Literal("DeclFileLine"), method_15408, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<double,std::allocator<double> > -------------------------------
static void constructor_17850( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>();
  else ::new(mem) ::std::vector<double>();
}

static void constructor_17851( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(const ::std::allocator<double>*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(const ::std::allocator<double>*)arg[0]);
}

static void constructor_17852( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1],
      *(const ::std::allocator<double>*)arg[2]);
  else ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1],
      *(const ::std::allocator<double>*)arg[2]);
  }
}

static void constructor_17853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(const ::std::vector<double>*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(const ::std::vector<double>*)arg[0]);
}

static void destructor_17854(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<double>*)o)->::std::vector<double>::~vector)();
}
static  void operator_17855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
  else   (((::std::vector<double>*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_17856( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const double*)arg[1]);
}

static  void method_17857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->begin)());
  else   (((::std::vector<double>*)o)->begin)();
}

static  void method_17858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::std::vector<double>*)o)->begin)());
  else   (((const ::std::vector<double>*)o)->begin)();
}

static  void method_17859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->end)());
  else   (((::std::vector<double>*)o)->end)();
}

static  void method_17860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::std::vector<double>*)o)->end)());
  else   (((const ::std::vector<double>*)o)->end)();
}

static  void method_17865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<double>*)o)->size)());
  else   (((const ::std::vector<double>*)o)->size)();
}

static  void method_17866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<double>*)o)->max_size)());
  else   (((const ::std::vector<double>*)o)->max_size)();
}

static  void method_17867( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<double>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<double>*)o)->resize)(*(::std::size_t*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_17868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<double>*)o)->capacity)());
  else   (((const ::std::vector<double>*)o)->capacity)();
}

static  void method_17869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<double>*)o)->empty)());
  else   (((const ::std::vector<double>*)o)->empty)();
}

static  void method_17870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_17871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_17872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->front)();
  else   (((::std::vector<double>*)o)->front)();
}

static  void method_17877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->front)();
  else   (((const ::std::vector<double>*)o)->front)();
}

static  void method_17878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->back)();
  else   (((::std::vector<double>*)o)->back)();
}

static  void method_17879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->back)();
  else   (((const ::std::vector<double>*)o)->back)();
}

static  void method_17880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<double>*)o)->data)());
  else   (((::std::vector<double>*)o)->data)();
}

static  void method_17881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<double>*)o)->data)());
  else   (((const ::std::vector<double>*)o)->data)();
}

static  void method_17882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->push_back)(*(const double*)arg[0]);
}

static  void method_17883( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<double>*)o)->pop_back)();
}

static  void method_17884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(const double*)arg[1]));
  else   (((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(const double*)arg[1]);
}

static  void method_17885( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const double*)arg[2]);
}

static  void method_17886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0]));
  else   (((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0]);
}

static  void method_17887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[1]));
  else   (((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[1]);
}

static  void method_17888( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->swap)(*(::std::vector<double>*)arg[0]);
}

static  void method_17889( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<double>*)o)->clear)();
}

static void method_newdel_3089( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<double,std::allocator<double> >")), ::Reflex::BaseOffset< ::std::vector<double>,::std::_Vector_base<double,std::allocator<double> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<double> >::Generate();
  else ::Reflex::Proxy< ::std::vector<double> >::Generate();
}

//------Dictionary for class vector<double,std::allocator<double> > -------------------------------
void __std__vector_double__db_datamem(Reflex::Class*);
void __std__vector_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_double__datamem_bld(&__std__vector_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_double__funcmem_bld(&__std__vector_double__db_funcmem);
void __std__vector_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<double>"), typeid(::std::vector<double>), sizeof(::std::vector<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3038, ::Reflex::BaseOffset< ::std::vector<double>, ::std::_Vector_base<double,std::allocator<double> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_694, Reflex::Literal("std::vector<double>::_Alloc_value_type"))
  .AddTypedef(type_3038, Reflex::Literal("std::vector<double>::_Base"))
  .AddTypedef(type_3676, Reflex::Literal("std::vector<double>::_Tp_alloc_type"))
  .AddTypedef(type_11033, Reflex::Literal("std::vector<double>::_Alloc_traits"))
  .AddTypedef(type_694, Reflex::Literal("std::vector<double>::value_type"))
  .AddTypedef(type_6336, Reflex::Literal("std::vector<double>::pointer"))
  .AddTypedef(type_17837, Reflex::Literal("std::vector<double>::const_pointer"))
  .AddTypedef(type_17839, Reflex::Literal("std::vector<double>::reference"))
  .AddTypedef(type_17841, Reflex::Literal("std::vector<double>::const_reference"))
  .AddTypedef(type_10880, Reflex::Literal("std::vector<double>::iterator"))
  .AddTypedef(type_10881, Reflex::Literal("std::vector<double>::const_iterator"))
  .AddTypedef(type_3940, Reflex::Literal("std::vector<double>::const_reverse_iterator"))
  .AddTypedef(type_3941, Reflex::Literal("std::vector<double>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<double>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<double>::difference_type"))
  .AddTypedef(type_3676, Reflex::Literal("std::vector<double>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_17850, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32329), Reflex::Literal("vector"), constructor_17851, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_17841, type_32329), Reflex::Literal("vector"), constructor_17852, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18881), Reflex::Literal("vector"), constructor_17853, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_17854, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3089, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_double__funcmem_bld);
}

//------Delayed data member builder for class vector<double,std::allocator<double> > -------------------
void __std__vector_double__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<double,std::allocator<double> > -------------------
void __std__vector_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18879, type_18881), Reflex::Literal("operator="), operator_17855, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_17841), Reflex::Literal("assign"), method_17856, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880), Reflex::Literal("begin"), method_17857, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10881), Reflex::Literal("begin"), method_17858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880), Reflex::Literal("end"), method_17859, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10881), Reflex::Literal("end"), method_17860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_17865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_17866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_694), Reflex::Literal("resize"), method_17867, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_17868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_17869, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_17870, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839, type_3404), Reflex::Literal("operator[]"), operator_17871, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841, type_3404), Reflex::Literal("operator[]"), operator_17872, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839, type_3404), Reflex::Literal("at"), method_17874, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841, type_3404), Reflex::Literal("at"), method_17875, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839), Reflex::Literal("front"), method_17876, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841), Reflex::Literal("front"), method_17877, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17839), Reflex::Literal("back"), method_17878, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17841), Reflex::Literal("back"), method_17879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6336), Reflex::Literal("data"), method_17880, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17837), Reflex::Literal("data"), method_17881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_17841), Reflex::Literal("push_back"), method_17882, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_17883, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880, type_10880, type_17841), Reflex::Literal("insert"), method_17884, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10880, type_3404, type_17841), Reflex::Literal("insert"), method_17885, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880, type_10880), Reflex::Literal("erase"), method_17886, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10880, type_10880, type_10880), Reflex::Literal("erase"), method_17887, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18879), Reflex::Literal("swap"), method_17888, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_17889, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class S_jk -------------------------------
static void destructor_28204(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineKnot::S_jk*)o)->::RooCubicSplineKnot::S_jk::~S_jk)();
}
static  void operator_28205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static void constructor_28206( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_jk();
  else ::new(mem) ::RooCubicSplineKnot::S_jk();
}

static void constructor_28207( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_jk(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::RooCubicSplineKnot::S_jk(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static void constructor_28208( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_jk(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot::S_jk(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_jk(*(const ::RooCubicSplineKnot::S_jk*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot::S_jk(*(const ::RooCubicSplineKnot::S_jk*)arg[0],
      *(double*)arg[1]);
  }
}

static  void operator_28209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator*=)(*(double*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator*=)(*(double*)arg[0]);
}

static  void operator_28210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator/=)(*(double*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator/=)(*(double*)arg[0]);
}

static  void operator_28211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator-)();
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator-)();
}

static  void operator_28212( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator+=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator+=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void operator_28213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_jk*)o)->operator-=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
  else   (((::RooCubicSplineKnot::S_jk*)o)->operator-=)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void operator_28214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot::S_jk*)o)->operator*)(*(double*)arg[0]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator*)(*(double*)arg[0]);
}

static  void operator_28215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot::S_jk*)o)->operator/)(*(double*)arg[0]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator/)(*(double*)arg[0]);
}

static  void operator_28216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot::S_jk*)o)->operator+)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator+)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void operator_28217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (RooCubicSplineKnot::S_jk)((((const ::RooCubicSplineKnot::S_jk*)o)->operator-)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator-)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void operator_28218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot::S_jk*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::RooCubicSplineKnot::S_jk*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]);
}

static void method_newdel_7149( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::S_jk >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class S_jk -------------------------------
void __RooCubicSplineKnot__S_jk_db_datamem(Reflex::Class*);
void __RooCubicSplineKnot__S_jk_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__S_jk_datamem_bld(&__RooCubicSplineKnot__S_jk_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__S_jk_funcmem_bld(&__RooCubicSplineKnot__S_jk_db_funcmem);
void __RooCubicSplineKnot__S_jk_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineKnot::S_jk"), typeid(::RooCubicSplineKnot::S_jk), sizeof(::RooCubicSplineKnot::S_jk), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~S_jk"), destructor_28204, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904, type_17906), Reflex::Literal("operator="), operator_28205, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("S_jk"), constructor_28206, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_694, type_694, type_694), Reflex::Literal("S_jk"), constructor_28207, 0, "a;b;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17906, type_694), Reflex::Literal("S_jk"), constructor_28208, 0, "other;offset=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7149, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineKnot__S_jk_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCubicSplineKnot__S_jk_funcmem_bld);
}

//------Delayed data member builder for class S_jk -------------------
void __RooCubicSplineKnot__S_jk_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_694, Reflex::Literal("t"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_jk, t), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("d"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_jk, d), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("s"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_jk, s), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("o"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_jk, o), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class S_jk -------------------
void __RooCubicSplineKnot__S_jk_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904, type_694), Reflex::Literal("operator*="), operator_28209, 0, "z", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904, type_694), Reflex::Literal("operator/="), operator_28210, 0, "z", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904), Reflex::Literal("operator-"), operator_28211, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904, type_17906), Reflex::Literal("operator+="), operator_28212, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904, type_17906), Reflex::Literal("operator-="), operator_28213, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7149, type_694), Reflex::Literal("operator*"), operator_28214, 0, "z", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7149, type_694), Reflex::Literal("operator/"), operator_28215, 0, "z", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7149, type_17906), Reflex::Literal("operator+"), operator_28216, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7149, type_17906), Reflex::Literal("operator-"), operator_28217, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_141, type_141), Reflex::Literal("operator()"), operator_28218, 0, "j;k", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class vector<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > -------------------------------
static void constructor_17915( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>();
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>();
}

static void constructor_17916( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(const ::std::allocator<RooCubicSplineKnot::S_jk>*)arg[0]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(const ::std::allocator<RooCubicSplineKnot::S_jk>*)arg[0]);
}

static void constructor_17917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0],
      *(const ::RooCubicSplineKnot::S_jk*)arg[1]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0],
      *(const ::RooCubicSplineKnot::S_jk*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0],
      *(const ::RooCubicSplineKnot::S_jk*)arg[1],
      *(const ::std::allocator<RooCubicSplineKnot::S_jk>*)arg[2]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(::std::size_t*)arg[0],
      *(const ::RooCubicSplineKnot::S_jk*)arg[1],
      *(const ::std::allocator<RooCubicSplineKnot::S_jk>*)arg[2]);
  }
}

static void constructor_17918( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(const ::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
  else ::new(mem) ::std::vector<RooCubicSplineKnot::S_jk>(*(const ::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
}

static void destructor_17919(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->::std::vector<RooCubicSplineKnot::S_jk>::~vector)();
}
static  void operator_17920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator=)(*(const ::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator=)(*(const ::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
}

static  void method_17921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RooCubicSplineKnot::S_jk*)arg[1]);
}

static  void method_17922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->begin)());
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->begin)();
}

static  void method_17923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->begin)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->begin)();
}

static  void method_17924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->end)());
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->end)();
}

static  void method_17925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->end)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->end)();
}

static  void method_17930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->size)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->size)();
}

static  void method_17931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->max_size)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->max_size)();
}

static  void method_17932( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RooCubicSplineKnot::S_jk*)arg[1]);
  }
}

static  void method_17933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->capacity)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->capacity)();
}

static  void method_17934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->empty)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->empty)();
}

static  void method_17935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_17936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_17937( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->front)();
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->front)();
}

static  void method_17942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->front)();
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->front)();
}

static  void method_17943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooCubicSplineKnot::S_jk>*)o)->back)();
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->back)();
}

static  void method_17944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->back)();
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->back)();
}

static  void method_17945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->data)());
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->data)();
}

static  void method_17946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->data)());
  else   (((const ::std::vector<RooCubicSplineKnot::S_jk>*)o)->data)();
}

static  void method_17947( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->push_back)(*(const ::RooCubicSplineKnot::S_jk*)arg[0]);
}

static  void method_17948( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->pop_back)();
}

static  void method_17949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(const ::RooCubicSplineKnot::S_jk*)arg[1]));
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(const ::RooCubicSplineKnot::S_jk*)arg[1]);
}

static  void method_17950( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RooCubicSplineKnot::S_jk*)arg[2]);
}

static  void method_17951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0]));
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0]);
}

static  void method_17952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >)((((::std::vector<RooCubicSplineKnot::S_jk>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[1]));
  else   (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooCubicSplineKnot::S_jk*,std::vector<RooCubicSplineKnot::S_jk> >*)arg[1]);
}

static  void method_17953( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->swap)(*(::std::vector<RooCubicSplineKnot::S_jk>*)arg[0]);
}

static  void method_17954( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooCubicSplineKnot::S_jk>*)o)->clear)();
}

static void method_newdel_3090( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooCubicSplineKnot::S_jk> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> >")), ::Reflex::BaseOffset< ::std::vector<RooCubicSplineKnot::S_jk>,::std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooCubicSplineKnot::S_jk> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooCubicSplineKnot::S_jk> >::Generate();
}

//------Dictionary for class vector<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > -------------------------------
void __std__vector_RooCubicSplineKnot__S_jk__db_datamem(Reflex::Class*);
void __std__vector_RooCubicSplineKnot__S_jk__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooCubicSplineKnot__S_jk__datamem_bld(&__std__vector_RooCubicSplineKnot__S_jk__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooCubicSplineKnot__S_jk__funcmem_bld(&__std__vector_RooCubicSplineKnot__S_jk__db_funcmem);
void __std__vector_RooCubicSplineKnot__S_jk__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>"), typeid(::std::vector<RooCubicSplineKnot::S_jk>), sizeof(::std::vector<RooCubicSplineKnot::S_jk>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3019, ::Reflex::BaseOffset< ::std::vector<RooCubicSplineKnot::S_jk>, ::std::_Vector_base<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7149, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::_Alloc_value_type"))
  .AddTypedef(type_3019, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::_Base"))
  .AddTypedef(type_3677, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::_Tp_alloc_type"))
  .AddTypedef(type_11014, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::_Alloc_traits"))
  .AddTypedef(type_7149, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::value_type"))
  .AddTypedef(type_17180, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::pointer"))
  .AddTypedef(type_17902, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::const_pointer"))
  .AddTypedef(type_17904, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::reference"))
  .AddTypedef(type_17906, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::const_reference"))
  .AddTypedef(type_10842, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::iterator"))
  .AddTypedef(type_10843, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::const_iterator"))
  .AddTypedef(type_3892, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::const_reverse_iterator"))
  .AddTypedef(type_3893, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::difference_type"))
  .AddTypedef(type_3677, Reflex::Literal("std::vector<RooCubicSplineKnot::S_jk>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_17915, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32082), Reflex::Literal("vector"), constructor_17916, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_17906, type_32082), Reflex::Literal("vector"), constructor_17917, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32515), Reflex::Literal("vector"), constructor_17918, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_17919, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3090, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooCubicSplineKnot__S_jk__funcmem_bld);
}

//------Delayed data member builder for class vector<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > -------------------
void __std__vector_RooCubicSplineKnot__S_jk__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooCubicSplineKnot::S_jk,std::allocator<RooCubicSplineKnot::S_jk> > -------------------
void __std__vector_RooCubicSplineKnot__S_jk__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32516, type_32515), Reflex::Literal("operator="), operator_17920, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_17906), Reflex::Literal("assign"), method_17921, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10842), Reflex::Literal("begin"), method_17922, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10843), Reflex::Literal("begin"), method_17923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10842), Reflex::Literal("end"), method_17924, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10843), Reflex::Literal("end"), method_17925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_17930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_17931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_7149), Reflex::Literal("resize"), method_17932, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_17933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_17934, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_17935, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904, type_3404), Reflex::Literal("operator[]"), operator_17936, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17906, type_3404), Reflex::Literal("operator[]"), operator_17937, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904, type_3404), Reflex::Literal("at"), method_17939, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17906, type_3404), Reflex::Literal("at"), method_17940, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904), Reflex::Literal("front"), method_17941, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17906), Reflex::Literal("front"), method_17942, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17904), Reflex::Literal("back"), method_17943, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17906), Reflex::Literal("back"), method_17944, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17180), Reflex::Literal("data"), method_17945, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17902), Reflex::Literal("data"), method_17946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_17906), Reflex::Literal("push_back"), method_17947, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_17948, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10842, type_10842, type_17906), Reflex::Literal("insert"), method_17949, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10842, type_3404, type_17906), Reflex::Literal("insert"), method_17950, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10842, type_10842), Reflex::Literal("erase"), method_17951, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10842, type_10842, type_10842), Reflex::Literal("erase"), method_17952, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32516), Reflex::Literal("swap"), method_17953, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_17954, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<float,std::allocator<float> > -------------------------------
static void constructor_17980( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>();
  else ::new(mem) ::std::vector<float>();
}

static void constructor_17981( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(const ::std::allocator<float>*)arg[0]);
  else ::new(mem) ::std::vector<float>(*(const ::std::allocator<float>*)arg[0]);
}

static void constructor_17982( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1],
      *(const ::std::allocator<float>*)arg[2]);
  else ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1],
      *(const ::std::allocator<float>*)arg[2]);
  }
}

static void constructor_17983( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(const ::std::vector<float>*)arg[0]);
  else ::new(mem) ::std::vector<float>(*(const ::std::vector<float>*)arg[0]);
}

static void destructor_17984(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<float>*)o)->::std::vector<float>::~vector)();
}
static  void operator_17985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->operator=)(*(const ::std::vector<float>*)arg[0]);
  else   (((::std::vector<float>*)o)->operator=)(*(const ::std::vector<float>*)arg[0]);
}

static  void method_17986( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const float*)arg[1]);
}

static  void method_17987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->begin)());
  else   (((::std::vector<float>*)o)->begin)();
}

static  void method_17988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const float*,std::vector<float> >)((((const ::std::vector<float>*)o)->begin)());
  else   (((const ::std::vector<float>*)o)->begin)();
}

static  void method_17989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->end)());
  else   (((::std::vector<float>*)o)->end)();
}

static  void method_17990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const float*,std::vector<float> >)((((const ::std::vector<float>*)o)->end)());
  else   (((const ::std::vector<float>*)o)->end)();
}

static  void method_17995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<float>*)o)->size)());
  else   (((const ::std::vector<float>*)o)->size)();
}

static  void method_17996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<float>*)o)->max_size)());
  else   (((const ::std::vector<float>*)o)->max_size)();
}

static  void method_17997( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<float>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<float>*)o)->resize)(*(::std::size_t*)arg[0],
      *(float*)arg[1]);
  }
}

static  void method_17998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<float>*)o)->capacity)());
  else   (((const ::std::vector<float>*)o)->capacity)();
}

static  void method_17999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<float>*)o)->empty)());
  else   (((const ::std::vector<float>*)o)->empty)();
}

static  void method_18000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18004( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18005( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->front)();
  else   (((::std::vector<float>*)o)->front)();
}

static  void method_18007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->front)();
  else   (((const ::std::vector<float>*)o)->front)();
}

static  void method_18008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->back)();
  else   (((::std::vector<float>*)o)->back)();
}

static  void method_18009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->back)();
  else   (((const ::std::vector<float>*)o)->back)();
}

static  void method_18010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<float>*)o)->data)());
  else   (((::std::vector<float>*)o)->data)();
}

static  void method_18011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<float>*)o)->data)());
  else   (((const ::std::vector<float>*)o)->data)();
}

static  void method_18012( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->push_back)(*(const float*)arg[0]);
}

static  void method_18013( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<float>*)o)->pop_back)();
}

static  void method_18014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(const float*)arg[1]));
  else   (((::std::vector<float>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(const float*)arg[1]);
}

static  void method_18015( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const float*)arg[2]);
}

static  void method_18016( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0]));
  else   (((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0]);
}

static  void method_18017( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[1]));
  else   (((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[1]);
}

static  void method_18018( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->swap)(*(::std::vector<float>*)arg[0]);
}

static  void method_18019( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<float>*)o)->clear)();
}

static void method_newdel_3091( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<float,std::allocator<float> >")), ::Reflex::BaseOffset< ::std::vector<float>,::std::_Vector_base<float,std::allocator<float> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<float> >::Generate();
  else ::Reflex::Proxy< ::std::vector<float> >::Generate();
}

//------Dictionary for class vector<float,std::allocator<float> > -------------------------------
void __std__vector_float__db_datamem(Reflex::Class*);
void __std__vector_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_float__datamem_bld(&__std__vector_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_float__funcmem_bld(&__std__vector_float__db_funcmem);
void __std__vector_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<float>"), typeid(::std::vector<float>), sizeof(::std::vector<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3020, ::Reflex::BaseOffset< ::std::vector<float>, ::std::_Vector_base<float,std::allocator<float> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_102, Reflex::Literal("std::vector<float>::_Alloc_value_type"))
  .AddTypedef(type_3020, Reflex::Literal("std::vector<float>::_Base"))
  .AddTypedef(type_3679, Reflex::Literal("std::vector<float>::_Tp_alloc_type"))
  .AddTypedef(type_11015, Reflex::Literal("std::vector<float>::_Alloc_traits"))
  .AddTypedef(type_102, Reflex::Literal("std::vector<float>::value_type"))
  .AddTypedef(type_6044, Reflex::Literal("std::vector<float>::pointer"))
  .AddTypedef(type_17967, Reflex::Literal("std::vector<float>::const_pointer"))
  .AddTypedef(type_17969, Reflex::Literal("std::vector<float>::reference"))
  .AddTypedef(type_17971, Reflex::Literal("std::vector<float>::const_reference"))
  .AddTypedef(type_10844, Reflex::Literal("std::vector<float>::iterator"))
  .AddTypedef(type_10845, Reflex::Literal("std::vector<float>::const_iterator"))
  .AddTypedef(type_3894, Reflex::Literal("std::vector<float>::const_reverse_iterator"))
  .AddTypedef(type_3895, Reflex::Literal("std::vector<float>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<float>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<float>::difference_type"))
  .AddTypedef(type_3679, Reflex::Literal("std::vector<float>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_17980, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32095), Reflex::Literal("vector"), constructor_17981, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_17971, type_32095), Reflex::Literal("vector"), constructor_17982, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32518), Reflex::Literal("vector"), constructor_17983, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_17984, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3091, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_float__funcmem_bld);
}

//------Delayed data member builder for class vector<float,std::allocator<float> > -------------------
void __std__vector_float__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<float,std::allocator<float> > -------------------
void __std__vector_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32519, type_32518), Reflex::Literal("operator="), operator_17985, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_17971), Reflex::Literal("assign"), method_17986, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10844), Reflex::Literal("begin"), method_17987, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10845), Reflex::Literal("begin"), method_17988, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10844), Reflex::Literal("end"), method_17989, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10845), Reflex::Literal("end"), method_17990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_17995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_17996, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_102), Reflex::Literal("resize"), method_17997, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_17998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_17999, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18000, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17969, type_3404), Reflex::Literal("operator[]"), operator_18001, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17971, type_3404), Reflex::Literal("operator[]"), operator_18002, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17969, type_3404), Reflex::Literal("at"), method_18004, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17971, type_3404), Reflex::Literal("at"), method_18005, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17969), Reflex::Literal("front"), method_18006, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17971), Reflex::Literal("front"), method_18007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17969), Reflex::Literal("back"), method_18008, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17971), Reflex::Literal("back"), method_18009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6044), Reflex::Literal("data"), method_18010, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17967), Reflex::Literal("data"), method_18011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_17971), Reflex::Literal("push_back"), method_18012, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18013, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10844, type_10844, type_17971), Reflex::Literal("insert"), method_18014, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10844, type_3404, type_17971), Reflex::Literal("insert"), method_18015, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10844, type_10844), Reflex::Literal("erase"), method_18016, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10844, type_10844, type_10844), Reflex::Literal("erase"), method_18017, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32519), Reflex::Literal("swap"), method_18018, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18019, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------------------
static void constructor_18045( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>();
  else ::new(mem) ::std::vector<unsigned long long>();
}

static void constructor_18046( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(const ::std::allocator<unsigned long long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long long>(*(const ::std::allocator<unsigned long long>*)arg[0]);
}

static void constructor_18047( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1]);
  else ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1],
      *(const ::std::allocator<unsigned long long>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1],
      *(const ::std::allocator<unsigned long long>*)arg[2]);
  }
}

static void constructor_18048( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(const ::std::vector<unsigned long long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long long>(*(const ::std::vector<unsigned long long>*)arg[0]);
}

static void destructor_18049(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned long long>*)o)->::std::vector<unsigned long long>::~vector)();
}
static  void operator_18050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->operator=)(*(const ::std::vector<unsigned long long>*)arg[0]);
  else   (((::std::vector<unsigned long long>*)o)->operator=)(*(const ::std::vector<unsigned long long>*)arg[0]);
}

static  void method_18051( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned long long*)arg[1]);
}

static  void method_18052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->begin)());
  else   (((::std::vector<unsigned long long>*)o)->begin)();
}

static  void method_18053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> >)((((const ::std::vector<unsigned long long>*)o)->begin)());
  else   (((const ::std::vector<unsigned long long>*)o)->begin)();
}

static  void method_18054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->end)());
  else   (((::std::vector<unsigned long long>*)o)->end)();
}

static  void method_18055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> >)((((const ::std::vector<unsigned long long>*)o)->end)());
  else   (((const ::std::vector<unsigned long long>*)o)->end)();
}

static  void method_18060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long long>*)o)->size)());
  else   (((const ::std::vector<unsigned long long>*)o)->size)();
}

static  void method_18061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long long>*)o)->max_size)());
  else   (((const ::std::vector<unsigned long long>*)o)->max_size)();
}

static  void method_18062( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned long long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned long long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned long long*)arg[1]);
  }
}

static  void method_18063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long long>*)o)->capacity)());
  else   (((const ::std::vector<unsigned long long>*)o)->capacity)();
}

static  void method_18064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned long long>*)o)->empty)());
  else   (((const ::std::vector<unsigned long long>*)o)->empty)();
}

static  void method_18065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->front)();
  else   (((::std::vector<unsigned long long>*)o)->front)();
}

static  void method_18072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->front)();
  else   (((const ::std::vector<unsigned long long>*)o)->front)();
}

static  void method_18073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->back)();
  else   (((::std::vector<unsigned long long>*)o)->back)();
}

static  void method_18074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->back)();
  else   (((const ::std::vector<unsigned long long>*)o)->back)();
}

static  void method_18075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned long long>*)o)->data)());
  else   (((::std::vector<unsigned long long>*)o)->data)();
}

static  void method_18076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned long long>*)o)->data)());
  else   (((const ::std::vector<unsigned long long>*)o)->data)();
}

static  void method_18077( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->push_back)(*(const unsigned long long*)arg[0]);
}

static  void method_18078( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long long>*)o)->pop_back)();
}

static  void method_18079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(const unsigned long long*)arg[1]));
  else   (((::std::vector<unsigned long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(const unsigned long long*)arg[1]);
}

static  void method_18080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned long long*)arg[2]);
}

static  void method_18081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0]));
  else   (((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0]);
}

static  void method_18082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[1]));
  else   (((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[1]);
}

static  void method_18083( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->swap)(*(::std::vector<unsigned long long>*)arg[0]);
}

static  void method_18084( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long long>*)o)->clear)();
}

static void method_newdel_3092( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long long,std::allocator<unsigned long long> >")), ::Reflex::BaseOffset< ::std::vector<unsigned long long>,::std::_Vector_base<unsigned long long,std::allocator<unsigned long long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x123( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned long long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned long long> >::Generate();
}

//------Dictionary for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------------------
void __std__vector_unsignedslongslong__db_datamem(Reflex::Class*);
void __std__vector_unsignedslongslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslongslong__datamem_bld(&__std__vector_unsignedslongslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslongslong__funcmem_bld(&__std__vector_unsignedslongslong__db_funcmem);
void __std__vector_unsignedslongslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned long long>"), typeid(::std::vector<unsigned long long>), sizeof(::std::vector<unsigned long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3021, ::Reflex::BaseOffset< ::std::vector<unsigned long long>, ::std::_Vector_base<unsigned long long,std::allocator<unsigned long long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_820, Reflex::Literal("std::vector<unsigned long long>::_Alloc_value_type"))
  .AddTypedef(type_3021, Reflex::Literal("std::vector<unsigned long long>::_Base"))
  .AddTypedef(type_3680, Reflex::Literal("std::vector<unsigned long long>::_Tp_alloc_type"))
  .AddTypedef(type_11016, Reflex::Literal("std::vector<unsigned long long>::_Alloc_traits"))
  .AddTypedef(type_820, Reflex::Literal("std::vector<unsigned long long>::value_type"))
  .AddTypedef(type_17217, Reflex::Literal("std::vector<unsigned long long>::pointer"))
  .AddTypedef(type_18032, Reflex::Literal("std::vector<unsigned long long>::const_pointer"))
  .AddTypedef(type_18034, Reflex::Literal("std::vector<unsigned long long>::reference"))
  .AddTypedef(type_18036, Reflex::Literal("std::vector<unsigned long long>::const_reference"))
  .AddTypedef(type_10846, Reflex::Literal("std::vector<unsigned long long>::iterator"))
  .AddTypedef(type_10847, Reflex::Literal("std::vector<unsigned long long>::const_iterator"))
  .AddTypedef(type_3896, Reflex::Literal("std::vector<unsigned long long>::const_reverse_iterator"))
  .AddTypedef(type_3897, Reflex::Literal("std::vector<unsigned long long>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<unsigned long long>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<unsigned long long>::difference_type"))
  .AddTypedef(type_3680, Reflex::Literal("std::vector<unsigned long long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18045, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32108), Reflex::Literal("vector"), constructor_18046, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18036, type_32108), Reflex::Literal("vector"), constructor_18047, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32521), Reflex::Literal("vector"), constructor_18048, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18049, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3092, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x123, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedslongslong__funcmem_bld);
}

//------Delayed data member builder for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------
void __std__vector_unsignedslongslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------
void __std__vector_unsignedslongslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32522, type_32521), Reflex::Literal("operator="), operator_18050, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18036), Reflex::Literal("assign"), method_18051, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10846), Reflex::Literal("begin"), method_18052, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10847), Reflex::Literal("begin"), method_18053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10846), Reflex::Literal("end"), method_18054, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10847), Reflex::Literal("end"), method_18055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_820), Reflex::Literal("resize"), method_18062, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18065, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18034, type_3404), Reflex::Literal("operator[]"), operator_18066, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18036, type_3404), Reflex::Literal("operator[]"), operator_18067, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18034, type_3404), Reflex::Literal("at"), method_18069, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18036, type_3404), Reflex::Literal("at"), method_18070, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18034), Reflex::Literal("front"), method_18071, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18036), Reflex::Literal("front"), method_18072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18034), Reflex::Literal("back"), method_18073, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18036), Reflex::Literal("back"), method_18074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17217), Reflex::Literal("data"), method_18075, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18032), Reflex::Literal("data"), method_18076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18036), Reflex::Literal("push_back"), method_18077, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18078, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10846, type_10846, type_18036), Reflex::Literal("insert"), method_18079, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10846, type_3404, type_18036), Reflex::Literal("insert"), method_18080, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10846, type_10846), Reflex::Literal("erase"), method_18081, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10846, type_10846, type_10846), Reflex::Literal("erase"), method_18082, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32522), Reflex::Literal("swap"), method_18083, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18084, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------------------
static void constructor_18110( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>();
  else ::new(mem) ::std::vector<unsigned long>();
}

static void constructor_18111( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(const ::std::allocator<unsigned long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long>(*(const ::std::allocator<unsigned long>*)arg[0]);
}

static void constructor_18112( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1]);
  else ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::allocator<unsigned long>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::allocator<unsigned long>*)arg[2]);
  }
}

static void constructor_18113( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(const ::std::vector<unsigned long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long>(*(const ::std::vector<unsigned long>*)arg[0]);
}

static void destructor_18114(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned long>*)o)->::std::vector<unsigned long>::~vector)();
}
static  void operator_18115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->operator=)(*(const ::std::vector<unsigned long>*)arg[0]);
  else   (((::std::vector<unsigned long>*)o)->operator=)(*(const ::std::vector<unsigned long>*)arg[0]);
}

static  void method_18116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned long*)arg[1]);
}

static  void method_18117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->begin)());
  else   (((::std::vector<unsigned long>*)o)->begin)();
}

static  void method_18118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >)((((const ::std::vector<unsigned long>*)o)->begin)());
  else   (((const ::std::vector<unsigned long>*)o)->begin)();
}

static  void method_18119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->end)());
  else   (((::std::vector<unsigned long>*)o)->end)();
}

static  void method_18120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >)((((const ::std::vector<unsigned long>*)o)->end)());
  else   (((const ::std::vector<unsigned long>*)o)->end)();
}

static  void method_18125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long>*)o)->size)());
  else   (((const ::std::vector<unsigned long>*)o)->size)();
}

static  void method_18126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long>*)o)->max_size)());
  else   (((const ::std::vector<unsigned long>*)o)->max_size)();
}

static  void method_18127( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned long*)arg[1]);
  }
}

static  void method_18128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long>*)o)->capacity)());
  else   (((const ::std::vector<unsigned long>*)o)->capacity)();
}

static  void method_18129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned long>*)o)->empty)());
  else   (((const ::std::vector<unsigned long>*)o)->empty)();
}

static  void method_18130( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->front)();
  else   (((::std::vector<unsigned long>*)o)->front)();
}

static  void method_18137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->front)();
  else   (((const ::std::vector<unsigned long>*)o)->front)();
}

static  void method_18138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->back)();
  else   (((::std::vector<unsigned long>*)o)->back)();
}

static  void method_18139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->back)();
  else   (((const ::std::vector<unsigned long>*)o)->back)();
}

static  void method_18140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned long>*)o)->data)());
  else   (((::std::vector<unsigned long>*)o)->data)();
}

static  void method_18141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned long>*)o)->data)());
  else   (((const ::std::vector<unsigned long>*)o)->data)();
}

static  void method_18142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->push_back)(*(const unsigned long*)arg[0]);
}

static  void method_18143( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long>*)o)->pop_back)();
}

static  void method_18144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(const unsigned long*)arg[1]));
  else   (((::std::vector<unsigned long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(const unsigned long*)arg[1]);
}

static  void method_18145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned long*)arg[2]);
}

static  void method_18146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0]));
  else   (((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0]);
}

static  void method_18147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[1]));
  else   (((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[1]);
}

static  void method_18148( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->swap)(*(::std::vector<unsigned long>*)arg[0]);
}

static  void method_18149( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long>*)o)->clear)();
}

static void method_newdel_3093( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x125( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long,std::allocator<unsigned long> >")), ::Reflex::BaseOffset< ::std::vector<unsigned long>,::std::_Vector_base<unsigned long,std::allocator<unsigned long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned long> >::Generate();
}

//------Dictionary for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------------------
void __std__vector_unsignedslong__db_datamem(Reflex::Class*);
void __std__vector_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslong__datamem_bld(&__std__vector_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslong__funcmem_bld(&__std__vector_unsignedslong__db_funcmem);
void __std__vector_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned long>"), typeid(::std::vector<unsigned long>), sizeof(::std::vector<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3022, ::Reflex::BaseOffset< ::std::vector<unsigned long>, ::std::_Vector_base<unsigned long,std::allocator<unsigned long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_167, Reflex::Literal("std::vector<unsigned long>::_Alloc_value_type"))
  .AddTypedef(type_3022, Reflex::Literal("std::vector<unsigned long>::_Base"))
  .AddTypedef(type_3681, Reflex::Literal("std::vector<unsigned long>::_Tp_alloc_type"))
  .AddTypedef(type_11017, Reflex::Literal("std::vector<unsigned long>::_Alloc_traits"))
  .AddTypedef(type_167, Reflex::Literal("std::vector<unsigned long>::value_type"))
  .AddTypedef(type_17236, Reflex::Literal("std::vector<unsigned long>::pointer"))
  .AddTypedef(type_18097, Reflex::Literal("std::vector<unsigned long>::const_pointer"))
  .AddTypedef(type_18099, Reflex::Literal("std::vector<unsigned long>::reference"))
  .AddTypedef(type_18101, Reflex::Literal("std::vector<unsigned long>::const_reference"))
  .AddTypedef(type_10848, Reflex::Literal("std::vector<unsigned long>::iterator"))
  .AddTypedef(type_10849, Reflex::Literal("std::vector<unsigned long>::const_iterator"))
  .AddTypedef(type_3898, Reflex::Literal("std::vector<unsigned long>::const_reverse_iterator"))
  .AddTypedef(type_3899, Reflex::Literal("std::vector<unsigned long>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<unsigned long>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<unsigned long>::difference_type"))
  .AddTypedef(type_3681, Reflex::Literal("std::vector<unsigned long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18110, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32121), Reflex::Literal("vector"), constructor_18111, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18101, type_32121), Reflex::Literal("vector"), constructor_18112, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32524), Reflex::Literal("vector"), constructor_18113, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18114, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3093, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------
void __std__vector_unsignedslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------
void __std__vector_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32525, type_32524), Reflex::Literal("operator="), operator_18115, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18101), Reflex::Literal("assign"), method_18116, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10848), Reflex::Literal("begin"), method_18117, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10849), Reflex::Literal("begin"), method_18118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10848), Reflex::Literal("end"), method_18119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10849), Reflex::Literal("end"), method_18120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_167), Reflex::Literal("resize"), method_18127, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18130, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18099, type_3404), Reflex::Literal("operator[]"), operator_18131, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18101, type_3404), Reflex::Literal("operator[]"), operator_18132, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18099, type_3404), Reflex::Literal("at"), method_18134, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18101, type_3404), Reflex::Literal("at"), method_18135, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18099), Reflex::Literal("front"), method_18136, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18101), Reflex::Literal("front"), method_18137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18099), Reflex::Literal("back"), method_18138, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18101), Reflex::Literal("back"), method_18139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17236), Reflex::Literal("data"), method_18140, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18097), Reflex::Literal("data"), method_18141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18101), Reflex::Literal("push_back"), method_18142, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18143, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10848, type_10848, type_18101), Reflex::Literal("insert"), method_18144, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10848, type_3404, type_18101), Reflex::Literal("insert"), method_18145, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10848, type_10848), Reflex::Literal("erase"), method_18146, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10848, type_10848, type_10848), Reflex::Literal("erase"), method_18147, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32525), Reflex::Literal("swap"), method_18148, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18149, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
static void constructor_18175( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>();
  else ::new(mem) ::std::vector<unsigned int>();
}

static void constructor_18176( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
}

static void constructor_18177( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  }
}

static void constructor_18178( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
}

static void destructor_18179(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned int>*)o)->::std::vector<unsigned int>::~vector)();
}
static  void operator_18180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
}

static  void method_18181( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_18182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->begin)());
  else   (((::std::vector<unsigned int>*)o)->begin)();
}

static  void method_18183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->begin)());
  else   (((const ::std::vector<unsigned int>*)o)->begin)();
}

static  void method_18184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->end)());
  else   (((::std::vector<unsigned int>*)o)->end)();
}

static  void method_18185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->end)());
  else   (((const ::std::vector<unsigned int>*)o)->end)();
}

static  void method_18190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->size)());
  else   (((const ::std::vector<unsigned int>*)o)->size)();
}

static  void method_18191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->max_size)());
  else   (((const ::std::vector<unsigned int>*)o)->max_size)();
}

static  void method_18192( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned int*)arg[1]);
  }
}

static  void method_18193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->capacity)());
  else   (((const ::std::vector<unsigned int>*)o)->capacity)();
}

static  void method_18194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned int>*)o)->empty)());
  else   (((const ::std::vector<unsigned int>*)o)->empty)();
}

static  void method_18195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->front)();
  else   (((::std::vector<unsigned int>*)o)->front)();
}

static  void method_18202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->front)();
  else   (((const ::std::vector<unsigned int>*)o)->front)();
}

static  void method_18203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->back)();
  else   (((::std::vector<unsigned int>*)o)->back)();
}

static  void method_18204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->back)();
  else   (((const ::std::vector<unsigned int>*)o)->back)();
}

static  void method_18205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned int>*)o)->data)());
  else   (((::std::vector<unsigned int>*)o)->data)();
}

static  void method_18206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned int>*)o)->data)());
  else   (((const ::std::vector<unsigned int>*)o)->data)();
}

static  void method_18207( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->push_back)(*(const unsigned int*)arg[0]);
}

static  void method_18208( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->pop_back)();
}

static  void method_18209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_18210( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned int*)arg[2]);
}

static  void method_18211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]);
}

static  void method_18212( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void method_18213( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->swap)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_18214( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->clear)();
}

static void method_newdel_3094( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >")), ::Reflex::BaseOffset< ::std::vector<unsigned int>,::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x129( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
}

//------Dictionary for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*);
void __std__vector_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__datamem_bld(&__std__vector_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__funcmem_bld(&__std__vector_unsignedsint__db_funcmem);
void __std__vector_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned int>"), typeid(::std::vector<unsigned int>), sizeof(::std::vector<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3023, ::Reflex::BaseOffset< ::std::vector<unsigned int>, ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_211, Reflex::Literal("std::vector<unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_3023, Reflex::Literal("std::vector<unsigned int>::_Base"))
  .AddTypedef(type_3682, Reflex::Literal("std::vector<unsigned int>::_Tp_alloc_type"))
  .AddTypedef(type_11018, Reflex::Literal("std::vector<unsigned int>::_Alloc_traits"))
  .AddTypedef(type_211, Reflex::Literal("std::vector<unsigned int>::value_type"))
  .AddTypedef(type_13933, Reflex::Literal("std::vector<unsigned int>::pointer"))
  .AddTypedef(type_18162, Reflex::Literal("std::vector<unsigned int>::const_pointer"))
  .AddTypedef(type_18164, Reflex::Literal("std::vector<unsigned int>::reference"))
  .AddTypedef(type_18166, Reflex::Literal("std::vector<unsigned int>::const_reference"))
  .AddTypedef(type_10850, Reflex::Literal("std::vector<unsigned int>::iterator"))
  .AddTypedef(type_10851, Reflex::Literal("std::vector<unsigned int>::const_iterator"))
  .AddTypedef(type_3900, Reflex::Literal("std::vector<unsigned int>::const_reverse_iterator"))
  .AddTypedef(type_3901, Reflex::Literal("std::vector<unsigned int>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<unsigned int>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<unsigned int>::difference_type"))
  .AddTypedef(type_3682, Reflex::Literal("std::vector<unsigned int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18175, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32134), Reflex::Literal("vector"), constructor_18176, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18166, type_32134), Reflex::Literal("vector"), constructor_18177, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32527), Reflex::Literal("vector"), constructor_18178, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18179, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3094, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x129, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32528, type_32527), Reflex::Literal("operator="), operator_18180, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18166), Reflex::Literal("assign"), method_18181, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10850), Reflex::Literal("begin"), method_18182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10851), Reflex::Literal("begin"), method_18183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10850), Reflex::Literal("end"), method_18184, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10851), Reflex::Literal("end"), method_18185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_211), Reflex::Literal("resize"), method_18192, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18195, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18164, type_3404), Reflex::Literal("operator[]"), operator_18196, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18166, type_3404), Reflex::Literal("operator[]"), operator_18197, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18164, type_3404), Reflex::Literal("at"), method_18199, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18166, type_3404), Reflex::Literal("at"), method_18200, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18164), Reflex::Literal("front"), method_18201, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18166), Reflex::Literal("front"), method_18202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18164), Reflex::Literal("back"), method_18203, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18166), Reflex::Literal("back"), method_18204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13933), Reflex::Literal("data"), method_18205, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18162), Reflex::Literal("data"), method_18206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18166), Reflex::Literal("push_back"), method_18207, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18208, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10850, type_10850, type_18166), Reflex::Literal("insert"), method_18209, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10850, type_3404, type_18166), Reflex::Literal("insert"), method_18210, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10850, type_10850), Reflex::Literal("erase"), method_18211, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10850, type_10850, type_10850), Reflex::Literal("erase"), method_18212, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32528), Reflex::Literal("swap"), method_18213, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18214, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------------------
static void constructor_18240( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>();
  else ::new(mem) ::std::vector<unsigned short>();
}

static void constructor_18241( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(const ::std::allocator<unsigned short>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short>(*(const ::std::allocator<unsigned short>*)arg[0]);
}

static void constructor_18242( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1]);
  else ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1],
      *(const ::std::allocator<unsigned short>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1],
      *(const ::std::allocator<unsigned short>*)arg[2]);
  }
}

static void constructor_18243( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(const ::std::vector<unsigned short>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short>(*(const ::std::vector<unsigned short>*)arg[0]);
}

static void destructor_18244(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned short>*)o)->::std::vector<unsigned short>::~vector)();
}
static  void operator_18245( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->operator=)(*(const ::std::vector<unsigned short>*)arg[0]);
  else   (((::std::vector<unsigned short>*)o)->operator=)(*(const ::std::vector<unsigned short>*)arg[0]);
}

static  void method_18246( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned short*)arg[1]);
}

static  void method_18247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->begin)());
  else   (((::std::vector<unsigned short>*)o)->begin)();
}

static  void method_18248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >)((((const ::std::vector<unsigned short>*)o)->begin)());
  else   (((const ::std::vector<unsigned short>*)o)->begin)();
}

static  void method_18249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->end)());
  else   (((::std::vector<unsigned short>*)o)->end)();
}

static  void method_18250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >)((((const ::std::vector<unsigned short>*)o)->end)());
  else   (((const ::std::vector<unsigned short>*)o)->end)();
}

static  void method_18255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short>*)o)->size)());
  else   (((const ::std::vector<unsigned short>*)o)->size)();
}

static  void method_18256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short>*)o)->max_size)());
  else   (((const ::std::vector<unsigned short>*)o)->max_size)();
}

static  void method_18257( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned short>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned short>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned short*)arg[1]);
  }
}

static  void method_18258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short>*)o)->capacity)());
  else   (((const ::std::vector<unsigned short>*)o)->capacity)();
}

static  void method_18259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned short>*)o)->empty)());
  else   (((const ::std::vector<unsigned short>*)o)->empty)();
}

static  void method_18260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->front)();
  else   (((::std::vector<unsigned short>*)o)->front)();
}

static  void method_18267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->front)();
  else   (((const ::std::vector<unsigned short>*)o)->front)();
}

static  void method_18268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->back)();
  else   (((::std::vector<unsigned short>*)o)->back)();
}

static  void method_18269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->back)();
  else   (((const ::std::vector<unsigned short>*)o)->back)();
}

static  void method_18270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned short>*)o)->data)());
  else   (((::std::vector<unsigned short>*)o)->data)();
}

static  void method_18271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned short>*)o)->data)());
  else   (((const ::std::vector<unsigned short>*)o)->data)();
}

static  void method_18272( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->push_back)(*(const unsigned short*)arg[0]);
}

static  void method_18273( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned short>*)o)->pop_back)();
}

static  void method_18274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(const unsigned short*)arg[1]));
  else   (((::std::vector<unsigned short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(const unsigned short*)arg[1]);
}

static  void method_18275( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned short*)arg[2]);
}

static  void method_18276( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0]));
  else   (((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0]);
}

static  void method_18277( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[1]));
  else   (((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[1]);
}

static  void method_18278( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->swap)(*(::std::vector<unsigned short>*)arg[0]);
}

static  void method_18279( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned short>*)o)->clear)();
}

static void method_newdel_3095( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x131( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned short,std::allocator<unsigned short> >")), ::Reflex::BaseOffset< ::std::vector<unsigned short>,::std::_Vector_base<unsigned short,std::allocator<unsigned short> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x132( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned short> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned short> >::Generate();
}

//------Dictionary for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------------------
void __std__vector_unsignedsshort__db_datamem(Reflex::Class*);
void __std__vector_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsshort__datamem_bld(&__std__vector_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsshort__funcmem_bld(&__std__vector_unsignedsshort__db_funcmem);
void __std__vector_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned short>"), typeid(::std::vector<unsigned short>), sizeof(::std::vector<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3024, ::Reflex::BaseOffset< ::std::vector<unsigned short>, ::std::_Vector_base<unsigned short,std::allocator<unsigned short> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_311, Reflex::Literal("std::vector<unsigned short>::_Alloc_value_type"))
  .AddTypedef(type_3024, Reflex::Literal("std::vector<unsigned short>::_Base"))
  .AddTypedef(type_3683, Reflex::Literal("std::vector<unsigned short>::_Tp_alloc_type"))
  .AddTypedef(type_11019, Reflex::Literal("std::vector<unsigned short>::_Alloc_traits"))
  .AddTypedef(type_311, Reflex::Literal("std::vector<unsigned short>::value_type"))
  .AddTypedef(type_4399, Reflex::Literal("std::vector<unsigned short>::pointer"))
  .AddTypedef(type_18227, Reflex::Literal("std::vector<unsigned short>::const_pointer"))
  .AddTypedef(type_18229, Reflex::Literal("std::vector<unsigned short>::reference"))
  .AddTypedef(type_18231, Reflex::Literal("std::vector<unsigned short>::const_reference"))
  .AddTypedef(type_10852, Reflex::Literal("std::vector<unsigned short>::iterator"))
  .AddTypedef(type_10853, Reflex::Literal("std::vector<unsigned short>::const_iterator"))
  .AddTypedef(type_3902, Reflex::Literal("std::vector<unsigned short>::const_reverse_iterator"))
  .AddTypedef(type_3903, Reflex::Literal("std::vector<unsigned short>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<unsigned short>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<unsigned short>::difference_type"))
  .AddTypedef(type_3683, Reflex::Literal("std::vector<unsigned short>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18240, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32147), Reflex::Literal("vector"), constructor_18241, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18231, type_32147), Reflex::Literal("vector"), constructor_18242, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32530), Reflex::Literal("vector"), constructor_18243, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18244, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3095, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x131, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x132, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsshort__funcmem_bld);
}

//------Delayed data member builder for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------
void __std__vector_unsignedsshort__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------
void __std__vector_unsignedsshort__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32531, type_32530), Reflex::Literal("operator="), operator_18245, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18231), Reflex::Literal("assign"), method_18246, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852), Reflex::Literal("begin"), method_18247, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10853), Reflex::Literal("begin"), method_18248, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852), Reflex::Literal("end"), method_18249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10853), Reflex::Literal("end"), method_18250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_311), Reflex::Literal("resize"), method_18257, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18259, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18260, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18229, type_3404), Reflex::Literal("operator[]"), operator_18261, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18231, type_3404), Reflex::Literal("operator[]"), operator_18262, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18229, type_3404), Reflex::Literal("at"), method_18264, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18231, type_3404), Reflex::Literal("at"), method_18265, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18229), Reflex::Literal("front"), method_18266, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18231), Reflex::Literal("front"), method_18267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18229), Reflex::Literal("back"), method_18268, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18231), Reflex::Literal("back"), method_18269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4399), Reflex::Literal("data"), method_18270, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18227), Reflex::Literal("data"), method_18271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18231), Reflex::Literal("push_back"), method_18272, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18273, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852, type_10852, type_18231), Reflex::Literal("insert"), method_18274, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10852, type_3404, type_18231), Reflex::Literal("insert"), method_18275, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852, type_10852), Reflex::Literal("erase"), method_18276, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10852, type_10852, type_10852), Reflex::Literal("erase"), method_18277, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32531), Reflex::Literal("swap"), method_18278, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18279, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned char,std::allocator<unsigned char> > -------------------------------
static void constructor_18305( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>();
  else ::new(mem) ::std::vector<unsigned char>();
}

static void constructor_18306( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(const ::std::allocator<unsigned char>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char>(*(const ::std::allocator<unsigned char>*)arg[0]);
}

static void constructor_18307( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1]);
  else ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1],
      *(const ::std::allocator<unsigned char>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1],
      *(const ::std::allocator<unsigned char>*)arg[2]);
  }
}

static void constructor_18308( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(const ::std::vector<unsigned char>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char>(*(const ::std::vector<unsigned char>*)arg[0]);
}

static void destructor_18309(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned char>*)o)->::std::vector<unsigned char>::~vector)();
}
static  void operator_18310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->operator=)(*(const ::std::vector<unsigned char>*)arg[0]);
  else   (((::std::vector<unsigned char>*)o)->operator=)(*(const ::std::vector<unsigned char>*)arg[0]);
}

static  void method_18311( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned char*)arg[1]);
}

static  void method_18312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->begin)());
  else   (((::std::vector<unsigned char>*)o)->begin)();
}

static  void method_18313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> >)((((const ::std::vector<unsigned char>*)o)->begin)());
  else   (((const ::std::vector<unsigned char>*)o)->begin)();
}

static  void method_18314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->end)());
  else   (((::std::vector<unsigned char>*)o)->end)();
}

static  void method_18315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> >)((((const ::std::vector<unsigned char>*)o)->end)());
  else   (((const ::std::vector<unsigned char>*)o)->end)();
}

static  void method_18320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char>*)o)->size)());
  else   (((const ::std::vector<unsigned char>*)o)->size)();
}

static  void method_18321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char>*)o)->max_size)());
  else   (((const ::std::vector<unsigned char>*)o)->max_size)();
}

static  void method_18322( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned char>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned char>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned char*)arg[1]);
  }
}

static  void method_18323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char>*)o)->capacity)());
  else   (((const ::std::vector<unsigned char>*)o)->capacity)();
}

static  void method_18324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned char>*)o)->empty)());
  else   (((const ::std::vector<unsigned char>*)o)->empty)();
}

static  void method_18325( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18330( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->front)();
  else   (((::std::vector<unsigned char>*)o)->front)();
}

static  void method_18332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->front)();
  else   (((const ::std::vector<unsigned char>*)o)->front)();
}

static  void method_18333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->back)();
  else   (((::std::vector<unsigned char>*)o)->back)();
}

static  void method_18334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->back)();
  else   (((const ::std::vector<unsigned char>*)o)->back)();
}

static  void method_18335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned char>*)o)->data)());
  else   (((::std::vector<unsigned char>*)o)->data)();
}

static  void method_18336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned char>*)o)->data)());
  else   (((const ::std::vector<unsigned char>*)o)->data)();
}

static  void method_18337( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->push_back)(*(const unsigned char*)arg[0]);
}

static  void method_18338( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned char>*)o)->pop_back)();
}

static  void method_18339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(const unsigned char*)arg[1]));
  else   (((::std::vector<unsigned char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(const unsigned char*)arg[1]);
}

static  void method_18340( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned char*)arg[2]);
}

static  void method_18341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0]));
  else   (((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0]);
}

static  void method_18342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[1]));
  else   (((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[1]);
}

static  void method_18343( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->swap)(*(::std::vector<unsigned char>*)arg[0]);
}

static  void method_18344( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned char>*)o)->clear)();
}

static void method_newdel_3096( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x134( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned char,std::allocator<unsigned char> >")), ::Reflex::BaseOffset< ::std::vector<unsigned char>,::std::_Vector_base<unsigned char,std::allocator<unsigned char> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned char> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned char> >::Generate();
}

//------Dictionary for class vector<unsigned char,std::allocator<unsigned char> > -------------------------------
void __std__vector_unsignedschar__db_datamem(Reflex::Class*);
void __std__vector_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedschar__datamem_bld(&__std__vector_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedschar__funcmem_bld(&__std__vector_unsignedschar__db_funcmem);
void __std__vector_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned char>"), typeid(::std::vector<unsigned char>), sizeof(::std::vector<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3025, ::Reflex::BaseOffset< ::std::vector<unsigned char>, ::std::_Vector_base<unsigned char,std::allocator<unsigned char> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_291, Reflex::Literal("std::vector<unsigned char>::_Alloc_value_type"))
  .AddTypedef(type_3025, Reflex::Literal("std::vector<unsigned char>::_Base"))
  .AddTypedef(type_3684, Reflex::Literal("std::vector<unsigned char>::_Tp_alloc_type"))
  .AddTypedef(type_11020, Reflex::Literal("std::vector<unsigned char>::_Alloc_traits"))
  .AddTypedef(type_291, Reflex::Literal("std::vector<unsigned char>::value_type"))
  .AddTypedef(type_17291, Reflex::Literal("std::vector<unsigned char>::pointer"))
  .AddTypedef(type_18292, Reflex::Literal("std::vector<unsigned char>::const_pointer"))
  .AddTypedef(type_18294, Reflex::Literal("std::vector<unsigned char>::reference"))
  .AddTypedef(type_18296, Reflex::Literal("std::vector<unsigned char>::const_reference"))
  .AddTypedef(type_10854, Reflex::Literal("std::vector<unsigned char>::iterator"))
  .AddTypedef(type_10855, Reflex::Literal("std::vector<unsigned char>::const_iterator"))
  .AddTypedef(type_3904, Reflex::Literal("std::vector<unsigned char>::const_reverse_iterator"))
  .AddTypedef(type_3905, Reflex::Literal("std::vector<unsigned char>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<unsigned char>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<unsigned char>::difference_type"))
  .AddTypedef(type_3684, Reflex::Literal("std::vector<unsigned char>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18305, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32160), Reflex::Literal("vector"), constructor_18306, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18296, type_32160), Reflex::Literal("vector"), constructor_18307, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32533), Reflex::Literal("vector"), constructor_18308, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18309, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3096, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedschar__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned char,std::allocator<unsigned char> > -------------------
void __std__vector_unsignedschar__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned char,std::allocator<unsigned char> > -------------------
void __std__vector_unsignedschar__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32534, type_32533), Reflex::Literal("operator="), operator_18310, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18296), Reflex::Literal("assign"), method_18311, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854), Reflex::Literal("begin"), method_18312, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10855), Reflex::Literal("begin"), method_18313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854), Reflex::Literal("end"), method_18314, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10855), Reflex::Literal("end"), method_18315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18320, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18321, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_291), Reflex::Literal("resize"), method_18322, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18324, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18325, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18294, type_3404), Reflex::Literal("operator[]"), operator_18326, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18296, type_3404), Reflex::Literal("operator[]"), operator_18327, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18294, type_3404), Reflex::Literal("at"), method_18329, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18296, type_3404), Reflex::Literal("at"), method_18330, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18294), Reflex::Literal("front"), method_18331, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18296), Reflex::Literal("front"), method_18332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18294), Reflex::Literal("back"), method_18333, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18296), Reflex::Literal("back"), method_18334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17291), Reflex::Literal("data"), method_18335, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18292), Reflex::Literal("data"), method_18336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18296), Reflex::Literal("push_back"), method_18337, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18338, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854, type_10854, type_18296), Reflex::Literal("insert"), method_18339, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10854, type_3404, type_18296), Reflex::Literal("insert"), method_18340, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854, type_10854), Reflex::Literal("erase"), method_18341, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10854, type_10854, type_10854), Reflex::Literal("erase"), method_18342, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32534), Reflex::Literal("swap"), method_18343, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18344, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long long int,std::allocator<long long int> > -------------------------------
static void constructor_18370( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>();
  else ::new(mem) ::std::vector<long long>();
}

static void constructor_18371( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(const ::std::allocator<long long>*)arg[0]);
  else ::new(mem) ::std::vector<long long>(*(const ::std::allocator<long long>*)arg[0]);
}

static void constructor_18372( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1]);
  else ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1],
      *(const ::std::allocator<long long>*)arg[2]);
  else ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1],
      *(const ::std::allocator<long long>*)arg[2]);
  }
}

static void constructor_18373( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(const ::std::vector<long long>*)arg[0]);
  else ::new(mem) ::std::vector<long long>(*(const ::std::vector<long long>*)arg[0]);
}

static void destructor_18374(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<long long>*)o)->::std::vector<long long>::~vector)();
}
static  void operator_18375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->operator=)(*(const ::std::vector<long long>*)arg[0]);
  else   (((::std::vector<long long>*)o)->operator=)(*(const ::std::vector<long long>*)arg[0]);
}

static  void method_18376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const long long*)arg[1]);
}

static  void method_18377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->begin)());
  else   (((::std::vector<long long>*)o)->begin)();
}

static  void method_18378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> >)((((const ::std::vector<long long>*)o)->begin)());
  else   (((const ::std::vector<long long>*)o)->begin)();
}

static  void method_18379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->end)());
  else   (((::std::vector<long long>*)o)->end)();
}

static  void method_18380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> >)((((const ::std::vector<long long>*)o)->end)());
  else   (((const ::std::vector<long long>*)o)->end)();
}

static  void method_18385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long long>*)o)->size)());
  else   (((const ::std::vector<long long>*)o)->size)();
}

static  void method_18386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long long>*)o)->max_size)());
  else   (((const ::std::vector<long long>*)o)->max_size)();
}

static  void method_18387( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<long long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<long long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(long long*)arg[1]);
  }
}

static  void method_18388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long long>*)o)->capacity)());
  else   (((const ::std::vector<long long>*)o)->capacity)();
}

static  void method_18389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<long long>*)o)->empty)());
  else   (((const ::std::vector<long long>*)o)->empty)();
}

static  void method_18390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18395( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->front)();
  else   (((::std::vector<long long>*)o)->front)();
}

static  void method_18397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->front)();
  else   (((const ::std::vector<long long>*)o)->front)();
}

static  void method_18398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->back)();
  else   (((::std::vector<long long>*)o)->back)();
}

static  void method_18399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->back)();
  else   (((const ::std::vector<long long>*)o)->back)();
}

static  void method_18400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<long long>*)o)->data)());
  else   (((::std::vector<long long>*)o)->data)();
}

static  void method_18401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<long long>*)o)->data)());
  else   (((const ::std::vector<long long>*)o)->data)();
}

static  void method_18402( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->push_back)(*(const long long*)arg[0]);
}

static  void method_18403( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long long>*)o)->pop_back)();
}

static  void method_18404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(const long long*)arg[1]));
  else   (((::std::vector<long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(const long long*)arg[1]);
}

static  void method_18405( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const long long*)arg[2]);
}

static  void method_18406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0]));
  else   (((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0]);
}

static  void method_18407( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[1]));
  else   (((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[1]);
}

static  void method_18408( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->swap)(*(::std::vector<long long>*)arg[0]);
}

static  void method_18409( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long long>*)o)->clear)();
}

static void method_newdel_3097( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x137( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long long,std::allocator<long long> >")), ::Reflex::BaseOffset< ::std::vector<long long>,::std::_Vector_base<long long,std::allocator<long long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<long long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<long long> >::Generate();
}

//------Dictionary for class vector<long long int,std::allocator<long long int> > -------------------------------
void __std__vector_longslong__db_datamem(Reflex::Class*);
void __std__vector_longslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_longslong__datamem_bld(&__std__vector_longslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_longslong__funcmem_bld(&__std__vector_longslong__db_funcmem);
void __std__vector_longslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<long long>"), typeid(::std::vector<long long>), sizeof(::std::vector<long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3026, ::Reflex::BaseOffset< ::std::vector<long long>, ::std::_Vector_base<long long,std::allocator<long long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2017, Reflex::Literal("std::vector<long long>::_Alloc_value_type"))
  .AddTypedef(type_3026, Reflex::Literal("std::vector<long long>::_Base"))
  .AddTypedef(type_3685, Reflex::Literal("std::vector<long long>::_Tp_alloc_type"))
  .AddTypedef(type_11021, Reflex::Literal("std::vector<long long>::_Alloc_traits"))
  .AddTypedef(type_2017, Reflex::Literal("std::vector<long long>::value_type"))
  .AddTypedef(type_17310, Reflex::Literal("std::vector<long long>::pointer"))
  .AddTypedef(type_18357, Reflex::Literal("std::vector<long long>::const_pointer"))
  .AddTypedef(type_18359, Reflex::Literal("std::vector<long long>::reference"))
  .AddTypedef(type_18361, Reflex::Literal("std::vector<long long>::const_reference"))
  .AddTypedef(type_10856, Reflex::Literal("std::vector<long long>::iterator"))
  .AddTypedef(type_10857, Reflex::Literal("std::vector<long long>::const_iterator"))
  .AddTypedef(type_3906, Reflex::Literal("std::vector<long long>::const_reverse_iterator"))
  .AddTypedef(type_3907, Reflex::Literal("std::vector<long long>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<long long>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<long long>::difference_type"))
  .AddTypedef(type_3685, Reflex::Literal("std::vector<long long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18370, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32173), Reflex::Literal("vector"), constructor_18371, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18361, type_32173), Reflex::Literal("vector"), constructor_18372, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32536), Reflex::Literal("vector"), constructor_18373, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18374, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3097, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x137, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_longslong__funcmem_bld);
}

//------Delayed data member builder for class vector<long long int,std::allocator<long long int> > -------------------
void __std__vector_longslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long long int,std::allocator<long long int> > -------------------
void __std__vector_longslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32537, type_32536), Reflex::Literal("operator="), operator_18375, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18361), Reflex::Literal("assign"), method_18376, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856), Reflex::Literal("begin"), method_18377, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10857), Reflex::Literal("begin"), method_18378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856), Reflex::Literal("end"), method_18379, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10857), Reflex::Literal("end"), method_18380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_2017), Reflex::Literal("resize"), method_18387, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18389, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18390, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18359, type_3404), Reflex::Literal("operator[]"), operator_18391, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18361, type_3404), Reflex::Literal("operator[]"), operator_18392, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18359, type_3404), Reflex::Literal("at"), method_18394, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18361, type_3404), Reflex::Literal("at"), method_18395, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18359), Reflex::Literal("front"), method_18396, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18361), Reflex::Literal("front"), method_18397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18359), Reflex::Literal("back"), method_18398, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18361), Reflex::Literal("back"), method_18399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17310), Reflex::Literal("data"), method_18400, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18357), Reflex::Literal("data"), method_18401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18361), Reflex::Literal("push_back"), method_18402, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18403, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856, type_10856, type_18361), Reflex::Literal("insert"), method_18404, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10856, type_3404, type_18361), Reflex::Literal("insert"), method_18405, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856, type_10856), Reflex::Literal("erase"), method_18406, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10856, type_10856, type_10856), Reflex::Literal("erase"), method_18407, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32537), Reflex::Literal("swap"), method_18408, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18409, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long int,std::allocator<long int> > -------------------------------
static void constructor_18435( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>();
  else ::new(mem) ::std::vector<long>();
}

static void constructor_18436( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(const ::std::allocator<long>*)arg[0]);
  else ::new(mem) ::std::vector<long>(*(const ::std::allocator<long>*)arg[0]);
}

static void constructor_18437( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1]);
  else ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1],
      *(const ::std::allocator<long>*)arg[2]);
  else ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1],
      *(const ::std::allocator<long>*)arg[2]);
  }
}

static void constructor_18438( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(const ::std::vector<long>*)arg[0]);
  else ::new(mem) ::std::vector<long>(*(const ::std::vector<long>*)arg[0]);
}

static void destructor_18439(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<long>*)o)->::std::vector<long>::~vector)();
}
static  void operator_18440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->operator=)(*(const ::std::vector<long>*)arg[0]);
  else   (((::std::vector<long>*)o)->operator=)(*(const ::std::vector<long>*)arg[0]);
}

static  void method_18441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const long*)arg[1]);
}

static  void method_18442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->begin)());
  else   (((::std::vector<long>*)o)->begin)();
}

static  void method_18443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long*,std::vector<long> >)((((const ::std::vector<long>*)o)->begin)());
  else   (((const ::std::vector<long>*)o)->begin)();
}

static  void method_18444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->end)());
  else   (((::std::vector<long>*)o)->end)();
}

static  void method_18445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long*,std::vector<long> >)((((const ::std::vector<long>*)o)->end)());
  else   (((const ::std::vector<long>*)o)->end)();
}

static  void method_18450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long>*)o)->size)());
  else   (((const ::std::vector<long>*)o)->size)();
}

static  void method_18451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long>*)o)->max_size)());
  else   (((const ::std::vector<long>*)o)->max_size)();
}

static  void method_18452( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(long*)arg[1]);
  }
}

static  void method_18453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long>*)o)->capacity)());
  else   (((const ::std::vector<long>*)o)->capacity)();
}

static  void method_18454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<long>*)o)->empty)());
  else   (((const ::std::vector<long>*)o)->empty)();
}

static  void method_18455( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18460( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->front)();
  else   (((::std::vector<long>*)o)->front)();
}

static  void method_18462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->front)();
  else   (((const ::std::vector<long>*)o)->front)();
}

static  void method_18463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->back)();
  else   (((::std::vector<long>*)o)->back)();
}

static  void method_18464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->back)();
  else   (((const ::std::vector<long>*)o)->back)();
}

static  void method_18465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<long>*)o)->data)());
  else   (((::std::vector<long>*)o)->data)();
}

static  void method_18466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<long>*)o)->data)());
  else   (((const ::std::vector<long>*)o)->data)();
}

static  void method_18467( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->push_back)(*(const long*)arg[0]);
}

static  void method_18468( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long>*)o)->pop_back)();
}

static  void method_18469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(const long*)arg[1]));
  else   (((::std::vector<long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(const long*)arg[1]);
}

static  void method_18470( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const long*)arg[2]);
}

static  void method_18471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0]));
  else   (((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0]);
}

static  void method_18472( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[1]));
  else   (((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[1]);
}

static  void method_18473( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->swap)(*(::std::vector<long>*)arg[0]);
}

static  void method_18474( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long>*)o)->clear)();
}

static void method_newdel_3098( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long,std::allocator<long> >")), ::Reflex::BaseOffset< ::std::vector<long>,::std::_Vector_base<long,std::allocator<long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<long> >::Generate();
}

//------Dictionary for class vector<long int,std::allocator<long int> > -------------------------------
void __std__vector_long__db_datamem(Reflex::Class*);
void __std__vector_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_long__datamem_bld(&__std__vector_long__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_long__funcmem_bld(&__std__vector_long__db_funcmem);
void __std__vector_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<long>"), typeid(::std::vector<long>), sizeof(::std::vector<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3027, ::Reflex::BaseOffset< ::std::vector<long>, ::std::_Vector_base<long,std::allocator<long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_194, Reflex::Literal("std::vector<long>::_Alloc_value_type"))
  .AddTypedef(type_3027, Reflex::Literal("std::vector<long>::_Base"))
  .AddTypedef(type_3686, Reflex::Literal("std::vector<long>::_Tp_alloc_type"))
  .AddTypedef(type_11022, Reflex::Literal("std::vector<long>::_Alloc_traits"))
  .AddTypedef(type_194, Reflex::Literal("std::vector<long>::value_type"))
  .AddTypedef(type_9454, Reflex::Literal("std::vector<long>::pointer"))
  .AddTypedef(type_18422, Reflex::Literal("std::vector<long>::const_pointer"))
  .AddTypedef(type_18424, Reflex::Literal("std::vector<long>::reference"))
  .AddTypedef(type_18426, Reflex::Literal("std::vector<long>::const_reference"))
  .AddTypedef(type_10858, Reflex::Literal("std::vector<long>::iterator"))
  .AddTypedef(type_10859, Reflex::Literal("std::vector<long>::const_iterator"))
  .AddTypedef(type_3908, Reflex::Literal("std::vector<long>::const_reverse_iterator"))
  .AddTypedef(type_3909, Reflex::Literal("std::vector<long>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<long>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<long>::difference_type"))
  .AddTypedef(type_3686, Reflex::Literal("std::vector<long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18435, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32186), Reflex::Literal("vector"), constructor_18436, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18426, type_32186), Reflex::Literal("vector"), constructor_18437, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32538), Reflex::Literal("vector"), constructor_18438, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18439, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3098, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_long__funcmem_bld);
}

//------Delayed data member builder for class vector<long int,std::allocator<long int> > -------------------
void __std__vector_long__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long int,std::allocator<long int> > -------------------
void __std__vector_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32539, type_32538), Reflex::Literal("operator="), operator_18440, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18426), Reflex::Literal("assign"), method_18441, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858), Reflex::Literal("begin"), method_18442, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10859), Reflex::Literal("begin"), method_18443, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858), Reflex::Literal("end"), method_18444, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10859), Reflex::Literal("end"), method_18445, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_194), Reflex::Literal("resize"), method_18452, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18455, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18424, type_3404), Reflex::Literal("operator[]"), operator_18456, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18426, type_3404), Reflex::Literal("operator[]"), operator_18457, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18424, type_3404), Reflex::Literal("at"), method_18459, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18426, type_3404), Reflex::Literal("at"), method_18460, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18424), Reflex::Literal("front"), method_18461, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18426), Reflex::Literal("front"), method_18462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18424), Reflex::Literal("back"), method_18463, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18426), Reflex::Literal("back"), method_18464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9454), Reflex::Literal("data"), method_18465, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18422), Reflex::Literal("data"), method_18466, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18426), Reflex::Literal("push_back"), method_18467, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18468, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858, type_10858, type_18426), Reflex::Literal("insert"), method_18469, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10858, type_3404, type_18426), Reflex::Literal("insert"), method_18470, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858, type_10858), Reflex::Literal("erase"), method_18471, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10858, type_10858, type_10858), Reflex::Literal("erase"), method_18472, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32539), Reflex::Literal("swap"), method_18473, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18474, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<int,std::allocator<int> > -------------------------------
static void constructor_18500( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>();
  else ::new(mem) ::std::vector<int>();
}

static void constructor_18501( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(const ::std::allocator<int>*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(const ::std::allocator<int>*)arg[0]);
}

static void constructor_18502( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  }
}

static void constructor_18503( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(const ::std::vector<int>*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(const ::std::vector<int>*)arg[0]);
}

static void destructor_18504(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<int>*)o)->::std::vector<int>::~vector)();
}
static  void operator_18505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->operator=)(*(const ::std::vector<int>*)arg[0]);
  else   (((::std::vector<int>*)o)->operator=)(*(const ::std::vector<int>*)arg[0]);
}

static  void method_18506( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const int*)arg[1]);
}

static  void method_18507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->begin)());
  else   (((::std::vector<int>*)o)->begin)();
}

static  void method_18508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const int*,std::vector<int> >)((((const ::std::vector<int>*)o)->begin)());
  else   (((const ::std::vector<int>*)o)->begin)();
}

static  void method_18509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->end)());
  else   (((::std::vector<int>*)o)->end)();
}

static  void method_18510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const int*,std::vector<int> >)((((const ::std::vector<int>*)o)->end)());
  else   (((const ::std::vector<int>*)o)->end)();
}

static  void method_18515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->size)());
  else   (((const ::std::vector<int>*)o)->size)();
}

static  void method_18516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->max_size)());
  else   (((const ::std::vector<int>*)o)->max_size)();
}

static  void method_18517( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_18518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->capacity)());
  else   (((const ::std::vector<int>*)o)->capacity)();
}

static  void method_18519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<int>*)o)->empty)());
  else   (((const ::std::vector<int>*)o)->empty)();
}

static  void method_18520( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->front)();
  else   (((::std::vector<int>*)o)->front)();
}

static  void method_18527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->front)();
  else   (((const ::std::vector<int>*)o)->front)();
}

static  void method_18528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->back)();
  else   (((::std::vector<int>*)o)->back)();
}

static  void method_18529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->back)();
  else   (((const ::std::vector<int>*)o)->back)();
}

static  void method_18530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<int>*)o)->data)());
  else   (((::std::vector<int>*)o)->data)();
}

static  void method_18531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<int>*)o)->data)());
  else   (((const ::std::vector<int>*)o)->data)();
}

static  void method_18532( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->push_back)(*(const int*)arg[0]);
}

static  void method_18533( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<int>*)o)->pop_back)();
}

static  void method_18534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(const int*)arg[1]));
  else   (((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(const int*)arg[1]);
}

static  void method_18535( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const int*)arg[2]);
}

static  void method_18536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0]));
  else   (((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0]);
}

static  void method_18537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[1]));
  else   (((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[1]);
}

static  void method_18538( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->swap)(*(::std::vector<int>*)arg[0]);
}

static  void method_18539( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<int>*)o)->clear)();
}

static void method_newdel_3099( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<int,std::allocator<int> >")), ::Reflex::BaseOffset< ::std::vector<int>,::std::_Vector_base<int,std::allocator<int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x144( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<int> >::Generate();
}

//------Dictionary for class vector<int,std::allocator<int> > -------------------------------
void __std__vector_int__db_datamem(Reflex::Class*);
void __std__vector_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_int__datamem_bld(&__std__vector_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_int__funcmem_bld(&__std__vector_int__db_funcmem);
void __std__vector_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<int>"), typeid(::std::vector<int>), sizeof(::std::vector<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3036, ::Reflex::BaseOffset< ::std::vector<int>, ::std::_Vector_base<int,std::allocator<int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_141, Reflex::Literal("std::vector<int>::_Alloc_value_type"))
  .AddTypedef(type_3036, Reflex::Literal("std::vector<int>::_Base"))
  .AddTypedef(type_3687, Reflex::Literal("std::vector<int>::_Tp_alloc_type"))
  .AddTypedef(type_11031, Reflex::Literal("std::vector<int>::_Alloc_traits"))
  .AddTypedef(type_141, Reflex::Literal("std::vector<int>::value_type"))
  .AddTypedef(type_4130, Reflex::Literal("std::vector<int>::pointer"))
  .AddTypedef(type_18487, Reflex::Literal("std::vector<int>::const_pointer"))
  .AddTypedef(type_18489, Reflex::Literal("std::vector<int>::reference"))
  .AddTypedef(type_18491, Reflex::Literal("std::vector<int>::const_reference"))
  .AddTypedef(type_10876, Reflex::Literal("std::vector<int>::iterator"))
  .AddTypedef(type_10877, Reflex::Literal("std::vector<int>::const_iterator"))
  .AddTypedef(type_3934, Reflex::Literal("std::vector<int>::const_reverse_iterator"))
  .AddTypedef(type_3935, Reflex::Literal("std::vector<int>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<int>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<int>::difference_type"))
  .AddTypedef(type_3687, Reflex::Literal("std::vector<int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18500, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32303), Reflex::Literal("vector"), constructor_18501, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18491, type_32303), Reflex::Literal("vector"), constructor_18502, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19594), Reflex::Literal("vector"), constructor_18503, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18504, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3099, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x144, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_int__funcmem_bld);
}

//------Delayed data member builder for class vector<int,std::allocator<int> > -------------------
void __std__vector_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<int,std::allocator<int> > -------------------
void __std__vector_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19592, type_19594), Reflex::Literal("operator="), operator_18505, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18491), Reflex::Literal("assign"), method_18506, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876), Reflex::Literal("begin"), method_18507, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10877), Reflex::Literal("begin"), method_18508, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876), Reflex::Literal("end"), method_18509, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10877), Reflex::Literal("end"), method_18510, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18516, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_141), Reflex::Literal("resize"), method_18517, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18520, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18489, type_3404), Reflex::Literal("operator[]"), operator_18521, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18491, type_3404), Reflex::Literal("operator[]"), operator_18522, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18489, type_3404), Reflex::Literal("at"), method_18524, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18491, type_3404), Reflex::Literal("at"), method_18525, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18489), Reflex::Literal("front"), method_18526, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18491), Reflex::Literal("front"), method_18527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18489), Reflex::Literal("back"), method_18528, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18491), Reflex::Literal("back"), method_18529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4130), Reflex::Literal("data"), method_18530, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18487), Reflex::Literal("data"), method_18531, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18491), Reflex::Literal("push_back"), method_18532, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18533, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876, type_10876, type_18491), Reflex::Literal("insert"), method_18534, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10876, type_3404, type_18491), Reflex::Literal("insert"), method_18535, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876, type_10876), Reflex::Literal("erase"), method_18536, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10876, type_10876, type_10876), Reflex::Literal("erase"), method_18537, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19592), Reflex::Literal("swap"), method_18538, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18539, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<short int,std::allocator<short int> > -------------------------------
static void constructor_18565( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>();
  else ::new(mem) ::std::vector<short>();
}

static void constructor_18566( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(const ::std::allocator<short>*)arg[0]);
  else ::new(mem) ::std::vector<short>(*(const ::std::allocator<short>*)arg[0]);
}

static void constructor_18567( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1]);
  else ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1],
      *(const ::std::allocator<short>*)arg[2]);
  else ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1],
      *(const ::std::allocator<short>*)arg[2]);
  }
}

static void constructor_18568( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(const ::std::vector<short>*)arg[0]);
  else ::new(mem) ::std::vector<short>(*(const ::std::vector<short>*)arg[0]);
}

static void destructor_18569(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<short>*)o)->::std::vector<short>::~vector)();
}
static  void operator_18570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->operator=)(*(const ::std::vector<short>*)arg[0]);
  else   (((::std::vector<short>*)o)->operator=)(*(const ::std::vector<short>*)arg[0]);
}

static  void method_18571( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const short*)arg[1]);
}

static  void method_18572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->begin)());
  else   (((::std::vector<short>*)o)->begin)();
}

static  void method_18573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const short*,std::vector<short> >)((((const ::std::vector<short>*)o)->begin)());
  else   (((const ::std::vector<short>*)o)->begin)();
}

static  void method_18574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->end)());
  else   (((::std::vector<short>*)o)->end)();
}

static  void method_18575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const short*,std::vector<short> >)((((const ::std::vector<short>*)o)->end)());
  else   (((const ::std::vector<short>*)o)->end)();
}

static  void method_18580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<short>*)o)->size)());
  else   (((const ::std::vector<short>*)o)->size)();
}

static  void method_18581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<short>*)o)->max_size)());
  else   (((const ::std::vector<short>*)o)->max_size)();
}

static  void method_18582( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<short>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<short>*)o)->resize)(*(::std::size_t*)arg[0],
      *(short*)arg[1]);
  }
}

static  void method_18583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<short>*)o)->capacity)());
  else   (((const ::std::vector<short>*)o)->capacity)();
}

static  void method_18584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<short>*)o)->empty)());
  else   (((const ::std::vector<short>*)o)->empty)();
}

static  void method_18585( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->front)();
  else   (((::std::vector<short>*)o)->front)();
}

static  void method_18592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->front)();
  else   (((const ::std::vector<short>*)o)->front)();
}

static  void method_18593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->back)();
  else   (((::std::vector<short>*)o)->back)();
}

static  void method_18594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->back)();
  else   (((const ::std::vector<short>*)o)->back)();
}

static  void method_18595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<short>*)o)->data)());
  else   (((::std::vector<short>*)o)->data)();
}

static  void method_18596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<short>*)o)->data)());
  else   (((const ::std::vector<short>*)o)->data)();
}

static  void method_18597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->push_back)(*(const short*)arg[0]);
}

static  void method_18598( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<short>*)o)->pop_back)();
}

static  void method_18599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(const short*)arg[1]));
  else   (((::std::vector<short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(const short*)arg[1]);
}

static  void method_18600( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const short*)arg[2]);
}

static  void method_18601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0]));
  else   (((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0]);
}

static  void method_18602( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[1]));
  else   (((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[1]);
}

static  void method_18603( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->swap)(*(::std::vector<short>*)arg[0]);
}

static  void method_18604( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<short>*)o)->clear)();
}

static void method_newdel_3100( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x146( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<short,std::allocator<short> >")), ::Reflex::BaseOffset< ::std::vector<short>,::std::_Vector_base<short,std::allocator<short> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x147( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<short> >::Generate();
  else ::Reflex::Proxy< ::std::vector<short> >::Generate();
}

//------Dictionary for class vector<short int,std::allocator<short int> > -------------------------------
void __std__vector_short__db_datamem(Reflex::Class*);
void __std__vector_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_short__datamem_bld(&__std__vector_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_short__funcmem_bld(&__std__vector_short__db_funcmem);
void __std__vector_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<short>"), typeid(::std::vector<short>), sizeof(::std::vector<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3028, ::Reflex::BaseOffset< ::std::vector<short>, ::std::_Vector_base<short,std::allocator<short> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_196, Reflex::Literal("std::vector<short>::_Alloc_value_type"))
  .AddTypedef(type_3028, Reflex::Literal("std::vector<short>::_Base"))
  .AddTypedef(type_3688, Reflex::Literal("std::vector<short>::_Tp_alloc_type"))
  .AddTypedef(type_11023, Reflex::Literal("std::vector<short>::_Alloc_traits"))
  .AddTypedef(type_196, Reflex::Literal("std::vector<short>::value_type"))
  .AddTypedef(type_17347, Reflex::Literal("std::vector<short>::pointer"))
  .AddTypedef(type_18552, Reflex::Literal("std::vector<short>::const_pointer"))
  .AddTypedef(type_18554, Reflex::Literal("std::vector<short>::reference"))
  .AddTypedef(type_18556, Reflex::Literal("std::vector<short>::const_reference"))
  .AddTypedef(type_10860, Reflex::Literal("std::vector<short>::iterator"))
  .AddTypedef(type_10861, Reflex::Literal("std::vector<short>::const_iterator"))
  .AddTypedef(type_3910, Reflex::Literal("std::vector<short>::const_reverse_iterator"))
  .AddTypedef(type_3911, Reflex::Literal("std::vector<short>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<short>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<short>::difference_type"))
  .AddTypedef(type_3688, Reflex::Literal("std::vector<short>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18565, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32199), Reflex::Literal("vector"), constructor_18566, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18556, type_32199), Reflex::Literal("vector"), constructor_18567, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32541), Reflex::Literal("vector"), constructor_18568, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18569, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x146, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_short__funcmem_bld);
}

//------Delayed data member builder for class vector<short int,std::allocator<short int> > -------------------
void __std__vector_short__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<short int,std::allocator<short int> > -------------------
void __std__vector_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32542, type_32541), Reflex::Literal("operator="), operator_18570, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18556), Reflex::Literal("assign"), method_18571, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860), Reflex::Literal("begin"), method_18572, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10861), Reflex::Literal("begin"), method_18573, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860), Reflex::Literal("end"), method_18574, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10861), Reflex::Literal("end"), method_18575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_196), Reflex::Literal("resize"), method_18582, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18585, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18554, type_3404), Reflex::Literal("operator[]"), operator_18586, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18556, type_3404), Reflex::Literal("operator[]"), operator_18587, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18554, type_3404), Reflex::Literal("at"), method_18589, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18556, type_3404), Reflex::Literal("at"), method_18590, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18554), Reflex::Literal("front"), method_18591, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18556), Reflex::Literal("front"), method_18592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18554), Reflex::Literal("back"), method_18593, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18556), Reflex::Literal("back"), method_18594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17347), Reflex::Literal("data"), method_18595, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18552), Reflex::Literal("data"), method_18596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18556), Reflex::Literal("push_back"), method_18597, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18598, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860, type_10860, type_18556), Reflex::Literal("insert"), method_18599, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10860, type_3404, type_18556), Reflex::Literal("insert"), method_18600, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860, type_10860), Reflex::Literal("erase"), method_18601, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10860, type_10860, type_10860), Reflex::Literal("erase"), method_18602, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32542), Reflex::Literal("swap"), method_18603, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18604, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<char,std::allocator<char> > -------------------------------
static void constructor_18629( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>();
  else ::new(mem) ::std::vector<char>();
}

static void constructor_18630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::vector<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_18631( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1]);
  else ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_18632( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(const ::std::vector<char>*)arg[0]);
  else ::new(mem) ::std::vector<char>(*(const ::std::vector<char>*)arg[0]);
}

static void destructor_18633(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<char>*)o)->::std::vector<char>::~vector)();
}
static  void operator_18634( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->operator=)(*(const ::std::vector<char>*)arg[0]);
  else   (((::std::vector<char>*)o)->operator=)(*(const ::std::vector<char>*)arg[0]);
}

static  void method_18635( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const char*)arg[1]);
}

static  void method_18636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->begin)());
  else   (((::std::vector<char>*)o)->begin)();
}

static  void method_18637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::vector<char> >)((((const ::std::vector<char>*)o)->begin)());
  else   (((const ::std::vector<char>*)o)->begin)();
}

static  void method_18638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->end)());
  else   (((::std::vector<char>*)o)->end)();
}

static  void method_18639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::vector<char> >)((((const ::std::vector<char>*)o)->end)());
  else   (((const ::std::vector<char>*)o)->end)();
}

static  void method_18644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char>*)o)->size)());
  else   (((const ::std::vector<char>*)o)->size)();
}

static  void method_18645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char>*)o)->max_size)());
  else   (((const ::std::vector<char>*)o)->max_size)();
}

static  void method_18646( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<char>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<char>*)o)->resize)(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  }
}

static  void method_18647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char>*)o)->capacity)());
  else   (((const ::std::vector<char>*)o)->capacity)();
}

static  void method_18648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<char>*)o)->empty)());
  else   (((const ::std::vector<char>*)o)->empty)();
}

static  void method_18649( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->front)();
  else   (((::std::vector<char>*)o)->front)();
}

static  void method_18656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->front)();
  else   (((const ::std::vector<char>*)o)->front)();
}

static  void method_18657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->back)();
  else   (((::std::vector<char>*)o)->back)();
}

static  void method_18658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->back)();
  else   (((const ::std::vector<char>*)o)->back)();
}

static  void method_18659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<char>*)o)->data)());
  else   (((::std::vector<char>*)o)->data)();
}

static  void method_18660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<char>*)o)->data)());
  else   (((const ::std::vector<char>*)o)->data)();
}

static  void method_18661( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->push_back)(*(const char*)arg[0]);
}

static  void method_18662( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<char>*)o)->pop_back)();
}

static  void method_18663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(const char*)arg[1]));
  else   (((::std::vector<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(const char*)arg[1]);
}

static  void method_18664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const char*)arg[2]);
}

static  void method_18665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0]));
  else   (((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0]);
}

static  void method_18666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[1]));
  else   (((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[1]);
}

static  void method_18667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->swap)(*(::std::vector<char>*)arg[0]);
}

static  void method_18668( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<char>*)o)->clear)();
}

static void method_newdel_3101( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x149( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<char,std::allocator<char> >")), ::Reflex::BaseOffset< ::std::vector<char>,::std::_Vector_base<char,std::allocator<char> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<char> >::Generate();
  else ::Reflex::Proxy< ::std::vector<char> >::Generate();
}

//------Dictionary for class vector<char,std::allocator<char> > -------------------------------
void __std__vector_char__db_datamem(Reflex::Class*);
void __std__vector_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_char__datamem_bld(&__std__vector_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_char__funcmem_bld(&__std__vector_char__db_funcmem);
void __std__vector_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<char>"), typeid(::std::vector<char>), sizeof(::std::vector<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3029, ::Reflex::BaseOffset< ::std::vector<char>, ::std::_Vector_base<char,std::allocator<char> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1039, Reflex::Literal("std::vector<char>::_Alloc_value_type"))
  .AddTypedef(type_3029, Reflex::Literal("std::vector<char>::_Base"))
  .AddTypedef(type_3689, Reflex::Literal("std::vector<char>::_Tp_alloc_type"))
  .AddTypedef(type_11024, Reflex::Literal("std::vector<char>::_Alloc_traits"))
  .AddTypedef(type_1039, Reflex::Literal("std::vector<char>::value_type"))
  .AddTypedef(type_2786, Reflex::Literal("std::vector<char>::pointer"))
  .AddTypedef(type_4128, Reflex::Literal("std::vector<char>::const_pointer"))
  .AddTypedef(type_18618, Reflex::Literal("std::vector<char>::reference"))
  .AddTypedef(type_18620, Reflex::Literal("std::vector<char>::const_reference"))
  .AddTypedef(type_10862, Reflex::Literal("std::vector<char>::iterator"))
  .AddTypedef(type_10863, Reflex::Literal("std::vector<char>::const_iterator"))
  .AddTypedef(type_3912, Reflex::Literal("std::vector<char>::const_reverse_iterator"))
  .AddTypedef(type_3913, Reflex::Literal("std::vector<char>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<char>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<char>::difference_type"))
  .AddTypedef(type_3689, Reflex::Literal("std::vector<char>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18629, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32212), Reflex::Literal("vector"), constructor_18630, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18620, type_32212), Reflex::Literal("vector"), constructor_18631, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32543), Reflex::Literal("vector"), constructor_18632, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18633, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x149, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_char__funcmem_bld);
}

//------Delayed data member builder for class vector<char,std::allocator<char> > -------------------
void __std__vector_char__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<char,std::allocator<char> > -------------------
void __std__vector_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32544, type_32543), Reflex::Literal("operator="), operator_18634, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18620), Reflex::Literal("assign"), method_18635, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862), Reflex::Literal("begin"), method_18636, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10863), Reflex::Literal("begin"), method_18637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862), Reflex::Literal("end"), method_18638, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10863), Reflex::Literal("end"), method_18639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18644, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_1039), Reflex::Literal("resize"), method_18646, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18649, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618, type_3404), Reflex::Literal("operator[]"), operator_18650, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18620, type_3404), Reflex::Literal("operator[]"), operator_18651, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618, type_3404), Reflex::Literal("at"), method_18653, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18620, type_3404), Reflex::Literal("at"), method_18654, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618), Reflex::Literal("front"), method_18655, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18620), Reflex::Literal("front"), method_18656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18618), Reflex::Literal("back"), method_18657, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18620), Reflex::Literal("back"), method_18658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2786), Reflex::Literal("data"), method_18659, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4128), Reflex::Literal("data"), method_18660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18620), Reflex::Literal("push_back"), method_18661, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18662, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862, type_10862, type_18620), Reflex::Literal("insert"), method_18663, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10862, type_3404, type_18620), Reflex::Literal("insert"), method_18664, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862, type_10862), Reflex::Literal("erase"), method_18665, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10862, type_10862, type_10862), Reflex::Literal("erase"), method_18666, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32544), Reflex::Literal("swap"), method_18667, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18668, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooFitResult*,std::allocator<RooFitResult*> > -------------------------------
static void constructor_18695( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>();
  else ::new(mem) ::std::vector<RooFitResult*>();
}

static void constructor_18696( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(const ::std::allocator<RooFitResult*>*)arg[0]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(const ::std::allocator<RooFitResult*>*)arg[0]);
}

static void constructor_18697( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0],
      *(::RooFitResult* const*)arg[1]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0],
      *(::RooFitResult* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0],
      *(::RooFitResult* const*)arg[1],
      *(const ::std::allocator<RooFitResult*>*)arg[2]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(::std::size_t*)arg[0],
      *(::RooFitResult* const*)arg[1],
      *(const ::std::allocator<RooFitResult*>*)arg[2]);
  }
}

static void constructor_18698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooFitResult*>(*(const ::std::vector<RooFitResult*>*)arg[0]);
  else ::new(mem) ::std::vector<RooFitResult*>(*(const ::std::vector<RooFitResult*>*)arg[0]);
}

static void destructor_18699(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooFitResult*>*)o)->::std::vector<RooFitResult*>::~vector)();
}
static  void operator_18700( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->operator=)(*(const ::std::vector<RooFitResult*>*)arg[0]);
  else   (((::std::vector<RooFitResult*>*)o)->operator=)(*(const ::std::vector<RooFitResult*>*)arg[0]);
}

static  void method_18701( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooFitResult* const*)arg[1]);
}

static  void method_18702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->begin)());
  else   (((::std::vector<RooFitResult*>*)o)->begin)();
}

static  void method_18703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult* const*,std::vector<RooFitResult*> >)((((const ::std::vector<RooFitResult*>*)o)->begin)());
  else   (((const ::std::vector<RooFitResult*>*)o)->begin)();
}

static  void method_18704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->end)());
  else   (((::std::vector<RooFitResult*>*)o)->end)();
}

static  void method_18705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult* const*,std::vector<RooFitResult*> >)((((const ::std::vector<RooFitResult*>*)o)->end)());
  else   (((const ::std::vector<RooFitResult*>*)o)->end)();
}

static  void method_18710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooFitResult*>*)o)->size)());
  else   (((const ::std::vector<RooFitResult*>*)o)->size)();
}

static  void method_18711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooFitResult*>*)o)->max_size)());
  else   (((const ::std::vector<RooFitResult*>*)o)->max_size)();
}

static  void method_18712( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooFitResult*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooFitResult*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooFitResult*)arg[1]);
  }
}

static  void method_18713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooFitResult*>*)o)->capacity)());
  else   (((const ::std::vector<RooFitResult*>*)o)->capacity)();
}

static  void method_18714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooFitResult*>*)o)->empty)());
  else   (((const ::std::vector<RooFitResult*>*)o)->empty)();
}

static  void method_18715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooFitResult*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooFitResult*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooFitResult*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooFitResult*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooFitResult*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooFitResult*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->front)();
  else   (((::std::vector<RooFitResult*>*)o)->front)();
}

static  void method_18722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooFitResult*>*)o)->front)();
  else   (((const ::std::vector<RooFitResult*>*)o)->front)();
}

static  void method_18723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooFitResult*>*)o)->back)();
  else   (((::std::vector<RooFitResult*>*)o)->back)();
}

static  void method_18724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooFitResult*>*)o)->back)();
  else   (((const ::std::vector<RooFitResult*>*)o)->back)();
}

static  void method_18725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooFitResult*>*)o)->data)());
  else   (((::std::vector<RooFitResult*>*)o)->data)();
}

static  void method_18726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooFitResult*>*)o)->data)());
  else   (((const ::std::vector<RooFitResult*>*)o)->data)();
}

static  void method_18727( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->push_back)(*(::RooFitResult* const*)arg[0]);
}

static  void method_18728( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooFitResult*>*)o)->pop_back)();
}

static  void method_18729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::RooFitResult* const*)arg[1]));
  else   (((::std::vector<RooFitResult*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::RooFitResult* const*)arg[1]);
}

static  void method_18730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooFitResult* const*)arg[2]);
}

static  void method_18731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0]));
  else   (((::std::vector<RooFitResult*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0]);
}

static  void method_18732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >)((((::std::vector<RooFitResult*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[1]));
  else   (((::std::vector<RooFitResult*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooFitResult**,std::vector<RooFitResult*> >*)arg[1]);
}

static  void method_18733( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooFitResult*>*)o)->swap)(*(::std::vector<RooFitResult*>*)arg[0]);
}

static  void method_18734( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooFitResult*>*)o)->clear)();
}

static void method_newdel_3102( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooFitResult*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> >")), ::Reflex::BaseOffset< ::std::vector<RooFitResult*>,::std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooFitResult*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooFitResult*> >::Generate();
}

//------Dictionary for class vector<RooFitResult*,std::allocator<RooFitResult*> > -------------------------------
void __std__vector_RooFitResultp__db_datamem(Reflex::Class*);
void __std__vector_RooFitResultp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooFitResultp__datamem_bld(&__std__vector_RooFitResultp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooFitResultp__funcmem_bld(&__std__vector_RooFitResultp__db_funcmem);
void __std__vector_RooFitResultp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooFitResult*>"), typeid(::std::vector<RooFitResult*>), sizeof(::std::vector<RooFitResult*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3030, ::Reflex::BaseOffset< ::std::vector<RooFitResult*>, ::std::_Vector_base<RooFitResult*,std::allocator<RooFitResult*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_18675, Reflex::Literal("std::vector<RooFitResult*>::_Alloc_value_type"))
  .AddTypedef(type_3030, Reflex::Literal("std::vector<RooFitResult*>::_Base"))
  .AddTypedef(type_3690, Reflex::Literal("std::vector<RooFitResult*>::_Tp_alloc_type"))
  .AddTypedef(type_11025, Reflex::Literal("std::vector<RooFitResult*>::_Alloc_traits"))
  .AddTypedef(type_18675, Reflex::Literal("std::vector<RooFitResult*>::value_type"))
  .AddTypedef(type_17384, Reflex::Literal("std::vector<RooFitResult*>::pointer"))
  .AddTypedef(type_18682, Reflex::Literal("std::vector<RooFitResult*>::const_pointer"))
  .AddTypedef(type_18684, Reflex::Literal("std::vector<RooFitResult*>::reference"))
  .AddTypedef(type_18686, Reflex::Literal("std::vector<RooFitResult*>::const_reference"))
  .AddTypedef(type_10864, Reflex::Literal("std::vector<RooFitResult*>::iterator"))
  .AddTypedef(type_10865, Reflex::Literal("std::vector<RooFitResult*>::const_iterator"))
  .AddTypedef(type_3914, Reflex::Literal("std::vector<RooFitResult*>::const_reverse_iterator"))
  .AddTypedef(type_3915, Reflex::Literal("std::vector<RooFitResult*>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<RooFitResult*>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<RooFitResult*>::difference_type"))
  .AddTypedef(type_3690, Reflex::Literal("std::vector<RooFitResult*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18695, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32225), Reflex::Literal("vector"), constructor_18696, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18686, type_32225), Reflex::Literal("vector"), constructor_18697, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32546), Reflex::Literal("vector"), constructor_18698, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18699, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3102, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooFitResultp__funcmem_bld);
}

//------Delayed data member builder for class vector<RooFitResult*,std::allocator<RooFitResult*> > -------------------
void __std__vector_RooFitResultp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooFitResult*,std::allocator<RooFitResult*> > -------------------
void __std__vector_RooFitResultp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32547, type_32546), Reflex::Literal("operator="), operator_18700, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18686), Reflex::Literal("assign"), method_18701, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864), Reflex::Literal("begin"), method_18702, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10865), Reflex::Literal("begin"), method_18703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864), Reflex::Literal("end"), method_18704, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10865), Reflex::Literal("end"), method_18705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18675), Reflex::Literal("resize"), method_18712, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18715, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18684, type_3404), Reflex::Literal("operator[]"), operator_18716, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18686, type_3404), Reflex::Literal("operator[]"), operator_18717, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18684, type_3404), Reflex::Literal("at"), method_18719, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18686, type_3404), Reflex::Literal("at"), method_18720, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18684), Reflex::Literal("front"), method_18721, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18686), Reflex::Literal("front"), method_18722, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18684), Reflex::Literal("back"), method_18723, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18686), Reflex::Literal("back"), method_18724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17384), Reflex::Literal("data"), method_18725, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18682), Reflex::Literal("data"), method_18726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18686), Reflex::Literal("push_back"), method_18727, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18728, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864, type_10864, type_18686), Reflex::Literal("insert"), method_18729, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10864, type_3404, type_18686), Reflex::Literal("insert"), method_18730, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864, type_10864), Reflex::Literal("erase"), method_18731, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10864, type_10864, type_10864), Reflex::Literal("erase"), method_18732, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32547), Reflex::Literal("swap"), method_18733, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18734, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void constructor_18760( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >();
}

static void constructor_18761( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static void constructor_18762( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[2]);
  }
}

static void constructor_18763( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static void destructor_18764(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::~vector)();
}
static  void operator_18765( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_18766( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
}

static  void method_18767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)();
}

static  void method_18768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)();
}

static  void method_18769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)();
}

static  void method_18770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->end)();
}

static  void method_18775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->size)();
}

static  void method_18776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->max_size)();
}

static  void method_18777( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  }
}

static  void method_18778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->capacity)();
}

static  void method_18779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->empty)();
}

static  void method_18780( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18782( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18785( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
}

static  void method_18787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->front)();
}

static  void method_18788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
}

static  void method_18789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->back)();
}

static  void method_18790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)();
}

static  void method_18791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->data)();
}

static  void method_18792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static  void method_18793( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->pop_back)();
}

static  void method_18794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
}

static  void method_18795( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[2]);
}

static  void method_18796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0]);
}

static  void method_18797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >)((((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,std::basic_string<char> >*,std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >*)arg[1]);
}

static  void method_18798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_18799( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >*)o)->clear)();
}

static void method_newdel_3103( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >,::std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >"), typeid(::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >), sizeof(::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3031, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >, ::std::_Vector_base<std::pair<std::basic_string<char>,std::basic_string<char> >,std::allocator<std::pair<std::basic_string<char>,std::basic_string<char> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3486, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Alloc_value_type"))
  .AddTypedef(type_3031, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Base"))
  .AddTypedef(type_3691, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Tp_alloc_type"))
  .AddTypedef(type_11026, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::_Alloc_traits"))
  .AddTypedef(type_3486, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_17403, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_18747, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_pointer"))
  .AddTypedef(type_18749, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::reference"))
  .AddTypedef(type_18751, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_reference"))
  .AddTypedef(type_10866, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::iterator"))
  .AddTypedef(type_10867, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_iterator"))
  .AddTypedef(type_3916, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::const_reverse_iterator"))
  .AddTypedef(type_3917, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_3691, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18760, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32238), Reflex::Literal("vector"), constructor_18761, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18751, type_32238), Reflex::Literal("vector"), constructor_18762, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32549), Reflex::Literal("vector"), constructor_18763, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18764, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32550, type_32549), Reflex::Literal("operator="), operator_18765, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18751), Reflex::Literal("assign"), method_18766, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866), Reflex::Literal("begin"), method_18767, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10867), Reflex::Literal("begin"), method_18768, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866), Reflex::Literal("end"), method_18769, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10867), Reflex::Literal("end"), method_18770, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_3486), Reflex::Literal("resize"), method_18777, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18780, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18749, type_3404), Reflex::Literal("operator[]"), operator_18781, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18751, type_3404), Reflex::Literal("operator[]"), operator_18782, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18749, type_3404), Reflex::Literal("at"), method_18784, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18751, type_3404), Reflex::Literal("at"), method_18785, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18749), Reflex::Literal("front"), method_18786, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18751), Reflex::Literal("front"), method_18787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18749), Reflex::Literal("back"), method_18788, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18751), Reflex::Literal("back"), method_18789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17403), Reflex::Literal("data"), method_18790, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18747), Reflex::Literal("data"), method_18791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18751), Reflex::Literal("push_back"), method_18792, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18793, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866, type_10866, type_18751), Reflex::Literal("insert"), method_18794, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10866, type_3404, type_18751), Reflex::Literal("insert"), method_18795, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866, type_10866), Reflex::Literal("erase"), method_18796, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10866, type_10866, type_10866), Reflex::Literal("erase"), method_18797, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32550), Reflex::Literal("swap"), method_18798, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18799, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > >,std::allocator<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > > > > -------------------------------
static void constructor_18825( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >();
  else ::new(mem) ::std::vector<std::map<void*,double> >();
}

static void constructor_18826( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(const ::std::allocator<std::map<void*,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(const ::std::allocator<std::map<void*,double> >*)arg[0]);
}

static void constructor_18827( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0],
      *(const ::std::map<void*,double>*)arg[1]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0],
      *(const ::std::map<void*,double>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0],
      *(const ::std::map<void*,double>*)arg[1],
      *(const ::std::allocator<std::map<void*,double> >*)arg[2]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(::std::size_t*)arg[0],
      *(const ::std::map<void*,double>*)arg[1],
      *(const ::std::allocator<std::map<void*,double> >*)arg[2]);
  }
}

static void constructor_18828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<void*,double> >(*(const ::std::vector<std::map<void*,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<void*,double> >(*(const ::std::vector<std::map<void*,double> >*)arg[0]);
}

static void destructor_18829(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::map<void*,double> >*)o)->::std::vector<std::map<void*,double> >::~vector)();
}
static  void operator_18830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->operator=)(*(const ::std::vector<std::map<void*,double> >*)arg[0]);
  else   (((::std::vector<std::map<void*,double> >*)o)->operator=)(*(const ::std::vector<std::map<void*,double> >*)arg[0]);
}

static  void method_18831( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::map<void*,double>*)arg[1]);
}

static  void method_18832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->begin)());
  else   (((::std::vector<std::map<void*,double> >*)o)->begin)();
}

static  void method_18833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((const ::std::vector<std::map<void*,double> >*)o)->begin)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->begin)();
}

static  void method_18834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->end)());
  else   (((::std::vector<std::map<void*,double> >*)o)->end)();
}

static  void method_18835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((const ::std::vector<std::map<void*,double> >*)o)->end)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->end)();
}

static  void method_18840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<void*,double> >*)o)->size)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->size)();
}

static  void method_18841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<void*,double> >*)o)->max_size)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->max_size)();
}

static  void method_18842( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::map<void*,double> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::map<void*,double> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::map<void*,double>*)arg[1]);
  }
}

static  void method_18843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<void*,double> >*)o)->capacity)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->capacity)();
}

static  void method_18844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::map<void*,double> >*)o)->empty)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->empty)();
}

static  void method_18845( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<void*,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18847( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<void*,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<void*,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<void*,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<void*,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<void*,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->front)();
  else   (((::std::vector<std::map<void*,double> >*)o)->front)();
}

static  void method_18852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<void*,double> >*)o)->front)();
  else   (((const ::std::vector<std::map<void*,double> >*)o)->front)();
}

static  void method_18853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<void*,double> >*)o)->back)();
  else   (((::std::vector<std::map<void*,double> >*)o)->back)();
}

static  void method_18854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<void*,double> >*)o)->back)();
  else   (((const ::std::vector<std::map<void*,double> >*)o)->back)();
}

static  void method_18855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::map<void*,double> >*)o)->data)());
  else   (((::std::vector<std::map<void*,double> >*)o)->data)();
}

static  void method_18856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::map<void*,double> >*)o)->data)());
  else   (((const ::std::vector<std::map<void*,double> >*)o)->data)();
}

static  void method_18857( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->push_back)(*(const ::std::map<void*,double>*)arg[0]);
}

static  void method_18858( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->pop_back)();
}

static  void method_18859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(const ::std::map<void*,double>*)arg[1]));
  else   (((::std::vector<std::map<void*,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(const ::std::map<void*,double>*)arg[1]);
}

static  void method_18860( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::map<void*,double>*)arg[2]);
}

static  void method_18861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0]));
  else   (((::std::vector<std::map<void*,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0]);
}

static  void method_18862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >)((((::std::vector<std::map<void*,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[1]));
  else   (((::std::vector<std::map<void*,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<void*,double>*,std::vector<std::map<void*,double> > >*)arg[1]);
}

static  void method_18863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->swap)(*(::std::vector<std::map<void*,double> >*)arg[0]);
}

static  void method_18864( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<void*,double> >*)o)->clear)();
}

static void method_newdel_3104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<void*,double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > >")), ::Reflex::BaseOffset< ::std::vector<std::map<void*,double> >,::std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::map<void*,double> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::map<void*,double> > >::Generate();
}

//------Dictionary for class vector<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > >,std::allocator<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > > > > -------------------------------
void __std__vector_std__map_voidp_double_s__db_datamem(Reflex::Class*);
void __std__vector_std__map_voidp_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__map_voidp_double_s__datamem_bld(&__std__vector_std__map_voidp_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__map_voidp_double_s__funcmem_bld(&__std__vector_std__map_voidp_double_s__db_funcmem);
void __std__vector_std__map_voidp_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::map<void*,double> >"), typeid(::std::vector<std::map<void*,double> >), sizeof(::std::vector<std::map<void*,double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3032, ::Reflex::BaseOffset< ::std::vector<std::map<void*,double> >, ::std::_Vector_base<std::map<void*,double>,std::allocator<std::map<void*,double> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3351, Reflex::Literal("std::vector<std::map<void*,double> >::_Alloc_value_type"))
  .AddTypedef(type_3032, Reflex::Literal("std::vector<std::map<void*,double> >::_Base"))
  .AddTypedef(type_3692, Reflex::Literal("std::vector<std::map<void*,double> >::_Tp_alloc_type"))
  .AddTypedef(type_11027, Reflex::Literal("std::vector<std::map<void*,double> >::_Alloc_traits"))
  .AddTypedef(type_3351, Reflex::Literal("std::vector<std::map<void*,double> >::value_type"))
  .AddTypedef(type_17422, Reflex::Literal("std::vector<std::map<void*,double> >::pointer"))
  .AddTypedef(type_18812, Reflex::Literal("std::vector<std::map<void*,double> >::const_pointer"))
  .AddTypedef(type_18814, Reflex::Literal("std::vector<std::map<void*,double> >::reference"))
  .AddTypedef(type_18816, Reflex::Literal("std::vector<std::map<void*,double> >::const_reference"))
  .AddTypedef(type_10868, Reflex::Literal("std::vector<std::map<void*,double> >::iterator"))
  .AddTypedef(type_10869, Reflex::Literal("std::vector<std::map<void*,double> >::const_iterator"))
  .AddTypedef(type_3918, Reflex::Literal("std::vector<std::map<void*,double> >::const_reverse_iterator"))
  .AddTypedef(type_3919, Reflex::Literal("std::vector<std::map<void*,double> >::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<std::map<void*,double> >::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<std::map<void*,double> >::difference_type"))
  .AddTypedef(type_3692, Reflex::Literal("std::vector<std::map<void*,double> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18825, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32251), Reflex::Literal("vector"), constructor_18826, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18816, type_32251), Reflex::Literal("vector"), constructor_18827, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32552), Reflex::Literal("vector"), constructor_18828, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18829, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__map_voidp_double_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > >,std::allocator<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > > > > -------------------
void __std__vector_std__map_voidp_double_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > >,std::allocator<std::map<void*, double, std::less<void*>, std::allocator<std::pair<void* const, double> > > > > -------------------
void __std__vector_std__map_voidp_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32553, type_32552), Reflex::Literal("operator="), operator_18830, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18816), Reflex::Literal("assign"), method_18831, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868), Reflex::Literal("begin"), method_18832, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10869), Reflex::Literal("begin"), method_18833, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868), Reflex::Literal("end"), method_18834, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10869), Reflex::Literal("end"), method_18835, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_3351), Reflex::Literal("resize"), method_18842, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18845, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18814, type_3404), Reflex::Literal("operator[]"), operator_18846, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18816, type_3404), Reflex::Literal("operator[]"), operator_18847, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18814, type_3404), Reflex::Literal("at"), method_18849, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18816, type_3404), Reflex::Literal("at"), method_18850, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18814), Reflex::Literal("front"), method_18851, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18816), Reflex::Literal("front"), method_18852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18814), Reflex::Literal("back"), method_18853, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18816), Reflex::Literal("back"), method_18854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17422), Reflex::Literal("data"), method_18855, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18812), Reflex::Literal("data"), method_18856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18816), Reflex::Literal("push_back"), method_18857, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18858, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868, type_10868, type_18816), Reflex::Literal("insert"), method_18859, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10868, type_3404, type_18816), Reflex::Literal("insert"), method_18860, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868, type_10868), Reflex::Literal("erase"), method_18861, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10868, type_10868, type_10868), Reflex::Literal("erase"), method_18862, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32553), Reflex::Literal("swap"), method_18863, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18864, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------------------
static void constructor_18890( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >();
  else ::new(mem) ::std::vector<std::vector<double> >();
}

static void constructor_18891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::allocator<std::vector<double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::allocator<std::vector<double> >*)arg[0]);
}

static void constructor_18892( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::std::allocator<std::vector<double> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::std::allocator<std::vector<double> >*)arg[2]);
  }
}

static void constructor_18893( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::vector<std::vector<double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::vector<std::vector<double> >*)arg[0]);
}

static void destructor_18894(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<double> >*)o)->::std::vector<std::vector<double> >::~vector)();
}
static  void operator_18895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->operator=)(*(const ::std::vector<std::vector<double> >*)arg[0]);
  else   (((::std::vector<std::vector<double> >*)o)->operator=)(*(const ::std::vector<std::vector<double> >*)arg[0]);
}

static  void method_18896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<double>*)arg[1]);
}

static  void method_18897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->begin)());
  else   (((::std::vector<std::vector<double> >*)o)->begin)();
}

static  void method_18898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > >)((((const ::std::vector<std::vector<double> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<double> >*)o)->begin)();
}

static  void method_18899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->end)());
  else   (((::std::vector<std::vector<double> >*)o)->end)();
}

static  void method_18900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > >)((((const ::std::vector<std::vector<double> >*)o)->end)());
  else   (((const ::std::vector<std::vector<double> >*)o)->end)();
}

static  void method_18905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double> >*)o)->size)());
  else   (((const ::std::vector<std::vector<double> >*)o)->size)();
}

static  void method_18906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<double> >*)o)->max_size)();
}

static  void method_18907( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<double> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<double> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<double>*)arg[1]);
  }
}

static  void method_18908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<double> >*)o)->capacity)();
}

static  void method_18909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<double> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<double> >*)o)->empty)();
}

static  void method_18910( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18912( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->front)();
  else   (((::std::vector<std::vector<double> >*)o)->front)();
}

static  void method_18917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->front)();
  else   (((const ::std::vector<std::vector<double> >*)o)->front)();
}

static  void method_18918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->back)();
  else   (((::std::vector<std::vector<double> >*)o)->back)();
}

static  void method_18919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->back)();
  else   (((const ::std::vector<std::vector<double> >*)o)->back)();
}

static  void method_18920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<double> >*)o)->data)());
  else   (((::std::vector<std::vector<double> >*)o)->data)();
}

static  void method_18921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<double> >*)o)->data)());
  else   (((const ::std::vector<std::vector<double> >*)o)->data)();
}

static  void method_18922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->push_back)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_18923( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double> >*)o)->pop_back)();
}

static  void method_18924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(const ::std::vector<double>*)arg[1]));
  else   (((::std::vector<std::vector<double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(const ::std::vector<double>*)arg[1]);
}

static  void method_18925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<double>*)arg[2]);
}

static  void method_18926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0]));
  else   (((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0]);
}

static  void method_18927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[1]));
  else   (((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[1]);
}

static  void method_18928( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->swap)(*(::std::vector<std::vector<double> >*)arg[0]);
}

static  void method_18929( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double> >*)o)->clear)();
}

static void method_newdel_3105( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<double> >,::std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<double> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<double> > >::Generate();
}

//------Dictionary for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------------------
void __std__vector_std__vector_double_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_s__datamem_bld(&__std__vector_std__vector_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_s__funcmem_bld(&__std__vector_std__vector_double_s__db_funcmem);
void __std__vector_std__vector_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<double> >"), typeid(::std::vector<std::vector<double> >), sizeof(::std::vector<std::vector<double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3033, ::Reflex::BaseOffset< ::std::vector<std::vector<double> >, ::std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3089, Reflex::Literal("std::vector<std::vector<double> >::_Alloc_value_type"))
  .AddTypedef(type_3033, Reflex::Literal("std::vector<std::vector<double> >::_Base"))
  .AddTypedef(type_3694, Reflex::Literal("std::vector<std::vector<double> >::_Tp_alloc_type"))
  .AddTypedef(type_11028, Reflex::Literal("std::vector<std::vector<double> >::_Alloc_traits"))
  .AddTypedef(type_3089, Reflex::Literal("std::vector<std::vector<double> >::value_type"))
  .AddTypedef(type_17441, Reflex::Literal("std::vector<std::vector<double> >::pointer"))
  .AddTypedef(type_18877, Reflex::Literal("std::vector<std::vector<double> >::const_pointer"))
  .AddTypedef(type_18879, Reflex::Literal("std::vector<std::vector<double> >::reference"))
  .AddTypedef(type_18881, Reflex::Literal("std::vector<std::vector<double> >::const_reference"))
  .AddTypedef(type_10870, Reflex::Literal("std::vector<std::vector<double> >::iterator"))
  .AddTypedef(type_10871, Reflex::Literal("std::vector<std::vector<double> >::const_iterator"))
  .AddTypedef(type_3928, Reflex::Literal("std::vector<std::vector<double> >::const_reverse_iterator"))
  .AddTypedef(type_3929, Reflex::Literal("std::vector<std::vector<double> >::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<std::vector<double> >::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<std::vector<double> >::difference_type"))
  .AddTypedef(type_3694, Reflex::Literal("std::vector<std::vector<double> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18890, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32264), Reflex::Literal("vector"), constructor_18891, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18881, type_32264), Reflex::Literal("vector"), constructor_18892, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32555), Reflex::Literal("vector"), constructor_18893, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18894, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3105, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_double_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------
void __std__vector_std__vector_double_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------
void __std__vector_std__vector_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32556, type_32555), Reflex::Literal("operator="), operator_18895, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18881), Reflex::Literal("assign"), method_18896, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870), Reflex::Literal("begin"), method_18897, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10871), Reflex::Literal("begin"), method_18898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870), Reflex::Literal("end"), method_18899, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10871), Reflex::Literal("end"), method_18900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_3089), Reflex::Literal("resize"), method_18907, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18910, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18879, type_3404), Reflex::Literal("operator[]"), operator_18911, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18881, type_3404), Reflex::Literal("operator[]"), operator_18912, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18879, type_3404), Reflex::Literal("at"), method_18914, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18881, type_3404), Reflex::Literal("at"), method_18915, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18879), Reflex::Literal("front"), method_18916, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18881), Reflex::Literal("front"), method_18917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18879), Reflex::Literal("back"), method_18918, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18881), Reflex::Literal("back"), method_18919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17441), Reflex::Literal("data"), method_18920, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18877), Reflex::Literal("data"), method_18921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18881), Reflex::Literal("push_back"), method_18922, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18923, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870, type_10870, type_18881), Reflex::Literal("insert"), method_18924, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10870, type_3404, type_18881), Reflex::Literal("insert"), method_18925, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870, type_10870), Reflex::Literal("erase"), method_18926, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10870, type_10870, type_10870), Reflex::Literal("erase"), method_18927, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32556), Reflex::Literal("swap"), method_18928, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18929, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > -------------------------------
static void constructor_18956( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>();
  else ::new(mem) ::std::vector<const RooAbsBinning*>();
}

static void constructor_18957( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(const ::std::allocator<const RooAbsBinning*>*)arg[0]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(const ::std::allocator<const RooAbsBinning*>*)arg[0]);
}

static void constructor_18958( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0],
      *(const ::RooAbsBinning* const*)arg[1]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0],
      *(const ::RooAbsBinning* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0],
      *(const ::RooAbsBinning* const*)arg[1],
      *(const ::std::allocator<const RooAbsBinning*>*)arg[2]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(::std::size_t*)arg[0],
      *(const ::RooAbsBinning* const*)arg[1],
      *(const ::std::allocator<const RooAbsBinning*>*)arg[2]);
  }
}

static void constructor_18959( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const RooAbsBinning*>(*(const ::std::vector<const RooAbsBinning*>*)arg[0]);
  else ::new(mem) ::std::vector<const RooAbsBinning*>(*(const ::std::vector<const RooAbsBinning*>*)arg[0]);
}

static void destructor_18960(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<const RooAbsBinning*>*)o)->::std::vector<const RooAbsBinning*>::~vector)();
}
static  void operator_18961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->operator=)(*(const ::std::vector<const RooAbsBinning*>*)arg[0]);
  else   (((::std::vector<const RooAbsBinning*>*)o)->operator=)(*(const ::std::vector<const RooAbsBinning*>*)arg[0]);
}

static  void method_18962( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RooAbsBinning* const*)arg[1]);
}

static  void method_18963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->begin)());
  else   (((::std::vector<const RooAbsBinning*>*)o)->begin)();
}

static  void method_18964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning* const*,std::vector<const RooAbsBinning*> >)((((const ::std::vector<const RooAbsBinning*>*)o)->begin)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->begin)();
}

static  void method_18965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->end)());
  else   (((::std::vector<const RooAbsBinning*>*)o)->end)();
}

static  void method_18966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning* const*,std::vector<const RooAbsBinning*> >)((((const ::std::vector<const RooAbsBinning*>*)o)->end)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->end)();
}

static  void method_18971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const RooAbsBinning*>*)o)->size)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->size)();
}

static  void method_18972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const RooAbsBinning*>*)o)->max_size)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->max_size)();
}

static  void method_18973( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<const RooAbsBinning*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<const RooAbsBinning*>*)o)->resize)(*(::std::size_t*)arg[0],
      (const ::RooAbsBinning*)arg[1]);
  }
}

static  void method_18974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const RooAbsBinning*>*)o)->capacity)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->capacity)();
}

static  void method_18975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<const RooAbsBinning*>*)o)->empty)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->empty)();
}

static  void method_18976( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const RooAbsBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RooAbsBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const RooAbsBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RooAbsBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->front)();
  else   (((::std::vector<const RooAbsBinning*>*)o)->front)();
}

static  void method_18983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RooAbsBinning*>*)o)->front)();
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->front)();
}

static  void method_18984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const RooAbsBinning*>*)o)->back)();
  else   (((::std::vector<const RooAbsBinning*>*)o)->back)();
}

static  void method_18985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const RooAbsBinning*>*)o)->back)();
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->back)();
}

static  void method_18986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<const RooAbsBinning*>*)o)->data)());
  else   (((::std::vector<const RooAbsBinning*>*)o)->data)();
}

static  void method_18987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<const RooAbsBinning*>*)o)->data)());
  else   (((const ::std::vector<const RooAbsBinning*>*)o)->data)();
}

static  void method_18988( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->push_back)(*(const ::RooAbsBinning* const*)arg[0]);
}

static  void method_18989( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->pop_back)();
}

static  void method_18990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(const ::RooAbsBinning* const*)arg[1]));
  else   (((::std::vector<const RooAbsBinning*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(const ::RooAbsBinning* const*)arg[1]);
}

static  void method_18991( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RooAbsBinning* const*)arg[2]);
}

static  void method_18992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0]));
  else   (((::std::vector<const RooAbsBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0]);
}

static  void method_18993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >)((((::std::vector<const RooAbsBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[1]));
  else   (((::std::vector<const RooAbsBinning*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const RooAbsBinning**,std::vector<const RooAbsBinning*> >*)arg[1]);
}

static  void method_18994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->swap)(*(::std::vector<const RooAbsBinning*>*)arg[0]);
}

static  void method_18995( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const RooAbsBinning*>*)o)->clear)();
}

static void method_newdel_3107( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<const RooAbsBinning*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> >")), ::Reflex::BaseOffset< ::std::vector<const RooAbsBinning*>,::std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<const RooAbsBinning*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<const RooAbsBinning*> >::Generate();
}

//------Dictionary for class vector<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > -------------------------------
void __std__vector_constsRooAbsBinningp__db_datamem(Reflex::Class*);
void __std__vector_constsRooAbsBinningp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_constsRooAbsBinningp__datamem_bld(&__std__vector_constsRooAbsBinningp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_constsRooAbsBinningp__funcmem_bld(&__std__vector_constsRooAbsBinningp__db_funcmem);
void __std__vector_constsRooAbsBinningp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<const RooAbsBinning*>"), typeid(::std::vector<const RooAbsBinning*>), sizeof(::std::vector<const RooAbsBinning*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3039, ::Reflex::BaseOffset< ::std::vector<const RooAbsBinning*>, ::std::_Vector_base<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_18936, Reflex::Literal("std::vector<const RooAbsBinning*>::_Alloc_value_type"))
  .AddTypedef(type_3039, Reflex::Literal("std::vector<const RooAbsBinning*>::_Base"))
  .AddTypedef(type_3708, Reflex::Literal("std::vector<const RooAbsBinning*>::_Tp_alloc_type"))
  .AddTypedef(type_11034, Reflex::Literal("std::vector<const RooAbsBinning*>::_Alloc_traits"))
  .AddTypedef(type_18936, Reflex::Literal("std::vector<const RooAbsBinning*>::value_type"))
  .AddTypedef(type_17553, Reflex::Literal("std::vector<const RooAbsBinning*>::pointer"))
  .AddTypedef(type_18943, Reflex::Literal("std::vector<const RooAbsBinning*>::const_pointer"))
  .AddTypedef(type_18945, Reflex::Literal("std::vector<const RooAbsBinning*>::reference"))
  .AddTypedef(type_18947, Reflex::Literal("std::vector<const RooAbsBinning*>::const_reference"))
  .AddTypedef(type_10882, Reflex::Literal("std::vector<const RooAbsBinning*>::iterator"))
  .AddTypedef(type_10883, Reflex::Literal("std::vector<const RooAbsBinning*>::const_iterator"))
  .AddTypedef(type_3944, Reflex::Literal("std::vector<const RooAbsBinning*>::const_reverse_iterator"))
  .AddTypedef(type_3945, Reflex::Literal("std::vector<const RooAbsBinning*>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<const RooAbsBinning*>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<const RooAbsBinning*>::difference_type"))
  .AddTypedef(type_3708, Reflex::Literal("std::vector<const RooAbsBinning*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18956, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32342), Reflex::Literal("vector"), constructor_18957, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_18947, type_32342), Reflex::Literal("vector"), constructor_18958, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32559), Reflex::Literal("vector"), constructor_18959, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18960, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_constsRooAbsBinningp__funcmem_bld);
}

//------Delayed data member builder for class vector<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > -------------------
void __std__vector_constsRooAbsBinningp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<const RooAbsBinning*,std::allocator<const RooAbsBinning*> > -------------------
void __std__vector_constsRooAbsBinningp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32560, type_32559), Reflex::Literal("operator="), operator_18961, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18947), Reflex::Literal("assign"), method_18962, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882), Reflex::Literal("begin"), method_18963, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10883), Reflex::Literal("begin"), method_18964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882), Reflex::Literal("end"), method_18965, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10883), Reflex::Literal("end"), method_18966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_18971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_18972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_18936), Reflex::Literal("resize"), method_18973, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_18974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_18975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_18976, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18945, type_3404), Reflex::Literal("operator[]"), operator_18977, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18947, type_3404), Reflex::Literal("operator[]"), operator_18978, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18945, type_3404), Reflex::Literal("at"), method_18980, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18947, type_3404), Reflex::Literal("at"), method_18981, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18945), Reflex::Literal("front"), method_18982, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18947), Reflex::Literal("front"), method_18983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18945), Reflex::Literal("back"), method_18984, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18947), Reflex::Literal("back"), method_18985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17553), Reflex::Literal("data"), method_18986, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18943), Reflex::Literal("data"), method_18987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_18947), Reflex::Literal("push_back"), method_18988, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_18989, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882, type_10882, type_18947), Reflex::Literal("insert"), method_18990, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10882, type_3404, type_18947), Reflex::Literal("insert"), method_18991, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882, type_10882), Reflex::Literal("erase"), method_18992, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10882, type_10882, type_10882), Reflex::Literal("erase"), method_18993, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32560), Reflex::Literal("swap"), method_18994, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_18995, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooAbsLValue*,std::allocator<RooAbsLValue*> > -------------------------------
static void constructor_19022( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsLValue*>();
  else ::new(mem) ::std::vector<RooAbsLValue*>();
}

static void constructor_19023( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsLValue*>(*(const ::std::allocator<RooAbsLValue*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsLValue*>(*(const ::std::allocator<RooAbsLValue*>*)arg[0]);
}

static void constructor_19024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsLValue*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsLValue*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsLValue* const*)arg[1]);
  else ::new(mem) ::std::vector<RooAbsLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsLValue* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsLValue* const*)arg[1],
      *(const ::std::allocator<RooAbsLValue*>*)arg[2]);
  else ::new(mem) ::std::vector<RooAbsLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsLValue* const*)arg[1],
      *(const ::std::allocator<RooAbsLValue*>*)arg[2]);
  }
}

static void constructor_19025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsLValue*>(*(const ::std::vector<RooAbsLValue*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsLValue*>(*(const ::std::vector<RooAbsLValue*>*)arg[0]);
}

static void destructor_19026(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooAbsLValue*>*)o)->::std::vector<RooAbsLValue*>::~vector)();
}
static  void operator_19027( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsLValue*>*)o)->operator=)(*(const ::std::vector<RooAbsLValue*>*)arg[0]);
  else   (((::std::vector<RooAbsLValue*>*)o)->operator=)(*(const ::std::vector<RooAbsLValue*>*)arg[0]);
}

static  void method_19028( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsLValue*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooAbsLValue* const*)arg[1]);
}

static  void method_19029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >)((((::std::vector<RooAbsLValue*>*)o)->begin)());
  else   (((::std::vector<RooAbsLValue*>*)o)->begin)();
}

static  void method_19030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsLValue* const*,std::vector<RooAbsLValue*> >)((((const ::std::vector<RooAbsLValue*>*)o)->begin)());
  else   (((const ::std::vector<RooAbsLValue*>*)o)->begin)();
}

static  void method_19031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >)((((::std::vector<RooAbsLValue*>*)o)->end)());
  else   (((::std::vector<RooAbsLValue*>*)o)->end)();
}

static  void method_19032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsLValue* const*,std::vector<RooAbsLValue*> >)((((const ::std::vector<RooAbsLValue*>*)o)->end)());
  else   (((const ::std::vector<RooAbsLValue*>*)o)->end)();
}

static  void method_19037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsLValue*>*)o)->size)());
  else   (((const ::std::vector<RooAbsLValue*>*)o)->size)();
}

static  void method_19038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsLValue*>*)o)->max_size)());
  else   (((const ::std::vector<RooAbsLValue*>*)o)->max_size)();
}

static  void method_19039( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooAbsLValue*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooAbsLValue*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooAbsLValue*)arg[1]);
  }
}

static  void method_19040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsLValue*>*)o)->capacity)());
  else   (((const ::std::vector<RooAbsLValue*>*)o)->capacity)();
}

static  void method_19041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooAbsLValue*>*)o)->empty)());
  else   (((const ::std::vector<RooAbsLValue*>*)o)->empty)();
}

static  void method_19042( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsLValue*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19043( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19044( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19046( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsLValue*>*)o)->front)();
  else   (((::std::vector<RooAbsLValue*>*)o)->front)();
}

static  void method_19049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsLValue*>*)o)->front)();
  else   (((const ::std::vector<RooAbsLValue*>*)o)->front)();
}

static  void method_19050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsLValue*>*)o)->back)();
  else   (((::std::vector<RooAbsLValue*>*)o)->back)();
}

static  void method_19051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsLValue*>*)o)->back)();
  else   (((const ::std::vector<RooAbsLValue*>*)o)->back)();
}

static  void method_19052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooAbsLValue*>*)o)->data)());
  else   (((::std::vector<RooAbsLValue*>*)o)->data)();
}

static  void method_19053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooAbsLValue*>*)o)->data)());
  else   (((const ::std::vector<RooAbsLValue*>*)o)->data)();
}

static  void method_19054( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsLValue*>*)o)->push_back)(*(::RooAbsLValue* const*)arg[0]);
}

static  void method_19055( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsLValue*>*)o)->pop_back)();
}

static  void method_19056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >)((((::std::vector<RooAbsLValue*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >*)arg[0],
    *(::RooAbsLValue* const*)arg[1]));
  else   (((::std::vector<RooAbsLValue*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >*)arg[0],
    *(::RooAbsLValue* const*)arg[1]);
}

static  void method_19057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsLValue*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooAbsLValue* const*)arg[2]);
}

static  void method_19058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >)((((::std::vector<RooAbsLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >*)arg[0]));
  else   (((::std::vector<RooAbsLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >*)arg[0]);
}

static  void method_19059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >)((((::std::vector<RooAbsLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >*)arg[1]));
  else   (((::std::vector<RooAbsLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsLValue**,std::vector<RooAbsLValue*> >*)arg[1]);
}

static  void method_19060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsLValue*>*)o)->swap)(*(::std::vector<RooAbsLValue*>*)arg[0]);
}

static  void method_19061( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsLValue*>*)o)->clear)();
}

static void method_newdel_3108( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsLValue*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsLValue*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsLValue*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsLValue*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsLValue*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x167( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsLValue*,std::allocator<RooAbsLValue*> >")), ::Reflex::BaseOffset< ::std::vector<RooAbsLValue*>,::std::_Vector_base<RooAbsLValue*,std::allocator<RooAbsLValue*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x168( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooAbsLValue*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooAbsLValue*> >::Generate();
}

//------Dictionary for class vector<RooAbsLValue*,std::allocator<RooAbsLValue*> > -------------------------------
void __std__vector_RooAbsLValuep__db_datamem(Reflex::Class*);
void __std__vector_RooAbsLValuep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsLValuep__datamem_bld(&__std__vector_RooAbsLValuep__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsLValuep__funcmem_bld(&__std__vector_RooAbsLValuep__db_funcmem);
void __std__vector_RooAbsLValuep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooAbsLValue*>"), typeid(::std::vector<RooAbsLValue*>), sizeof(::std::vector<RooAbsLValue*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3034, ::Reflex::BaseOffset< ::std::vector<RooAbsLValue*>, ::std::_Vector_base<RooAbsLValue*,std::allocator<RooAbsLValue*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_19002, Reflex::Literal("std::vector<RooAbsLValue*>::_Alloc_value_type"))
  .AddTypedef(type_3034, Reflex::Literal("std::vector<RooAbsLValue*>::_Base"))
  .AddTypedef(type_3709, Reflex::Literal("std::vector<RooAbsLValue*>::_Tp_alloc_type"))
  .AddTypedef(type_11029, Reflex::Literal("std::vector<RooAbsLValue*>::_Alloc_traits"))
  .AddTypedef(type_19002, Reflex::Literal("std::vector<RooAbsLValue*>::value_type"))
  .AddTypedef(type_17460, Reflex::Literal("std::vector<RooAbsLValue*>::pointer"))
  .AddTypedef(type_19009, Reflex::Literal("std::vector<RooAbsLValue*>::const_pointer"))
  .AddTypedef(type_19011, Reflex::Literal("std::vector<RooAbsLValue*>::reference"))
  .AddTypedef(type_19013, Reflex::Literal("std::vector<RooAbsLValue*>::const_reference"))
  .AddTypedef(type_10872, Reflex::Literal("std::vector<RooAbsLValue*>::iterator"))
  .AddTypedef(type_10873, Reflex::Literal("std::vector<RooAbsLValue*>::const_iterator"))
  .AddTypedef(type_3930, Reflex::Literal("std::vector<RooAbsLValue*>::const_reverse_iterator"))
  .AddTypedef(type_3931, Reflex::Literal("std::vector<RooAbsLValue*>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<RooAbsLValue*>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<RooAbsLValue*>::difference_type"))
  .AddTypedef(type_3709, Reflex::Literal("std::vector<RooAbsLValue*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19022, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32277), Reflex::Literal("vector"), constructor_19023, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19013, type_32277), Reflex::Literal("vector"), constructor_19024, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32562), Reflex::Literal("vector"), constructor_19025, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19026, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3108, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x167, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooAbsLValuep__funcmem_bld);
}

//------Delayed data member builder for class vector<RooAbsLValue*,std::allocator<RooAbsLValue*> > -------------------
void __std__vector_RooAbsLValuep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooAbsLValue*,std::allocator<RooAbsLValue*> > -------------------
void __std__vector_RooAbsLValuep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32563, type_32562), Reflex::Literal("operator="), operator_19027, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19013), Reflex::Literal("assign"), method_19028, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872), Reflex::Literal("begin"), method_19029, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10873), Reflex::Literal("begin"), method_19030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872), Reflex::Literal("end"), method_19031, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10873), Reflex::Literal("end"), method_19032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19002), Reflex::Literal("resize"), method_19039, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19042, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19011, type_3404), Reflex::Literal("operator[]"), operator_19043, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013, type_3404), Reflex::Literal("operator[]"), operator_19044, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19011, type_3404), Reflex::Literal("at"), method_19046, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013, type_3404), Reflex::Literal("at"), method_19047, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19011), Reflex::Literal("front"), method_19048, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("front"), method_19049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19011), Reflex::Literal("back"), method_19050, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19013), Reflex::Literal("back"), method_19051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17460), Reflex::Literal("data"), method_19052, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19009), Reflex::Literal("data"), method_19053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19013), Reflex::Literal("push_back"), method_19054, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19055, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872, type_10872, type_19013), Reflex::Literal("insert"), method_19056, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10872, type_3404, type_19013), Reflex::Literal("insert"), method_19057, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872, type_10872), Reflex::Literal("erase"), method_19058, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10872, type_10872, type_10872), Reflex::Literal("erase"), method_19059, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32563), Reflex::Literal("swap"), method_19060, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19061, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<double, std::allocator<double> >*,std::allocator<std::vector<double, std::allocator<double> >*> > -------------------------------
static void constructor_19087( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>();
  else ::new(mem) ::std::vector<std::vector<double>*>();
}

static void constructor_19088( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(const ::std::allocator<std::vector<double>*>*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(const ::std::allocator<std::vector<double>*>*)arg[0]);
}

static void constructor_19089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0],
      *(::std::vector<double>* const*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0],
      *(::std::vector<double>* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0],
      *(::std::vector<double>* const*)arg[1],
      *(const ::std::allocator<std::vector<double>*>*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(::std::size_t*)arg[0],
      *(::std::vector<double>* const*)arg[1],
      *(const ::std::allocator<std::vector<double>*>*)arg[2]);
  }
}

static void constructor_19090( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double>*>(*(const ::std::vector<std::vector<double>*>*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double>*>(*(const ::std::vector<std::vector<double>*>*)arg[0]);
}

static void destructor_19091(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<double>*>*)o)->::std::vector<std::vector<double>*>::~vector)();
}
static  void operator_19092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->operator=)(*(const ::std::vector<std::vector<double>*>*)arg[0]);
  else   (((::std::vector<std::vector<double>*>*)o)->operator=)(*(const ::std::vector<std::vector<double>*>*)arg[0]);
}

static  void method_19093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::std::vector<double>* const*)arg[1]);
}

static  void method_19094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->begin)());
  else   (((::std::vector<std::vector<double>*>*)o)->begin)();
}

static  void method_19095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>* const*,std::vector<std::vector<double>*> >)((((const ::std::vector<std::vector<double>*>*)o)->begin)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->begin)();
}

static  void method_19096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->end)());
  else   (((::std::vector<std::vector<double>*>*)o)->end)();
}

static  void method_19097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>* const*,std::vector<std::vector<double>*> >)((((const ::std::vector<std::vector<double>*>*)o)->end)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->end)();
}

static  void method_19102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double>*>*)o)->size)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->size)();
}

static  void method_19103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double>*>*)o)->max_size)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->max_size)();
}

static  void method_19104( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<double>*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<double>*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::std::vector<double>*)arg[1]);
  }
}

static  void method_19105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double>*>*)o)->capacity)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->capacity)();
}

static  void method_19106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<double>*>*)o)->empty)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->empty)();
}

static  void method_19107( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double>*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double>*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double>*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double>*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->front)();
  else   (((::std::vector<std::vector<double>*>*)o)->front)();
}

static  void method_19114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double>*>*)o)->front)();
  else   (((const ::std::vector<std::vector<double>*>*)o)->front)();
}

static  void method_19115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double>*>*)o)->back)();
  else   (((::std::vector<std::vector<double>*>*)o)->back)();
}

static  void method_19116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double>*>*)o)->back)();
  else   (((const ::std::vector<std::vector<double>*>*)o)->back)();
}

static  void method_19117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<double>*>*)o)->data)());
  else   (((::std::vector<std::vector<double>*>*)o)->data)();
}

static  void method_19118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<double>*>*)o)->data)());
  else   (((const ::std::vector<std::vector<double>*>*)o)->data)();
}

static  void method_19119( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->push_back)(*(::std::vector<double>* const*)arg[0]);
}

static  void method_19120( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->pop_back)();
}

static  void method_19121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::std::vector<double>* const*)arg[1]));
  else   (((::std::vector<std::vector<double>*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::std::vector<double>* const*)arg[1]);
}

static  void method_19122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::vector<double>* const*)arg[2]);
}

static  void method_19123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0]));
  else   (((::std::vector<std::vector<double>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0]);
}

static  void method_19124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >)((((::std::vector<std::vector<double>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[1]));
  else   (((::std::vector<std::vector<double>*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>**,std::vector<std::vector<double>*> >*)arg[1]);
}

static  void method_19125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->swap)(*(::std::vector<std::vector<double>*>*)arg[0]);
}

static  void method_19126( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double>*>*)o)->clear)();
}

static void method_newdel_3109( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double>*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> >")), ::Reflex::BaseOffset< ::std::vector<std::vector<double>*>,::std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x171( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<double>*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<double>*> >::Generate();
}

//------Dictionary for class vector<std::vector<double, std::allocator<double> >*,std::allocator<std::vector<double, std::allocator<double> >*> > -------------------------------
void __std__vector_std__vector_double_p__db_datamem(Reflex::Class*);
void __std__vector_std__vector_double_p__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_p__datamem_bld(&__std__vector_std__vector_double_p__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_p__funcmem_bld(&__std__vector_std__vector_double_p__db_funcmem);
void __std__vector_std__vector_double_p__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<double>*>"), typeid(::std::vector<std::vector<double>*>), sizeof(::std::vector<std::vector<double>*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3035, ::Reflex::BaseOffset< ::std::vector<std::vector<double>*>, ::std::_Vector_base<std::vector<double>*,std::allocator<std::vector<double>*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_17441, Reflex::Literal("std::vector<std::vector<double>*>::_Alloc_value_type"))
  .AddTypedef(type_3035, Reflex::Literal("std::vector<std::vector<double>*>::_Base"))
  .AddTypedef(type_3710, Reflex::Literal("std::vector<std::vector<double>*>::_Tp_alloc_type"))
  .AddTypedef(type_11030, Reflex::Literal("std::vector<std::vector<double>*>::_Alloc_traits"))
  .AddTypedef(type_17441, Reflex::Literal("std::vector<std::vector<double>*>::value_type"))
  .AddTypedef(type_17479, Reflex::Literal("std::vector<std::vector<double>*>::pointer"))
  .AddTypedef(type_19074, Reflex::Literal("std::vector<std::vector<double>*>::const_pointer"))
  .AddTypedef(type_19076, Reflex::Literal("std::vector<std::vector<double>*>::reference"))
  .AddTypedef(type_19078, Reflex::Literal("std::vector<std::vector<double>*>::const_reference"))
  .AddTypedef(type_10874, Reflex::Literal("std::vector<std::vector<double>*>::iterator"))
  .AddTypedef(type_10875, Reflex::Literal("std::vector<std::vector<double>*>::const_iterator"))
  .AddTypedef(type_3932, Reflex::Literal("std::vector<std::vector<double>*>::const_reverse_iterator"))
  .AddTypedef(type_3933, Reflex::Literal("std::vector<std::vector<double>*>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<std::vector<double>*>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<std::vector<double>*>::difference_type"))
  .AddTypedef(type_3710, Reflex::Literal("std::vector<std::vector<double>*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19087, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32290), Reflex::Literal("vector"), constructor_19088, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19078, type_32290), Reflex::Literal("vector"), constructor_19089, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32565), Reflex::Literal("vector"), constructor_19090, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19091, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3109, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_double_p__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<double, std::allocator<double> >*,std::allocator<std::vector<double, std::allocator<double> >*> > -------------------
void __std__vector_std__vector_double_p__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<double, std::allocator<double> >*,std::allocator<std::vector<double, std::allocator<double> >*> > -------------------
void __std__vector_std__vector_double_p__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32566, type_32565), Reflex::Literal("operator="), operator_19092, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19078), Reflex::Literal("assign"), method_19093, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874), Reflex::Literal("begin"), method_19094, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10875), Reflex::Literal("begin"), method_19095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874), Reflex::Literal("end"), method_19096, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10875), Reflex::Literal("end"), method_19097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_17441), Reflex::Literal("resize"), method_19104, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19107, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19076, type_3404), Reflex::Literal("operator[]"), operator_19108, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19078, type_3404), Reflex::Literal("operator[]"), operator_19109, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19076, type_3404), Reflex::Literal("at"), method_19111, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19078, type_3404), Reflex::Literal("at"), method_19112, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19076), Reflex::Literal("front"), method_19113, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19078), Reflex::Literal("front"), method_19114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19076), Reflex::Literal("back"), method_19115, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19078), Reflex::Literal("back"), method_19116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17479), Reflex::Literal("data"), method_19117, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19074), Reflex::Literal("data"), method_19118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19078), Reflex::Literal("push_back"), method_19119, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19120, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874, type_10874, type_19078), Reflex::Literal("insert"), method_19121, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10874, type_3404, type_19078), Reflex::Literal("insert"), method_19122, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874, type_10874), Reflex::Literal("erase"), method_19123, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10874, type_10874, type_10874), Reflex::Literal("erase"), method_19124, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32566), Reflex::Literal("swap"), method_19125, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19126, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooNormSetCache,std::allocator<RooNormSetCache> > -------------------------------
static void constructor_19152( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>();
  else ::new(mem) ::std::vector<RooNormSetCache>();
}

static void constructor_19153( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(const ::std::allocator<RooNormSetCache>*)arg[0]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(const ::std::allocator<RooNormSetCache>*)arg[0]);
}

static void constructor_19154( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0],
      *(const ::RooNormSetCache*)arg[1]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0],
      *(const ::RooNormSetCache*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0],
      *(const ::RooNormSetCache*)arg[1],
      *(const ::std::allocator<RooNormSetCache>*)arg[2]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(::std::size_t*)arg[0],
      *(const ::RooNormSetCache*)arg[1],
      *(const ::std::allocator<RooNormSetCache>*)arg[2]);
  }
}

static void constructor_19155( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooNormSetCache>(*(const ::std::vector<RooNormSetCache>*)arg[0]);
  else ::new(mem) ::std::vector<RooNormSetCache>(*(const ::std::vector<RooNormSetCache>*)arg[0]);
}

static void destructor_19156(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooNormSetCache>*)o)->::std::vector<RooNormSetCache>::~vector)();
}
static  void operator_19157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->operator=)(*(const ::std::vector<RooNormSetCache>*)arg[0]);
  else   (((::std::vector<RooNormSetCache>*)o)->operator=)(*(const ::std::vector<RooNormSetCache>*)arg[0]);
}

static  void method_19158( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RooNormSetCache*)arg[1]);
}

static  void method_19159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->begin)());
  else   (((::std::vector<RooNormSetCache>*)o)->begin)();
}

static  void method_19160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooNormSetCache*,std::vector<RooNormSetCache> >)((((const ::std::vector<RooNormSetCache>*)o)->begin)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->begin)();
}

static  void method_19161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->end)());
  else   (((::std::vector<RooNormSetCache>*)o)->end)();
}

static  void method_19162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooNormSetCache*,std::vector<RooNormSetCache> >)((((const ::std::vector<RooNormSetCache>*)o)->end)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->end)();
}

static  void method_19167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooNormSetCache>*)o)->size)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->size)();
}

static  void method_19168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooNormSetCache>*)o)->max_size)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->max_size)();
}

static  void method_19169( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooNormSetCache>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooNormSetCache>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RooNormSetCache*)arg[1]);
  }
}

static  void method_19170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooNormSetCache>*)o)->capacity)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->capacity)();
}

static  void method_19171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooNormSetCache>*)o)->empty)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->empty)();
}

static  void method_19172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooNormSetCache>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooNormSetCache>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooNormSetCache>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooNormSetCache>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooNormSetCache>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooNormSetCache>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->front)();
  else   (((::std::vector<RooNormSetCache>*)o)->front)();
}

static  void method_19179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooNormSetCache>*)o)->front)();
  else   (((const ::std::vector<RooNormSetCache>*)o)->front)();
}

static  void method_19180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooNormSetCache>*)o)->back)();
  else   (((::std::vector<RooNormSetCache>*)o)->back)();
}

static  void method_19181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooNormSetCache>*)o)->back)();
  else   (((const ::std::vector<RooNormSetCache>*)o)->back)();
}

static  void method_19182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooNormSetCache>*)o)->data)());
  else   (((::std::vector<RooNormSetCache>*)o)->data)();
}

static  void method_19183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooNormSetCache>*)o)->data)());
  else   (((const ::std::vector<RooNormSetCache>*)o)->data)();
}

static  void method_19184( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->push_back)(*(const ::RooNormSetCache*)arg[0]);
}

static  void method_19185( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->pop_back)();
}

static  void method_19186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(const ::RooNormSetCache*)arg[1]));
  else   (((::std::vector<RooNormSetCache>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(const ::RooNormSetCache*)arg[1]);
}

static  void method_19187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RooNormSetCache*)arg[2]);
}

static  void method_19188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0]));
  else   (((::std::vector<RooNormSetCache>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0]);
}

static  void method_19189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >)((((::std::vector<RooNormSetCache>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[1]));
  else   (((::std::vector<RooNormSetCache>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooNormSetCache*,std::vector<RooNormSetCache> >*)arg[1]);
}

static  void method_19190( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->swap)(*(::std::vector<RooNormSetCache>*)arg[0]);
}

static  void method_19191( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooNormSetCache>*)o)->clear)();
}

static void method_newdel_3110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooNormSetCache> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x173( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> >")), ::Reflex::BaseOffset< ::std::vector<RooNormSetCache>,::std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x174( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooNormSetCache> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooNormSetCache> >::Generate();
}

//------Dictionary for class vector<RooNormSetCache,std::allocator<RooNormSetCache> > -------------------------------
void __std__vector_RooNormSetCache__db_datamem(Reflex::Class*);
void __std__vector_RooNormSetCache__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooNormSetCache__datamem_bld(&__std__vector_RooNormSetCache__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooNormSetCache__funcmem_bld(&__std__vector_RooNormSetCache__db_funcmem);
void __std__vector_RooNormSetCache__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooNormSetCache>"), typeid(::std::vector<RooNormSetCache>), sizeof(::std::vector<RooNormSetCache>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3047, ::Reflex::BaseOffset< ::std::vector<RooNormSetCache>, ::std::_Vector_base<RooNormSetCache,std::allocator<RooNormSetCache> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_795, Reflex::Literal("std::vector<RooNormSetCache>::_Alloc_value_type"))
  .AddTypedef(type_3047, Reflex::Literal("std::vector<RooNormSetCache>::_Base"))
  .AddTypedef(type_3711, Reflex::Literal("std::vector<RooNormSetCache>::_Tp_alloc_type"))
  .AddTypedef(type_11042, Reflex::Literal("std::vector<RooNormSetCache>::_Alloc_traits"))
  .AddTypedef(type_795, Reflex::Literal("std::vector<RooNormSetCache>::value_type"))
  .AddTypedef(type_17705, Reflex::Literal("std::vector<RooNormSetCache>::pointer"))
  .AddTypedef(type_19139, Reflex::Literal("std::vector<RooNormSetCache>::const_pointer"))
  .AddTypedef(type_19141, Reflex::Literal("std::vector<RooNormSetCache>::reference"))
  .AddTypedef(type_19143, Reflex::Literal("std::vector<RooNormSetCache>::const_reference"))
  .AddTypedef(type_10898, Reflex::Literal("std::vector<RooNormSetCache>::iterator"))
  .AddTypedef(type_10899, Reflex::Literal("std::vector<RooNormSetCache>::const_iterator"))
  .AddTypedef(type_3976, Reflex::Literal("std::vector<RooNormSetCache>::const_reverse_iterator"))
  .AddTypedef(type_3977, Reflex::Literal("std::vector<RooNormSetCache>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<RooNormSetCache>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<RooNormSetCache>::difference_type"))
  .AddTypedef(type_3711, Reflex::Literal("std::vector<RooNormSetCache>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19152, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32446), Reflex::Literal("vector"), constructor_19153, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19143, type_32446), Reflex::Literal("vector"), constructor_19154, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32568), Reflex::Literal("vector"), constructor_19155, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19156, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooNormSetCache__funcmem_bld);
}

//------Delayed data member builder for class vector<RooNormSetCache,std::allocator<RooNormSetCache> > -------------------
void __std__vector_RooNormSetCache__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooNormSetCache,std::allocator<RooNormSetCache> > -------------------
void __std__vector_RooNormSetCache__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32569, type_32568), Reflex::Literal("operator="), operator_19157, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19143), Reflex::Literal("assign"), method_19158, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898), Reflex::Literal("begin"), method_19159, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10899), Reflex::Literal("begin"), method_19160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898), Reflex::Literal("end"), method_19161, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10899), Reflex::Literal("end"), method_19162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_795), Reflex::Literal("resize"), method_19169, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19172, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19141, type_3404), Reflex::Literal("operator[]"), operator_19173, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19143, type_3404), Reflex::Literal("operator[]"), operator_19174, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19141, type_3404), Reflex::Literal("at"), method_19176, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19143, type_3404), Reflex::Literal("at"), method_19177, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19141), Reflex::Literal("front"), method_19178, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19143), Reflex::Literal("front"), method_19179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19141), Reflex::Literal("back"), method_19180, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19143), Reflex::Literal("back"), method_19181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17705), Reflex::Literal("data"), method_19182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19139), Reflex::Literal("data"), method_19183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19143), Reflex::Literal("push_back"), method_19184, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19185, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898, type_10898, type_19143), Reflex::Literal("insert"), method_19186, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10898, type_3404, type_19143), Reflex::Literal("insert"), method_19187, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898, type_10898), Reflex::Literal("erase"), method_19188, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10898, type_10898, type_10898), Reflex::Literal("erase"), method_19189, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32569), Reflex::Literal("swap"), method_19190, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19191, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<double, TString>,std::allocator<std::pair<double, TString> > > -------------------------------
static void constructor_19217( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >();
  else ::new(mem) ::std::vector<std::pair<double,TString> >();
}

static void constructor_19218( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(const ::std::allocator<std::pair<double,TString> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(const ::std::allocator<std::pair<double,TString> >*)arg[0]);
}

static void constructor_19219( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,TString>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,TString>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,TString>*)arg[1],
      *(const ::std::allocator<std::pair<double,TString> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,TString>*)arg[1],
      *(const ::std::allocator<std::pair<double,TString> >*)arg[2]);
  }
}

static void constructor_19220( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,TString> >(*(const ::std::vector<std::pair<double,TString> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,TString> >(*(const ::std::vector<std::pair<double,TString> >*)arg[0]);
}

static void destructor_19221(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<double,TString> >*)o)->::std::vector<std::pair<double,TString> >::~vector)();
}
static  void operator_19222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->operator=)(*(const ::std::vector<std::pair<double,TString> >*)arg[0]);
  else   (((::std::vector<std::pair<double,TString> >*)o)->operator=)(*(const ::std::vector<std::pair<double,TString> >*)arg[0]);
}

static  void method_19223( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<double,TString>*)arg[1]);
}

static  void method_19224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->begin)());
  else   (((::std::vector<std::pair<double,TString> >*)o)->begin)();
}

static  void method_19225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((const ::std::vector<std::pair<double,TString> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->begin)();
}

static  void method_19226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->end)());
  else   (((::std::vector<std::pair<double,TString> >*)o)->end)();
}

static  void method_19227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((const ::std::vector<std::pair<double,TString> >*)o)->end)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->end)();
}

static  void method_19232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,TString> >*)o)->size)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->size)();
}

static  void method_19233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,TString> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->max_size)();
}

static  void method_19234( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<double,TString> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<double,TString> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<double,TString>*)arg[1]);
  }
}

static  void method_19235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,TString> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->capacity)();
}

static  void method_19236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<double,TString> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->empty)();
}

static  void method_19237( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19238( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<double,TString> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19239( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,TString> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<double,TString> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19242( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,TString> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->front)();
  else   (((::std::vector<std::pair<double,TString> >*)o)->front)();
}

static  void method_19244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,TString> >*)o)->front)();
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->front)();
}

static  void method_19245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,TString> >*)o)->back)();
  else   (((::std::vector<std::pair<double,TString> >*)o)->back)();
}

static  void method_19246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,TString> >*)o)->back)();
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->back)();
}

static  void method_19247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<double,TString> >*)o)->data)());
  else   (((::std::vector<std::pair<double,TString> >*)o)->data)();
}

static  void method_19248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<double,TString> >*)o)->data)());
  else   (((const ::std::vector<std::pair<double,TString> >*)o)->data)();
}

static  void method_19249( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->push_back)(*(const ::std::pair<double,TString>*)arg[0]);
}

static  void method_19250( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->pop_back)();
}

static  void method_19251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(const ::std::pair<double,TString>*)arg[1]));
  else   (((::std::vector<std::pair<double,TString> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(const ::std::pair<double,TString>*)arg[1]);
}

static  void method_19252( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<double,TString>*)arg[2]);
}

static  void method_19253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0]));
  else   (((::std::vector<std::pair<double,TString> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0]);
}

static  void method_19254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >)((((::std::vector<std::pair<double,TString> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[1]));
  else   (((::std::vector<std::pair<double,TString> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<double,TString>*,std::vector<std::pair<double,TString> > >*)arg[1]);
}

static  void method_19255( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->swap)(*(::std::vector<std::pair<double,TString> >*)arg[0]);
}

static  void method_19256( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<double,TString> >*)o)->clear)();
}

static void method_newdel_3111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,TString> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x176( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<double,TString> >,::std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x177( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<double,TString> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<double,TString> > >::Generate();
}

//------Dictionary for class vector<std::pair<double, TString>,std::allocator<std::pair<double, TString> > > -------------------------------
void __std__vector_std__pair_double_TString_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_double_TString_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_double_TString_s__datamem_bld(&__std__vector_std__pair_double_TString_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_double_TString_s__funcmem_bld(&__std__vector_std__pair_double_TString_s__db_funcmem);
void __std__vector_std__pair_double_TString_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<double,TString> >"), typeid(::std::vector<std::pair<double,TString> >), sizeof(::std::vector<std::pair<double,TString> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3037, ::Reflex::BaseOffset< ::std::vector<std::pair<double,TString> >, ::std::_Vector_base<std::pair<double,TString>,std::allocator<std::pair<double,TString> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3516, Reflex::Literal("std::vector<std::pair<double,TString> >::_Alloc_value_type"))
  .AddTypedef(type_3037, Reflex::Literal("std::vector<std::pair<double,TString> >::_Base"))
  .AddTypedef(type_3717, Reflex::Literal("std::vector<std::pair<double,TString> >::_Tp_alloc_type"))
  .AddTypedef(type_11032, Reflex::Literal("std::vector<std::pair<double,TString> >::_Alloc_traits"))
  .AddTypedef(type_3516, Reflex::Literal("std::vector<std::pair<double,TString> >::value_type"))
  .AddTypedef(type_17516, Reflex::Literal("std::vector<std::pair<double,TString> >::pointer"))
  .AddTypedef(type_19204, Reflex::Literal("std::vector<std::pair<double,TString> >::const_pointer"))
  .AddTypedef(type_19206, Reflex::Literal("std::vector<std::pair<double,TString> >::reference"))
  .AddTypedef(type_19208, Reflex::Literal("std::vector<std::pair<double,TString> >::const_reference"))
  .AddTypedef(type_10878, Reflex::Literal("std::vector<std::pair<double,TString> >::iterator"))
  .AddTypedef(type_10879, Reflex::Literal("std::vector<std::pair<double,TString> >::const_iterator"))
  .AddTypedef(type_3938, Reflex::Literal("std::vector<std::pair<double,TString> >::const_reverse_iterator"))
  .AddTypedef(type_3939, Reflex::Literal("std::vector<std::pair<double,TString> >::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<std::pair<double,TString> >::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<std::pair<double,TString> >::difference_type"))
  .AddTypedef(type_3717, Reflex::Literal("std::vector<std::pair<double,TString> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19217, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32316), Reflex::Literal("vector"), constructor_19218, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19208, type_32316), Reflex::Literal("vector"), constructor_19219, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32571), Reflex::Literal("vector"), constructor_19220, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19221, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x177, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_double_TString_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<double, TString>,std::allocator<std::pair<double, TString> > > -------------------
void __std__vector_std__pair_double_TString_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<double, TString>,std::allocator<std::pair<double, TString> > > -------------------
void __std__vector_std__pair_double_TString_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32572, type_32571), Reflex::Literal("operator="), operator_19222, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19208), Reflex::Literal("assign"), method_19223, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878), Reflex::Literal("begin"), method_19224, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10879), Reflex::Literal("begin"), method_19225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878), Reflex::Literal("end"), method_19226, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10879), Reflex::Literal("end"), method_19227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_3516), Reflex::Literal("resize"), method_19234, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19236, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19237, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19206, type_3404), Reflex::Literal("operator[]"), operator_19238, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19208, type_3404), Reflex::Literal("operator[]"), operator_19239, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19206, type_3404), Reflex::Literal("at"), method_19241, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19208, type_3404), Reflex::Literal("at"), method_19242, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19206), Reflex::Literal("front"), method_19243, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19208), Reflex::Literal("front"), method_19244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19206), Reflex::Literal("back"), method_19245, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19208), Reflex::Literal("back"), method_19246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17516), Reflex::Literal("data"), method_19247, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19204), Reflex::Literal("data"), method_19248, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19208), Reflex::Literal("push_back"), method_19249, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19250, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878, type_10878, type_19208), Reflex::Literal("insert"), method_19251, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10878, type_3404, type_19208), Reflex::Literal("insert"), method_19252, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878, type_10878), Reflex::Literal("erase"), method_19253, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10878, type_10878, type_10878), Reflex::Literal("erase"), method_19254, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32572), Reflex::Literal("swap"), method_19255, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19256, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<TString,std::allocator<TString> > -------------------------------
static void constructor_19279( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>();
  else ::new(mem) ::std::vector<TString>();
}

static void constructor_19280( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(const ::std::allocator<TString>*)arg[0]);
  else ::new(mem) ::std::vector<TString>(*(const ::std::allocator<TString>*)arg[0]);
}

static void constructor_19281( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0],
      *(const ::TString*)arg[1]);
  else ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0],
      *(const ::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0],
      *(const ::TString*)arg[1],
      *(const ::std::allocator<TString>*)arg[2]);
  else ::new(mem) ::std::vector<TString>(*(::std::size_t*)arg[0],
      *(const ::TString*)arg[1],
      *(const ::std::allocator<TString>*)arg[2]);
  }
}

static void constructor_19282( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TString>(*(const ::std::vector<TString>*)arg[0]);
  else ::new(mem) ::std::vector<TString>(*(const ::std::vector<TString>*)arg[0]);
}

static void destructor_19283(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TString>*)o)->::std::vector<TString>::~vector)();
}
static  void operator_19284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->operator=)(*(const ::std::vector<TString>*)arg[0]);
  else   (((::std::vector<TString>*)o)->operator=)(*(const ::std::vector<TString>*)arg[0]);
}

static  void method_19285( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::TString*)arg[1]);
}

static  void method_19286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->begin)());
  else   (((::std::vector<TString>*)o)->begin)();
}

static  void method_19287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TString*,std::vector<TString> >)((((const ::std::vector<TString>*)o)->begin)());
  else   (((const ::std::vector<TString>*)o)->begin)();
}

static  void method_19288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->end)());
  else   (((::std::vector<TString>*)o)->end)();
}

static  void method_19289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TString*,std::vector<TString> >)((((const ::std::vector<TString>*)o)->end)());
  else   (((const ::std::vector<TString>*)o)->end)();
}

static  void method_19294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TString>*)o)->size)());
  else   (((const ::std::vector<TString>*)o)->size)();
}

static  void method_19295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TString>*)o)->max_size)());
  else   (((const ::std::vector<TString>*)o)->max_size)();
}

static  void method_19296( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TString>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TString>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::TString*)arg[1]);
  }
}

static  void method_19297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TString>*)o)->capacity)());
  else   (((const ::std::vector<TString>*)o)->capacity)();
}

static  void method_19298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TString>*)o)->empty)());
  else   (((const ::std::vector<TString>*)o)->empty)();
}

static  void method_19299( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TString>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19301( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TString>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TString>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TString>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19304( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TString>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TString>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->front)();
  else   (((::std::vector<TString>*)o)->front)();
}

static  void method_19306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TString>*)o)->front)();
  else   (((const ::std::vector<TString>*)o)->front)();
}

static  void method_19307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TString>*)o)->back)();
  else   (((::std::vector<TString>*)o)->back)();
}

static  void method_19308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TString>*)o)->back)();
  else   (((const ::std::vector<TString>*)o)->back)();
}

static  void method_19309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TString>*)o)->data)());
  else   (((::std::vector<TString>*)o)->data)();
}

static  void method_19310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TString>*)o)->data)());
  else   (((const ::std::vector<TString>*)o)->data)();
}

static  void method_19311( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->push_back)(*(const ::TString*)arg[0]);
}

static  void method_19312( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TString>*)o)->pop_back)();
}

static  void method_19313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(const ::TString*)arg[1]));
  else   (((::std::vector<TString>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(const ::TString*)arg[1]);
}

static  void method_19314( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::TString*)arg[2]);
}

static  void method_19315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0]));
  else   (((::std::vector<TString>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0]);
}

static  void method_19316( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >)((((::std::vector<TString>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[1]));
  else   (((::std::vector<TString>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TString*,std::vector<TString> >*)arg[1]);
}

static  void method_19317( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TString>*)o)->swap)(*(::std::vector<TString>*)arg[0]);
}

static  void method_19318( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TString>*)o)->clear)();
}

static void method_newdel_3113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TString> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x179( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TString,std::allocator<TString> >")), ::Reflex::BaseOffset< ::std::vector<TString>,::std::_Vector_base<TString,std::allocator<TString> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x180( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TString> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TString> >::Generate();
}

//------Dictionary for class vector<TString,std::allocator<TString> > -------------------------------
void __std__vector_TString__db_datamem(Reflex::Class*);
void __std__vector_TString__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TString__datamem_bld(&__std__vector_TString__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TString__funcmem_bld(&__std__vector_TString__db_funcmem);
void __std__vector_TString__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TString>"), typeid(::std::vector<TString>), sizeof(::std::vector<TString>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3041, ::Reflex::BaseOffset< ::std::vector<TString>, ::std::_Vector_base<TString,std::allocator<TString> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2743, Reflex::Literal("std::vector<TString>::_Alloc_value_type"))
  .AddTypedef(type_3041, Reflex::Literal("std::vector<TString>::_Base"))
  .AddTypedef(type_3724, Reflex::Literal("std::vector<TString>::_Tp_alloc_type"))
  .AddTypedef(type_11036, Reflex::Literal("std::vector<TString>::_Alloc_traits"))
  .AddTypedef(type_2743, Reflex::Literal("std::vector<TString>::value_type"))
  .AddTypedef(type_17591, Reflex::Literal("std::vector<TString>::pointer"))
  .AddTypedef(type_9745, Reflex::Literal("std::vector<TString>::const_pointer"))
  .AddTypedef(type_6056, Reflex::Literal("std::vector<TString>::reference"))
  .AddTypedef(type_5544, Reflex::Literal("std::vector<TString>::const_reference"))
  .AddTypedef(type_10886, Reflex::Literal("std::vector<TString>::iterator"))
  .AddTypedef(type_10887, Reflex::Literal("std::vector<TString>::const_iterator"))
  .AddTypedef(type_3950, Reflex::Literal("std::vector<TString>::const_reverse_iterator"))
  .AddTypedef(type_3951, Reflex::Literal("std::vector<TString>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<TString>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<TString>::difference_type"))
  .AddTypedef(type_3724, Reflex::Literal("std::vector<TString>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19279, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32368), Reflex::Literal("vector"), constructor_19280, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_5544, type_32368), Reflex::Literal("vector"), constructor_19281, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32573), Reflex::Literal("vector"), constructor_19282, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19283, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x179, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x180, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TString__funcmem_bld);
}

//------Delayed data member builder for class vector<TString,std::allocator<TString> > -------------------
void __std__vector_TString__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TString,std::allocator<TString> > -------------------
void __std__vector_TString__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32574, type_32573), Reflex::Literal("operator="), operator_19284, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_5544), Reflex::Literal("assign"), method_19285, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886), Reflex::Literal("begin"), method_19286, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10887), Reflex::Literal("begin"), method_19287, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886), Reflex::Literal("end"), method_19288, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10887), Reflex::Literal("end"), method_19289, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19294, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_2743), Reflex::Literal("resize"), method_19296, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19298, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19299, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6056, type_3404), Reflex::Literal("operator[]"), operator_19300, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5544, type_3404), Reflex::Literal("operator[]"), operator_19301, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6056, type_3404), Reflex::Literal("at"), method_19303, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5544, type_3404), Reflex::Literal("at"), method_19304, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6056), Reflex::Literal("front"), method_19305, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5544), Reflex::Literal("front"), method_19306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6056), Reflex::Literal("back"), method_19307, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5544), Reflex::Literal("back"), method_19308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17591), Reflex::Literal("data"), method_19309, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9745), Reflex::Literal("data"), method_19310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_5544), Reflex::Literal("push_back"), method_19311, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19312, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886, type_10886, type_5544), Reflex::Literal("insert"), method_19313, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10886, type_3404, type_5544), Reflex::Literal("insert"), method_19314, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886, type_10886), Reflex::Literal("erase"), method_19315, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10886, type_10886, type_10886), Reflex::Literal("erase"), method_19316, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32574), Reflex::Literal("swap"), method_19317, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19318, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > >,std::allocator<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > > > > -------------------------------
static void constructor_19344( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >();
  else ::new(mem) ::std::vector<std::map<int,int> >();
}

static void constructor_19345( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(const ::std::allocator<std::map<int,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(const ::std::allocator<std::map<int,int> >*)arg[0]);
}

static void constructor_19346( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::map<int,int>*)arg[1]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::map<int,int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::map<int,int>*)arg[1],
      *(const ::std::allocator<std::map<int,int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::map<int,int>*)arg[1],
      *(const ::std::allocator<std::map<int,int> >*)arg[2]);
  }
}

static void constructor_19347( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<int,int> >(*(const ::std::vector<std::map<int,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<int,int> >(*(const ::std::vector<std::map<int,int> >*)arg[0]);
}

static void destructor_19348(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::map<int,int> >*)o)->::std::vector<std::map<int,int> >::~vector)();
}
static  void operator_19349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->operator=)(*(const ::std::vector<std::map<int,int> >*)arg[0]);
  else   (((::std::vector<std::map<int,int> >*)o)->operator=)(*(const ::std::vector<std::map<int,int> >*)arg[0]);
}

static  void method_19350( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::map<int,int>*)arg[1]);
}

static  void method_19351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->begin)());
  else   (((::std::vector<std::map<int,int> >*)o)->begin)();
}

static  void method_19352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<int,int>*,std::vector<std::map<int,int> > >)((((const ::std::vector<std::map<int,int> >*)o)->begin)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->begin)();
}

static  void method_19353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->end)());
  else   (((::std::vector<std::map<int,int> >*)o)->end)();
}

static  void method_19354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<int,int>*,std::vector<std::map<int,int> > >)((((const ::std::vector<std::map<int,int> >*)o)->end)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->end)();
}

static  void method_19359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<int,int> >*)o)->size)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->size)();
}

static  void method_19360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<int,int> >*)o)->max_size)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->max_size)();
}

static  void method_19361( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::map<int,int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::map<int,int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::map<int,int>*)arg[1]);
  }
}

static  void method_19362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<int,int> >*)o)->capacity)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->capacity)();
}

static  void method_19363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::map<int,int> >*)o)->empty)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->empty)();
}

static  void method_19364( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->front)();
  else   (((::std::vector<std::map<int,int> >*)o)->front)();
}

static  void method_19371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<int,int> >*)o)->front)();
  else   (((const ::std::vector<std::map<int,int> >*)o)->front)();
}

static  void method_19372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<int,int> >*)o)->back)();
  else   (((::std::vector<std::map<int,int> >*)o)->back)();
}

static  void method_19373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<int,int> >*)o)->back)();
  else   (((const ::std::vector<std::map<int,int> >*)o)->back)();
}

static  void method_19374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::map<int,int> >*)o)->data)());
  else   (((::std::vector<std::map<int,int> >*)o)->data)();
}

static  void method_19375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::map<int,int> >*)o)->data)());
  else   (((const ::std::vector<std::map<int,int> >*)o)->data)();
}

static  void method_19376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->push_back)(*(const ::std::map<int,int>*)arg[0]);
}

static  void method_19377( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->pop_back)();
}

static  void method_19378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(const ::std::map<int,int>*)arg[1]));
  else   (((::std::vector<std::map<int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(const ::std::map<int,int>*)arg[1]);
}

static  void method_19379( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::map<int,int>*)arg[2]);
}

static  void method_19380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0]));
  else   (((::std::vector<std::map<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0]);
}

static  void method_19381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >)((((::std::vector<std::map<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[1]));
  else   (((::std::vector<std::map<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<int,int>*,std::vector<std::map<int,int> > >*)arg[1]);
}

static  void method_19382( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->swap)(*(::std::vector<std::map<int,int> >*)arg[0]);
}

static  void method_19383( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<int,int> >*)o)->clear)();
}

static void method_newdel_3114( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<int,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x182( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > >")), ::Reflex::BaseOffset< ::std::vector<std::map<int,int> >,::std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::map<int,int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::map<int,int> > >::Generate();
}

//------Dictionary for class vector<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > >,std::allocator<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > > > > -------------------------------
void __std__vector_std__map_int_int_s__db_datamem(Reflex::Class*);
void __std__vector_std__map_int_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__map_int_int_s__datamem_bld(&__std__vector_std__map_int_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__map_int_int_s__funcmem_bld(&__std__vector_std__map_int_int_s__db_funcmem);
void __std__vector_std__map_int_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::map<int,int> >"), typeid(::std::vector<std::map<int,int> >), sizeof(::std::vector<std::map<int,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3042, ::Reflex::BaseOffset< ::std::vector<std::map<int,int> >, ::std::_Vector_base<std::map<int,int>,std::allocator<std::map<int,int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3365, Reflex::Literal("std::vector<std::map<int,int> >::_Alloc_value_type"))
  .AddTypedef(type_3042, Reflex::Literal("std::vector<std::map<int,int> >::_Base"))
  .AddTypedef(type_3725, Reflex::Literal("std::vector<std::map<int,int> >::_Tp_alloc_type"))
  .AddTypedef(type_11037, Reflex::Literal("std::vector<std::map<int,int> >::_Alloc_traits"))
  .AddTypedef(type_3365, Reflex::Literal("std::vector<std::map<int,int> >::value_type"))
  .AddTypedef(type_17610, Reflex::Literal("std::vector<std::map<int,int> >::pointer"))
  .AddTypedef(type_19331, Reflex::Literal("std::vector<std::map<int,int> >::const_pointer"))
  .AddTypedef(type_19333, Reflex::Literal("std::vector<std::map<int,int> >::reference"))
  .AddTypedef(type_19335, Reflex::Literal("std::vector<std::map<int,int> >::const_reference"))
  .AddTypedef(type_10888, Reflex::Literal("std::vector<std::map<int,int> >::iterator"))
  .AddTypedef(type_10889, Reflex::Literal("std::vector<std::map<int,int> >::const_iterator"))
  .AddTypedef(type_3952, Reflex::Literal("std::vector<std::map<int,int> >::const_reverse_iterator"))
  .AddTypedef(type_3953, Reflex::Literal("std::vector<std::map<int,int> >::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<std::map<int,int> >::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<std::map<int,int> >::difference_type"))
  .AddTypedef(type_3725, Reflex::Literal("std::vector<std::map<int,int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19344, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32381), Reflex::Literal("vector"), constructor_19345, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19335, type_32381), Reflex::Literal("vector"), constructor_19346, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32576), Reflex::Literal("vector"), constructor_19347, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19348, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3114, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__map_int_int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > >,std::allocator<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > > > > -------------------
void __std__vector_std__map_int_int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > >,std::allocator<std::map<int, int, std::less<int>, std::allocator<std::pair<const int, int> > > > > -------------------
void __std__vector_std__map_int_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32577, type_32576), Reflex::Literal("operator="), operator_19349, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19335), Reflex::Literal("assign"), method_19350, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888), Reflex::Literal("begin"), method_19351, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10889), Reflex::Literal("begin"), method_19352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888), Reflex::Literal("end"), method_19353, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10889), Reflex::Literal("end"), method_19354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_3365), Reflex::Literal("resize"), method_19361, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19364, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19333, type_3404), Reflex::Literal("operator[]"), operator_19365, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19335, type_3404), Reflex::Literal("operator[]"), operator_19366, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19333, type_3404), Reflex::Literal("at"), method_19368, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19335, type_3404), Reflex::Literal("at"), method_19369, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19333), Reflex::Literal("front"), method_19370, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19335), Reflex::Literal("front"), method_19371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19333), Reflex::Literal("back"), method_19372, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19335), Reflex::Literal("back"), method_19373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17610), Reflex::Literal("data"), method_19374, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19331), Reflex::Literal("data"), method_19375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19335), Reflex::Literal("push_back"), method_19376, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19377, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888, type_10888, type_19335), Reflex::Literal("insert"), method_19378, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10888, type_3404, type_19335), Reflex::Literal("insert"), method_19379, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888, type_10888), Reflex::Literal("erase"), method_19380, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10888, type_10888, type_10888), Reflex::Literal("erase"), method_19381, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32577), Reflex::Literal("swap"), method_19382, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19383, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > -------------------------------
static void constructor_19410( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>();
  else ::new(mem) ::std::vector<RooAbsRealLValue*>();
}

static void constructor_19411( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(const ::std::allocator<RooAbsRealLValue*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(const ::std::allocator<RooAbsRealLValue*>*)arg[0]);
}

static void constructor_19412( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsRealLValue* const*)arg[1]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsRealLValue* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsRealLValue* const*)arg[1],
      *(const ::std::allocator<RooAbsRealLValue*>*)arg[2]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(::std::size_t*)arg[0],
      *(::RooAbsRealLValue* const*)arg[1],
      *(const ::std::allocator<RooAbsRealLValue*>*)arg[2]);
  }
}

static void constructor_19413( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsRealLValue*>(*(const ::std::vector<RooAbsRealLValue*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsRealLValue*>(*(const ::std::vector<RooAbsRealLValue*>*)arg[0]);
}

static void destructor_19414(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooAbsRealLValue*>*)o)->::std::vector<RooAbsRealLValue*>::~vector)();
}
static  void operator_19415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->operator=)(*(const ::std::vector<RooAbsRealLValue*>*)arg[0]);
  else   (((::std::vector<RooAbsRealLValue*>*)o)->operator=)(*(const ::std::vector<RooAbsRealLValue*>*)arg[0]);
}

static  void method_19416( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooAbsRealLValue* const*)arg[1]);
}

static  void method_19417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->begin)());
  else   (((::std::vector<RooAbsRealLValue*>*)o)->begin)();
}

static  void method_19418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue* const*,std::vector<RooAbsRealLValue*> >)((((const ::std::vector<RooAbsRealLValue*>*)o)->begin)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->begin)();
}

static  void method_19419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->end)());
  else   (((::std::vector<RooAbsRealLValue*>*)o)->end)();
}

static  void method_19420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue* const*,std::vector<RooAbsRealLValue*> >)((((const ::std::vector<RooAbsRealLValue*>*)o)->end)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->end)();
}

static  void method_19425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsRealLValue*>*)o)->size)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->size)();
}

static  void method_19426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsRealLValue*>*)o)->max_size)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->max_size)();
}

static  void method_19427( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooAbsRealLValue*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooAbsRealLValue*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooAbsRealLValue*)arg[1]);
  }
}

static  void method_19428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsRealLValue*>*)o)->capacity)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->capacity)();
}

static  void method_19429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooAbsRealLValue*>*)o)->empty)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->empty)();
}

static  void method_19430( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19431( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsRealLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19432( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsRealLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsRealLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsRealLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->front)();
  else   (((::std::vector<RooAbsRealLValue*>*)o)->front)();
}

static  void method_19437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsRealLValue*>*)o)->front)();
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->front)();
}

static  void method_19438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsRealLValue*>*)o)->back)();
  else   (((::std::vector<RooAbsRealLValue*>*)o)->back)();
}

static  void method_19439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsRealLValue*>*)o)->back)();
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->back)();
}

static  void method_19440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooAbsRealLValue*>*)o)->data)());
  else   (((::std::vector<RooAbsRealLValue*>*)o)->data)();
}

static  void method_19441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooAbsRealLValue*>*)o)->data)());
  else   (((const ::std::vector<RooAbsRealLValue*>*)o)->data)();
}

static  void method_19442( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->push_back)(*(::RooAbsRealLValue* const*)arg[0]);
}

static  void method_19443( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->pop_back)();
}

static  void method_19444( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::RooAbsRealLValue* const*)arg[1]));
  else   (((::std::vector<RooAbsRealLValue*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::RooAbsRealLValue* const*)arg[1]);
}

static  void method_19445( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooAbsRealLValue* const*)arg[2]);
}

static  void method_19446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0]));
  else   (((::std::vector<RooAbsRealLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0]);
}

static  void method_19447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >)((((::std::vector<RooAbsRealLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[1]));
  else   (((::std::vector<RooAbsRealLValue*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsRealLValue**,std::vector<RooAbsRealLValue*> >*)arg[1]);
}

static  void method_19448( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->swap)(*(::std::vector<RooAbsRealLValue*>*)arg[0]);
}

static  void method_19449( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsRealLValue*>*)o)->clear)();
}

static void method_newdel_3115( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsRealLValue*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x185( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> >")), ::Reflex::BaseOffset< ::std::vector<RooAbsRealLValue*>,::std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x186( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooAbsRealLValue*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooAbsRealLValue*> >::Generate();
}

//------Dictionary for class vector<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > -------------------------------
void __std__vector_RooAbsRealLValuep__db_datamem(Reflex::Class*);
void __std__vector_RooAbsRealLValuep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsRealLValuep__datamem_bld(&__std__vector_RooAbsRealLValuep__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsRealLValuep__funcmem_bld(&__std__vector_RooAbsRealLValuep__db_funcmem);
void __std__vector_RooAbsRealLValuep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooAbsRealLValue*>"), typeid(::std::vector<RooAbsRealLValue*>), sizeof(::std::vector<RooAbsRealLValue*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3040, ::Reflex::BaseOffset< ::std::vector<RooAbsRealLValue*>, ::std::_Vector_base<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_19390, Reflex::Literal("std::vector<RooAbsRealLValue*>::_Alloc_value_type"))
  .AddTypedef(type_3040, Reflex::Literal("std::vector<RooAbsRealLValue*>::_Base"))
  .AddTypedef(type_3721, Reflex::Literal("std::vector<RooAbsRealLValue*>::_Tp_alloc_type"))
  .AddTypedef(type_11035, Reflex::Literal("std::vector<RooAbsRealLValue*>::_Alloc_traits"))
  .AddTypedef(type_19390, Reflex::Literal("std::vector<RooAbsRealLValue*>::value_type"))
  .AddTypedef(type_17572, Reflex::Literal("std::vector<RooAbsRealLValue*>::pointer"))
  .AddTypedef(type_19397, Reflex::Literal("std::vector<RooAbsRealLValue*>::const_pointer"))
  .AddTypedef(type_19399, Reflex::Literal("std::vector<RooAbsRealLValue*>::reference"))
  .AddTypedef(type_19401, Reflex::Literal("std::vector<RooAbsRealLValue*>::const_reference"))
  .AddTypedef(type_10884, Reflex::Literal("std::vector<RooAbsRealLValue*>::iterator"))
  .AddTypedef(type_10885, Reflex::Literal("std::vector<RooAbsRealLValue*>::const_iterator"))
  .AddTypedef(type_3946, Reflex::Literal("std::vector<RooAbsRealLValue*>::const_reverse_iterator"))
  .AddTypedef(type_3947, Reflex::Literal("std::vector<RooAbsRealLValue*>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<RooAbsRealLValue*>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<RooAbsRealLValue*>::difference_type"))
  .AddTypedef(type_3721, Reflex::Literal("std::vector<RooAbsRealLValue*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19410, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32355), Reflex::Literal("vector"), constructor_19411, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19401, type_32355), Reflex::Literal("vector"), constructor_19412, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32579), Reflex::Literal("vector"), constructor_19413, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19414, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x185, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooAbsRealLValuep__funcmem_bld);
}

//------Delayed data member builder for class vector<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > -------------------
void __std__vector_RooAbsRealLValuep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooAbsRealLValue*,std::allocator<RooAbsRealLValue*> > -------------------
void __std__vector_RooAbsRealLValuep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32580, type_32579), Reflex::Literal("operator="), operator_19415, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19401), Reflex::Literal("assign"), method_19416, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884), Reflex::Literal("begin"), method_19417, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10885), Reflex::Literal("begin"), method_19418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884), Reflex::Literal("end"), method_19419, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10885), Reflex::Literal("end"), method_19420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19425, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19426, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19390), Reflex::Literal("resize"), method_19427, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19430, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19399, type_3404), Reflex::Literal("operator[]"), operator_19431, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19401, type_3404), Reflex::Literal("operator[]"), operator_19432, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19399, type_3404), Reflex::Literal("at"), method_19434, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19401, type_3404), Reflex::Literal("at"), method_19435, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19399), Reflex::Literal("front"), method_19436, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19401), Reflex::Literal("front"), method_19437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19399), Reflex::Literal("back"), method_19438, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19401), Reflex::Literal("back"), method_19439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17572), Reflex::Literal("data"), method_19440, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19397), Reflex::Literal("data"), method_19441, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19401), Reflex::Literal("push_back"), method_19442, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19443, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884, type_10884, type_19401), Reflex::Literal("insert"), method_19444, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10884, type_3404, type_19401), Reflex::Literal("insert"), method_19445, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884, type_10884), Reflex::Literal("erase"), method_19446, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10884, type_10884, type_10884), Reflex::Literal("erase"), method_19447, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32580), Reflex::Literal("swap"), method_19448, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19449, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<bool,std::allocator<bool> > -------------------------------
static  void method_19469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<bool>)((((const ::std::vector<bool>*)o)->get_allocator)());
  else   (((const ::std::vector<bool>*)o)->get_allocator)();
}

static void constructor_19470( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>();
  else ::new(mem) ::std::vector<bool>();
}

static void constructor_19471( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(const ::std::allocator<bool>*)arg[0]);
  else ::new(mem) ::std::vector<bool>(*(const ::std::allocator<bool>*)arg[0]);
}

static void constructor_19472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1]);
  else ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::allocator<bool>*)arg[2]);
  else ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::allocator<bool>*)arg[2]);
  }
}

static void constructor_19473( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(const ::std::vector<bool>*)arg[0]);
  else ::new(mem) ::std::vector<bool>(*(const ::std::vector<bool>*)arg[0]);
}

static void destructor_19474(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<bool>*)o)->::std::vector<bool>::~vector)();
}
static  void operator_19475( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<bool>*)o)->operator=)(*(const ::std::vector<bool>*)arg[0]);
  else   (((::std::vector<bool>*)o)->operator=)(*(const ::std::vector<bool>*)arg[0]);
}

static  void method_19476( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const bool*)arg[1]);
}

static  void method_19477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->begin)());
  else   (((::std::vector<bool>*)o)->begin)();
}

static  void method_19478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_const_iterator)((((const ::std::vector<bool>*)o)->begin)());
  else   (((const ::std::vector<bool>*)o)->begin)();
}

static  void method_19479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->end)());
  else   (((::std::vector<bool>*)o)->end)();
}

static  void method_19480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_const_iterator)((((const ::std::vector<bool>*)o)->end)());
  else   (((const ::std::vector<bool>*)o)->end)();
}

static  void method_19485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<bool>*)o)->size)());
  else   (((const ::std::vector<bool>*)o)->size)();
}

static  void method_19486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<bool>*)o)->max_size)());
  else   (((const ::std::vector<bool>*)o)->max_size)();
}

static  void method_19487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<bool>*)o)->capacity)());
  else   (((const ::std::vector<bool>*)o)->capacity)();
}

static  void method_19488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->empty)());
  else   (((const ::std::vector<bool>*)o)->empty)();
}

static  void operator_19489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19492( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19494( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_19495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->front)());
  else   (((::std::vector<bool>*)o)->front)();
}

static  void method_19496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->front)());
  else   (((const ::std::vector<bool>*)o)->front)();
}

static  void method_19497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->back)());
  else   (((::std::vector<bool>*)o)->back)();
}

static  void method_19498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->back)());
  else   (((const ::std::vector<bool>*)o)->back)();
}

static  void method_19499( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->data)();
}

static  void method_19500( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->push_back)(*(bool*)arg[0]);
}

static  void method_19501( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->swap)(*(::std::vector<bool>*)arg[0]);
}

static  void method_19502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->swap)(*(::std::_Bit_reference*)arg[0],
    *(::std::_Bit_reference*)arg[1]);
}

static  void method_19503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0]));
    else     (((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0],
      *(const bool*)arg[1]));
    else     (((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_19504( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0],
    *(::std::size_t*)arg[1],
    *(const bool*)arg[2]);
}

static  void method_19505( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->pop_back)();
}

static  void method_19506( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0]));
  else   (((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0]);
}

static  void method_19507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0],
    *(::std::_Bit_iterator*)arg[1]));
  else   (((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0],
    *(::std::_Bit_iterator*)arg[1]);
}

static  void method_19508( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<bool>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<bool>*)o)->resize)(*(::std::size_t*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_19509( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->flip)();
}

static  void method_19510( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->clear)();
}

static void method_newdel_3116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Bvector_base<std::allocator<bool> >")), ::Reflex::BaseOffset< ::std::vector<bool>,::std::_Bvector_base<std::allocator<bool> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x189( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<bool> >::Generate();
  else ::Reflex::Proxy< ::std::vector<bool> >::Generate();
}

//------Dictionary for class vector<bool,std::allocator<bool> > -------------------------------
void __std__vector_bool__db_datamem(Reflex::Class*);
void __std__vector_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_bool__datamem_bld(&__std__vector_bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_bool__funcmem_bld(&__std__vector_bool__db_funcmem);
void __std__vector_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<bool>"), typeid(::std::vector<bool>), sizeof(::std::vector<bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3254, ::Reflex::BaseOffset< ::std::vector<bool>, ::std::_Bvector_base<std::allocator<bool> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3254, Reflex::Literal("std::vector<bool>::_Base"))
  .AddTypedef(type_667, Reflex::Literal("std::vector<bool>::value_type"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<bool>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<bool>::difference_type"))
  .AddTypedef(type_3222, Reflex::Literal("std::vector<bool>::reference"))
  .AddTypedef(type_667, Reflex::Literal("std::vector<bool>::const_reference"))
  .AddTypedef(type_17824, Reflex::Literal("std::vector<bool>::pointer"))
  .AddTypedef(type_17814, Reflex::Literal("std::vector<bool>::const_pointer"))
  .AddTypedef(type_3223, Reflex::Literal("std::vector<bool>::iterator"))
  .AddTypedef(type_4012, Reflex::Literal("std::vector<bool>::const_iterator"))
  .AddTypedef(type_3990, Reflex::Literal("std::vector<bool>::const_reverse_iterator"))
  .AddTypedef(type_3991, Reflex::Literal("std::vector<bool>::reverse_iterator"))
  .AddTypedef(type_3723, Reflex::Literal("std::vector<bool>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19470, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32581), Reflex::Literal("vector"), constructor_19471, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_25948, type_32581), Reflex::Literal("vector"), constructor_19472, 0, "__n;__value=bool();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32582), Reflex::Literal("vector"), constructor_19473, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19474, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x189, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_bool__funcmem_bld);
}

//------Delayed data member builder for class vector<bool,std::allocator<bool> > -------------------
void __std__vector_bool__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<bool,std::allocator<bool> > -------------------
void __std__vector_bool__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3723), Reflex::Literal("get_allocator"), method_19469, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32583, type_32582), Reflex::Literal("operator="), operator_19475, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_25948), Reflex::Literal("assign"), method_19476, 0, "__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3223), Reflex::Literal("begin"), method_19477, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4012), Reflex::Literal("begin"), method_19478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3223), Reflex::Literal("end"), method_19479, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4012), Reflex::Literal("end"), method_19480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19485, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19487, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19488, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3222, type_3404), Reflex::Literal("operator[]"), operator_19489, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667, type_3404), Reflex::Literal("operator[]"), operator_19490, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3222, type_3404), Reflex::Literal("at"), method_19492, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667, type_3404), Reflex::Literal("at"), method_19493, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19494, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3222), Reflex::Literal("front"), method_19495, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("front"), method_19496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3222), Reflex::Literal("back"), method_19497, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("back"), method_19498, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("data"), method_19499, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_667), Reflex::Literal("push_back"), method_19500, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32583), Reflex::Literal("swap"), method_19501, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3222, type_3222), Reflex::Literal("swap"), method_19502, 0, "__x;__y", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3223, type_3223, type_25948), Reflex::Literal("insert"), method_19503, 0, "__position;__x=bool()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3223, type_3404, type_25948), Reflex::Literal("insert"), method_19504, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19505, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3223, type_3223), Reflex::Literal("erase"), method_19506, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3223, type_3223, type_3223), Reflex::Literal("erase"), method_19507, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_667), Reflex::Literal("resize"), method_19508, 0, "__new_size;__x=bool()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("flip"), method_19509, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19510, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooArgSet*,std::allocator<RooArgSet*> > -------------------------------
static void constructor_19538( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>();
  else ::new(mem) ::std::vector<RooArgSet*>();
}

static void constructor_19539( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(const ::std::allocator<RooArgSet*>*)arg[0]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(const ::std::allocator<RooArgSet*>*)arg[0]);
}

static void constructor_19540( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0],
      *(::RooArgSet* const*)arg[1]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0],
      *(::RooArgSet* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0],
      *(::RooArgSet* const*)arg[1],
      *(const ::std::allocator<RooArgSet*>*)arg[2]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(::std::size_t*)arg[0],
      *(::RooArgSet* const*)arg[1],
      *(const ::std::allocator<RooArgSet*>*)arg[2]);
  }
}

static void constructor_19541( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooArgSet*>(*(const ::std::vector<RooArgSet*>*)arg[0]);
  else ::new(mem) ::std::vector<RooArgSet*>(*(const ::std::vector<RooArgSet*>*)arg[0]);
}

static void destructor_19542(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooArgSet*>*)o)->::std::vector<RooArgSet*>::~vector)();
}
static  void operator_19543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->operator=)(*(const ::std::vector<RooArgSet*>*)arg[0]);
  else   (((::std::vector<RooArgSet*>*)o)->operator=)(*(const ::std::vector<RooArgSet*>*)arg[0]);
}

static  void method_19544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooArgSet* const*)arg[1]);
}

static  void method_19545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->begin)());
  else   (((::std::vector<RooArgSet*>*)o)->begin)();
}

static  void method_19546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet* const*,std::vector<RooArgSet*> >)((((const ::std::vector<RooArgSet*>*)o)->begin)());
  else   (((const ::std::vector<RooArgSet*>*)o)->begin)();
}

static  void method_19547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->end)());
  else   (((::std::vector<RooArgSet*>*)o)->end)();
}

static  void method_19548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet* const*,std::vector<RooArgSet*> >)((((const ::std::vector<RooArgSet*>*)o)->end)());
  else   (((const ::std::vector<RooArgSet*>*)o)->end)();
}

static  void method_19553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooArgSet*>*)o)->size)());
  else   (((const ::std::vector<RooArgSet*>*)o)->size)();
}

static  void method_19554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooArgSet*>*)o)->max_size)());
  else   (((const ::std::vector<RooArgSet*>*)o)->max_size)();
}

static  void method_19555( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooArgSet*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooArgSet*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooArgSet*)arg[1]);
  }
}

static  void method_19556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooArgSet*>*)o)->capacity)());
  else   (((const ::std::vector<RooArgSet*>*)o)->capacity)();
}

static  void method_19557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooArgSet*>*)o)->empty)());
  else   (((const ::std::vector<RooArgSet*>*)o)->empty)();
}

static  void method_19558( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooArgSet*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooArgSet*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooArgSet*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooArgSet*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooArgSet*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooArgSet*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->front)();
  else   (((::std::vector<RooArgSet*>*)o)->front)();
}

static  void method_19565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooArgSet*>*)o)->front)();
  else   (((const ::std::vector<RooArgSet*>*)o)->front)();
}

static  void method_19566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooArgSet*>*)o)->back)();
  else   (((::std::vector<RooArgSet*>*)o)->back)();
}

static  void method_19567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooArgSet*>*)o)->back)();
  else   (((const ::std::vector<RooArgSet*>*)o)->back)();
}

static  void method_19568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooArgSet*>*)o)->data)());
  else   (((::std::vector<RooArgSet*>*)o)->data)();
}

static  void method_19569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooArgSet*>*)o)->data)());
  else   (((const ::std::vector<RooArgSet*>*)o)->data)();
}

static  void method_19570( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->push_back)(*(::RooArgSet* const*)arg[0]);
}

static  void method_19571( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooArgSet*>*)o)->pop_back)();
}

static  void method_19572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::RooArgSet* const*)arg[1]));
  else   (((::std::vector<RooArgSet*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::RooArgSet* const*)arg[1]);
}

static  void method_19573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooArgSet* const*)arg[2]);
}

static  void method_19574( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0]));
  else   (((::std::vector<RooArgSet*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0]);
}

static  void method_19575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >)((((::std::vector<RooArgSet*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[1]));
  else   (((::std::vector<RooArgSet*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooArgSet**,std::vector<RooArgSet*> >*)arg[1]);
}

static  void method_19576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooArgSet*>*)o)->swap)(*(::std::vector<RooArgSet*>*)arg[0]);
}

static  void method_19577( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooArgSet*>*)o)->clear)();
}

static void method_newdel_3117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooArgSet*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x191( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> >")), ::Reflex::BaseOffset< ::std::vector<RooArgSet*>,::std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x192( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooArgSet*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooArgSet*> >::Generate();
}

//------Dictionary for class vector<RooArgSet*,std::allocator<RooArgSet*> > -------------------------------
void __std__vector_RooArgSetp__db_datamem(Reflex::Class*);
void __std__vector_RooArgSetp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooArgSetp__datamem_bld(&__std__vector_RooArgSetp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooArgSetp__funcmem_bld(&__std__vector_RooArgSetp__db_funcmem);
void __std__vector_RooArgSetp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooArgSet*>"), typeid(::std::vector<RooArgSet*>), sizeof(::std::vector<RooArgSet*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3043, ::Reflex::BaseOffset< ::std::vector<RooArgSet*>, ::std::_Vector_base<RooArgSet*,std::allocator<RooArgSet*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2835, Reflex::Literal("std::vector<RooArgSet*>::_Alloc_value_type"))
  .AddTypedef(type_3043, Reflex::Literal("std::vector<RooArgSet*>::_Base"))
  .AddTypedef(type_3729, Reflex::Literal("std::vector<RooArgSet*>::_Tp_alloc_type"))
  .AddTypedef(type_11038, Reflex::Literal("std::vector<RooArgSet*>::_Alloc_traits"))
  .AddTypedef(type_2835, Reflex::Literal("std::vector<RooArgSet*>::value_type"))
  .AddTypedef(type_17629, Reflex::Literal("std::vector<RooArgSet*>::pointer"))
  .AddTypedef(type_19525, Reflex::Literal("std::vector<RooArgSet*>::const_pointer"))
  .AddTypedef(type_19527, Reflex::Literal("std::vector<RooArgSet*>::reference"))
  .AddTypedef(type_19529, Reflex::Literal("std::vector<RooArgSet*>::const_reference"))
  .AddTypedef(type_10890, Reflex::Literal("std::vector<RooArgSet*>::iterator"))
  .AddTypedef(type_10891, Reflex::Literal("std::vector<RooArgSet*>::const_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<RooArgSet*>::const_reverse_iterator"))
  .AddTypedef(type_3955, Reflex::Literal("std::vector<RooArgSet*>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<RooArgSet*>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<RooArgSet*>::difference_type"))
  .AddTypedef(type_3729, Reflex::Literal("std::vector<RooArgSet*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19538, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32394), Reflex::Literal("vector"), constructor_19539, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19529, type_32394), Reflex::Literal("vector"), constructor_19540, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32585), Reflex::Literal("vector"), constructor_19541, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19542, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x191, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x192, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooArgSetp__funcmem_bld);
}

//------Delayed data member builder for class vector<RooArgSet*,std::allocator<RooArgSet*> > -------------------
void __std__vector_RooArgSetp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooArgSet*,std::allocator<RooArgSet*> > -------------------
void __std__vector_RooArgSetp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32586, type_32585), Reflex::Literal("operator="), operator_19543, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19529), Reflex::Literal("assign"), method_19544, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890), Reflex::Literal("begin"), method_19545, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10891), Reflex::Literal("begin"), method_19546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890), Reflex::Literal("end"), method_19547, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10891), Reflex::Literal("end"), method_19548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_2835), Reflex::Literal("resize"), method_19555, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19558, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19527, type_3404), Reflex::Literal("operator[]"), operator_19559, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19529, type_3404), Reflex::Literal("operator[]"), operator_19560, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19527, type_3404), Reflex::Literal("at"), method_19562, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19529, type_3404), Reflex::Literal("at"), method_19563, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19527), Reflex::Literal("front"), method_19564, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19529), Reflex::Literal("front"), method_19565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19527), Reflex::Literal("back"), method_19566, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19529), Reflex::Literal("back"), method_19567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17629), Reflex::Literal("data"), method_19568, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19525), Reflex::Literal("data"), method_19569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19529), Reflex::Literal("push_back"), method_19570, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19571, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890, type_10890, type_19529), Reflex::Literal("insert"), method_19572, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10890, type_3404, type_19529), Reflex::Literal("insert"), method_19573, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890, type_10890), Reflex::Literal("erase"), method_19574, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10890, type_10890, type_10890), Reflex::Literal("erase"), method_19575, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32586), Reflex::Literal("swap"), method_19576, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19577, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------------------
static void constructor_19603( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >();
  else ::new(mem) ::std::vector<std::vector<int> >();
}

static void constructor_19604( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::allocator<std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::allocator<std::vector<int> >*)arg[0]);
}

static void constructor_19605( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1],
      *(const ::std::allocator<std::vector<int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1],
      *(const ::std::allocator<std::vector<int> >*)arg[2]);
  }
}

static void constructor_19606( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::vector<std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::vector<std::vector<int> >*)arg[0]);
}

static void destructor_19607(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<int> >*)o)->::std::vector<std::vector<int> >::~vector)();
}
static  void operator_19608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->operator=)(*(const ::std::vector<std::vector<int> >*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->operator=)(*(const ::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_19609( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<int>*)arg[1]);
}

static  void method_19610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->begin)());
  else   (((::std::vector<std::vector<int> >*)o)->begin)();
}

static  void method_19611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >)((((const ::std::vector<std::vector<int> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<int> >*)o)->begin)();
}

static  void method_19612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->end)());
  else   (((::std::vector<std::vector<int> >*)o)->end)();
}

static  void method_19613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >)((((const ::std::vector<std::vector<int> >*)o)->end)());
  else   (((const ::std::vector<std::vector<int> >*)o)->end)();
}

static  void method_19618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->size)());
  else   (((const ::std::vector<std::vector<int> >*)o)->size)();
}

static  void method_19619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<int> >*)o)->max_size)();
}

static  void method_19620( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<int>*)arg[1]);
  }
}

static  void method_19621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<int> >*)o)->capacity)();
}

static  void method_19622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<int> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<int> >*)o)->empty)();
}

static  void method_19623( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19627( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->front)();
  else   (((::std::vector<std::vector<int> >*)o)->front)();
}

static  void method_19630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->front)();
  else   (((const ::std::vector<std::vector<int> >*)o)->front)();
}

static  void method_19631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->back)();
  else   (((::std::vector<std::vector<int> >*)o)->back)();
}

static  void method_19632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->back)();
  else   (((const ::std::vector<std::vector<int> >*)o)->back)();
}

static  void method_19633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<int> >*)o)->data)());
  else   (((::std::vector<std::vector<int> >*)o)->data)();
}

static  void method_19634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<int> >*)o)->data)());
  else   (((const ::std::vector<std::vector<int> >*)o)->data)();
}

static  void method_19635( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->push_back)(*(const ::std::vector<int>*)arg[0]);
}

static  void method_19636( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<int> >*)o)->pop_back)();
}

static  void method_19637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(const ::std::vector<int>*)arg[1]));
  else   (((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(const ::std::vector<int>*)arg[1]);
}

static  void method_19638( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<int>*)arg[2]);
}

static  void method_19639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0]));
  else   (((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0]);
}

static  void method_19640( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[1]));
  else   (((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[1]);
}

static  void method_19641( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->swap)(*(::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_19642( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<int> >*)o)->clear)();
}

static void method_newdel_3118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x194( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<int> >,::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x195( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<int> > >::Generate();
}

//------Dictionary for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------------------
void __std__vector_std__vector_int_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_int_s__datamem_bld(&__std__vector_std__vector_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_int_s__funcmem_bld(&__std__vector_std__vector_int_s__db_funcmem);
void __std__vector_std__vector_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<int> >"), typeid(::std::vector<std::vector<int> >), sizeof(::std::vector<std::vector<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3044, ::Reflex::BaseOffset< ::std::vector<std::vector<int> >, ::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3099, Reflex::Literal("std::vector<std::vector<int> >::_Alloc_value_type"))
  .AddTypedef(type_3044, Reflex::Literal("std::vector<std::vector<int> >::_Base"))
  .AddTypedef(type_3730, Reflex::Literal("std::vector<std::vector<int> >::_Tp_alloc_type"))
  .AddTypedef(type_11039, Reflex::Literal("std::vector<std::vector<int> >::_Alloc_traits"))
  .AddTypedef(type_3099, Reflex::Literal("std::vector<std::vector<int> >::value_type"))
  .AddTypedef(type_17648, Reflex::Literal("std::vector<std::vector<int> >::pointer"))
  .AddTypedef(type_19590, Reflex::Literal("std::vector<std::vector<int> >::const_pointer"))
  .AddTypedef(type_19592, Reflex::Literal("std::vector<std::vector<int> >::reference"))
  .AddTypedef(type_19594, Reflex::Literal("std::vector<std::vector<int> >::const_reference"))
  .AddTypedef(type_10892, Reflex::Literal("std::vector<std::vector<int> >::iterator"))
  .AddTypedef(type_10893, Reflex::Literal("std::vector<std::vector<int> >::const_iterator"))
  .AddTypedef(type_3956, Reflex::Literal("std::vector<std::vector<int> >::const_reverse_iterator"))
  .AddTypedef(type_3957, Reflex::Literal("std::vector<std::vector<int> >::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<std::vector<int> >::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<std::vector<int> >::difference_type"))
  .AddTypedef(type_3730, Reflex::Literal("std::vector<std::vector<int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19603, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32407), Reflex::Literal("vector"), constructor_19604, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19594, type_32407), Reflex::Literal("vector"), constructor_19605, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32588), Reflex::Literal("vector"), constructor_19606, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19607, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x194, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x195, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------
void __std__vector_std__vector_int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------
void __std__vector_std__vector_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32589, type_32588), Reflex::Literal("operator="), operator_19608, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19594), Reflex::Literal("assign"), method_19609, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892), Reflex::Literal("begin"), method_19610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10893), Reflex::Literal("begin"), method_19611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892), Reflex::Literal("end"), method_19612, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10893), Reflex::Literal("end"), method_19613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_3099), Reflex::Literal("resize"), method_19620, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19623, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19592, type_3404), Reflex::Literal("operator[]"), operator_19624, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19594, type_3404), Reflex::Literal("operator[]"), operator_19625, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19592, type_3404), Reflex::Literal("at"), method_19627, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19594, type_3404), Reflex::Literal("at"), method_19628, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19592), Reflex::Literal("front"), method_19629, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19594), Reflex::Literal("front"), method_19630, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19592), Reflex::Literal("back"), method_19631, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19594), Reflex::Literal("back"), method_19632, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17648), Reflex::Literal("data"), method_19633, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19590), Reflex::Literal("data"), method_19634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19594), Reflex::Literal("push_back"), method_19635, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19636, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892, type_10892, type_19594), Reflex::Literal("insert"), method_19637, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10892, type_3404, type_19594), Reflex::Literal("insert"), method_19638, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892, type_10892), Reflex::Literal("erase"), method_19639, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10892, type_10892, type_10892), Reflex::Literal("erase"), method_19640, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32589), Reflex::Literal("swap"), method_19641, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19642, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
static void constructor_19668( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >();
}

static void constructor_19669( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static void constructor_19670( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[2]);
  }
}

static void constructor_19671( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static void destructor_19672(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->::std::vector<std::pair<std::basic_string<char>,int> >::~vector)();
}
static  void operator_19673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static  void method_19674( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
}

static  void method_19675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)();
}

static  void method_19676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)();
}

static  void method_19677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)();
}

static  void method_19678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)();
}

static  void method_19683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->size)();
}

static  void method_19684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->max_size)();
}

static  void method_19685( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,int>*)arg[1]);
  }
}

static  void method_19686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->capacity)();
}

static  void method_19687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->empty)();
}

static  void method_19688( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19692( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
}

static  void method_19695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
}

static  void method_19696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
}

static  void method_19697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
}

static  void method_19698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)();
}

static  void method_19699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)();
}

static  void method_19700( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
}

static  void method_19701( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->pop_back)();
}

static  void method_19702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
}

static  void method_19703( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[2]);
}

static  void method_19704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0]);
}

static  void method_19705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[1]);
}

static  void method_19706( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static  void method_19707( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->clear)();
}

static void method_newdel_3119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x197( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,int> >,::std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x198( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,int> > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__int_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__int_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__int_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__int_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >"), typeid(::std::vector<std::pair<std::basic_string<char>,int> >), sizeof(::std::vector<std::pair<std::basic_string<char>,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3049, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,int> >, ::std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3554, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Alloc_value_type"))
  .AddTypedef(type_3049, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Base"))
  .AddTypedef(type_3747, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Tp_alloc_type"))
  .AddTypedef(type_11044, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Alloc_traits"))
  .AddTypedef(type_3554, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::value_type"))
  .AddTypedef(type_17743, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::pointer"))
  .AddTypedef(type_19655, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_pointer"))
  .AddTypedef(type_19657, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::reference"))
  .AddTypedef(type_19659, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_reference"))
  .AddTypedef(type_10902, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::iterator"))
  .AddTypedef(type_10903, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_iterator"))
  .AddTypedef(type_3994, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_reverse_iterator"))
  .AddTypedef(type_3995, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::difference_type"))
  .AddTypedef(type_3747, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19668, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32472), Reflex::Literal("vector"), constructor_19669, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19659, type_32472), Reflex::Literal("vector"), constructor_19670, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32591), Reflex::Literal("vector"), constructor_19671, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19672, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x198, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__vector_std__pair_std__basic_string_char__int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__vector_std__pair_std__basic_string_char__int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31105, type_32591), Reflex::Literal("operator="), operator_19673, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19659), Reflex::Literal("assign"), method_19674, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902), Reflex::Literal("begin"), method_19675, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10903), Reflex::Literal("begin"), method_19676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902), Reflex::Literal("end"), method_19677, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10903), Reflex::Literal("end"), method_19678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_3554), Reflex::Literal("resize"), method_19685, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19688, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19657, type_3404), Reflex::Literal("operator[]"), operator_19689, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19659, type_3404), Reflex::Literal("operator[]"), operator_19690, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19657, type_3404), Reflex::Literal("at"), method_19692, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19659, type_3404), Reflex::Literal("at"), method_19693, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19657), Reflex::Literal("front"), method_19694, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19659), Reflex::Literal("front"), method_19695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19657), Reflex::Literal("back"), method_19696, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19659), Reflex::Literal("back"), method_19697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17743), Reflex::Literal("data"), method_19698, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19655), Reflex::Literal("data"), method_19699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19659), Reflex::Literal("push_back"), method_19700, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19701, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902, type_10902, type_19659), Reflex::Literal("insert"), method_19702, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10902, type_3404, type_19659), Reflex::Literal("insert"), method_19703, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902, type_10902), Reflex::Literal("erase"), method_19704, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10902, type_10902, type_10902), Reflex::Literal("erase"), method_19705, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_31105), Reflex::Literal("swap"), method_19706, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19707, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooAbsArg*,std::allocator<RooAbsArg*> > -------------------------------
static void constructor_19734( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>();
  else ::new(mem) ::std::vector<RooAbsArg*>();
}

static void constructor_19735( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(const ::std::allocator<RooAbsArg*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(const ::std::allocator<RooAbsArg*>*)arg[0]);
}

static void constructor_19736( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0],
      *(::RooAbsArg* const*)arg[1]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0],
      *(::RooAbsArg* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0],
      *(::RooAbsArg* const*)arg[1],
      *(const ::std::allocator<RooAbsArg*>*)arg[2]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(::std::size_t*)arg[0],
      *(::RooAbsArg* const*)arg[1],
      *(const ::std::allocator<RooAbsArg*>*)arg[2]);
  }
}

static void constructor_19737( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsArg*>(*(const ::std::vector<RooAbsArg*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsArg*>(*(const ::std::vector<RooAbsArg*>*)arg[0]);
}

static void destructor_19738(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooAbsArg*>*)o)->::std::vector<RooAbsArg*>::~vector)();
}
static  void operator_19739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->operator=)(*(const ::std::vector<RooAbsArg*>*)arg[0]);
  else   (((::std::vector<RooAbsArg*>*)o)->operator=)(*(const ::std::vector<RooAbsArg*>*)arg[0]);
}

static  void method_19740( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooAbsArg* const*)arg[1]);
}

static  void method_19741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->begin)());
  else   (((::std::vector<RooAbsArg*>*)o)->begin)();
}

static  void method_19742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg* const*,std::vector<RooAbsArg*> >)((((const ::std::vector<RooAbsArg*>*)o)->begin)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->begin)();
}

static  void method_19743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->end)());
  else   (((::std::vector<RooAbsArg*>*)o)->end)();
}

static  void method_19744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg* const*,std::vector<RooAbsArg*> >)((((const ::std::vector<RooAbsArg*>*)o)->end)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->end)();
}

static  void method_19749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsArg*>*)o)->size)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->size)();
}

static  void method_19750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsArg*>*)o)->max_size)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->max_size)();
}

static  void method_19751( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooAbsArg*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooAbsArg*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooAbsArg*)arg[1]);
  }
}

static  void method_19752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsArg*>*)o)->capacity)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->capacity)();
}

static  void method_19753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooAbsArg*>*)o)->empty)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->empty)();
}

static  void method_19754( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsArg*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsArg*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsArg*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsArg*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsArg*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsArg*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->front)();
  else   (((::std::vector<RooAbsArg*>*)o)->front)();
}

static  void method_19761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsArg*>*)o)->front)();
  else   (((const ::std::vector<RooAbsArg*>*)o)->front)();
}

static  void method_19762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsArg*>*)o)->back)();
  else   (((::std::vector<RooAbsArg*>*)o)->back)();
}

static  void method_19763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsArg*>*)o)->back)();
  else   (((const ::std::vector<RooAbsArg*>*)o)->back)();
}

static  void method_19764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooAbsArg*>*)o)->data)());
  else   (((::std::vector<RooAbsArg*>*)o)->data)();
}

static  void method_19765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooAbsArg*>*)o)->data)());
  else   (((const ::std::vector<RooAbsArg*>*)o)->data)();
}

static  void method_19766( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->push_back)(*(::RooAbsArg* const*)arg[0]);
}

static  void method_19767( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->pop_back)();
}

static  void method_19768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::RooAbsArg* const*)arg[1]));
  else   (((::std::vector<RooAbsArg*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::RooAbsArg* const*)arg[1]);
}

static  void method_19769( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooAbsArg* const*)arg[2]);
}

static  void method_19770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0]));
  else   (((::std::vector<RooAbsArg*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0]);
}

static  void method_19771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >)((((::std::vector<RooAbsArg*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[1]));
  else   (((::std::vector<RooAbsArg*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsArg**,std::vector<RooAbsArg*> >*)arg[1]);
}

static  void method_19772( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->swap)(*(::std::vector<RooAbsArg*>*)arg[0]);
}

static  void method_19773( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsArg*>*)o)->clear)();
}

static void method_newdel_3120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsArg*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x200( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> >")), ::Reflex::BaseOffset< ::std::vector<RooAbsArg*>,::std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x201( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooAbsArg*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooAbsArg*> >::Generate();
}

//------Dictionary for class vector<RooAbsArg*,std::allocator<RooAbsArg*> > -------------------------------
void __std__vector_RooAbsArgp__db_datamem(Reflex::Class*);
void __std__vector_RooAbsArgp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsArgp__datamem_bld(&__std__vector_RooAbsArgp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsArgp__funcmem_bld(&__std__vector_RooAbsArgp__db_funcmem);
void __std__vector_RooAbsArgp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooAbsArg*>"), typeid(::std::vector<RooAbsArg*>), sizeof(::std::vector<RooAbsArg*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3045, ::Reflex::BaseOffset< ::std::vector<RooAbsArg*>, ::std::_Vector_base<RooAbsArg*,std::allocator<RooAbsArg*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_19714, Reflex::Literal("std::vector<RooAbsArg*>::_Alloc_value_type"))
  .AddTypedef(type_3045, Reflex::Literal("std::vector<RooAbsArg*>::_Base"))
  .AddTypedef(type_3748, Reflex::Literal("std::vector<RooAbsArg*>::_Tp_alloc_type"))
  .AddTypedef(type_11040, Reflex::Literal("std::vector<RooAbsArg*>::_Alloc_traits"))
  .AddTypedef(type_19714, Reflex::Literal("std::vector<RooAbsArg*>::value_type"))
  .AddTypedef(type_17667, Reflex::Literal("std::vector<RooAbsArg*>::pointer"))
  .AddTypedef(type_19721, Reflex::Literal("std::vector<RooAbsArg*>::const_pointer"))
  .AddTypedef(type_19723, Reflex::Literal("std::vector<RooAbsArg*>::reference"))
  .AddTypedef(type_19725, Reflex::Literal("std::vector<RooAbsArg*>::const_reference"))
  .AddTypedef(type_10894, Reflex::Literal("std::vector<RooAbsArg*>::iterator"))
  .AddTypedef(type_10895, Reflex::Literal("std::vector<RooAbsArg*>::const_iterator"))
  .AddTypedef(type_3972, Reflex::Literal("std::vector<RooAbsArg*>::const_reverse_iterator"))
  .AddTypedef(type_3973, Reflex::Literal("std::vector<RooAbsArg*>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<RooAbsArg*>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<RooAbsArg*>::difference_type"))
  .AddTypedef(type_3748, Reflex::Literal("std::vector<RooAbsArg*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19734, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32420), Reflex::Literal("vector"), constructor_19735, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19725, type_32420), Reflex::Literal("vector"), constructor_19736, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32593), Reflex::Literal("vector"), constructor_19737, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19738, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x201, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooAbsArgp__funcmem_bld);
}

//------Delayed data member builder for class vector<RooAbsArg*,std::allocator<RooAbsArg*> > -------------------
void __std__vector_RooAbsArgp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooAbsArg*,std::allocator<RooAbsArg*> > -------------------
void __std__vector_RooAbsArgp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32594, type_32593), Reflex::Literal("operator="), operator_19739, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19725), Reflex::Literal("assign"), method_19740, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894), Reflex::Literal("begin"), method_19741, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10895), Reflex::Literal("begin"), method_19742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894), Reflex::Literal("end"), method_19743, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10895), Reflex::Literal("end"), method_19744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19714), Reflex::Literal("resize"), method_19751, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19754, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19723, type_3404), Reflex::Literal("operator[]"), operator_19755, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19725, type_3404), Reflex::Literal("operator[]"), operator_19756, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19723, type_3404), Reflex::Literal("at"), method_19758, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19725, type_3404), Reflex::Literal("at"), method_19759, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19723), Reflex::Literal("front"), method_19760, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19725), Reflex::Literal("front"), method_19761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19723), Reflex::Literal("back"), method_19762, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19725), Reflex::Literal("back"), method_19763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17667), Reflex::Literal("data"), method_19764, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19721), Reflex::Literal("data"), method_19765, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19725), Reflex::Literal("push_back"), method_19766, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19767, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894, type_10894, type_19725), Reflex::Literal("insert"), method_19768, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10894, type_3404, type_19725), Reflex::Literal("insert"), method_19769, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894, type_10894), Reflex::Literal("erase"), method_19770, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10894, type_10894, type_10894), Reflex::Literal("erase"), method_19771, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32594), Reflex::Literal("swap"), method_19772, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19773, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > -------------------------------
static void constructor_19800( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>();
  else ::new(mem) ::std::vector<RooAbsCacheElement*>();
}

static void constructor_19801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(const ::std::allocator<RooAbsCacheElement*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(const ::std::allocator<RooAbsCacheElement*>*)arg[0]);
}

static void constructor_19802( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0],
      *(::RooAbsCacheElement* const*)arg[1]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0],
      *(::RooAbsCacheElement* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0],
      *(::RooAbsCacheElement* const*)arg[1],
      *(const ::std::allocator<RooAbsCacheElement*>*)arg[2]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(::std::size_t*)arg[0],
      *(::RooAbsCacheElement* const*)arg[1],
      *(const ::std::allocator<RooAbsCacheElement*>*)arg[2]);
  }
}

static void constructor_19803( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooAbsCacheElement*>(*(const ::std::vector<RooAbsCacheElement*>*)arg[0]);
  else ::new(mem) ::std::vector<RooAbsCacheElement*>(*(const ::std::vector<RooAbsCacheElement*>*)arg[0]);
}

static void destructor_19804(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooAbsCacheElement*>*)o)->::std::vector<RooAbsCacheElement*>::~vector)();
}
static  void operator_19805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->operator=)(*(const ::std::vector<RooAbsCacheElement*>*)arg[0]);
  else   (((::std::vector<RooAbsCacheElement*>*)o)->operator=)(*(const ::std::vector<RooAbsCacheElement*>*)arg[0]);
}

static  void method_19806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::RooAbsCacheElement* const*)arg[1]);
}

static  void method_19807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->begin)());
  else   (((::std::vector<RooAbsCacheElement*>*)o)->begin)();
}

static  void method_19808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement* const*,std::vector<RooAbsCacheElement*> >)((((const ::std::vector<RooAbsCacheElement*>*)o)->begin)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->begin)();
}

static  void method_19809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->end)());
  else   (((::std::vector<RooAbsCacheElement*>*)o)->end)();
}

static  void method_19810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement* const*,std::vector<RooAbsCacheElement*> >)((((const ::std::vector<RooAbsCacheElement*>*)o)->end)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->end)();
}

static  void method_19815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsCacheElement*>*)o)->size)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->size)();
}

static  void method_19816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsCacheElement*>*)o)->max_size)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->max_size)();
}

static  void method_19817( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooAbsCacheElement*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooAbsCacheElement*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::RooAbsCacheElement*)arg[1]);
  }
}

static  void method_19818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooAbsCacheElement*>*)o)->capacity)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->capacity)();
}

static  void method_19819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooAbsCacheElement*>*)o)->empty)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->empty)();
}

static  void method_19820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsCacheElement*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19822( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsCacheElement*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooAbsCacheElement*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsCacheElement*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->front)();
  else   (((::std::vector<RooAbsCacheElement*>*)o)->front)();
}

static  void method_19827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsCacheElement*>*)o)->front)();
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->front)();
}

static  void method_19828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooAbsCacheElement*>*)o)->back)();
  else   (((::std::vector<RooAbsCacheElement*>*)o)->back)();
}

static  void method_19829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooAbsCacheElement*>*)o)->back)();
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->back)();
}

static  void method_19830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooAbsCacheElement*>*)o)->data)());
  else   (((::std::vector<RooAbsCacheElement*>*)o)->data)();
}

static  void method_19831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooAbsCacheElement*>*)o)->data)());
  else   (((const ::std::vector<RooAbsCacheElement*>*)o)->data)();
}

static  void method_19832( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->push_back)(*(::RooAbsCacheElement* const*)arg[0]);
}

static  void method_19833( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->pop_back)();
}

static  void method_19834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::RooAbsCacheElement* const*)arg[1]));
  else   (((::std::vector<RooAbsCacheElement*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::RooAbsCacheElement* const*)arg[1]);
}

static  void method_19835( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::RooAbsCacheElement* const*)arg[2]);
}

static  void method_19836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0]));
  else   (((::std::vector<RooAbsCacheElement*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0]);
}

static  void method_19837( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >)((((::std::vector<RooAbsCacheElement*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[1]));
  else   (((::std::vector<RooAbsCacheElement*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooAbsCacheElement**,std::vector<RooAbsCacheElement*> >*)arg[1]);
}

static  void method_19838( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->swap)(*(::std::vector<RooAbsCacheElement*>*)arg[0]);
}

static  void method_19839( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooAbsCacheElement*>*)o)->clear)();
}

static void method_newdel_3121( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooAbsCacheElement*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> >")), ::Reflex::BaseOffset< ::std::vector<RooAbsCacheElement*>,::std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x204( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooAbsCacheElement*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooAbsCacheElement*> >::Generate();
}

//------Dictionary for class vector<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > -------------------------------
void __std__vector_RooAbsCacheElementp__db_datamem(Reflex::Class*);
void __std__vector_RooAbsCacheElementp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsCacheElementp__datamem_bld(&__std__vector_RooAbsCacheElementp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooAbsCacheElementp__funcmem_bld(&__std__vector_RooAbsCacheElementp__db_funcmem);
void __std__vector_RooAbsCacheElementp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooAbsCacheElement*>"), typeid(::std::vector<RooAbsCacheElement*>), sizeof(::std::vector<RooAbsCacheElement*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3046, ::Reflex::BaseOffset< ::std::vector<RooAbsCacheElement*>, ::std::_Vector_base<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_19780, Reflex::Literal("std::vector<RooAbsCacheElement*>::_Alloc_value_type"))
  .AddTypedef(type_3046, Reflex::Literal("std::vector<RooAbsCacheElement*>::_Base"))
  .AddTypedef(type_3749, Reflex::Literal("std::vector<RooAbsCacheElement*>::_Tp_alloc_type"))
  .AddTypedef(type_11041, Reflex::Literal("std::vector<RooAbsCacheElement*>::_Alloc_traits"))
  .AddTypedef(type_19780, Reflex::Literal("std::vector<RooAbsCacheElement*>::value_type"))
  .AddTypedef(type_17686, Reflex::Literal("std::vector<RooAbsCacheElement*>::pointer"))
  .AddTypedef(type_19787, Reflex::Literal("std::vector<RooAbsCacheElement*>::const_pointer"))
  .AddTypedef(type_19789, Reflex::Literal("std::vector<RooAbsCacheElement*>::reference"))
  .AddTypedef(type_19791, Reflex::Literal("std::vector<RooAbsCacheElement*>::const_reference"))
  .AddTypedef(type_10896, Reflex::Literal("std::vector<RooAbsCacheElement*>::iterator"))
  .AddTypedef(type_10897, Reflex::Literal("std::vector<RooAbsCacheElement*>::const_iterator"))
  .AddTypedef(type_3974, Reflex::Literal("std::vector<RooAbsCacheElement*>::const_reverse_iterator"))
  .AddTypedef(type_3975, Reflex::Literal("std::vector<RooAbsCacheElement*>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<RooAbsCacheElement*>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<RooAbsCacheElement*>::difference_type"))
  .AddTypedef(type_3749, Reflex::Literal("std::vector<RooAbsCacheElement*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19800, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32433), Reflex::Literal("vector"), constructor_19801, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19791, type_32433), Reflex::Literal("vector"), constructor_19802, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32596), Reflex::Literal("vector"), constructor_19803, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19804, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3121, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x204, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooAbsCacheElementp__funcmem_bld);
}

//------Delayed data member builder for class vector<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > -------------------
void __std__vector_RooAbsCacheElementp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooAbsCacheElement*,std::allocator<RooAbsCacheElement*> > -------------------
void __std__vector_RooAbsCacheElementp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32597, type_32596), Reflex::Literal("operator="), operator_19805, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19791), Reflex::Literal("assign"), method_19806, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896), Reflex::Literal("begin"), method_19807, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10897), Reflex::Literal("begin"), method_19808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896), Reflex::Literal("end"), method_19809, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10897), Reflex::Literal("end"), method_19810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19780), Reflex::Literal("resize"), method_19817, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19820, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19789, type_3404), Reflex::Literal("operator[]"), operator_19821, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19791, type_3404), Reflex::Literal("operator[]"), operator_19822, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19789, type_3404), Reflex::Literal("at"), method_19824, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19791, type_3404), Reflex::Literal("at"), method_19825, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19789), Reflex::Literal("front"), method_19826, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19791), Reflex::Literal("front"), method_19827, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19789), Reflex::Literal("back"), method_19828, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19791), Reflex::Literal("back"), method_19829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17686), Reflex::Literal("data"), method_19830, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19787), Reflex::Literal("data"), method_19831, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19791), Reflex::Literal("push_back"), method_19832, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19833, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896, type_10896, type_19791), Reflex::Literal("insert"), method_19834, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10896, type_3404, type_19791), Reflex::Literal("insert"), method_19835, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896, type_10896), Reflex::Literal("erase"), method_19836, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10896, type_10896, type_10896), Reflex::Literal("erase"), method_19837, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32597), Reflex::Literal("swap"), method_19838, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19839, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > -------------------------------
static void constructor_19865( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>();
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>();
}

static void constructor_19866( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(const ::std::allocator<RooMsgService::StreamConfig>*)arg[0]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(const ::std::allocator<RooMsgService::StreamConfig>*)arg[0]);
}

static void constructor_19867( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0],
      *(const ::RooMsgService::StreamConfig*)arg[1]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0],
      *(const ::RooMsgService::StreamConfig*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0],
      *(const ::RooMsgService::StreamConfig*)arg[1],
      *(const ::std::allocator<RooMsgService::StreamConfig>*)arg[2]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(::std::size_t*)arg[0],
      *(const ::RooMsgService::StreamConfig*)arg[1],
      *(const ::std::allocator<RooMsgService::StreamConfig>*)arg[2]);
  }
}

static void constructor_19868( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(const ::std::vector<RooMsgService::StreamConfig>*)arg[0]);
  else ::new(mem) ::std::vector<RooMsgService::StreamConfig>(*(const ::std::vector<RooMsgService::StreamConfig>*)arg[0]);
}

static void destructor_19869(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<RooMsgService::StreamConfig>*)o)->::std::vector<RooMsgService::StreamConfig>::~vector)();
}
static  void operator_19870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->operator=)(*(const ::std::vector<RooMsgService::StreamConfig>*)arg[0]);
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->operator=)(*(const ::std::vector<RooMsgService::StreamConfig>*)arg[0]);
}

static  void method_19871( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::RooMsgService::StreamConfig*)arg[1]);
}

static  void method_19872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->begin)());
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->begin)();
}

static  void method_19873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->begin)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->begin)();
}

static  void method_19874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->end)());
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->end)();
}

static  void method_19875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->end)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->end)();
}

static  void method_19880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->size)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->size)();
}

static  void method_19881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->max_size)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->max_size)();
}

static  void method_19882( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<RooMsgService::StreamConfig>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<RooMsgService::StreamConfig>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::RooMsgService::StreamConfig*)arg[1]);
  }
}

static  void method_19883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->capacity)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->capacity)();
}

static  void method_19884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<RooMsgService::StreamConfig>*)o)->empty)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->empty)();
}

static  void method_19885( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooMsgService::StreamConfig>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooMsgService::StreamConfig>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->front)();
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->front)();
}

static  void method_19892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooMsgService::StreamConfig>*)o)->front)();
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->front)();
}

static  void method_19893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<RooMsgService::StreamConfig>*)o)->back)();
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->back)();
}

static  void method_19894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<RooMsgService::StreamConfig>*)o)->back)();
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->back)();
}

static  void method_19895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<RooMsgService::StreamConfig>*)o)->data)());
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->data)();
}

static  void method_19896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<RooMsgService::StreamConfig>*)o)->data)());
  else   (((const ::std::vector<RooMsgService::StreamConfig>*)o)->data)();
}

static  void method_19897( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->push_back)(*(const ::RooMsgService::StreamConfig*)arg[0]);
}

static  void method_19898( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->pop_back)();
}

static  void method_19899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(const ::RooMsgService::StreamConfig*)arg[1]));
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(const ::RooMsgService::StreamConfig*)arg[1]);
}

static  void method_19900( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::RooMsgService::StreamConfig*)arg[2]);
}

static  void method_19901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0]));
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0]);
}

static  void method_19902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >)((((::std::vector<RooMsgService::StreamConfig>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[1]));
  else   (((::std::vector<RooMsgService::StreamConfig>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<RooMsgService::StreamConfig*,std::vector<RooMsgService::StreamConfig> >*)arg[1]);
}

static  void method_19903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->swap)(*(::std::vector<RooMsgService::StreamConfig>*)arg[0]);
}

static  void method_19904( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<RooMsgService::StreamConfig>*)o)->clear)();
}

static void method_newdel_3122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<RooMsgService::StreamConfig> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x206( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> >")), ::Reflex::BaseOffset< ::std::vector<RooMsgService::StreamConfig>,::std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x207( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<RooMsgService::StreamConfig> >::Generate();
  else ::Reflex::Proxy< ::std::vector<RooMsgService::StreamConfig> >::Generate();
}

//------Dictionary for class vector<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > -------------------------------
void __std__vector_RooMsgService__StreamConfig__db_datamem(Reflex::Class*);
void __std__vector_RooMsgService__StreamConfig__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_RooMsgService__StreamConfig__datamem_bld(&__std__vector_RooMsgService__StreamConfig__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_RooMsgService__StreamConfig__funcmem_bld(&__std__vector_RooMsgService__StreamConfig__db_funcmem);
void __std__vector_RooMsgService__StreamConfig__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<RooMsgService::StreamConfig>"), typeid(::std::vector<RooMsgService::StreamConfig>), sizeof(::std::vector<RooMsgService::StreamConfig>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3048, ::Reflex::BaseOffset< ::std::vector<RooMsgService::StreamConfig>, ::std::_Vector_base<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4318, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::_Alloc_value_type"))
  .AddTypedef(type_3048, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::_Base"))
  .AddTypedef(type_3754, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::_Tp_alloc_type"))
  .AddTypedef(type_11043, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::_Alloc_traits"))
  .AddTypedef(type_4318, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::value_type"))
  .AddTypedef(type_17724, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::pointer"))
  .AddTypedef(type_19852, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::const_pointer"))
  .AddTypedef(type_19854, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::reference"))
  .AddTypedef(type_19856, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::const_reference"))
  .AddTypedef(type_10900, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::iterator"))
  .AddTypedef(type_10901, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::const_iterator"))
  .AddTypedef(type_3982, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::const_reverse_iterator"))
  .AddTypedef(type_3983, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::difference_type"))
  .AddTypedef(type_3754, Reflex::Literal("std::vector<RooMsgService::StreamConfig>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19865, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32459), Reflex::Literal("vector"), constructor_19866, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19856, type_32459), Reflex::Literal("vector"), constructor_19867, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20699), Reflex::Literal("vector"), constructor_19868, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19869, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x206, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x207, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_RooMsgService__StreamConfig__funcmem_bld);
}

//------Delayed data member builder for class vector<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > -------------------
void __std__vector_RooMsgService__StreamConfig__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<RooMsgService::StreamConfig,std::allocator<RooMsgService::StreamConfig> > -------------------
void __std__vector_RooMsgService__StreamConfig__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20697, type_20699), Reflex::Literal("operator="), operator_19870, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19856), Reflex::Literal("assign"), method_19871, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900), Reflex::Literal("begin"), method_19872, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10901), Reflex::Literal("begin"), method_19873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900), Reflex::Literal("end"), method_19874, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10901), Reflex::Literal("end"), method_19875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_4318), Reflex::Literal("resize"), method_19882, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19885, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19854, type_3404), Reflex::Literal("operator[]"), operator_19886, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19856, type_3404), Reflex::Literal("operator[]"), operator_19887, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19854, type_3404), Reflex::Literal("at"), method_19889, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19856, type_3404), Reflex::Literal("at"), method_19890, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19854), Reflex::Literal("front"), method_19891, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19856), Reflex::Literal("front"), method_19892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19854), Reflex::Literal("back"), method_19893, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19856), Reflex::Literal("back"), method_19894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17724), Reflex::Literal("data"), method_19895, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19852), Reflex::Literal("data"), method_19896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19856), Reflex::Literal("push_back"), method_19897, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19898, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900, type_10900, type_19856), Reflex::Literal("insert"), method_19899, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10900, type_3404, type_19856), Reflex::Literal("insert"), method_19900, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900, type_10900), Reflex::Literal("erase"), method_19901, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10900, type_10900, type_10900), Reflex::Literal("erase"), method_19902, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_20697), Reflex::Literal("swap"), method_19903, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19904, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<TVirtualArray*,std::allocator<TVirtualArray*> > -------------------------------
static void constructor_19931( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>();
  else ::new(mem) ::std::vector<TVirtualArray*>();
}

static void constructor_19932( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(const ::std::allocator<TVirtualArray*>*)arg[0]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(const ::std::allocator<TVirtualArray*>*)arg[0]);
}

static void constructor_19933( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0],
      *(::TVirtualArray* const*)arg[1]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0],
      *(::TVirtualArray* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0],
      *(::TVirtualArray* const*)arg[1],
      *(const ::std::allocator<TVirtualArray*>*)arg[2]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(::std::size_t*)arg[0],
      *(::TVirtualArray* const*)arg[1],
      *(const ::std::allocator<TVirtualArray*>*)arg[2]);
  }
}

static void constructor_19934( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TVirtualArray*>(*(const ::std::vector<TVirtualArray*>*)arg[0]);
  else ::new(mem) ::std::vector<TVirtualArray*>(*(const ::std::vector<TVirtualArray*>*)arg[0]);
}

static void destructor_19935(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TVirtualArray*>*)o)->::std::vector<TVirtualArray*>::~vector)();
}
static  void operator_19936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->operator=)(*(const ::std::vector<TVirtualArray*>*)arg[0]);
  else   (((::std::vector<TVirtualArray*>*)o)->operator=)(*(const ::std::vector<TVirtualArray*>*)arg[0]);
}

static  void method_19937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::TVirtualArray* const*)arg[1]);
}

static  void method_19938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->begin)());
  else   (((::std::vector<TVirtualArray*>*)o)->begin)();
}

static  void method_19939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray* const*,std::vector<TVirtualArray*> >)((((const ::std::vector<TVirtualArray*>*)o)->begin)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->begin)();
}

static  void method_19940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->end)());
  else   (((::std::vector<TVirtualArray*>*)o)->end)();
}

static  void method_19941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray* const*,std::vector<TVirtualArray*> >)((((const ::std::vector<TVirtualArray*>*)o)->end)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->end)();
}

static  void method_19946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TVirtualArray*>*)o)->size)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->size)();
}

static  void method_19947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TVirtualArray*>*)o)->max_size)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->max_size)();
}

static  void method_19948( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TVirtualArray*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TVirtualArray*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::TVirtualArray*)arg[1]);
  }
}

static  void method_19949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TVirtualArray*>*)o)->capacity)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->capacity)();
}

static  void method_19950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TVirtualArray*>*)o)->empty)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->empty)();
}

static  void method_19951( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TVirtualArray*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TVirtualArray*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TVirtualArray*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TVirtualArray*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19956( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TVirtualArray*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TVirtualArray*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->front)();
  else   (((::std::vector<TVirtualArray*>*)o)->front)();
}

static  void method_19958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TVirtualArray*>*)o)->front)();
  else   (((const ::std::vector<TVirtualArray*>*)o)->front)();
}

static  void method_19959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TVirtualArray*>*)o)->back)();
  else   (((::std::vector<TVirtualArray*>*)o)->back)();
}

static  void method_19960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TVirtualArray*>*)o)->back)();
  else   (((const ::std::vector<TVirtualArray*>*)o)->back)();
}

static  void method_19961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TVirtualArray*>*)o)->data)());
  else   (((::std::vector<TVirtualArray*>*)o)->data)();
}

static  void method_19962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TVirtualArray*>*)o)->data)());
  else   (((const ::std::vector<TVirtualArray*>*)o)->data)();
}

static  void method_19963( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->push_back)(*(::TVirtualArray* const*)arg[0]);
}

static  void method_19964( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->pop_back)();
}

static  void method_19965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::TVirtualArray* const*)arg[1]));
  else   (((::std::vector<TVirtualArray*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::TVirtualArray* const*)arg[1]);
}

static  void method_19966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::TVirtualArray* const*)arg[2]);
}

static  void method_19967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0]));
  else   (((::std::vector<TVirtualArray*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0]);
}

static  void method_19968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >)((((::std::vector<TVirtualArray*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[1]));
  else   (((::std::vector<TVirtualArray*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TVirtualArray**,std::vector<TVirtualArray*> >*)arg[1]);
}

static  void method_19969( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->swap)(*(::std::vector<TVirtualArray*>*)arg[0]);
}

static  void method_19970( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TVirtualArray*>*)o)->clear)();
}

static void method_newdel_3124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TVirtualArray*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x209( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> >")), ::Reflex::BaseOffset< ::std::vector<TVirtualArray*>,::std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x210( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TVirtualArray*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TVirtualArray*> >::Generate();
}

//------Dictionary for class vector<TVirtualArray*,std::allocator<TVirtualArray*> > -------------------------------
void __std__vector_TVirtualArrayp__db_datamem(Reflex::Class*);
void __std__vector_TVirtualArrayp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TVirtualArrayp__datamem_bld(&__std__vector_TVirtualArrayp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TVirtualArrayp__funcmem_bld(&__std__vector_TVirtualArrayp__db_funcmem);
void __std__vector_TVirtualArrayp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TVirtualArray*>"), typeid(::std::vector<TVirtualArray*>), sizeof(::std::vector<TVirtualArray*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3050, ::Reflex::BaseOffset< ::std::vector<TVirtualArray*>, ::std::_Vector_base<TVirtualArray*,std::allocator<TVirtualArray*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_19911, Reflex::Literal("std::vector<TVirtualArray*>::_Alloc_value_type"))
  .AddTypedef(type_3050, Reflex::Literal("std::vector<TVirtualArray*>::_Base"))
  .AddTypedef(type_3774, Reflex::Literal("std::vector<TVirtualArray*>::_Tp_alloc_type"))
  .AddTypedef(type_11045, Reflex::Literal("std::vector<TVirtualArray*>::_Alloc_traits"))
  .AddTypedef(type_19911, Reflex::Literal("std::vector<TVirtualArray*>::value_type"))
  .AddTypedef(type_17762, Reflex::Literal("std::vector<TVirtualArray*>::pointer"))
  .AddTypedef(type_19918, Reflex::Literal("std::vector<TVirtualArray*>::const_pointer"))
  .AddTypedef(type_19920, Reflex::Literal("std::vector<TVirtualArray*>::reference"))
  .AddTypedef(type_19922, Reflex::Literal("std::vector<TVirtualArray*>::const_reference"))
  .AddTypedef(type_10904, Reflex::Literal("std::vector<TVirtualArray*>::iterator"))
  .AddTypedef(type_10905, Reflex::Literal("std::vector<TVirtualArray*>::const_iterator"))
  .AddTypedef(type_4002, Reflex::Literal("std::vector<TVirtualArray*>::const_reverse_iterator"))
  .AddTypedef(type_4003, Reflex::Literal("std::vector<TVirtualArray*>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<TVirtualArray*>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<TVirtualArray*>::difference_type"))
  .AddTypedef(type_3774, Reflex::Literal("std::vector<TVirtualArray*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19931, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32485), Reflex::Literal("vector"), constructor_19932, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19922, type_32485), Reflex::Literal("vector"), constructor_19933, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32600), Reflex::Literal("vector"), constructor_19934, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19935, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x210, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TVirtualArrayp__funcmem_bld);
}

//------Delayed data member builder for class vector<TVirtualArray*,std::allocator<TVirtualArray*> > -------------------
void __std__vector_TVirtualArrayp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TVirtualArray*,std::allocator<TVirtualArray*> > -------------------
void __std__vector_TVirtualArrayp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32601, type_32600), Reflex::Literal("operator="), operator_19936, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19922), Reflex::Literal("assign"), method_19937, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904), Reflex::Literal("begin"), method_19938, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10905), Reflex::Literal("begin"), method_19939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904), Reflex::Literal("end"), method_19940, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10905), Reflex::Literal("end"), method_19941, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_19946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_19947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19911), Reflex::Literal("resize"), method_19948, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_19949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_19950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_19951, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19920, type_3404), Reflex::Literal("operator[]"), operator_19952, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19922, type_3404), Reflex::Literal("operator[]"), operator_19953, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19920, type_3404), Reflex::Literal("at"), method_19955, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19922, type_3404), Reflex::Literal("at"), method_19956, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19920), Reflex::Literal("front"), method_19957, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19922), Reflex::Literal("front"), method_19958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19920), Reflex::Literal("back"), method_19959, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19922), Reflex::Literal("back"), method_19960, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17762), Reflex::Literal("data"), method_19961, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19918), Reflex::Literal("data"), method_19962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19922), Reflex::Literal("push_back"), method_19963, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_19964, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904, type_10904, type_19922), Reflex::Literal("insert"), method_19965, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10904, type_3404, type_19922), Reflex::Literal("insert"), method_19966, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904, type_10904), Reflex::Literal("erase"), method_19967, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10904, type_10904, type_10904), Reflex::Literal("erase"), method_19968, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32601), Reflex::Literal("swap"), method_19969, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_19970, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > -------------------------------
static void constructor_19996( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>();
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>();
}

static void constructor_19997( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(const ::std::allocator<ROOT::TSchemaHelper>*)arg[0]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(const ::std::allocator<ROOT::TSchemaHelper>*)arg[0]);
}

static void constructor_19998( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0],
      *(const ::ROOT::TSchemaHelper*)arg[1]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0],
      *(const ::ROOT::TSchemaHelper*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0],
      *(const ::ROOT::TSchemaHelper*)arg[1],
      *(const ::std::allocator<ROOT::TSchemaHelper>*)arg[2]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(::std::size_t*)arg[0],
      *(const ::ROOT::TSchemaHelper*)arg[1],
      *(const ::std::allocator<ROOT::TSchemaHelper>*)arg[2]);
  }
}

static void constructor_19999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(const ::std::vector<ROOT::TSchemaHelper>*)arg[0]);
  else ::new(mem) ::std::vector<ROOT::TSchemaHelper>(*(const ::std::vector<ROOT::TSchemaHelper>*)arg[0]);
}

static void destructor_20000(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<ROOT::TSchemaHelper>*)o)->::std::vector<ROOT::TSchemaHelper>::~vector)();
}
static  void operator_20001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->operator=)(*(const ::std::vector<ROOT::TSchemaHelper>*)arg[0]);
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->operator=)(*(const ::std::vector<ROOT::TSchemaHelper>*)arg[0]);
}

static  void method_20002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::ROOT::TSchemaHelper*)arg[1]);
}

static  void method_20003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->begin)());
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->begin)();
}

static  void method_20004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->begin)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->begin)();
}

static  void method_20005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->end)());
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->end)();
}

static  void method_20006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->end)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->end)();
}

static  void method_20011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->size)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->size)();
}

static  void method_20012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->max_size)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->max_size)();
}

static  void method_20013( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<ROOT::TSchemaHelper>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<ROOT::TSchemaHelper>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::ROOT::TSchemaHelper*)arg[1]);
  }
}

static  void method_20014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->capacity)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->capacity)();
}

static  void method_20015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<ROOT::TSchemaHelper>*)o)->empty)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->empty)();
}

static  void method_20016( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20017( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ROOT::TSchemaHelper>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20020( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ROOT::TSchemaHelper>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->front)();
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->front)();
}

static  void method_20023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ROOT::TSchemaHelper>*)o)->front)();
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->front)();
}

static  void method_20024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ROOT::TSchemaHelper>*)o)->back)();
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->back)();
}

static  void method_20025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ROOT::TSchemaHelper>*)o)->back)();
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->back)();
}

static  void method_20026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<ROOT::TSchemaHelper>*)o)->data)());
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->data)();
}

static  void method_20027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<ROOT::TSchemaHelper>*)o)->data)());
  else   (((const ::std::vector<ROOT::TSchemaHelper>*)o)->data)();
}

static  void method_20028( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->push_back)(*(const ::ROOT::TSchemaHelper*)arg[0]);
}

static  void method_20029( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->pop_back)();
}

static  void method_20030( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(const ::ROOT::TSchemaHelper*)arg[1]));
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(const ::ROOT::TSchemaHelper*)arg[1]);
}

static  void method_20031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::ROOT::TSchemaHelper*)arg[2]);
}

static  void method_20032( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0]));
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0]);
}

static  void method_20033( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >)((((::std::vector<ROOT::TSchemaHelper>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[1]));
  else   (((::std::vector<ROOT::TSchemaHelper>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<ROOT::TSchemaHelper*,std::vector<ROOT::TSchemaHelper> >*)arg[1]);
}

static  void method_20034( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->swap)(*(::std::vector<ROOT::TSchemaHelper>*)arg[0]);
}

static  void method_20035( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<ROOT::TSchemaHelper>*)o)->clear)();
}

static void method_newdel_3125( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<ROOT::TSchemaHelper> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x212( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> >")), ::Reflex::BaseOffset< ::std::vector<ROOT::TSchemaHelper>,::std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x213( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<ROOT::TSchemaHelper> >::Generate();
  else ::Reflex::Proxy< ::std::vector<ROOT::TSchemaHelper> >::Generate();
}

//------Dictionary for class vector<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > -------------------------------
void __std__vector_ROOT__TSchemaHelper__db_datamem(Reflex::Class*);
void __std__vector_ROOT__TSchemaHelper__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_ROOT__TSchemaHelper__datamem_bld(&__std__vector_ROOT__TSchemaHelper__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_ROOT__TSchemaHelper__funcmem_bld(&__std__vector_ROOT__TSchemaHelper__db_funcmem);
void __std__vector_ROOT__TSchemaHelper__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<ROOT::TSchemaHelper>"), typeid(::std::vector<ROOT::TSchemaHelper>), sizeof(::std::vector<ROOT::TSchemaHelper>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_3051, ::Reflex::BaseOffset< ::std::vector<ROOT::TSchemaHelper>, ::std::_Vector_base<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_13467, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::_Alloc_value_type"))
  .AddTypedef(type_3051, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::_Base"))
  .AddTypedef(type_3775, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::_Tp_alloc_type"))
  .AddTypedef(type_11046, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::_Alloc_traits"))
  .AddTypedef(type_13467, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::value_type"))
  .AddTypedef(type_17781, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::pointer"))
  .AddTypedef(type_19983, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::const_pointer"))
  .AddTypedef(type_19985, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::reference"))
  .AddTypedef(type_19987, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::const_reference"))
  .AddTypedef(type_10906, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::iterator"))
  .AddTypedef(type_10907, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::const_iterator"))
  .AddTypedef(type_4004, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::const_reverse_iterator"))
  .AddTypedef(type_4005, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::reverse_iterator"))
  .AddTypedef(type_3404, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::size_type"))
  .AddTypedef(type_3256, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::difference_type"))
  .AddTypedef(type_3775, Reflex::Literal("std::vector<ROOT::TSchemaHelper>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19996, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32498), Reflex::Literal("vector"), constructor_19997, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3404, type_19987, type_32498), Reflex::Literal("vector"), constructor_19998, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32603), Reflex::Literal("vector"), constructor_19999, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20000, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x212, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x213, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_ROOT__TSchemaHelper__funcmem_bld);
}

//------Delayed data member builder for class vector<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > -------------------
void __std__vector_ROOT__TSchemaHelper__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<ROOT::TSchemaHelper,std::allocator<ROOT::TSchemaHelper> > -------------------
void __std__vector_ROOT__TSchemaHelper__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32604, type_32603), Reflex::Literal("operator="), operator_20001, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_19987), Reflex::Literal("assign"), method_20002, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906), Reflex::Literal("begin"), method_20003, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10907), Reflex::Literal("begin"), method_20004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906), Reflex::Literal("end"), method_20005, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10907), Reflex::Literal("end"), method_20006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("size"), method_20011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("max_size"), method_20012, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404, type_13467), Reflex::Literal("resize"), method_20013, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3404), Reflex::Literal("capacity"), method_20014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_667), Reflex::Literal("empty"), method_20015, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_3404), Reflex::Literal("reserve"), method_20016, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19985, type_3404), Reflex::Literal("operator[]"), operator_20017, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19987, type_3404), Reflex::Literal("operator[]"), operator_20018, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19985, type_3404), Reflex::Literal("at"), method_20020, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19987, type_3404), Reflex::Literal("at"), method_20021, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19985), Reflex::Literal("front"), method_20022, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19987), Reflex::Literal("front"), method_20023, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19985), Reflex::Literal("back"), method_20024, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19987), Reflex::Literal("back"), method_20025, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17781), Reflex::Literal("data"), method_20026, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19983), Reflex::Literal("data"), method_20027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_19987), Reflex::Literal("push_back"), method_20028, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("pop_back"), method_20029, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906, type_10906, type_19987), Reflex::Literal("insert"), method_20030, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_10906, type_3404, type_19987), Reflex::Literal("insert"), method_20031, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906, type_10906), Reflex::Literal("erase"), method_20032, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10906, type_10906, type_10906), Reflex::Literal("erase"), method_20033, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511, type_32604), Reflex::Literal("swap"), method_20034, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1511), Reflex::Literal("clear"), method_20035, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooAbsData*> -------------------------------
static void destructor_22897(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,RooAbsData*>*)o)->::std::pair<std::basic_string<char>,RooAbsData*>::~pair)();
}
static  void operator_22898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,RooAbsData*>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,RooAbsData*>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,RooAbsData*>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,RooAbsData*>*)arg[0]);
}

static void constructor_22899( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>(*(const ::std::pair<std::basic_string<char>,RooAbsData*>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>(*(const ::std::pair<std::basic_string<char>,RooAbsData*>*)arg[0]);
}

static void constructor_22900( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>();
  else ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>();
}

static void constructor_22901( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>(*(const ::std::basic_string<char>*)arg[0],
      *(::RooAbsData* const*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,RooAbsData*>(*(const ::std::basic_string<char>*)arg[0],
      *(::RooAbsData* const*)arg[1]);
}

static void method_newdel_3485( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,RooAbsData*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooAbsData*> -------------------------------
void __std__pair_std__basic_string_char__RooAbsDatap__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__RooAbsDatap__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__RooAbsDatap__datamem_bld(&__std__pair_std__basic_string_char__RooAbsDatap__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__RooAbsDatap__funcmem_bld(&__std__pair_std__basic_string_char__RooAbsDatap__db_funcmem);
void __std__pair_std__basic_string_char__RooAbsDatap__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,RooAbsData*>"), typeid(::std::pair<std::basic_string<char>,RooAbsData*>), sizeof(::std::pair<std::basic_string<char>,RooAbsData*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_3147, Reflex::Literal("std::pair<std::basic_string<char>,RooAbsData*>::first_type"))
  .AddTypedef(type_22352, Reflex::Literal("std::pair<std::basic_string<char>,RooAbsData*>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_22897, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33035, type_33036), Reflex::Literal("operator="), operator_22898, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33036), Reflex::Literal("pair"), constructor_22899, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_22900, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16945, type_32973), Reflex::Literal("pair"), constructor_22901, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3485, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__RooAbsDatap__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooAbsData*> -------------------
void __std__pair_std__basic_string_char__RooAbsDatap__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3147, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__RooAbsDatap_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_22352, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__RooAbsDatap_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,RooAbsData*> -------------------
void __std__pair_std__basic_string_char__RooAbsDatap__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BoundaryConditions -------------------------------
static void destructor_28196(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineKnot::BoundaryConditions*)o)->::RooCubicSplineKnot::BoundaryConditions::~BoundaryConditions)();
}
static  void operator_28197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::BoundaryConditions*)o)->operator=)(*(const ::RooCubicSplineKnot::BoundaryConditions*)arg[0]);
  else   (((::RooCubicSplineKnot::BoundaryConditions*)o)->operator=)(*(const ::RooCubicSplineKnot::BoundaryConditions*)arg[0]);
}

static void constructor_28198( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(const ::RooCubicSplineKnot::BoundaryConditions*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(const ::RooCubicSplineKnot::BoundaryConditions*)arg[0]);
}

static void constructor_28199( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions();
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions(*(bool*)arg[0],
      *(bool*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3]);
  }
}

static void constructor_x215( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::BoundaryConditions();
  else ::new(mem) ::RooCubicSplineKnot::BoundaryConditions();
}

static void method_newdel_7148( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::RooCubicSplineKnot::BoundaryConditions >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BoundaryConditions -------------------------------
void __RooCubicSplineKnot__BoundaryConditions_db_datamem(Reflex::Class*);
void __RooCubicSplineKnot__BoundaryConditions_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__BoundaryConditions_datamem_bld(&__RooCubicSplineKnot__BoundaryConditions_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__BoundaryConditions_funcmem_bld(&__RooCubicSplineKnot__BoundaryConditions_db_funcmem);
void __RooCubicSplineKnot__BoundaryConditions_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineKnot::BoundaryConditions"), typeid(::RooCubicSplineKnot::BoundaryConditions), sizeof(::RooCubicSplineKnot::BoundaryConditions), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BoundaryConditions"), destructor_28196, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33698, type_33699), Reflex::Literal("operator="), operator_28197, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33699), Reflex::Literal("BoundaryConditions"), constructor_28198, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_667, type_667, type_694, type_694), Reflex::Literal("BoundaryConditions"), constructor_28199, 0, "leftSecondDerivative=true;rightSecondDerivative=true;valueLeft=0;valueRight=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BoundaryConditions"), constructor_x215, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7148, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineKnot__BoundaryConditions_datamem_bld);
}

//------Delayed data member builder for class BoundaryConditions -------------------
void __RooCubicSplineKnot__BoundaryConditions_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_33697, Reflex::Literal("secondDerivative"), OffsetOf(__shadow__::__RooCubicSplineKnot__BoundaryConditions, secondDerivative), ::Reflex::PUBLIC)
  .AddDataMember(type_33612, Reflex::Literal("value"), OffsetOf(__shadow__::__RooCubicSplineKnot__BoundaryConditions, value), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BoundaryConditions -------------------
void __RooCubicSplineKnot__BoundaryConditions_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class S_edge -------------------------------
static void destructor_28221(void*, void * o, const std::vector<void*>&, void *) {
(((::RooCubicSplineKnot::S_edge*)o)->::RooCubicSplineKnot::S_edge::~S_edge)();
}
static  void operator_28222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::RooCubicSplineKnot::S_edge*)o)->operator=)(*(const ::RooCubicSplineKnot::S_edge*)arg[0]);
  else   (((::RooCubicSplineKnot::S_edge*)o)->operator=)(*(const ::RooCubicSplineKnot::S_edge*)arg[0]);
}

static void constructor_28223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_edge(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot::S_edge(*(double*)arg[0],
      *(double*)arg[1]);
}

static void constructor_28224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_edge(*(const ::RooCubicSplineKnot::S_edge*)arg[0]);
  else ::new(mem) ::RooCubicSplineKnot::S_edge(*(const ::RooCubicSplineKnot::S_edge*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::RooCubicSplineKnot::S_edge(*(const ::RooCubicSplineKnot::S_edge*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::RooCubicSplineKnot::S_edge(*(const ::RooCubicSplineKnot::S_edge*)arg[0],
      *(double*)arg[1]);
  }
}

static  void operator_28225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::RooCubicSplineKnot::S_edge*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::RooCubicSplineKnot::S_edge*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]);
}

//------Dictionary for class S_edge -------------------------------
void __RooCubicSplineKnot__S_edge_db_datamem(Reflex::Class*);
void __RooCubicSplineKnot__S_edge_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__S_edge_datamem_bld(&__RooCubicSplineKnot__S_edge_db_datamem);
Reflex::GenreflexMemberBuilder __RooCubicSplineKnot__S_edge_funcmem_bld(&__RooCubicSplineKnot__S_edge_db_funcmem);
void __RooCubicSplineKnot__S_edge_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("RooCubicSplineKnot::S_edge"), typeid(::RooCubicSplineKnot::S_edge), sizeof(::RooCubicSplineKnot::S_edge), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~S_edge"), destructor_28221, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33700, type_33701), Reflex::Literal("operator="), operator_28222, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_694, type_694), Reflex::Literal("S_edge"), constructor_28223, 0, "a;b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33701, type_694), Reflex::Literal("S_edge"), constructor_28224, 0, "other;offset=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddOnDemandDataMemberBuilder(&__RooCubicSplineKnot__S_edge_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__RooCubicSplineKnot__S_edge_funcmem_bld);
}

//------Delayed data member builder for class S_edge -------------------
void __RooCubicSplineKnot__S_edge_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_694, Reflex::Literal("alpha"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_edge, alpha), ::Reflex::PRIVATE)
  .AddDataMember(type_694, Reflex::Literal("beta"), OffsetOf(__shadow__::__RooCubicSplineKnot__S_edge, beta), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class S_edge -------------------
void __RooCubicSplineKnot__S_edge_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_694, type_141, type_141), Reflex::Literal("operator()"), operator_28225, 0, "j;k", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
static void function_5377( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 29 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainSignal(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(double*)arg[15],
      *(double*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::TString*)arg[22],
      *(::TString*)arg[23],
      *(::TString*)arg[24],
      *(::TString*)arg[25],
      *(::Bool_t*)arg[26],
      *(::Bool_t*)arg[27],
      (::RooWorkspace*)arg[28]);
    else MassFitUtils::ObtainSignal(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(double*)arg[15],
      *(double*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::TString*)arg[22],
      *(::TString*)arg[23],
      *(::TString*)arg[24],
      *(::TString*)arg[25],
      *(::Bool_t*)arg[26],
      *(::Bool_t*)arg[27],
      (::RooWorkspace*)arg[28]);
  }
  else if ( arg.size() == 30 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainSignal(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(double*)arg[15],
      *(double*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::TString*)arg[22],
      *(::TString*)arg[23],
      *(::TString*)arg[24],
      *(::TString*)arg[25],
      *(::Bool_t*)arg[26],
      *(::Bool_t*)arg[27],
      (::RooWorkspace*)arg[28],
      *(bool*)arg[29]);
    else MassFitUtils::ObtainSignal(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(double*)arg[15],
      *(double*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::TString*)arg[22],
      *(::TString*)arg[23],
      *(::TString*)arg[24],
      *(::TString*)arg[25],
      *(::Bool_t*)arg[26],
      *(::Bool_t*)arg[27],
      (::RooWorkspace*)arg[28],
      *(bool*)arg[29]);
  }
}
static void function_5378( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainLbLcPi(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(::TString*)arg[9],
    *(::TString*)arg[10],
    *(::TString*)arg[11],
    (::RooWorkspace*)arg[12],
    *(bool*)arg[13]);
  else MassFitUtils::ObtainLbLcPi(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(::TString*)arg[9],
    *(::TString*)arg[10],
    *(::TString*)arg[11],
    (::RooWorkspace*)arg[12],
    *(bool*)arg[13]);
}
static void function_5379( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 15 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14]);
    else MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14]);
  }
  else if ( arg.size() == 16 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14],
      *(bool*)arg[15]);
    else MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14],
      *(bool*)arg[15]);
  }
  else if ( arg.size() == 17 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14],
      *(bool*)arg[15],
      *(bool*)arg[16]);
    else MassFitUtils::getSpecBkg4kfactor(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      (::RooWorkspace*)arg[13],
      *(::TFile*)arg[14],
      *(bool*)arg[15],
      *(bool*)arg[16]);
  }
}
static void function_5380( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainBDPi(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(::TString*)arg[11],
    *(::TString*)arg[12],
    *(::TString*)arg[13],
    *(::Bool_t*)arg[14],
    *(::TString*)arg[15]);
  else MassFitUtils::ObtainBDPi(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(int*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(::TString*)arg[11],
    *(::TString*)arg[12],
    *(::TString*)arg[13],
    *(::Bool_t*)arg[14],
    *(::TString*)arg[15]);
}
static void function_5381( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 24 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainData(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::Bool_t*)arg[22],
      (::RooWorkspace*)arg[23]);
    else MassFitUtils::ObtainData(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::Bool_t*)arg[22],
      (::RooWorkspace*)arg[23]);
  }
  else if ( arg.size() == 25 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainData(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::Bool_t*)arg[22],
      (::RooWorkspace*)arg[23],
      *(bool*)arg[24]);
    else MassFitUtils::ObtainData(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      *(::TString*)arg[19],
      *(::TString*)arg[20],
      *(::TString*)arg[21],
      *(::Bool_t*)arg[22],
      (::RooWorkspace*)arg[23],
      *(bool*)arg[24]);
  }
}
static void function_5382( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 21 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainMissForBsDsK(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20]);
    else MassFitUtils::ObtainMissForBsDsK(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20]);
  }
  else if ( arg.size() == 22 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainMissForBsDsK(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
    else MassFitUtils::ObtainMissForBsDsK(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
  }
}
static void function_5383( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 21 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainMissForBsDsPi(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20]);
    else MassFitUtils::ObtainMissForBsDsPi(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20]);
  }
  else if ( arg.size() == 22 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainMissForBsDsPi(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
    else MassFitUtils::ObtainMissForBsDsPi(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(double*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(::TString*)arg[18],
      (::RooWorkspace*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
  }
}
static void function_5384( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)MassFitUtils::CreatePdfSpecBackground(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    (::RooWorkspace*)arg[10],
    *(::Bool_t*)arg[11],
    *(bool*)arg[12]);
  else MassFitUtils::CreatePdfSpecBackground(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    (::RooWorkspace*)arg[10],
    *(::Bool_t*)arg[11],
    *(bool*)arg[12]);
}
static void function_5385( void*, void*, const std::vector<void*>& arg, void*)
{
  MassFitUtils::ExpectedYield(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(::TString*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(::TString*)arg[15],
    *(::TString*)arg[16],
    *(::TString*)arg[17],
    *(::TString*)arg[18]);
}
static void function_5386( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 21 ) {
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainSpecBack(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      (::RooWorkspace*)arg[18],
      *(::Bool_t*)arg[19],
      *(::Bool_t*)arg[20]);
    else MassFitUtils::ObtainSpecBack(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      (::RooWorkspace*)arg[18],
      *(::Bool_t*)arg[19],
      *(::Bool_t*)arg[20]);
  }
  else if ( arg.size() == 22 ) { 
    if (retaddr) *(void**)retaddr = (void*)MassFitUtils::ObtainSpecBack(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      (::RooWorkspace*)arg[18],
      *(::Bool_t*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
    else MassFitUtils::ObtainSpecBack(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(double*)arg[10],
      *(double*)arg[11],
      *(double*)arg[12],
      *(double*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      (::RooWorkspace*)arg[18],
      *(::Bool_t*)arg[19],
      *(::Bool_t*)arg[20],
      *(bool*)arg[21]);
  }
}
static void function_6749( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3],
      *(double*)arg[4]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3],
      *(double*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
    else PTResModels::getPTResolutionModel((const char*)arg[0],
      *(::RooRealVar*)arg[1],
      (const char*)arg[2],
      *(bool*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5]);
  }
}
static void function_6750( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(bool*)arg[9]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(bool*)arg[9]);
  }
}
static void function_6751( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 8 ) {
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(bool*)arg[8]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(bool*)arg[8]);
  }
}
static void function_6752( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(double*)arg[5]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(double*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6]);
    else PTResModels::tripleGausResolutionModel(*(::RooRealVar*)arg[0],
      *(bool*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3],
      *(bool*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6]);
  }
}
static void function_7987( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::build_Bs2DsK_BKG_MDFitter(*(::RooAbsReal*)arg[0],
    *(::RooAbsReal*)arg[1],
    (::RooWorkspace*)arg[2],
    (::RooAddPdf*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    *(::RooRealVar*)arg[10],
    *(::RooRealVar*)arg[11],
    *(::RooRealVar*)arg[12],
    *(::RooRealVar*)arg[13],
    *(::RooRealVar*)arg[14],
    *(::RooRealVar*)arg[15],
    (::RooAbsPdf*)arg[16],
    *(::RooRealVar*)arg[17],
    *(::RooRealVar*)arg[18],
    *(::RooRealVar*)arg[19],
    *(::TString*)arg[20],
    *(::RooRealVar*)arg[21],
    *(bool*)arg[22]);
  else Bs2Dsh2011TDAnaModels::build_Bs2DsK_BKG_MDFitter(*(::RooAbsReal*)arg[0],
    *(::RooAbsReal*)arg[1],
    (::RooWorkspace*)arg[2],
    (::RooAddPdf*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    *(::RooRealVar*)arg[10],
    *(::RooRealVar*)arg[11],
    *(::RooRealVar*)arg[12],
    *(::RooRealVar*)arg[13],
    *(::RooRealVar*)arg[14],
    *(::RooRealVar*)arg[15],
    (::RooAbsPdf*)arg[16],
    *(::RooRealVar*)arg[17],
    *(::RooRealVar*)arg[18],
    *(::RooRealVar*)arg[19],
    *(::TString*)arg[20],
    *(::RooRealVar*)arg[21],
    *(bool*)arg[22]);
}
static void function_7988( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      *(bool*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_7989( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBdDsX(*(::RooAbsReal*)arg[0],
      *(::RooFormulaVar*)arg[1],
      *(::RooFormulaVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooFormulaVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10]);
    else Bs2Dsh2011TDAnaModels::buildBdDsX(*(::RooAbsReal*)arg[0],
      *(::RooFormulaVar*)arg[1],
      *(::RooFormulaVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooFormulaVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBdDsX(*(::RooAbsReal*)arg[0],
      *(::RooFormulaVar*)arg[1],
      *(::RooFormulaVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooFormulaVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10],
      *(bool*)arg[11]);
    else Bs2Dsh2011TDAnaModels::buildBdDsX(*(::RooAbsReal*)arg[0],
      *(::RooFormulaVar*)arg[1],
      *(::RooFormulaVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooFormulaVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10],
      *(bool*)arg[11]);
  }
}
static void function_7990( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 19 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBsDsK_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      (::RooAddPdf*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(bool*)arg[18]);
    else Bs2Dsh2011TDAnaModels::buildBsDsK_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      (::RooAddPdf*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(bool*)arg[18]);
  }
  else if ( arg.size() == 20 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBsDsK_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      (::RooAddPdf*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(bool*)arg[18],
      *(bool*)arg[19]);
    else Bs2Dsh2011TDAnaModels::buildBsDsK_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      (::RooAddPdf*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::TString*)arg[16],
      *(::TString*)arg[17],
      *(bool*)arg[18],
      *(bool*)arg[19]);
  }
}
static void function_7991( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      (::RooAbsPdf*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      (::RooAbsPdf*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      (::RooAbsPdf*)arg[5],
      *(bool*)arg[6]);
    else Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      (::RooAbsPdf*)arg[4],
      (::RooAbsPdf*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_7992( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_7993( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBPDF_sim(*(::RooAbsReal*)arg[0],
    *(::RooRealVar*)arg[1],
    *(::RooRealVar*)arg[2],
    *(::RooRealVar*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    (const char*)arg[10],
    (const char*)arg[11],
    *(bool*)arg[12]);
  else Bs2Dsh2011TDAnaModels::buildDoubleCBPDF_sim(*(::RooAbsReal*)arg[0],
    *(::RooRealVar*)arg[1],
    *(::RooRealVar*)arg[2],
    *(::RooRealVar*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    (const char*)arg[10],
    (const char*)arg[11],
    *(bool*)arg[12]);
}
static void function_7994( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooFormulaVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8]);
    else Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooFormulaVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooFormulaVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8],
      *(bool*)arg[9]);
    else Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooFormulaVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8],
      *(bool*)arg[9]);
  }
}
static void function_7995( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8]);
    else Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8],
      *(bool*)arg[9]);
    else Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      (const char*)arg[6],
      (const char*)arg[7],
      *(bool*)arg[8],
      *(bool*)arg[9]);
  }
}
static void function_7996( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_7997( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)(Bs2Dsh2011TDAnaModels::CheckPDF((::RooAbsPdf*)arg[0]));
    else Bs2Dsh2011TDAnaModels::CheckPDF((::RooAbsPdf*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)(Bs2Dsh2011TDAnaModels::CheckPDF((::RooAbsPdf*)arg[0],
      *(bool*)arg[1]));
    else Bs2Dsh2011TDAnaModels::CheckPDF((::RooAbsPdf*)arg[0],
      *(bool*)arg[1]);
  }
}
static void function_7998( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 20 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBsDsPi_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      (::RooAbsPdf*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::RooRealVar*)arg[16],
      *(::TString*)arg[17],
      *(::RooRealVar*)arg[18],
      *(bool*)arg[19]);
    else Bs2Dsh2011TDAnaModels::buildBsDsPi_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      (::RooAbsPdf*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::RooRealVar*)arg[16],
      *(::TString*)arg[17],
      *(::RooRealVar*)arg[18],
      *(bool*)arg[19]);
  }
  else if ( arg.size() == 21 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildBsDsPi_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      (::RooAbsPdf*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::RooRealVar*)arg[16],
      *(::TString*)arg[17],
      *(::RooRealVar*)arg[18],
      *(bool*)arg[19],
      *(bool*)arg[20]);
    else Bs2Dsh2011TDAnaModels::buildBsDsPi_sim(*(::RooRealVar*)arg[0],
      (::RooWorkspace*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      (::RooAbsPdf*)arg[9],
      *(::RooRealVar*)arg[10],
      *(::RooRealVar*)arg[11],
      *(::RooRealVar*)arg[12],
      *(::RooRealVar*)arg[13],
      *(::RooRealVar*)arg[14],
      *(::RooRealVar*)arg[15],
      *(::RooRealVar*)arg[16],
      *(::TString*)arg[17],
      *(::RooRealVar*)arg[18],
      *(bool*)arg[19],
      *(bool*)arg[20]);
  }
}
static void function_7999( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3]);
    else Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainPIDKShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_8000( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainComboBs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::TString*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainComboBs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::TString*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainComboBs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainComboBs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_8001( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::build_Bs2DsPi_BKG_MDFitter(*(::RooAbsReal*)arg[0],
    *(::RooAbsReal*)arg[1],
    (::RooWorkspace*)arg[2],
    *(::RooRealVar*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    (::RooAbsPdf*)arg[10],
    *(::RooRealVar*)arg[11],
    *(::RooRealVar*)arg[12],
    *(::RooRealVar*)arg[13],
    *(::RooRealVar*)arg[14],
    (::RooAbsPdf*)arg[15],
    *(::RooRealVar*)arg[16],
    *(::RooRealVar*)arg[17],
    *(::RooRealVar*)arg[18],
    *(::RooRealVar*)arg[19],
    *(::RooRealVar*)arg[20],
    *(::RooRealVar*)arg[21],
    *(::TString*)arg[22],
    *(::RooRealVar*)arg[23],
    *(bool*)arg[24]);
  else Bs2Dsh2011TDAnaModels::build_Bs2DsPi_BKG_MDFitter(*(::RooAbsReal*)arg[0],
    *(::RooAbsReal*)arg[1],
    (::RooWorkspace*)arg[2],
    *(::RooRealVar*)arg[3],
    *(::RooRealVar*)arg[4],
    *(::RooRealVar*)arg[5],
    *(::RooRealVar*)arg[6],
    *(::RooRealVar*)arg[7],
    *(::RooRealVar*)arg[8],
    *(::RooRealVar*)arg[9],
    (::RooAbsPdf*)arg[10],
    *(::RooRealVar*)arg[11],
    *(::RooRealVar*)arg[12],
    *(::RooRealVar*)arg[13],
    *(::RooRealVar*)arg[14],
    (::RooAbsPdf*)arg[15],
    *(::RooRealVar*)arg[16],
    *(::RooRealVar*)arg[17],
    *(::RooRealVar*)arg[18],
    *(::RooRealVar*)arg[19],
    *(::RooRealVar*)arg[20],
    *(::RooRealVar*)arg[21],
    *(::TString*)arg[22],
    *(::RooRealVar*)arg[23],
    *(bool*)arg[24]);
}
static void function_8002( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)(Bs2Dsh2011TDAnaModels::CheckVar((::RooRealVar*)arg[0]));
    else Bs2Dsh2011TDAnaModels::CheckVar((::RooRealVar*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)(Bs2Dsh2011TDAnaModels::CheckVar((::RooRealVar*)arg[0],
      *(bool*)arg[1]));
    else Bs2Dsh2011TDAnaModels::CheckVar((::RooRealVar*)arg[0],
      *(bool*)arg[1]);
  }
}
static void function_8003( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_8004( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainMassShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2],
      *(::RooRealVar*)arg[3]);
    else Bs2Dsh2011TDAnaModels::ObtainMassShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2],
      *(::RooRealVar*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainMassShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainMassShape((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2],
      *(::RooRealVar*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_8005( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 12 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooRealVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
    else Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooRealVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooRealVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
    else Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::RooRealVar*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_8006( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 12 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
    else Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
    else Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(::RooRealVar*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_8007( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainComboDs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      (::RooAbsPdf*)arg[3],
      *(::TString*)arg[4]);
    else Bs2Dsh2011TDAnaModels::ObtainComboDs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      (::RooAbsPdf*)arg[3],
      *(::TString*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::ObtainComboDs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      (::RooAbsPdf*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
    else Bs2Dsh2011TDAnaModels::ObtainComboDs(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      (::RooAbsPdf*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_8008( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_9456( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsKK((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsKK((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9457( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsKP((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsKP((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9458( void*, void*, const std::vector<void*>& arg, void*)
{
  WeightingUtils::PlotWeightingSample(*(::TString*)arg[0],
    (::RooDataSet*)arg[1],
    (::RooDataSet*)arg[2],
    (::RooRealVar*)arg[3],
    (::RooRealVar*)arg[4],
    (::RooRealVar*)arg[5],
    (::RooRealVar*)arg[6],
    *(::Int_t*)arg[7],
    *(::Int_t*)arg[8],
    *(::Int_t*)arg[9],
    *(::Int_t*)arg[10],
    *(::TString*)arg[11],
    *(::TString*)arg[12],
    *(::TString*)arg[13],
    *(::TString*)arg[14],
    *(::TString*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
}
static void function_9459( void*, void*, const std::vector<void*>& arg, void*)
{
  WeightingUtils::PlotWeightingSample(*(::TString*)arg[0],
    (::RooDataSet*)arg[1],
    (::RooDataSet*)arg[2],
    (::RooRealVar*)arg[3],
    (::RooRealVar*)arg[4],
    (::RooRealVar*)arg[5],
    *(::Int_t*)arg[6],
    *(::Int_t*)arg[7],
    *(::Int_t*)arg[8],
    *(::TString*)arg[9],
    *(::TString*)arg[10],
    *(::TString*)arg[11],
    *(::TString*)arg[12],
    *(::TString*)arg[13],
    (::RooWorkspace*)arg[14],
    *(bool*)arg[15]);
}
static void function_9460( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(WeightingUtils::CheckWeightLabel(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else WeightingUtils::CheckWeightLabel(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_9461( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::Get2DHist((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    (::RooRealVar*)arg[2],
    *(::Int_t*)arg[3],
    *(::Int_t*)arg[4],
    *(::TString*)arg[5],
    *(bool*)arg[6]);
  else WeightingUtils::Get2DHist((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    (::RooRealVar*)arg[2],
    *(::Int_t*)arg[3],
    *(::Int_t*)arg[4],
    *(::TString*)arg[5],
    *(bool*)arg[6]);
}
static void function_9462( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainHistRatio(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::Int_t*)arg[4],
    *(::Int_t*)arg[5],
    *(::Int_t*)arg[6],
    *(::TString*)arg[7],
    *(::TString*)arg[8],
    *(::TString*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(double*)arg[15],
    *(::TString*)arg[16],
    (::RooWorkspace*)arg[17],
    *(bool*)arg[18]);
  else WeightingUtils::ObtainHistRatio(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::Int_t*)arg[4],
    *(::Int_t*)arg[5],
    *(::Int_t*)arg[6],
    *(::TString*)arg[7],
    *(::TString*)arg[8],
    *(::TString*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(double*)arg[15],
    *(::TString*)arg[16],
    (::RooWorkspace*)arg[17],
    *(bool*)arg[18]);
}
static void function_9463( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainHistRatio(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::Int_t*)arg[4],
    *(::Int_t*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(::TString*)arg[12],
    (::RooWorkspace*)arg[13],
    *(bool*)arg[14]);
  else WeightingUtils::ObtainHistRatio(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::Int_t*)arg[4],
    *(::Int_t*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(::TString*)arg[12],
    (::RooWorkspace*)arg[13],
    *(bool*)arg[14]);
}
static void function_9464( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(::Int_t*)arg[14],
    *(::Int_t*)arg[15],
    *(::Int_t*)arg[16],
    *(::TString*)arg[17],
    (::RooWorkspace*)arg[18],
    *(bool*)arg[19]);
  else WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(::Int_t*)arg[14],
    *(::Int_t*)arg[15],
    *(::Int_t*)arg[16],
    *(::TString*)arg[17],
    (::RooWorkspace*)arg[18],
    *(bool*)arg[19]);
}
static void function_9465( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(::Int_t*)arg[11],
    *(::Int_t*)arg[12],
    *(::TString*)arg[13],
    (::RooWorkspace*)arg[14],
    *(bool*)arg[15]);
  else WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(double*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(::Int_t*)arg[11],
    *(::Int_t*)arg[12],
    *(::TString*)arg[13],
    (::RooWorkspace*)arg[14],
    *(bool*)arg[15]);
}
static void function_9466( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::GetDataCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    (::RooRealVar*)arg[4],
    *(bool*)arg[5]);
  else WeightingUtils::GetDataCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    (::RooRealVar*)arg[4],
    *(bool*)arg[5]);
}
static void function_9467( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::GetDataCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    *(bool*)arg[4]);
  else WeightingUtils::GetDataCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    *(bool*)arg[4]);
}
static void function_9468( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsPiK((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsPiK((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9469( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsPiPi((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsPiPi((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9470( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(WeightingUtils::CheckTreeLabel(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(bool*)arg[2]));
  else WeightingUtils::CheckTreeLabel(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(bool*)arg[2]);
}
static void function_9471( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(WeightingUtils::CheckTreeLabel(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else WeightingUtils::CheckTreeLabel(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_9472( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::FitPDFShapeForPIDBsDsKPi((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
  else WeightingUtils::FitPDFShapeForPIDBsDsKPi((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    *(::TString*)arg[2],
    *(bool*)arg[3]);
}
static void function_9473( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainPIDShapeFromCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(double*)arg[15],
    *(::Int_t*)arg[16],
    *(::Int_t*)arg[17],
    *(::Int_t*)arg[18],
    *(::TString*)arg[19],
    (::RooWorkspace*)arg[20],
    *(bool*)arg[21]);
  else WeightingUtils::ObtainPIDShapeFromCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(double*)arg[14],
    *(double*)arg[15],
    *(::Int_t*)arg[16],
    *(::Int_t*)arg[17],
    *(::Int_t*)arg[18],
    *(::TString*)arg[19],
    (::RooWorkspace*)arg[20],
    *(bool*)arg[21]);
}
static void function_9474( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainPIDShapeFromCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(::Int_t*)arg[13],
    *(::Int_t*)arg[14],
    *(::TString*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
  else WeightingUtils::ObtainPIDShapeFromCalibSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::TString*)arg[2],
    *(::TString*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(::Int_t*)arg[13],
    *(::Int_t*)arg[14],
    *(::TString*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
}
static void function_9475( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::Get3DHist((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    (::TH3F*)arg[4],
    *(bool*)arg[5]);
  else WeightingUtils::Get3DHist((::RooDataSet*)arg[0],
    (::RooRealVar*)arg[1],
    (::RooRealVar*)arg[2],
    (::RooRealVar*)arg[3],
    (::TH3F*)arg[4],
    *(bool*)arg[5]);
}
static void function_9476( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainHistRatioOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::Int_t*)arg[2],
    *(::Int_t*)arg[3],
    *(::Int_t*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(::TString*)arg[14],
    (::RooWorkspace*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
  else WeightingUtils::ObtainHistRatioOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::Int_t*)arg[2],
    *(::Int_t*)arg[3],
    *(::Int_t*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6],
    *(::TString*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(double*)arg[10],
    *(double*)arg[11],
    *(double*)arg[12],
    *(double*)arg[13],
    *(::TString*)arg[14],
    (::RooWorkspace*)arg[15],
    (::RooWorkspace*)arg[16],
    *(bool*)arg[17]);
}
static void function_9477( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)WeightingUtils::ObtainHistRatioOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::Int_t*)arg[2],
    *(::Int_t*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(::TString*)arg[10],
    (::RooWorkspace*)arg[11],
    (::RooWorkspace*)arg[12],
    *(bool*)arg[13]);
  else WeightingUtils::ObtainHistRatioOneSample(*(::TString*)arg[0],
    *(::TString*)arg[1],
    *(::Int_t*)arg[2],
    *(::Int_t*)arg[3],
    *(::TString*)arg[4],
    *(::TString*)arg[5],
    *(double*)arg[6],
    *(double*)arg[7],
    *(double*)arg[8],
    *(double*)arg[9],
    *(::TString*)arg[10],
    (::RooWorkspace*)arg[11],
    (::RooWorkspace*)arg[12],
    *(bool*)arg[13]);
}
static void function_9977( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 10 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9]);
    else GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10]);
    else GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
    else GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
    else GeneralModels::buildRooBDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_9978( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10]);
    else GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11]);
    else GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11],
      (const char*)arg[12]);
    else GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11],
      (const char*)arg[12]);
  }
  else if ( arg.size() == 14 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11],
      (const char*)arg[12],
      *(bool*)arg[13]);
    else GeneralModels::buildRooBDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(::RooAbsReal*)arg[10],
      (const char*)arg[11],
      (const char*)arg[12],
      *(bool*)arg[13]);
  }
}
static void function_9979( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 10 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9]);
    else GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10]);
    else GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
    else GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
    else GeneralModels::buildDoubleCBEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(::RooRealVar*)arg[9],
      (const char*)arg[10],
      (const char*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_9980( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4]);
    else GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5]);
    else GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5],
      (const char*)arg[6]);
    else GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5],
      (const char*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5],
      (const char*)arg[6],
      *(bool*)arg[7]);
    else GeneralModels::buildRooDecayEPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      *(::RooRealVar*)arg[4],
      (const char*)arg[5],
      (const char*)arg[6],
      *(bool*)arg[7]);
  }
}
static void function_9981( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3]);
    else GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4]);
    else GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
    else GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
    else GeneralModels::buildRooDecayPDF(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      (::RooResolutionModel*)arg[2],
      (::RooAbsReal*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_9982( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3]);
    else GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4]);
    else GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
    else GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
    else GeneralModels::buildGaussianEPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::RooRealVar*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_9983( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 9 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8]);
    else GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8]);
  }
  else if ( arg.size() == 10 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9]);
    else GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9],
      (const char*)arg[10]);
    else GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9],
      (const char*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9],
      (const char*)arg[10],
      *(bool*)arg[11]);
    else GeneralModels::buildDoubleCBPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      (const char*)arg[9],
      (const char*)arg[10],
      *(bool*)arg[11]);
  }
}
static void function_9984( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
    else GeneralModels::buildKeysPDF(*(::RooAbsReal*)arg[0],
      *(::RooDataSet*)arg[1],
      *(::RooKeysPdf::Mirror*)arg[2],
      *(double*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_9985( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 12 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12]);
  }
  else if ( arg.size() == 14 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13]);
  }
  else if ( arg.size() == 15 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13],
      *(bool*)arg[14]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      (::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13],
      *(bool*)arg[14]);
  }
}
static void function_9986( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 12 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12]);
  }
  else if ( arg.size() == 14 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13]);
  }
  else if ( arg.size() == 15 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13],
      *(bool*)arg[14]);
    else GeneralModels::buildRooBDecayPDFWithPEDTE(*(::RooAbsReal*)arg[0],
      *(::RooAbsReal*)arg[1],
      *(::RooAbsReal*)arg[2],
      *(::RooAbsReal*)arg[3],
      *(::RooAbsReal*)arg[4],
      *(::RooAbsReal*)arg[5],
      *(::RooAbsReal*)arg[6],
      *(::RooAbsReal*)arg[7],
      *(::RooAbsReal*)arg[8],
      (::RooAbsPdf*)arg[9],
      (::RooResolutionModel*)arg[10],
      (::RooAbsReal*)arg[11],
      (const char*)arg[12],
      (const char*)arg[13],
      *(bool*)arg[14]);
  }
}
static void function_9987( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
    else GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3]);
    else GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4]);
    else GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4],
      *(bool*)arg[5]);
    else GeneralModels::buildGaussianPDF(*(::RooAbsReal*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_12529( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 8 ) {
    if (retaddr) *(void**)retaddr = (void*)Bs2DshModels::buildBsBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7]);
    else Bs2DshModels::buildBsBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7]);
  }
  else if ( arg.size() == 9 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bs2DshModels::buildBsBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(bool*)arg[8]);
    else Bs2DshModels::buildBsBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      *(bool*)arg[8]);
  }
}
static void function_13929( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 7 ) {
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6]);
    else Bd2DhModels::buildBdBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6]);
  }
  else if ( arg.size() == 8 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(bool*)arg[7]);
    else Bd2DhModels::buildBdBackgroundEPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(bool*)arg[7]);
  }
}
static void function_13930( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 10 ) {
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundNoTagEPDFInTime(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9]);
    else Bd2DhModels::buildBdBackgroundNoTagEPDFInTime(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9]);
  }
  else if ( arg.size() == 11 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundNoTagEPDFInTime(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(bool*)arg[10]);
    else Bd2DhModels::buildBdBackgroundNoTagEPDFInTime(*(::RooAbsReal*)arg[0],
      *(::RooRealVar*)arg[1],
      *(::RooRealVar*)arg[2],
      *(::RooRealVar*)arg[3],
      *(::RooRealVar*)arg[4],
      *(::RooRealVar*)arg[5],
      *(::RooRealVar*)arg[6],
      *(::RooRealVar*)arg[7],
      (::RooResolutionModel*)arg[8],
      (::RooAbsReal*)arg[9],
      *(bool*)arg[10]);
  }
}
static void function_13931( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 6 ) {
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(const long*)arg[2],
      *(const long*)arg[3],
      *(const long*)arg[4],
      *(const long*)arg[5]);
    else Bd2DhModels::buildBdBackgroundPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(const long*)arg[2],
      *(const long*)arg[3],
      *(const long*)arg[4],
      *(const long*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = (void*)Bd2DhModels::buildBdBackgroundPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(const long*)arg[2],
      *(const long*)arg[3],
      *(const long*)arg[4],
      *(const long*)arg[5],
      *(bool*)arg[6]);
    else Bd2DhModels::buildBdBackgroundPDFInMass(*(::RooAbsReal*)arg[0],
      *(::RooStringVar*)arg[1],
      *(const long*)arg[2],
      *(const long*)arg[3],
      *(const long*)arg[4],
      *(const long*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_14381( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadPIDHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
    else GeneralUtils::ReadPIDHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadPIDHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
    else GeneralUtils::ReadPIDHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14382( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreateHistPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3]);
    else GeneralUtils::CreateHistPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreateHistPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3],
      *(bool*)arg[4]);
    else GeneralUtils::CreateHistPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14383( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::GetLabel(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::GetLabel(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14384( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (TString)(GeneralUtils::ReadOneMode(*(::TString*)arg[0]));
    else GeneralUtils::ReadOneMode(*(::TString*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (TString)(GeneralUtils::ReadOneMode(*(::TString*)arg[0],
      *(bool*)arg[1]));
    else GeneralUtils::ReadOneMode(*(::TString*)arg[0],
      *(bool*)arg[1]);
  }
}
static void function_14385( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    GeneralUtils::SaveDataSet((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    GeneralUtils::SaveDataSet((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14386( void*, void*, const std::vector<void*>& arg, void*)
{
  GeneralUtils::Save2DComparison((::TH2F*)arg[0],
    *(::TString*)arg[1],
    (::TH2F*)arg[2],
    *(::TString*)arg[3],
    (::TH2F*)arg[4],
    *(::TString*)arg[5],
    *(::TString*)arg[6]);
}
static void function_14387( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::AddHist((::TH1F*)arg[0],
      *(::Double_t*)arg[1],
      (::TH1F*)arg[2],
      *(::Double_t*)arg[3]);
    else GeneralUtils::AddHist((::TH1F*)arg[0],
      *(::Double_t*)arg[1],
      (::TH1F*)arg[2],
      *(::Double_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::AddHist((::TH1F*)arg[0],
      *(::Double_t*)arg[1],
      (::TH1F*)arg[2],
      *(::Double_t*)arg[3],
      *(bool*)arg[4]);
    else GeneralUtils::AddHist((::TH1F*)arg[0],
      *(::Double_t*)arg[1],
      (::TH1F*)arg[2],
      *(::Double_t*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14388( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    GeneralUtils::SaveTemplateHist((::RooDataHist*)arg[0],
      (::RooHistPdf*)arg[1],
      (::RooRealVar*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    GeneralUtils::SaveTemplateHist((::RooDataHist*)arg[0],
      (::RooHistPdf*)arg[1],
      (::RooRealVar*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_14389( void*, void*, const std::vector<void*>& arg, void*)
{
  GeneralUtils::Save2DHist((::TH2F*)arg[0],
    *(::TString*)arg[1]);
}
static void function_14390( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    GeneralUtils::ReadOneName(*(::TString*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1],
      *(::TString*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    GeneralUtils::ReadOneName(*(::TString*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1],
      *(::TString*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14391( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::Read3DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
    else GeneralUtils::Read3DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::Read3DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
    else GeneralUtils::Read3DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14392( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreateBinnedPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3]);
    else GeneralUtils::CreateBinnedPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreateBinnedPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3],
      *(bool*)arg[4]);
    else GeneralUtils::CreateBinnedPDF((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::Int_t*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14393( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadTreeData(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(int*)arg[1]);
    else GeneralUtils::ReadTreeData(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadTreeData(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::ReadTreeData(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(int*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14394( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetObservable((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetObservable((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetObservable((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetObservable((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14395( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    GeneralUtils::SaveWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    GeneralUtils::SaveWorkspace((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14396( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::LoadWorkspace(*(::TString*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::LoadWorkspace(*(::TString*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::LoadWorkspace(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::LoadWorkspace(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14397( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    GeneralUtils::SaveTemplate((::RooDataSet*)arg[0],
      (::RooKeysPdf*)arg[1],
      (::RooRealVar*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    GeneralUtils::SaveTemplate((::RooDataSet*)arg[0],
      (::RooKeysPdf*)arg[1],
      (::RooRealVar*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_14398( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetRooArgSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetRooArgSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetRooArgSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetRooArgSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14399( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadTreeMC((const char*)arg[0],
      (const char*)arg[1]);
    else GeneralUtils::ReadTreeMC((const char*)arg[0],
      (const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::ReadTreeMC((const char*)arg[0],
      (const char*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::ReadTreeMC((const char*)arg[0],
      (const char*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14400( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreatePDFMC((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::Bool_t*)arg[4]);
    else GeneralUtils::CreatePDFMC((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::Bool_t*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::CreatePDFMC((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::Bool_t*)arg[4],
      *(bool*)arg[5]);
    else GeneralUtils::CreatePDFMC((::RooDataSet*)arg[0],
      (::RooRealVar*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::Bool_t*)arg[4],
      *(bool*)arg[5]);
  }
}
static void function_14401( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetCategory((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetCategory((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetCategory((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetCategory((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14402( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckDMode(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckDMode(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14403( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckDMode(*(::std::string*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckDMode(*(::std::string*)arg[0],
    *(bool*)arg[1]);
}
static void function_14404( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::Read2DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
    else GeneralUtils::Read2DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::Read2DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
    else GeneralUtils::Read2DHist(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::TString*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14405( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckBDTGBin(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckBDTGBin(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14406( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetDataHist((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetDataHist((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetDataHist((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetDataHist((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14407( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckPolarity(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckPolarity(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14408( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckPolarity(*(::std::string*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckPolarity(*(::std::string*)arg[0],
    *(bool*)arg[1]);
}
static void function_14409( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetDataSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
    else GeneralUtils::GetDataSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::GetDataSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
    else GeneralUtils::GetDataSet((::RooWorkspace*)arg[0],
      *(::TString*)arg[1],
      *(bool*)arg[2]);
  }
}
static void function_14410( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckKKPiMode(*(::TString*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckKKPiMode(*(::TString*)arg[0],
    *(bool*)arg[1]);
}
static void function_14411( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (TString)(GeneralUtils::CheckKKPiMode(*(::std::string*)arg[0],
    *(bool*)arg[1]));
  else GeneralUtils::CheckKKPiMode(*(::std::string*)arg[0],
    *(bool*)arg[1]);
}
static void function_14412( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    GeneralUtils::ReadMode(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    GeneralUtils::ReadMode(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1],
      *(bool*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    GeneralUtils::ReadMode(*(::std::vector<std::basic_string<char> >*)arg[0],
      *(::std::vector<std::basic_string<char> >*)arg[1],
      *(bool*)arg[2],
      *(bool*)arg[3]);
  }
}
static void function_14413( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::TreeCut((::TTree*)arg[0],
      *(::TCut*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3]);
    else GeneralUtils::TreeCut((::TTree*)arg[0],
      *(::TCut*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = (void*)GeneralUtils::TreeCut((::TTree*)arg[0],
      *(::TCut*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(bool*)arg[4]);
    else GeneralUtils::TreeCut((::TTree*)arg[0],
      *(::TCut*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(bool*)arg[4]);
  }
}
static void function_14414( void*, void*, const std::vector<void*>& arg, void*)
{
  GeneralUtils::Save3DHist((::TH3F*)arg[0],
    *(::TString*)arg[1]);
}
static void function_14415( void*, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 4 ) {
    GeneralUtils::saveDataTemplateToFile((::RooAbsData*)arg[0],
      (::RooAbsPdf*)arg[1],
      (::RooRealVar*)arg[2],
      (const char*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    GeneralUtils::saveDataTemplateToFile((::RooAbsData*)arg[0],
      (::RooAbsPdf*)arg[1],
      (::RooRealVar*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    GeneralUtils::saveDataTemplateToFile((::RooAbsData*)arg[0],
      (::RooAbsPdf*)arg[1],
      (::RooRealVar*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    GeneralUtils::saveDataTemplateToFile((::RooAbsData*)arg[0],
      (::RooAbsPdf*)arg[1],
      (::RooRealVar*)arg[2],
      (const char*)arg[3],
      (const char*)arg[4],
      (const char*)arg[5],
      *(bool*)arg[6]);
  }
}
static void function_15173( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::CopyDataForToys((::TTree*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10]);
    else SFitUtils::CopyDataForToys((::TTree*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::CopyDataForToys((::TTree*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10],
      *(bool*)arg[11]);
    else SFitUtils::CopyDataForToys((::TTree*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(::TString*)arg[3],
      *(::TString*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(::TString*)arg[10],
      *(bool*)arg[11]);
  }
}
static void function_15174( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights2(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10]);
    else SFitUtils::ReadDataFromSWeights2(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights2(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11]);
    else SFitUtils::ReadDataFromSWeights2(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11]);
  }
}
static void function_15175( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 11 ) {
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10]);
    else SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10]);
  }
  else if ( arg.size() == 12 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11]);
    else SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11]);
  }
  else if ( arg.size() == 13 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11],
      *(bool*)arg[12]);
    else SFitUtils::ReadDataFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(::TString*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(::TString*)arg[5],
      *(::TString*)arg[6],
      *(::TString*)arg[7],
      *(::TString*)arg[8],
      *(::TString*)arg[9],
      *(bool*)arg[10],
      *(bool*)arg[11],
      *(bool*)arg[12]);
  }
}
static void function_15176( void* retaddr, void*, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 17 ) {
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadLbLcPiFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(::TString*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      (::RooWorkspace*)arg[16]);
    else SFitUtils::ReadLbLcPiFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(::TString*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      (::RooWorkspace*)arg[16]);
  }
  else if ( arg.size() == 18 ) { 
    if (retaddr) *(void**)retaddr = (void*)SFitUtils::ReadLbLcPiFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(::TString*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      (::RooWorkspace*)arg[16],
      *(bool*)arg[17]);
    else SFitUtils::ReadLbLcPiFromSWeights(*(::TString*)arg[0],
      *(::TString*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4],
      *(double*)arg[5],
      *(double*)arg[6],
      *(double*)arg[7],
      *(double*)arg[8],
      *(double*)arg[9],
      *(::TString*)arg[10],
      *(::TString*)arg[11],
      *(::TString*)arg[12],
      *(::TString*)arg[13],
      *(::TString*)arg[14],
      *(::TString*)arg[15],
      (::RooWorkspace*)arg[16],
      *(bool*)arg[17]);
  }
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TagEfficiencyWeight_dict(); 
      __RooBinned1DQuinticBase_RooAbsReal__dict(); 
      __DecRateCoeff_dict(); 
      __IfThreeWayPdf_dict(); 
      __Inverse_dict(); 
      __RooEffConvGenContext_dict(); 
      __BdPTAcceptance_dict(); 
      __RooBinned2DBicubicBase_RooAbsPdf__dict(); 
      __RooBinned2DBicubicBase_RooAbsReal__dict(); 
      __IfThreeWayCatPdf_dict(); 
      __NonOscTaggingPdf_dict(); 
      __DTAcceptanceLHCbNote2007041_dict(); 
      __RooEffResModel_dict(); 
      __RooAbsEffResModel_dict(); 
      __IfThreeWayCat_dict(); 
      __RooCubicSplineKnot_dict(); 
      __RooBinnedPdf_dict(); 
      __MistagDistribution_dict(); 
      __SquaredSum_dict(); 
      __RooGenSmearIntegrandBinding_dict(); 
      __RooGaussEfficiencyModel_dict(); 
      __RooGeneralisedSmearingBase_RooAbsPdf__dict(); 
      __RooBinned1DQuinticBase_RooAbsPdf__dict(); 
      __RooEffHistProd_dict(); 
      __RooAbsGaussModelEfficiency_dict(); 
      __RooGeneralisedSmearingBase_RooAbsReal__dict(); 
      __TagEfficiencyWeightNoCat_dict(); 
      __FinalStateChargePdf_dict(); 
      __TaggingCat_dict(); 
      __RangeAcceptance_dict(); 
      __PowLawAcceptance_dict(); 
      __MistagCalibration_dict(); 
      __SharedArrayImp_double__dict(); 
      __SharedArrayImp_float__dict(); 
      __SharedArrayImp_unsignedslongslong__dict(); 
      __SharedArrayImp_unsignedslong__dict(); 
      __SharedArrayImp_unsignedsint__dict(); 
      __SharedArrayImp_unsignedsshort__dict(); 
      __SharedArrayImp_unsignedschar__dict(); 
      __SharedArrayImp_longslong__dict(); 
      __SharedArrayImp_long__dict(); 
      __SharedArrayImp_int__dict(); 
      __SharedArrayImp_short__dict(); 
      __SharedArrayImp_char__dict(); 
      __Dilution_dict(); 
      __FitMeTool_dict(); 
      __RooCubicSplineFun_dict(); 
      __CPObservable_dict(); 
      __RooComplementCoef_dict(); 
      __SharedArray_double__dict(); 
      __SharedArray_float__dict(); 
      __SharedArray_unsignedslongslong__dict(); 
      __SharedArray_unsignedslong__dict(); 
      __SharedArray_unsignedsint__dict(); 
      __SharedArray_unsignedsshort__dict(); 
      __SharedArray_unsignedschar__dict(); 
      __SharedArray_longslong__dict(); 
      __SharedArray_long__dict(); 
      __SharedArray_int__dict(); 
      __SharedArray_short__dict(); 
      __SharedArray_char__dict(); 
      __IfThreeWay_dict(); 
      __RooCruijff_dict(); 
      __CombBkgPTPdf_dict(); 
      __RooBinnedFun_dict(); 
      __std__vector_double__dict(); 
      __RooCubicSplineKnot__S_jk_dict(); 
      __std__vector_RooCubicSplineKnot__S_jk__dict(); 
      __std__vector_float__dict(); 
      __std__vector_unsignedslongslong__dict(); 
      __std__vector_unsignedslong__dict(); 
      __std__vector_unsignedsint__dict(); 
      __std__vector_unsignedsshort__dict(); 
      __std__vector_unsignedschar__dict(); 
      __std__vector_longslong__dict(); 
      __std__vector_long__dict(); 
      __std__vector_int__dict(); 
      __std__vector_short__dict(); 
      __std__vector_char__dict(); 
      __std__vector_RooFitResultp__dict(); 
      __std__vector_std__pair_std__basic_string_char__std__basic_string_char_s_s__dict(); 
      __std__vector_std__map_voidp_double_s__dict(); 
      __std__vector_std__vector_double_s__dict(); 
      __std__vector_constsRooAbsBinningp__dict(); 
      __std__vector_RooAbsLValuep__dict(); 
      __std__vector_std__vector_double_p__dict(); 
      __std__vector_RooNormSetCache__dict(); 
      __std__vector_std__pair_double_TString_s__dict(); 
      __std__vector_TString__dict(); 
      __std__vector_std__map_int_int_s__dict(); 
      __std__vector_RooAbsRealLValuep__dict(); 
      __std__vector_bool__dict(); 
      __std__vector_RooArgSetp__dict(); 
      __std__vector_std__vector_int_s__dict(); 
      __std__vector_std__pair_std__basic_string_char__int_s__dict(); 
      __std__vector_RooAbsArgp__dict(); 
      __std__vector_RooAbsCacheElementp__dict(); 
      __std__vector_RooMsgService__StreamConfig__dict(); 
      __std__vector_TVirtualArrayp__dict(); 
      __std__vector_ROOT__TSchemaHelper__dict(); 
      __std__pair_std__basic_string_char__RooAbsDatap__dict(); 
      __RooCubicSplineKnot__BoundaryConditions_dict(); 
      __RooCubicSplineKnot__S_edge_dict(); 
      ::Reflex::Type t0 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_668, type_668, type_27699, type_667);      ::Reflex::FunctionBuilder(t0, Reflex::Literal("MassFitUtils::ObtainSignal"), function_5377, 0, Reflex::Literal("filesDir;sig;PIDcut2;Pcut_down2;Pcut_up2;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;time_down;time_up;PT_down;PT_up;nTr_down;nTr_up;mVar;mDVar;tVar;terrVar;tagVar;tagOmegaVar;idVar;mProbVar;mode;reweight;veto;work;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t1 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t1, Reflex::Literal("MassFitUtils::ObtainLbLcPi"), function_5378, 0, Reflex::Literal("filesDir;sig;PIDcut;Pcut_down;Pcut_up;PT_down;PT_up;nTr_down;nTr_up;mVar;mDVar;mode;workspace;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t2 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_141, type_141, type_141, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_27699, type_27874, type_667, type_667);      ::Reflex::FunctionBuilder(t2, Reflex::Literal("MassFitUtils::getSpecBkg4kfactor"), function_5379, 0, Reflex::Literal("filesDir;sig;sigtree;PIDcut;PIDmisscut;pPIDcut;Pcut_down;Pcut_up;BDTGCut;Dmass_down;Dmass_up;mVar;hypo;workspace;ffile;mass_win=true;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t3 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_6056, type_668, type_6056);      ::Reflex::FunctionBuilder(t3, Reflex::Literal("MassFitUtils::ObtainBDPi"), function_5380, 0, Reflex::Literal("filesDir;sigBs;PIDcut;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Bmass_down;Bmass_up;Dmass_down;Dmass_up;mVar;mProbVar;mode;MC;hypo"), ::Reflex::PUBLIC);
      ::Reflex::Type t4 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_668, type_27699, type_667);      ::Reflex::FunctionBuilder(t4, Reflex::Literal("MassFitUtils::ObtainData"), function_5381, 0, Reflex::Literal("fileDir;sig;PIDcut;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;time_down;time_up;mVar;mDVar;tVar;terrVar;tagVar;tagOmegaVar;idVar;mProbVar;mode;tagtool;workspace;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t5 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_6056, type_6056, type_27699, type_668, type_667);      ::Reflex::FunctionBuilder(t5, Reflex::Literal("MassFitUtils::ObtainMissForBsDsK"), function_5382, 0, Reflex::Literal("filesDir;sig;PIDmisscut;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;PT_down;PT_up;nTr_down;nTr_up;mVar;mDVar;mProbVar;mode;workspace;mistag;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t6 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_6056, type_6056, type_27699, type_668, type_667);      ::Reflex::FunctionBuilder(t6, Reflex::Literal("MassFitUtils::ObtainMissForBsDsPi"), function_5383, 0, Reflex::Literal("filesDir;sig;namehypo;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;PT_down;PT_up;nTr_down;nTr_up;mVar;mDVar;mProbVar;mode;workspace;mistag;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t7 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_694, type_694, type_694, type_694, type_27699, type_668, type_667);      ::Reflex::FunctionBuilder(t7, Reflex::Literal("MassFitUtils::CreatePdfSpecBackground"), function_5384, 0, Reflex::Literal("filesDirMU;sigMU;filesDirMD;sigMD;mVar;mDVar;Bmass_down;Bmass_up;Dmass_down;Dmass_up;workspace;mistag;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t8 = ::Reflex::FunctionTypeBuilder(type_1511, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_6056, type_6056);      ::Reflex::FunctionBuilder(t8, Reflex::Literal("MassFitUtils::ExpectedYield"), function_5385, 0, Reflex::Literal("filesDir;sigBs;sigBd;sigPID_lab4;PIDcut_lab4;sigPID_lab51;PIDcut_lab51;sigPID_lab52;PIDcut_lab52;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;mVar;mProbVar;mode;mode2"), ::Reflex::PUBLIC);
      ::Reflex::Type t9 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_141, type_141, type_141, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_6056, type_6056, type_27699, type_668, type_668, type_667);      ::Reflex::FunctionBuilder(t9, Reflex::Literal("MassFitUtils::ObtainSpecBack"), function_5386, 0, Reflex::Literal("filesDir;sig;sigtree;PIDcut;PIDmisscut;pPIDcut;Pcut_down;Pcut_up;BDTG_down;BDTG_up;Dmass_down;Dmass_up;Bmass_down;Bmass_up;mVar;mDVar;mProbVar;hypo;workspace;save;mistag;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t10 = ::Reflex::FunctionTypeBuilder(type_27676, type_4128, type_27670, type_4128, type_667, type_694, type_694);      ::Reflex::FunctionBuilder(t10, Reflex::Literal("PTResModels::getPTResolutionModel"), function_6749, 0, Reflex::Literal("modelName;time;prefix=\"Sig\";debug=false;scalingfactor=1.0e+0;biasonmean=0.0"), ::Reflex::PUBLIC);
      ::Reflex::Type t11 = ::Reflex::FunctionTypeBuilder(type_27676, type_27670, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_667);      ::Reflex::FunctionBuilder(t11, Reflex::Literal("PTResModels::tripleGausResolutionModel"), function_6750, 0, Reflex::Literal("time;scalingfactor;biasonmean;sigma1;sigma2;sigma3;frac1;frac2;frac3;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t12 = ::Reflex::FunctionTypeBuilder(type_27676, type_27670, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_667);      ::Reflex::FunctionBuilder(t12, Reflex::Literal("PTResModels::tripleGausResolutionModel"), function_6751, 0, Reflex::Literal("time;scalingfactor;biasonmean;sigma1;sigma2;sigma3;frac1;frac2;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t13 = ::Reflex::FunctionTypeBuilder(type_27676, type_27670, type_667, type_667, type_667, type_667, type_694, type_694);      ::Reflex::FunctionBuilder(t13, Reflex::Literal("PTResModels::tripleGausResolutionModel"), function_6752, 0, Reflex::Literal("time;fixparameters=true;fixfractions=true;extended=true;debug=false;scalingfactor=1.0e+0;biasonmean=0.0"), ::Reflex::PUBLIC);
      ::Reflex::Type t14 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27660, type_27699, type_28297, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27917, type_27670, type_27670, type_27670, type_6056, type_27670, type_667);      ::Reflex::FunctionBuilder(t14, Reflex::Literal("Bs2Dsh2011TDAnaModels::build_Bs2DsK_BKG_MDFitter"), function_7987, 0, Reflex::Literal("mass;massDs;work;pdf_Bd2DsK;nCombBkgEvts;nBsLb2DsDsstPPiRhoEvts;nBs2DsDssKKstEvts;nBd2DKEvts;nLb2LcKEvts;g1_f1;g2_f1;g2_f2;g3_f1;g4_f1;g4_f2;g5_f1;pdf_SignalDs;cBVar;cDVar;fracDsComb;samplemode;lumRatio;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t15 = ::Reflex::FunctionTypeBuilder(type_28298, type_27699, type_6056, type_6056, type_27670, type_27917, type_667);      ::Reflex::FunctionBuilder(t15, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForMDFitter"), function_7988, 0, Reflex::Literal("work;mode;pol;lumRatio;pdf_Ds=0l;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t16 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_28122, type_28122, type_694, type_694, type_28122, type_694, type_694, type_694, type_6056, type_6056, type_667);      ::Reflex::FunctionBuilder(t16, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildBdDsX"), function_7989, 0, Reflex::Literal("obs;meanVar;sigma1Var;alpha1;n1;sigma2Var;alpha2;n2;frac;samplemode;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t17 = ::Reflex::FunctionTypeBuilder(type_27917, type_27670, type_27699, type_28297, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_6056, type_6056, type_667, type_667);      ::Reflex::FunctionBuilder(t17, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildBsDsK_sim"), function_7990, 0, Reflex::Literal("mass;work;pdf;nCombBkgEvts;nBs2DsDsstPiRhoEvts;nBs2DsDssKKstEvts;nLb2DsDsstpEvts;nBd2DKEvts;nLb2LcKEvts;g1_f1;g1_f2;g1_f3;g2_f1;g2_f2;g2_f3;g3_f1;sample;mode;toys;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t18 = ::Reflex::FunctionTypeBuilder(type_28298, type_27699, type_6056, type_6056, type_27670, type_27917, type_27917, type_667);      ::Reflex::FunctionBuilder(t18, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainRooProdPdfForFullFitter"), function_7991, 0, Reflex::Literal("work;mode;pol;lumRatio;pdf_Time;pdf_Ds=0l;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t19 = ::Reflex::FunctionTypeBuilder(type_28299, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t19, Reflex::Literal("Bs2Dsh2011TDAnaModels::GetRooKeysPdfFromWorkspace"), function_7992, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t20 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t20, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleCBPDF_sim"), function_7993, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;nEvents;prefix;bName;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t21 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27670, type_27670, type_27670, type_27670, type_28122, type_4128, type_4128, type_667, type_667);      ::Reflex::FunctionBuilder(t21, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim"), function_7994, 0, Reflex::Literal("obs;mean;sigma1;sigma2;frac;nEvents;prefix;bName;extendend;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t22 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27670, type_27670, type_27670, type_27670, type_27670, type_4128, type_4128, type_667, type_667);      ::Reflex::FunctionBuilder(t22, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleGEPDF_sim"), function_7995, 0, Reflex::Literal("obs;mean;sigma1;sigma2;frac;nEvents;prefix;bName;extendend;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t23 = ::Reflex::FunctionTypeBuilder(type_28300, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t23, Reflex::Literal("Bs2Dsh2011TDAnaModels::GetRooHistPdfFromWorkspace"), function_7996, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t24 = ::Reflex::FunctionTypeBuilder(type_667, type_27917, type_667);      ::Reflex::FunctionBuilder(t24, Reflex::Literal("Bs2Dsh2011TDAnaModels::CheckPDF"), function_7997, 0, Reflex::Literal("pdf;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t25 = ::Reflex::FunctionTypeBuilder(type_27917, type_27670, type_27699, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27917, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_6056, type_27670, type_667, type_667);      ::Reflex::FunctionBuilder(t25, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildBsDsPi_sim"), function_7998, 0, Reflex::Literal("mass;work;nCombBkgEvts;nBd2DPiEvts;nBs2DsDsstPiRhoEvts;g1_f1;g1_f2;nLb2LcPiEvts;nBdDsPi;pdf_BdDsPi;nBdDsstPi;nBd2DsRhoEvts;nBd2DstPiEvts;nBs2DsKEvts;cB1Var;cB2Var;fracComb;samplemode;lumRatio;toys;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t26 = ::Reflex::FunctionTypeBuilder(type_27917, type_27699, type_6056, type_6056, type_27670, type_667, type_667);      ::Reflex::FunctionBuilder(t26, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainPIDKShape"), function_7999, 0, Reflex::Literal("work;mode;pol;lumRatio;DsMode=false;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t27 = ::Reflex::FunctionTypeBuilder(type_28297, type_27660, type_27670, type_27670, type_27670, type_6056, type_667);      ::Reflex::FunctionBuilder(t27, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainComboBs"), function_8000, 0, Reflex::Literal("mass;cBVar;cBVar2;frac;Mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t28 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27660, type_27699, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27917, type_27670, type_27670, type_27670, type_27670, type_27917, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_6056, type_27670, type_667);      ::Reflex::FunctionBuilder(t28, Reflex::Literal("Bs2Dsh2011TDAnaModels::build_Bs2DsPi_BKG_MDFitter"), function_8001, 0, Reflex::Literal("mass;massDs;work;nCombBkgEvts;nBd2DPiEvts;nBs2DsDsstPiRhoEvts;g1_f1;g1_f2;nLb2LcPiEvts;nBdDsPi;pdf_BdDsPi;nBdDsstPi;nBd2DRhoEvts;nBd2DstPiEvts;nBs2DsKEvts;pdf_SignalDs;cBVar;cB2Var;fracBsComb;cDVar;fracDsComb;fracPIDComb;samplemode;lumRatio;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t29 = ::Reflex::FunctionTypeBuilder(type_667, type_22885, type_667);      ::Reflex::FunctionBuilder(t29, Reflex::Literal("Bs2Dsh2011TDAnaModels::CheckVar"), function_8002, 0, Reflex::Literal("var;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t30 = ::Reflex::FunctionTypeBuilder(type_27917, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t30, Reflex::Literal("Bs2Dsh2011TDAnaModels::GetRooBinned1DFromWorkspace"), function_8003, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t31 = ::Reflex::FunctionTypeBuilder(type_27917, type_27699, type_6056, type_667, type_27670, type_667);      ::Reflex::FunctionBuilder(t31, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainMassShape"), function_8004, 0, Reflex::Literal("work;mode;dsMass;lumRatio;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t32 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27670, type_27670, type_694, type_694, type_27670, type_694, type_694, type_694, type_27670, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t32, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_fix"), function_8005, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;nEvents;prefix;bName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t33 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t33, Reflex::Literal("Bs2Dsh2011TDAnaModels::buildDoubleCBEPDF_sim"), function_8006, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;nEvents;prefix;bName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t34 = ::Reflex::FunctionTypeBuilder(type_28297, type_27660, type_27670, type_27670, type_27917, type_6056, type_667);      ::Reflex::FunctionBuilder(t34, Reflex::Literal("Bs2Dsh2011TDAnaModels::ObtainComboDs"), function_8007, 0, Reflex::Literal("massDs;cDVar;fracDsComb;pdf_SignalDs;Mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t35 = ::Reflex::FunctionTypeBuilder(type_28297, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t35, Reflex::Literal("Bs2Dsh2011TDAnaModels::GetRooAddPdfFromWorkspace"), function_8008, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t36 = ::Reflex::FunctionTypeBuilder(type_27917, type_27919, type_22885, type_6056, type_667);      ::Reflex::FunctionBuilder(t36, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsKK"), function_9456, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t37 = ::Reflex::FunctionTypeBuilder(type_27917, type_27919, type_22885, type_6056, type_667);      ::Reflex::FunctionBuilder(t37, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsKP"), function_9457, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t38 = ::Reflex::FunctionTypeBuilder(type_1511, type_6056, type_27919, type_27919, type_22885, type_22885, type_22885, type_22885, type_1309, type_1309, type_1309, type_1309, type_6056, type_6056, type_6056, type_6056, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t38, Reflex::Literal("WeightingUtils::PlotWeightingSample"), function_9458, 0, Reflex::Literal("nm;dataCalib;dataCalibRW;Var1;Var2;Var3;PID;bin1;bin2;bin3;binPIDK;label1;label2;label3;dir;ext;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t39 = ::Reflex::FunctionTypeBuilder(type_1511, type_6056, type_27919, type_27919, type_22885, type_22885, type_22885, type_1309, type_1309, type_1309, type_6056, type_6056, type_6056, type_6056, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t39, Reflex::Literal("WeightingUtils::PlotWeightingSample"), function_9459, 0, Reflex::Literal("nm;dataCalib;dataCalibRW;Var1;Var2;PID;bin1;bin2;bin3;label1;label2;label3;dir;ext;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t40 = ::Reflex::FunctionTypeBuilder(type_2743, type_6056, type_667);      ::Reflex::FunctionBuilder(t40, Reflex::Literal("WeightingUtils::CheckWeightLabel"), function_9460, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t41 = ::Reflex::FunctionTypeBuilder(type_28477, type_27919, type_22885, type_22885, type_1309, type_1309, type_6056, type_667);      ::Reflex::FunctionBuilder(t41, Reflex::Literal("WeightingUtils::Get2DHist"), function_9461, 0, Reflex::Literal("data;Var1;Var2;bin1;bin2;histName1;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t42 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_6056, type_1309, type_1309, type_1309, type_6056, type_6056, type_6056, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t42, Reflex::Literal("WeightingUtils::ObtainHistRatio"), function_9462, 0, Reflex::Literal("filesDir;sig;fileCalibUp;workCalibUp;bin1;bin2;bin3;nameVar1;nameVar2;nameVar3;Var1_down;Var1_up;Var2_down;Var2_up;Var3_down;Var3_up;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t43 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_6056, type_1309, type_1309, type_6056, type_6056, type_694, type_694, type_694, type_694, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t43, Reflex::Literal("WeightingUtils::ObtainHistRatio"), function_9463, 0, Reflex::Literal("filesDir;sig;fileCalibUp;workCalibUp;bin1;bin2;nameVar1;nameVar2;Var1_down;Var1_up;Var2_down;Var2_up;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t44 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_1309, type_1309, type_1309, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t44, Reflex::Literal("WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample"), function_9464, 0, Reflex::Literal("fileCalib;workCalib;namePID;nameVar1;nameVar2;nameVar3;PID_down;PID_up;Var1_down;Var1_up;Var2_down;Var2_up;Var3_down;Var3_up;bin1;bin2;bin3;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t45 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_6056, type_6056, type_694, type_694, type_694, type_694, type_694, type_694, type_1309, type_1309, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t45, Reflex::Literal("WeightingUtils::ObtainPIDShapeFromCalibSampleOneSample"), function_9465, 0, Reflex::Literal("fileCalib;workCalib;namePID;nameVar1;nameVar2;PID_down;PID_up;Var1_down;Var1_up;Var2_down;Var2_up;bin1;bin2;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t46 = ::Reflex::FunctionTypeBuilder(type_27919, type_6056, type_6056, type_22885, type_22885, type_22885, type_667);      ::Reflex::FunctionBuilder(t46, Reflex::Literal("WeightingUtils::GetDataCalibSample"), function_9466, 0, Reflex::Literal("fileName;workName;Var1;Var2;Var3;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t47 = ::Reflex::FunctionTypeBuilder(type_27919, type_6056, type_6056, type_22885, type_22885, type_667);      ::Reflex::FunctionBuilder(t47, Reflex::Literal("WeightingUtils::GetDataCalibSample"), function_9467, 0, Reflex::Literal("fileName;workName;Var1;Var2;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t48 = ::Reflex::FunctionTypeBuilder(type_27917, type_27919, type_22885, type_6056, type_667);      ::Reflex::FunctionBuilder(t48, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsPiK"), function_9468, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t49 = ::Reflex::FunctionTypeBuilder(type_27917, type_27919, type_22885, type_6056, type_667);      ::Reflex::FunctionBuilder(t49, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsPiPi"), function_9469, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t50 = ::Reflex::FunctionTypeBuilder(type_2743, type_6056, type_6056, type_667);      ::Reflex::FunctionBuilder(t50, Reflex::Literal("WeightingUtils::CheckTreeLabel"), function_9470, 0, Reflex::Literal("fileCalib;check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t51 = ::Reflex::FunctionTypeBuilder(type_2743, type_6056, type_667);      ::Reflex::FunctionBuilder(t51, Reflex::Literal("WeightingUtils::CheckTreeLabel"), function_9471, 0, Reflex::Literal("fileCalib;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t52 = ::Reflex::FunctionTypeBuilder(type_27917, type_27919, type_22885, type_6056, type_667);      ::Reflex::FunctionBuilder(t52, Reflex::Literal("WeightingUtils::FitPDFShapeForPIDBsDsKPi"), function_9472, 0, Reflex::Literal("data;Var;name;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t53 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_1309, type_1309, type_1309, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t53, Reflex::Literal("WeightingUtils::ObtainPIDShapeFromCalibSample"), function_9473, 0, Reflex::Literal("filesDir;sig;fileCalibUp;workCalibUp;PIDVar1;nameVar1;nameVar2;nameVar3;PID_down;PID_up;Var1_down;Var1_up;Var2_down;Var2_up;Var3_down;Var3_up;bin1;bin2;bin3;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t54 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_2743, type_694, type_694, type_694, type_694, type_694, type_694, type_1309, type_1309, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t54, Reflex::Literal("WeightingUtils::ObtainPIDShapeFromCalibSample"), function_9474, 0, Reflex::Literal("filesDir;sig;fileCalibUp;workCalibUp;PIDVar1;nameVar1;nameVar2;PID_down;PID_up;Var1_down;Var1_up;Var2_down;Var2_up;bin1;bin2;type;work;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t55 = ::Reflex::FunctionTypeBuilder(type_28478, type_27919, type_22885, type_22885, type_22885, type_28478, type_667);      ::Reflex::FunctionBuilder(t55, Reflex::Literal("WeightingUtils::Get3DHist"), function_9475, 0, Reflex::Literal("data;Var1;Var2;Var3;hist;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t56 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_1309, type_1309, type_1309, type_6056, type_6056, type_6056, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_27699, type_27699, type_667);      ::Reflex::FunctionBuilder(t56, Reflex::Literal("WeightingUtils::ObtainHistRatioOneSample"), function_9476, 0, Reflex::Literal("fileCalib;workCalib;bin1;bin2;bin3;nameVar1;nameVar2;nameVar3;Var1_down;Var1_up;Var2_down;Var2_up;Var3_down;Var3_up;type;work;workL;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t57 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_1309, type_1309, type_6056, type_6056, type_694, type_694, type_694, type_694, type_6056, type_27699, type_27699, type_667);      ::Reflex::FunctionBuilder(t57, Reflex::Literal("WeightingUtils::ObtainHistRatioOneSample"), function_9477, 0, Reflex::Literal("fileCalib;workCalib;bin1;bin2;nameVar1;nameVar2;Var1_down;Var1_up;Var2_down;Var2_up;type;work;workL;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t58 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27676, type_28025, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t58, Reflex::Literal("GeneralModels::buildRooBDecayPDF"), function_9977, 0, Reflex::Literal("time;Gamma;deltaGamma;deltaM;cosh;sinh;cos;sin;resModel;acceptance;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t59 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27676, type_28025, type_27660, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t59, Reflex::Literal("GeneralModels::buildRooBDecayEPDF"), function_9978, 0, Reflex::Literal("time;Gamma;deltaGamma;deltaM;cosh;sinh;cos;sin;resModel;acceptance;nEvents;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t60 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_27670, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t60, Reflex::Literal("GeneralModels::buildDoubleCBEPDF"), function_9979, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;nEvents;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t61 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27670, type_27676, type_28025, type_27670, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t61, Reflex::Literal("GeneralModels::buildRooDecayEPDF"), function_9980, 0, Reflex::Literal("time;Gamma;resModel;acceptance;nEvents;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t62 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27670, type_27676, type_28025, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t62, Reflex::Literal("GeneralModels::buildRooDecayPDF"), function_9981, 0, Reflex::Literal("time;Gamma;resModel;acceptance;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t63 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_694, type_694, type_27670, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t63, Reflex::Literal("GeneralModels::buildGaussianEPDF"), function_9982, 0, Reflex::Literal("obs;mean;sigma;nEvents;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t64 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t64, Reflex::Literal("GeneralModels::buildDoubleCBPDF"), function_9983, 0, Reflex::Literal("obs;mean;sigma1;alpha1;n1;sigma2;alpha2;n2;frac;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t65 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_28549, type_13032, type_694, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t65, Reflex::Literal("GeneralModels::buildKeysPDF"), function_9984, 0, Reflex::Literal("obs;dataset;mirror=MirrorBoth;rho=1.0e+0;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t66 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_28025, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27917, type_27676, type_28025, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t66, Reflex::Literal("GeneralModels::buildRooBDecayPDFWithPEDTE"), function_9985, 0, Reflex::Literal("time;timeerr;Gamma;deltaGamma;deltaM;cosh;sinh;cos;sin;timeerrPdf;resModel;acceptance;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t67 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27660, type_27917, type_27676, type_28025, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t67, Reflex::Literal("GeneralModels::buildRooBDecayPDFWithPEDTE"), function_9986, 0, Reflex::Literal("time;timeerr;Gamma;deltaGamma;deltaM;cosh;sinh;cos;sin;timeerrPdf;resModel;acceptance;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t68 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_694, type_694, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t68, Reflex::Literal("GeneralModels::buildGaussianPDF"), function_9987, 0, Reflex::Literal("obs;mean;sigma;prefix=\"Sig\";bName=\"B_{d}\";debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t69 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_28255, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_667);      ::Reflex::FunctionBuilder(t69, Reflex::Literal("Bs2DshModels::buildBsBackgroundEPDFInMass"), function_12529, 0, Reflex::Literal("m_obs_mass;filesDir;nCombBkgEvts;nBd2DPiEvts;nBs2DsRhoEvts;nBs2DsstPiEvts;nBs2DsXEvts;nLb2LcPiEvts;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t70 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_28255, type_27670, type_27670, type_27670, type_27670, type_27670, type_667);      ::Reflex::FunctionBuilder(t70, Reflex::Literal("Bd2DhModels::buildBdBackgroundEPDFInMass"), function_13929, 0, Reflex::Literal("m_obs_mass;filesDir;nCombBkgEvts;nBd2DKEvts;nBd2DRhoEvts;nBd2DstPiEvts;nBd2DXEvts;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t71 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27670, type_27676, type_28025, type_667);      ::Reflex::FunctionBuilder(t71, Reflex::Literal("Bd2DhModels::buildBdBackgroundNoTagEPDFInTime"), function_13930, 0, Reflex::Literal("time;Gamma;nCombBkgEvts;CombBkgPTPdf_a;CombBkgPTPdf_f;CombBkgPTPdf_alpha;CombBkgPTPdf_beta;nBd2DKEvts;resModel;acceptance;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t72 = ::Reflex::FunctionTypeBuilder(type_27917, type_27660, type_28255, type_194c, type_194c, type_194c, type_194c, type_667);      ::Reflex::FunctionBuilder(t72, Reflex::Literal("Bd2DhModels::buildBdBackgroundPDFInMass"), function_13931, 0, Reflex::Literal("m_obs_mass;filesDir;fracCombBkgEvts;fracBd2DKEvts;fracBd2DstPiEvts;fracBd2DXEvts;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t73 = ::Reflex::FunctionTypeBuilder(type_28508, type_31777, type_6056, type_141, type_667);      ::Reflex::FunctionBuilder(t73, Reflex::Literal("GeneralUtils::ReadPIDHist"), function_14381, 0, Reflex::Literal("FilePID;nameHist;sample;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t74 = ::Reflex::FunctionTypeBuilder(type_28300, type_27919, type_22885, type_6056, type_1309, type_667);      ::Reflex::FunctionBuilder(t74, Reflex::Literal("GeneralUtils::CreateHistPDF"), function_14382, 0, Reflex::Literal("dataSet;obs;name;bin;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t75 = ::Reflex::FunctionTypeBuilder(type_2743, type_6056, type_667);      ::Reflex::FunctionBuilder(t75, Reflex::Literal("GeneralUtils::GetLabel"), function_14383, 0, Reflex::Literal("mode;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t76 = ::Reflex::FunctionTypeBuilder(type_2743, type_2743, type_667);      ::Reflex::FunctionBuilder(t76, Reflex::Literal("GeneralUtils::ReadOneMode"), function_14384, 0, Reflex::Literal("path;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t77 = ::Reflex::FunctionTypeBuilder(type_1511, type_27919, type_22885, type_6056, type_6056, type_667);      ::Reflex::FunctionBuilder(t77, Reflex::Literal("GeneralUtils::SaveDataSet"), function_14385, 0, Reflex::Literal("dataSet;mass;sample;mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t78 = ::Reflex::FunctionTypeBuilder(type_1511, type_28477, type_6056, type_28477, type_6056, type_28477, type_6056, type_6056);      ::Reflex::FunctionBuilder(t78, Reflex::Literal("GeneralUtils::Save2DComparison"), function_14386, 0, Reflex::Literal("hist1;l1;hist2;l2;hist3;l3;ext"), ::Reflex::PUBLIC);
      ::Reflex::Type t79 = ::Reflex::FunctionTypeBuilder(type_28508, type_28508, type_2317, type_28508, type_2317, type_667);      ::Reflex::FunctionBuilder(t79, Reflex::Literal("GeneralUtils::AddHist"), function_14387, 0, Reflex::Literal("hist1;w1;hist2;w2;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t80 = ::Reflex::FunctionTypeBuilder(type_1511, type_27817, type_28300, type_22885, type_6056, type_6056, type_667);      ::Reflex::FunctionBuilder(t80, Reflex::Literal("GeneralUtils::SaveTemplateHist"), function_14388, 0, Reflex::Literal("dataSet;pdf;mass;sample;mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t81 = ::Reflex::FunctionTypeBuilder(type_1511, type_28477, type_6056);      ::Reflex::FunctionBuilder(t81, Reflex::Literal("GeneralUtils::Save2DHist"), function_14389, 0, Reflex::Literal("hist;ext"), ::Reflex::PUBLIC);
      ::Reflex::Type t82 = ::Reflex::FunctionTypeBuilder(type_1511, type_6056, type_31777, type_6056, type_667);      ::Reflex::FunctionBuilder(t82, Reflex::Literal("GeneralUtils::ReadOneName"), function_14390, 0, Reflex::Literal("filesDir;FileName;sig;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t83 = ::Reflex::FunctionTypeBuilder(type_28478, type_31777, type_6056, type_141, type_667);      ::Reflex::FunctionBuilder(t83, Reflex::Literal("GeneralUtils::Read3DHist"), function_14391, 0, Reflex::Literal("FilePID;nameHist;sample;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t84 = ::Reflex::FunctionTypeBuilder(type_27917, type_27919, type_22885, type_6056, type_1309, type_667);      ::Reflex::FunctionBuilder(t84, Reflex::Literal("GeneralUtils::CreateBinnedPDF"), function_14392, 0, Reflex::Literal("dataSet;obs;name;bin;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t85 = ::Reflex::FunctionTypeBuilder(type_8017, type_31777, type_141, type_667);      ::Reflex::FunctionBuilder(t85, Reflex::Literal("GeneralUtils::ReadTreeData"), function_14393, 0, Reflex::Literal("FileName;sample;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t86 = ::Reflex::FunctionTypeBuilder(type_22885, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t86, Reflex::Literal("GeneralUtils::GetObservable"), function_14394, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t87 = ::Reflex::FunctionTypeBuilder(type_1511, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t87, Reflex::Literal("GeneralUtils::SaveWorkspace"), function_14395, 0, Reflex::Literal("work;name;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t88 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_667);      ::Reflex::FunctionBuilder(t88, Reflex::Literal("GeneralUtils::LoadWorkspace"), function_14396, 0, Reflex::Literal("fileName;workName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t89 = ::Reflex::FunctionTypeBuilder(type_1511, type_27919, type_28299, type_22885, type_6056, type_6056, type_667);      ::Reflex::FunctionBuilder(t89, Reflex::Literal("GeneralUtils::SaveTemplate"), function_14397, 0, Reflex::Literal("dataSet;pdf;mass;sample;mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t90 = ::Reflex::FunctionTypeBuilder(type_2835, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t90, Reflex::Literal("GeneralUtils::GetRooArgSet"), function_14398, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t91 = ::Reflex::FunctionTypeBuilder(type_8017, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t91, Reflex::Literal("GeneralUtils::ReadTreeMC"), function_14399, 0, Reflex::Literal("fileName;treeName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t92 = ::Reflex::FunctionTypeBuilder(type_28299, type_27919, type_22885, type_6056, type_6056, type_668, type_667);      ::Reflex::FunctionBuilder(t92, Reflex::Literal("GeneralUtils::CreatePDFMC"), function_14400, 0, Reflex::Literal("dataSetMC;massMC;sample;mode;mistag;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t93 = ::Reflex::FunctionTypeBuilder(type_27925, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t93, Reflex::Literal("GeneralUtils::GetCategory"), function_14401, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t94 = ::Reflex::FunctionTypeBuilder(type_2743, type_6056, type_667);      ::Reflex::FunctionBuilder(t94, Reflex::Literal("GeneralUtils::CheckDMode"), function_14402, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t95 = ::Reflex::FunctionTypeBuilder(type_2743, type_31778, type_667);      ::Reflex::FunctionBuilder(t95, Reflex::Literal("GeneralUtils::CheckDMode"), function_14403, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t96 = ::Reflex::FunctionTypeBuilder(type_28477, type_31777, type_6056, type_141, type_667);      ::Reflex::FunctionBuilder(t96, Reflex::Literal("GeneralUtils::Read2DHist"), function_14404, 0, Reflex::Literal("FilePID;nameHist;sample;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t97 = ::Reflex::FunctionTypeBuilder(type_2743, type_6056, type_667);      ::Reflex::FunctionBuilder(t97, Reflex::Literal("GeneralUtils::CheckBDTGBin"), function_14405, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t98 = ::Reflex::FunctionTypeBuilder(type_27817, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t98, Reflex::Literal("GeneralUtils::GetDataHist"), function_14406, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t99 = ::Reflex::FunctionTypeBuilder(type_2743, type_6056, type_667);      ::Reflex::FunctionBuilder(t99, Reflex::Literal("GeneralUtils::CheckPolarity"), function_14407, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t100 = ::Reflex::FunctionTypeBuilder(type_2743, type_31778, type_667);      ::Reflex::FunctionBuilder(t100, Reflex::Literal("GeneralUtils::CheckPolarity"), function_14408, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t101 = ::Reflex::FunctionTypeBuilder(type_27919, type_27699, type_6056, type_667);      ::Reflex::FunctionBuilder(t101, Reflex::Literal("GeneralUtils::GetDataSet"), function_14409, 0, Reflex::Literal("work;obs;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t102 = ::Reflex::FunctionTypeBuilder(type_2743, type_6056, type_667);      ::Reflex::FunctionBuilder(t102, Reflex::Literal("GeneralUtils::CheckKKPiMode"), function_14410, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t103 = ::Reflex::FunctionTypeBuilder(type_2743, type_31778, type_667);      ::Reflex::FunctionBuilder(t103, Reflex::Literal("GeneralUtils::CheckKKPiMode"), function_14411, 0, Reflex::Literal("check;debug"), ::Reflex::PUBLIC);
      ::Reflex::Type t104 = ::Reflex::FunctionTypeBuilder(type_1511, type_31777, type_31777, type_667, type_667);      ::Reflex::FunctionBuilder(t104, Reflex::Literal("GeneralUtils::ReadMode"), function_14412, 0, Reflex::Literal("MCFileName;mode;iskfactor=false;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t105 = ::Reflex::FunctionTypeBuilder(type_8017, type_8017, type_28552, type_6056, type_6056, type_667);      ::Reflex::FunctionBuilder(t105, Reflex::Literal("GeneralUtils::TreeCut"), function_14413, 0, Reflex::Literal("tree;cut;sample;mode;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t106 = ::Reflex::FunctionTypeBuilder(type_1511, type_28478, type_6056);      ::Reflex::FunctionBuilder(t106, Reflex::Literal("GeneralUtils::Save3DHist"), function_14414, 0, Reflex::Literal("hist;ext"), ::Reflex::PUBLIC);
      ::Reflex::Type t107 = ::Reflex::FunctionTypeBuilder(type_1511, type_22352, type_27917, type_22885, type_4128, type_4128, type_4128, type_667);      ::Reflex::FunctionBuilder(t107, Reflex::Literal("GeneralUtils::saveDataTemplateToFile"), function_14415, 0, Reflex::Literal("data;pdf;observable;mode;extension=\"pdf\";suffix=0l;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t108 = ::Reflex::FunctionTypeBuilder(type_27919, type_8017, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_667);      ::Reflex::FunctionBuilder(t108, Reflex::Literal("SFitUtils::CopyDataForToys"), function_15173, 0, Reflex::Literal("tree;mVar;mDVar;PIDKVar;tVar;terrVar;tagVar;tagOmegaVar;idVar;trueIDVar;dataName;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t109 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_694, type_694, type_6056, type_6056, type_6056, type_6056, type_6056, type_667, type_667);      ::Reflex::FunctionBuilder(t109, Reflex::Literal("SFitUtils::ReadDataFromSWeights2"), function_15174, 0, Reflex::Literal("part;pathFile;treeName;time_down;time_up;tVar;terrVar;tagName;tagOmegaVar;idVar;weighted;debug=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t110 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_6056, type_694, type_694, type_6056, type_6056, type_6056, type_6056, type_6056, type_667, type_667, type_667);      ::Reflex::FunctionBuilder(t110, Reflex::Literal("SFitUtils::ReadDataFromSWeights"), function_15175, 0, Reflex::Literal("part;pathFile;treeName;time_down;time_up;tVar;terrVar;tagName;tagOmegaVar;idVar;weighted;debug=false;applykfactor=false"), ::Reflex::PUBLIC);
      ::Reflex::Type t111 = ::Reflex::FunctionTypeBuilder(type_27699, type_6056, type_6056, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_694, type_6056, type_6056, type_6056, type_6056, type_6056, type_6056, type_27699, type_667);      ::Reflex::FunctionBuilder(t111, Reflex::Literal("SFitUtils::ReadLbLcPiFromSWeights"), function_15176, 0, Reflex::Literal("pathFile;treeName;P_down;P_up;PT_down;PT_up;nTr_down;nTr_up;PID_down;PID_up;mVar;mDVar;pVar;ptVar;nTrVar;pidVar;workspace;debug=false"), ::Reflex::PUBLIC);
    }
    ~Dictionaries() {
      type_12.Unload(); // class TagEfficiencyWeight 
      type_130.Unload(); // class RooBinned1DQuinticBase<RooAbsReal> 
      type_259.Unload(); // class DecRateCoeff 
      type_266.Unload(); // class IfThreeWayPdf 
      type_286.Unload(); // class Inverse 
      type_324.Unload(); // class RooEffConvGenContext 
      type_327.Unload(); // class BdPTAcceptance 
      type_449.Unload(); // class RooBinned2DBicubicBase<RooAbsPdf> 
      type_450.Unload(); // class RooBinned2DBicubicBase<RooAbsReal> 
      type_485.Unload(); // class IfThreeWayCatPdf 
      type_515.Unload(); // class NonOscTaggingPdf 
      type_577.Unload(); // class DTAcceptanceLHCbNote2007041 
      type_664.Unload(); // class RooEffResModel 
      type_670.Unload(); // class RooAbsEffResModel 
      type_723.Unload(); // class IfThreeWayCat 
      type_855.Unload(); // class RooCubicSplineKnot 
      type_995.Unload(); // class RooBinnedPdf 
      type_1073.Unload(); // class MistagDistribution 
      type_1305.Unload(); // class SquaredSum 
      type_1382.Unload(); // class RooGenSmearIntegrandBinding 
      type_1438.Unload(); // class RooGaussEfficiencyModel 
      type_1473.Unload(); // class RooGeneralisedSmearingBase<RooAbsPdf> 
      type_1576.Unload(); // class RooBinned1DQuinticBase<RooAbsPdf> 
      type_1630.Unload(); // class RooEffHistProd 
      type_1672.Unload(); // class RooAbsGaussModelEfficiency 
      type_1675.Unload(); // class RooGeneralisedSmearingBase<RooAbsReal> 
      type_1679.Unload(); // class TagEfficiencyWeightNoCat 
      type_1744.Unload(); // class FinalStateChargePdf 
      type_1831.Unload(); // class TaggingCat 
      type_1880.Unload(); // class RangeAcceptance 
      type_1909.Unload(); // class PowLawAcceptance 
      type_1927.Unload(); // class MistagCalibration 
      type_1939.Unload(); // class SharedArrayImp<double> 
      type_1940.Unload(); // class SharedArrayImp<float> 
      type_1941.Unload(); // class SharedArrayImp<unsigned long long> 
      type_1942.Unload(); // class SharedArrayImp<unsigned long> 
      type_1943.Unload(); // class SharedArrayImp<unsigned int> 
      type_1944.Unload(); // class SharedArrayImp<unsigned short> 
      type_1945.Unload(); // class SharedArrayImp<unsigned char> 
      type_1946.Unload(); // class SharedArrayImp<long long> 
      type_1947.Unload(); // class SharedArrayImp<long> 
      type_1948.Unload(); // class SharedArrayImp<int> 
      type_1949.Unload(); // class SharedArrayImp<short> 
      type_1950.Unload(); // class SharedArrayImp<char> 
      type_2072.Unload(); // class Dilution 
      type_2078.Unload(); // class FitMeTool 
      type_2117.Unload(); // class RooCubicSplineFun 
      type_2165.Unload(); // class CPObservable 
      type_2200.Unload(); // class RooComplementCoef 
      type_2203.Unload(); // class SharedArray<double> 
      type_2204.Unload(); // class SharedArray<float> 
      type_2205.Unload(); // class SharedArray<unsigned long long> 
      type_2206.Unload(); // class SharedArray<unsigned long> 
      type_2207.Unload(); // class SharedArray<unsigned int> 
      type_2208.Unload(); // class SharedArray<unsigned short> 
      type_2209.Unload(); // class SharedArray<unsigned char> 
      type_2210.Unload(); // class SharedArray<long long> 
      type_2211.Unload(); // class SharedArray<long> 
      type_2212.Unload(); // class SharedArray<int> 
      type_2213.Unload(); // class SharedArray<short> 
      type_2214.Unload(); // class SharedArray<char> 
      type_2231.Unload(); // class IfThreeWay 
      type_2502.Unload(); // class RooCruijff 
      type_2590.Unload(); // class CombBkgPTPdf 
      type_2744.Unload(); // class RooBinnedFun 
      type_3089.Unload(); // class std::vector<double> 
      type_7149.Unload(); // class RooCubicSplineKnot::S_jk 
      type_3090.Unload(); // class std::vector<RooCubicSplineKnot::S_jk> 
      type_3091.Unload(); // class std::vector<float> 
      type_3092.Unload(); // class std::vector<unsigned long long> 
      type_3093.Unload(); // class std::vector<unsigned long> 
      type_3094.Unload(); // class std::vector<unsigned int> 
      type_3095.Unload(); // class std::vector<unsigned short> 
      type_3096.Unload(); // class std::vector<unsigned char> 
      type_3097.Unload(); // class std::vector<long long> 
      type_3098.Unload(); // class std::vector<long> 
      type_3099.Unload(); // class std::vector<int> 
      type_3100.Unload(); // class std::vector<short> 
      type_3101.Unload(); // class std::vector<char> 
      type_3102.Unload(); // class std::vector<RooFitResult*> 
      type_3103.Unload(); // class std::vector<std::pair<std::basic_string<char>,std::basic_string<char> > > 
      type_3104.Unload(); // class std::vector<std::map<void*,double> > 
      type_3105.Unload(); // class std::vector<std::vector<double> > 
      type_3107.Unload(); // class std::vector<const RooAbsBinning*> 
      type_3108.Unload(); // class std::vector<RooAbsLValue*> 
      type_3109.Unload(); // class std::vector<std::vector<double>*> 
      type_3110.Unload(); // class std::vector<RooNormSetCache> 
      type_3111.Unload(); // class std::vector<std::pair<double,TString> > 
      type_3113.Unload(); // class std::vector<TString> 
      type_3114.Unload(); // class std::vector<std::map<int,int> > 
      type_3115.Unload(); // class std::vector<RooAbsRealLValue*> 
      type_3116.Unload(); // class std::vector<bool> 
      type_3117.Unload(); // class std::vector<RooArgSet*> 
      type_3118.Unload(); // class std::vector<std::vector<int> > 
      type_3119.Unload(); // class std::vector<std::pair<std::basic_string<char>,int> > 
      type_3120.Unload(); // class std::vector<RooAbsArg*> 
      type_3121.Unload(); // class std::vector<RooAbsCacheElement*> 
      type_3122.Unload(); // class std::vector<RooMsgService::StreamConfig> 
      type_3124.Unload(); // class std::vector<TVirtualArray*> 
      type_3125.Unload(); // class std::vector<ROOT::TSchemaHelper> 
      type_3485.Unload(); // class std::pair<std::basic_string<char>,RooAbsData*> 
      type_7148.Unload(); // class RooCubicSplineKnot::BoundaryConditions 
      type_7150.Unload(); // class RooCubicSplineKnot::S_edge 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
